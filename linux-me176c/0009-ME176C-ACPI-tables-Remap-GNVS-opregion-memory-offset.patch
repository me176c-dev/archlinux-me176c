From d00784d3be92a1aa07a554f4193f517948abd8d8 Mon Sep 17 00:00:00 2001
From: lambdadroid <lambdadroid@gmail.com>
Date: Sat, 2 Sep 2017 21:55:56 +0200
Subject: [PATCH 09/25] ME176C: ACPI / tables: Remap GNVS opregion memory
 offset in custom DSDTs

We want to override the DSDT table at runtime to fix various issues
caused by mistakes in the DSDT table. However, the DSDT table seems
to differ in the GNVS operation region memory offset on each device.

To allow us to replace the DSDT with a generic fixed version, we
search for the GNVS operation region memory offset in the binary
original table at runtime, and replace the dummy value in the new
table.
---
 drivers/acpi/tables.c | 66 ++++++++++++++++++++++++++++++++++++++++++-
 1 file changed, 65 insertions(+), 1 deletion(-)

diff --git a/drivers/acpi/tables.c b/drivers/acpi/tables.c
index 80ce2a7d224b..bf1074c242e5 100644
--- a/drivers/acpi/tables.c
+++ b/drivers/acpi/tables.c
@@ -707,6 +707,70 @@ acpi_os_physical_table_override(struct acpi_table_header *existing_table,
 					  table_length);
 }
 
+#ifdef CONFIG_ACPI_CUSTOM_DSDT
+                                        /*OpRegion*/       /*GNVS*/       /*SystemMemory*/
+static const char gnvs_region_prefix[] = {0x5b,0x80, 0x47,0x4e,0x56,0x53, 0x00};
+
+#define GNVS_REGION_MIN_LENGTH	(sizeof(gnvs_region_prefix) + 1 + sizeof(__le32))
+#define AML_DWORD_PREFIX		0x0c
+
+static __le32* acpi_os_dsdt_find_gnvs_region_offset(struct acpi_table_header *header)
+{
+	/* Find the GNVS OperationRegion definition in the ACPI table */
+	char *gnvs = strnstr((const char*) header, gnvs_region_prefix, header->length);
+	if (!gnvs) {
+		return NULL;
+	}
+
+	/* Make sure we don't access memory out-of-bounds */
+	if (((const void*) header + header->length - (const void*) gnvs) < GNVS_REGION_MIN_LENGTH) {
+		return NULL;
+	}
+
+	/* Skip the search prefix */
+	gnvs += ARRAY_SIZE(gnvs_region_prefix);
+
+	/* Offset should have a DWordPrefix (0x0c) */
+	if (*gnvs != AML_DWORD_PREFIX) {
+		pr_err("Invalid GNVS address prefix: %x", *gnvs);
+		return NULL;
+	}
+
+	/* Return pointer to the region offset */
+	return (__le32*) (gnvs + 1);
+}
+
+static void acpi_os_prepare_dsdt_table(struct acpi_table_header *existing_table,
+		       struct acpi_table_header **new_table)
+{
+	__le32 *gnvs_offset_original;
+	__le32 *gnvs_offset_new;
+
+	*new_table = (struct acpi_table_header *)AmlCode;
+
+	/* Find real GNVS region offset */
+	gnvs_offset_original = acpi_os_dsdt_find_gnvs_region_offset(existing_table);
+	if (!gnvs_offset_original) {
+		pr_warn("GNVS region offset not found in original table");
+		return;
+	}
+
+	/* Find dummy GNVS region offset */
+	gnvs_offset_new = acpi_os_dsdt_find_gnvs_region_offset(*new_table);
+	if (!gnvs_offset_new) {
+		pr_warn("GNVS region offset not found in dummy table");
+		return;
+	}
+
+	/* Update offset if necessary */
+	if (*gnvs_offset_original != *gnvs_offset_new) {
+		pr_info("GNVS region offset mismatch, updating 0x%x -> 0x%x",
+			le32_to_cpu(*gnvs_offset_new), le32_to_cpu(*gnvs_offset_original));
+		*gnvs_offset_new = *gnvs_offset_original;
+	}
+}
+#endif
+
 acpi_status
 acpi_os_table_override(struct acpi_table_header *existing_table,
 		       struct acpi_table_header **new_table)
@@ -718,7 +782,7 @@ acpi_os_table_override(struct acpi_table_header *existing_table,
 
 #ifdef CONFIG_ACPI_CUSTOM_DSDT
 	if (strncmp(existing_table->signature, "DSDT", 4) == 0)
-		*new_table = (struct acpi_table_header *)AmlCode;
+		acpi_os_prepare_dsdt_table(existing_table, new_table);
 #endif
 	if (*new_table != NULL)
 		acpi_table_taint(existing_table);
-- 
2.17.0

