From 5208cd59af0df32a821ecf0237c6b6fd68b7f9d4 Mon Sep 17 00:00:00 2001
From: lambdadroid <lambdadroid@gmail.com>
Date: Fri, 19 May 2017 12:25:13 +0200
Subject: [PATCH 18/26] ME176C: power: supply: Import battery/charger drivers

Taken from: l-byt-r1_V12.10.1.33-201509171530-foss
---
 .../power/supply/ASUS_BATTERY/ME176C/Kconfig  |   32 +
 .../power/supply/ASUS_BATTERY/ME176C/Makefile |    8 +
 .../ASUS_BATTERY/ME176C/bq24192_charger.c     | 3559 ++++++++
 .../ASUS_BATTERY/ME176C/ug31xx/Makefile       |   21 +
 .../ASUS_BATTERY/ME176C/ug31xx/global.h       |   28 +
 .../ASUS_BATTERY/ME176C/ug31xx/stdafx.h       |   49 +
 .../ASUS_BATTERY/ME176C/ug31xx/typeDefine.h   |  400 +
 .../ASUS_BATTERY/ME176C/ug31xx/uG31xx.h       |  159 +
 .../ASUS_BATTERY/ME176C/ug31xx/uG31xx_API.c   | 7134 +++++++++++++++++
 .../ASUS_BATTERY/ME176C/ug31xx/uG31xx_API.h   |  549 ++
 .../ME176C/ug31xx/uG31xx_API_Backup.c         |  793 ++
 .../ME176C/ug31xx/uG31xx_API_Backup.h         |  167 +
 .../ME176C/ug31xx/uG31xx_API_Capacity.c       | 2967 +++++++
 .../ME176C/ug31xx/uG31xx_API_Capacity.h       |  288 +
 .../ME176C/ug31xx/uG31xx_API_Measurement.c    | 2567 ++++++
 .../ME176C/ug31xx/uG31xx_API_Measurement.h    |  217 +
 .../ME176C/ug31xx/uG31xx_API_Otp.c            |  952 +++
 .../ME176C/ug31xx/uG31xx_API_Otp.h            |   94 +
 .../ME176C/ug31xx/uG31xx_API_Platform.c       | 1509 ++++
 .../ME176C/ug31xx/uG31xx_API_Platform.h       |  245 +
 .../ME176C/ug31xx/uG31xx_API_System.c         | 2029 +++++
 .../ME176C/ug31xx/uG31xx_API_System.h         |  275 +
 .../ME176C/ug31xx/uG31xx_Platform.h           |   35 +
 .../ME176C/ug31xx/uG31xx_Reg_Def.h            |  668 ++
 .../ASUS_BATTERY/ME176C/ug31xx/ug31xx_gauge.c | 4466 +++++++++++
 .../ASUS_BATTERY/ME176C/ug31xx/ug31xx_gauge.h |  213 +
 .../ME176C/ug31xx/ug31xx_ggb_data_k013.h      |  237 +
 .../ME176C/ug31xx/ug31xx_version.h            |    8 +
 drivers/power/supply/Kconfig                  |    1 +
 drivers/power/supply/Makefile                 |    2 +
 30 files changed, 29672 insertions(+)
 create mode 100644 drivers/power/supply/ASUS_BATTERY/ME176C/Kconfig
 create mode 100644 drivers/power/supply/ASUS_BATTERY/ME176C/Makefile
 create mode 100755 drivers/power/supply/ASUS_BATTERY/ME176C/bq24192_charger.c
 create mode 100644 drivers/power/supply/ASUS_BATTERY/ME176C/ug31xx/Makefile
 create mode 100644 drivers/power/supply/ASUS_BATTERY/ME176C/ug31xx/global.h
 create mode 100644 drivers/power/supply/ASUS_BATTERY/ME176C/ug31xx/stdafx.h
 create mode 100644 drivers/power/supply/ASUS_BATTERY/ME176C/ug31xx/typeDefine.h
 create mode 100644 drivers/power/supply/ASUS_BATTERY/ME176C/ug31xx/uG31xx.h
 create mode 100644 drivers/power/supply/ASUS_BATTERY/ME176C/ug31xx/uG31xx_API.c
 create mode 100644 drivers/power/supply/ASUS_BATTERY/ME176C/ug31xx/uG31xx_API.h
 create mode 100644 drivers/power/supply/ASUS_BATTERY/ME176C/ug31xx/uG31xx_API_Backup.c
 create mode 100644 drivers/power/supply/ASUS_BATTERY/ME176C/ug31xx/uG31xx_API_Backup.h
 create mode 100644 drivers/power/supply/ASUS_BATTERY/ME176C/ug31xx/uG31xx_API_Capacity.c
 create mode 100644 drivers/power/supply/ASUS_BATTERY/ME176C/ug31xx/uG31xx_API_Capacity.h
 create mode 100644 drivers/power/supply/ASUS_BATTERY/ME176C/ug31xx/uG31xx_API_Measurement.c
 create mode 100644 drivers/power/supply/ASUS_BATTERY/ME176C/ug31xx/uG31xx_API_Measurement.h
 create mode 100644 drivers/power/supply/ASUS_BATTERY/ME176C/ug31xx/uG31xx_API_Otp.c
 create mode 100644 drivers/power/supply/ASUS_BATTERY/ME176C/ug31xx/uG31xx_API_Otp.h
 create mode 100644 drivers/power/supply/ASUS_BATTERY/ME176C/ug31xx/uG31xx_API_Platform.c
 create mode 100644 drivers/power/supply/ASUS_BATTERY/ME176C/ug31xx/uG31xx_API_Platform.h
 create mode 100644 drivers/power/supply/ASUS_BATTERY/ME176C/ug31xx/uG31xx_API_System.c
 create mode 100644 drivers/power/supply/ASUS_BATTERY/ME176C/ug31xx/uG31xx_API_System.h
 create mode 100644 drivers/power/supply/ASUS_BATTERY/ME176C/ug31xx/uG31xx_Platform.h
 create mode 100644 drivers/power/supply/ASUS_BATTERY/ME176C/ug31xx/uG31xx_Reg_Def.h
 create mode 100644 drivers/power/supply/ASUS_BATTERY/ME176C/ug31xx/ug31xx_gauge.c
 create mode 100644 drivers/power/supply/ASUS_BATTERY/ME176C/ug31xx/ug31xx_gauge.h
 create mode 100755 drivers/power/supply/ASUS_BATTERY/ME176C/ug31xx/ug31xx_ggb_data_k013.h
 create mode 100644 drivers/power/supply/ASUS_BATTERY/ME176C/ug31xx/ug31xx_version.h

diff --git a/drivers/power/supply/ASUS_BATTERY/ME176C/Kconfig b/drivers/power/supply/ASUS_BATTERY/ME176C/Kconfig
new file mode 100644
index 000000000000..36c8bdc71d9c
--- /dev/null
+++ b/drivers/power/supply/ASUS_BATTERY/ME176C/Kconfig
@@ -0,0 +1,32 @@
+#
+#  Battery driver configuration
+#
+
+menuconfig ASUS_ME176C_BATTERY
+	bool "ASUS ME176C Battery support"
+	help
+	  Say Y here. This option doesn't affect the kernel.
+	  If unsure, say Y.
+
+if ASUS_ME176C_BATTERY
+
+config ASUS_BATTERY_ME176C_CHARGER_BQ24192
+	tristate "TI BQ24192/BQ24191/BQ24190 Charger"
+        default y
+	select POWER_SUPPLY_CHARGER
+	depends on I2C
+	help
+	  BQ24192 is the charger chip for lithium-ion (Li+) batteries
+	  in handheld and portable equipment.
+
+	  Say Y here if you know your platform has this chip for charging
+	  support.
+
+config ASUS_BATTERY_ME176C_UPI_BATTERY
+	tristate "UPI ug31xx"
+		default y
+	depends on I2C
+	help
+	  say Y to enable suspport for the ug31
+
+endif
diff --git a/drivers/power/supply/ASUS_BATTERY/ME176C/Makefile b/drivers/power/supply/ASUS_BATTERY/ME176C/Makefile
new file mode 100644
index 000000000000..53584f4cb6e4
--- /dev/null
+++ b/drivers/power/supply/ASUS_BATTERY/ME176C/Makefile
@@ -0,0 +1,8 @@
+#
+#  Copyright (c) 2013, ASUSTek, Inc. All Rights Reserved.
+#
+
+KBUILD_CFLAGS += -DASUS_USER_BUILD
+
+obj-$(CONFIG_ASUS_BATTERY_ME176C_CHARGER_BQ24192)	+= bq24192_charger.o
+obj-$(CONFIG_ASUS_BATTERY_ME176C_UPI_BATTERY)	+= ug31xx/
diff --git a/drivers/power/supply/ASUS_BATTERY/ME176C/bq24192_charger.c b/drivers/power/supply/ASUS_BATTERY/ME176C/bq24192_charger.c
new file mode 100755
index 000000000000..841243513818
--- /dev/null
+++ b/drivers/power/supply/ASUS_BATTERY/ME176C/bq24192_charger.c
@@ -0,0 +1,3559 @@
+/*
+ * bq24192_charger.c - Charger driver for TI BQ24192,BQ24191 and BQ24190
+ *
+ * Copyright (C) 2011 Intel Corporation
+ *
+ * ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; version 2 of the License.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA.
+ *
+ * ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+ * Author: Ramakrishna Pallala <ramakrishna.pallala@intel.com>
+ * Author: Raj Pandey <raj.pandey@intel.com>
+ */
+
+#include <linux/module.h>
+#include <linux/err.h>
+#include <linux/init.h>
+#include <linux/interrupt.h>
+#include <linux/workqueue.h>
+#include <linux/slab.h>
+#include <linux/device.h>
+#include <linux/i2c.h>
+#include <linux/debugfs.h>
+#include <linux/seq_file.h>
+#include <linux/power_supply.h>
+#include <linux/power/bq24192_charger.h>
+#include <linux/sfi.h>
+#include <linux/pm_runtime.h>
+#include <linux/io.h>
+#include <linux/sched.h>
+#include <linux/delay.h>
+#include <linux/gpio.h>
+#include <linux/wakelock.h>
+#include <linux/version.h>
+#include <linux/usb/otg.h>
+#include <linux/platform_data/intel_mid_remoteproc.h>
+#include <linux/rpmsg.h>
+
+#include <asm/intel_mid_gpadc.h>
+#include <asm/intel_scu_ipc.h>
+#include <asm/intel_scu_pmic.h>
+#include <asm/intel_mid_rpmsg.h>
+
+#define DRV_NAME "bq24192_charger"
+#define DEV_NAME "bq24192"
+#include <linux/acpi_gpio.h>
+#include <linux/mfd/intel_mid_pmic.h>
+#include <linux/regulator/of_regulator.h>
+#include <linux/regulator/consumer.h>
+#include <linux/proc_fs.h>
+
+
+#define REGULATOR_V3P3S		"v3p3s"
+
+#define R_PMIC_CHGRIRQ 0x0A
+#define R_PMIC_MIRQS0  0x17
+#define R_PMIC_MIRQSX  0x18
+
+
+/*
+ * D0, D1, D2 can be used to set current limits
+ * and D3, D4, D5, D6 can be used to voltage limits
+ */
+#define BQ24192_INPUT_SRC_CNTL_REG		0x0
+#define INPUT_SRC_CNTL_EN_HIZ			(1 << 7)
+#define BATTERY_NEAR_FULL(a)			((a * 98)/100)
+/*
+ * set input voltage lim to 4.68V. This will help in charger
+ * instability issue when duty cycle reaches 100%.
+ */
+#define INPUT_SRC_VOLT_LMT_DEF                 (3 << 4)
+#define INPUT_SRC_VOLT_LMT_444                 (7 << 3)
+#define INPUT_SRC_VOLT_LMT_468                 (5 << 4)
+#define INPUT_SRC_VOLT_LMT_476                 (0xB << 3)
+
+#define INPUT_SRC_VINDPM_MASK                  (0xF << 3)
+#define INPUT_SRC_LOW_VBAT_LIMIT               3600
+#define INPUT_SRC_MIDL_VBAT_LIMIT              4000
+#define INPUT_SRC_MIDH_VBAT_LIMIT              4200
+#define INPUT_SRC_HIGH_VBAT_LIMIT              4350
+
+/* D0, D1, D2 represent the input current limit */
+#define INPUT_SRC_CUR_LMT0		0x0	/* 100mA */
+#define INPUT_SRC_CUR_LMT1		0x1	/* 150mA */
+#define INPUT_SRC_CUR_LMT2		0x2	/* 500mA */
+#define INPUT_SRC_CUR_LMT3		0x3	/* 900mA */
+#define INPUT_SRC_CUR_LMT4		0x4	/* 1000mA */
+#define INPUT_SRC_CUR_LMT5		0x5	/* 1200mA */
+#define INPUT_SRC_CUR_LMT6		0x6	/* 2000mA */
+#define INPUT_SRC_CUR_LMT7		0x7	/* 3000mA */
+
+/*
+ * D1, D2, D3 can be used to set min sys voltage limit
+ * and D4, D5 can be used to control the charger
+ */
+#define BQ24192_POWER_ON_CFG_REG		0x1
+#define POWER_ON_CFG_RESET			(1 << 7)
+#define POWER_ON_CFG_I2C_WDTTMR_RESET		(1 << 6)
+#define CHR_CFG_BIT_POS				4
+#define CHR_CFG_BIT_LEN				2
+#define POWER_ON_CFG_CHRG_CFG_DIS		(0 << 4)
+#define POWER_ON_CFG_CHRG_CFG_EN		(1 << 4)
+#define POWER_ON_CFG_CHRG_CFG_OTG		(3 << 4)
+#define POWER_ON_CFG_BOOST_LIM			(1 << 0)
+
+/*
+ * Charge Current control register
+ * with range from 500 - 4532mA
+ */
+#define BQ24192_CHRG_CUR_CNTL_REG		0x2
+#define BQ24192_CHRG_CUR_OFFSET		512	/* 500 mA */
+#define BQ24192_CHRG_CUR_LSB_TO_CUR	64	/* 64 mA */
+#define BQ24192_GET_CHRG_CUR(reg) ((reg>>2)*BQ24192_CHRG_CUR_LSB_TO_CUR\
+			+ BQ24192_CHRG_CUR_OFFSET) /* in mA */
+#define BQ24192_CHRG_ITERM_OFFSET       128
+#define BQ24192_CHRG_CUR_LSB_TO_ITERM   128
+
+/* Pre charge and termination current limit reg */
+#define BQ24192_PRECHRG_TERM_CUR_CNTL_REG	0x3
+#define BQ24192_TERM_CURR_LIMIT_128		0	/* 128mA */
+#define BQ24192_PRE_CHRG_CURR_256		(1 << 4)  /* 256mA */
+
+/* Charge voltage control reg */
+#define BQ24192_CHRG_VOLT_CNTL_REG	0x4
+#define BQ24192_CHRG_VOLT_OFFSET	3504	/* 3504 mV */
+#define BQ24192_CHRG_VOLT_LSB_TO_VOLT	16	/* 16 mV */
+/* Low voltage setting 0 - 2.8V and 1 - 3.0V */
+#define CHRG_VOLT_CNTL_BATTLOWV		(1 << 1)
+/* Battery Recharge threshold 0 - 100mV and 1 - 300mV */
+#define CHRG_VOLT_CNTL_VRECHRG		(0 << 0)
+#define BQ24192_GET_CHRG_VOLT(reg) ((reg>>2)*BQ24192_CHRG_VOLT_LSB_TO_VOLT\
+			+ BQ24192_CHRG_VOLT_OFFSET) /* in mV */
+
+/* Charge termination and Timer control reg */
+#define BQ24192_CHRG_TIMER_EXP_CNTL_REG		0x5
+#define CHRG_TIMER_EXP_CNTL_EN_TERM		(1 << 7)
+#define CHRG_TIMER_EXP_CNTL_TERM_STAT		(1 << 6)
+/* WDT Timer uses 2 bits */
+#define WDT_TIMER_BIT_POS			4
+#define WDT_TIMER_BIT_LEN			2
+#define CHRG_TIMER_EXP_CNTL_WDTDISABLE		(0 << 4)
+#define CHRG_TIMER_EXP_CNTL_WDT40SEC		(1 << 4)
+#define CHRG_TIMER_EXP_CNTL_WDT80SEC		(2 << 4)
+#define CHRG_TIMER_EXP_CNTL_WDT160SEC		(3 << 4)
+#define WDTIMER_RESET_MASK			0x40
+/* Safety Timer Enable bit */
+#define CHRG_TIMER_EXP_CNTL_EN_TIMER		(1 << 3)
+/* Charge Timer uses 2bits(20 hrs) */
+#define SFT_TIMER_BIT_POS			1
+#define SFT_TIMER_BIT_LEN			2
+#define CHRG_TIMER_EXP_CNTL_SFT_TIMER		(3 << 1)
+
+#define BQ24192_CHRG_THRM_REGL_REG		0x6
+
+#define BQ24192_MISC_OP_CNTL_REG		0x7
+#define MISC_OP_CNTL_DPDM_EN			(1 << 7)
+#define MISC_OP_CNTL_TMR2X_EN			(1 << 6)
+#define MISC_OP_CNTL_BATFET_DIS			(1 << 5)
+#define MISC_OP_CNTL_BATGOOD_EN			(1 << 4)
+/* To mask INT's write 0 to the bit */
+#define MISC_OP_CNTL_MINT_CHRG			(1 << 1)
+#define MISC_OP_CNTL_MINT_BATT			(1 << 0)
+
+#define BQ24192_SYSTEM_STAT_REG			0x8
+/* D6, D7 show VBUS status */
+#define SYSTEM_STAT_VBUS_BITS			(3 << 6)
+#define SYSTEM_STAT_VBUS_UNKNOWN		0
+#define SYSTEM_STAT_VBUS_HOST			(1 << 6)
+#define SYSTEM_STAT_VBUS_ADP			(2 << 6)
+#define SYSTEM_STAT_VBUS_OTG			(3 << 6)
+/* D4, D5 show charger status */
+#define SYSTEM_STAT_NOT_CHRG			(0 << 4)
+#define SYSTEM_STAT_PRE_CHRG			(1 << 4)
+#define SYSTEM_STAT_FAST_CHRG			(2 << 4)
+#define SYSTEM_STAT_CHRG_DONE			(3 << 4)
+#define SYSTEM_STAT_DPM				(1 << 3)
+#define SYSTEM_STAT_PWR_GOOD			(1 << 2)
+#define SYSTEM_STAT_THERM_REG			(1 << 1)
+#define SYSTEM_STAT_VSYS_LOW			(1 << 0)
+#define SYSTEM_STAT_CHRG_MASK			(3 << 4)
+
+#define BQ24192_FAULT_STAT_REG			0x9
+#define FAULT_STAT_WDT_TMR_EXP			(1 << 7)
+#define FAULT_STAT_OTG_FLT			(1 << 6)
+/* D4, D5 show charger fault status */
+#define FAULT_STAT_CHRG_BITS			(3 << 4)
+#define FAULT_STAT_CHRG_NORMAL			(0 << 4)
+#define FAULT_STAT_CHRG_IN_FLT			(1 << 4)
+#define FAULT_STAT_CHRG_THRM_FLT		(2 << 4)
+#define FAULT_STAT_CHRG_TMR_FLT			(3 << 4)
+#define FAULT_STAT_BATT_FLT			(1 << 3)
+#define FAULT_STAT_BATT_TEMP_BITS		(3 << 0)
+
+#define BQ24192_VENDER_REV_REG			0xA
+/* D3, D4, D5 indicates the chip model number */
+#define BQ24190_IC_VERSION			0x0
+#define BQ24191_IC_VERSION			0x1
+#define BQ24192_IC_VERSION			0x2
+#define BQ24192I_IC_VERSION			0x3
+#define BQ2419x_IC_VERSION			0x4
+
+#define BQ24192_MAX_MEM		12
+#define NR_RETRY_CNT		3
+
+#define CHARGER_PS_NAME				"bq24192_charger"
+
+#define CHARGER_TASK_JIFFIES		(HZ * 150)/* 150sec */
+#define CHARGER_HOST_JIFFIES		(HZ * 60) /* 60sec */
+#define FULL_THREAD_JIFFIES		(HZ * 30) /* 30sec */
+#define TEMP_THREAD_JIFFIES		(HZ * 30) /* 30sec */
+
+#define BATT_TEMP_MAX_DEF	60	/* 60 degrees */
+#define BATT_TEMP_MIN_DEF	0
+
+/* Max no. of tries to clear the charger from Hi-Z mode */
+#define MAX_TRY		3
+
+/* Max no. of tries to reset the bq24192i WDT */
+#define MAX_RESET_WDT_RETRY 8
+
+/*
+ * usb notify callback
+ */
+#define USB_NOTIFY_CALLBACK
+
+static struct power_supply *fg_psy;
+struct bq24192_chip *chip_extern=NULL;
+extern int entry_mode;
+
+//...........................................................................
+static int bq2415x_sysfs_flag=0; //lambert
+static int suspend_flag=1;  //lambert,1:normal charger,0:mode for aging
+static unsigned char WakeLockFlag=0;//lambert,0:already unlock,1:already lock
+static int g_charger_mode = -1; //lambert,0:dc,1:usb,2:ac
+
+//.......................................................................................................
+struct bq24192_otg_event {
+	struct list_head node;
+	bool is_enable;
+};
+
+static enum bq24192_chrgr_stat {
+	BQ24192_CHRGR_STAT_UNKNOWN =0,
+	BQ24192_CHRGR_STAT_CHARGING,
+	BQ24192_CHRGR_STAT_FAULT,
+	BQ24192_CHRGR_STAT_LOW_SUPPLY_FAULT,
+	BQ24192_CHRGR_STAT_BAT_FULL,
+};
+
+struct bq24192_chip {
+	struct i2c_client *client;
+	struct bq24192_platform_data *pdata;
+	struct power_supply usb;
+	struct delayed_work power_state_task_wrkr;
+	struct delayed_work chrg_task_wrkr;
+	struct delayed_work chrg_full_wrkr;
+	struct delayed_work jeita_wrkr;
+	struct delayed_work chrg_temp_wrkr;
+	struct delayed_work otg_disable_wrkr;
+	struct delayed_work otg_wrkr;
+	struct work_struct otg_evt_work;
+	struct notifier_block	otg_nb;
+	struct list_head	otg_queue;
+	struct mutex event_lock;
+	struct power_supply_cable_props cap;
+	struct power_supply_cable_props cached_cap;
+	struct usb_phy *transceiver;
+	/* Wake lock to prevent platform from going to S3 when charging */
+	struct wake_lock wakelock;
+	spinlock_t otg_queue_lock;
+
+
+	enum bq24192_chrgr_stat chgr_stat;
+	enum power_supply_charger_cable_type cable_type;
+	int cc;
+	int cv;
+	int inlmt;
+	int max_cc;
+	int max_cv;
+	int max_temp;
+	int min_temp;
+	int iterm;
+	int batt_status;
+	int bat_health;
+	int cntl_state;
+	int irq;
+	bool is_charger_enabled;
+	bool is_charging_enabled;
+	bool votg;
+	bool is_pwr_good;
+	bool boost_mode;
+	bool online;
+	bool present;
+	bool sfttmr_expired;
+};
+
+void charger_enabled_poweron();
+int bq24192_chargeric_status(void);
+
+// Webber +++++++++++++++++++++++++++
+bool detect_charging(void);
+// Webber ---------------------------
+
+
+
+#ifdef CONFIG_DEBUG_FS
+static struct dentry *bq24192_dbgfs_root;
+static char bq24192_dbg_regs[BQ24192_MAX_MEM][4];
+#endif
+
+static int bq24192_reg_read_modify(struct i2c_client *client, u8 reg,
+							u8 val, bool bit_set);
+
+static struct i2c_client *bq24192_client;
+
+static enum power_supply_property bq24192_usb_props[] = {
+	POWER_SUPPLY_PROP_PRESENT,
+	POWER_SUPPLY_PROP_ONLINE,
+	POWER_SUPPLY_PROP_TYPE,
+	POWER_SUPPLY_PROP_HEALTH,
+	POWER_SUPPLY_PROP_MAX_CHARGE_CURRENT,
+	POWER_SUPPLY_PROP_MAX_CHARGE_VOLTAGE,
+	POWER_SUPPLY_PROP_CHARGE_CURRENT,
+	POWER_SUPPLY_PROP_CHARGE_VOLTAGE,
+	POWER_SUPPLY_PROP_INLMT,
+	POWER_SUPPLY_PROP_ENABLE_CHARGING,
+	POWER_SUPPLY_PROP_ENABLE_CHARGER,
+	POWER_SUPPLY_PROP_CHARGE_TERM_CUR,
+	POWER_SUPPLY_PROP_CABLE_TYPE,
+	POWER_SUPPLY_PROP_CHARGE_CONTROL_LIMIT,
+	POWER_SUPPLY_PROP_CHARGE_CONTROL_LIMIT_MAX,
+	POWER_SUPPLY_PROP_MAX_TEMP,
+	POWER_SUPPLY_PROP_MIN_TEMP
+};
+
+static enum power_supply_type get_power_supply_type(
+		enum power_supply_charger_cable_type cable)
+{
+
+	switch (cable) {
+
+	case POWER_SUPPLY_CHARGER_TYPE_USB_DCP:
+		return POWER_SUPPLY_TYPE_USB_DCP;
+	case POWER_SUPPLY_CHARGER_TYPE_USB_CDP:
+		return POWER_SUPPLY_TYPE_USB_CDP;
+	case POWER_SUPPLY_CHARGER_TYPE_USB_ACA:
+		return POWER_SUPPLY_TYPE_USB_ACA;
+	case POWER_SUPPLY_CHARGER_TYPE_AC:
+		return POWER_SUPPLY_TYPE_MAINS;
+	case POWER_SUPPLY_CHARGER_TYPE_NONE:
+	case POWER_SUPPLY_CHARGER_TYPE_USB_SDP:
+	default:
+		return POWER_SUPPLY_TYPE_USB;
+	}
+
+	return POWER_SUPPLY_TYPE_USB;
+}
+
+#ifdef ASUS_ENG_BUILD
+bool eng_charging_limit = true;
+
+int asus_charging_toggle_write(struct file *file, const char *buffer, size_t count, loff_t *data) {
+
+    if (buffer[0] == '1') {
+        /* turn on charging limit in eng mode */
+        eng_charging_limit = true;
+    } else if (buffer[0] == '0') {
+        /* turn off charging limit in eng mode */
+        eng_charging_limit = false;
+        charger_enabled_poweron();
+    }
+    printk(" %s: %s\n", __func__, eng_charging_limit ? "enable charger limit" : "disable charger limit");
+
+    cancel_delayed_work_sync(&chip_extern->jeita_wrkr);
+    schedule_delayed_work(&chip_extern->jeita_wrkr, 0*HZ);
+
+    return count;
+}
+
+static int asus_charging_toggle_read(struct seq_file *m, void *p) {
+        int len = 0;
+        printk(" %s: %s\n", __func__, eng_charging_limit ? "enable charger limit" : "disable charger limit");
+        seq_printf(m,"%s: %s\n", __func__, eng_charging_limit ? "enable charger limit" : "disable charger limit");
+        return len;
+}
+
+static int proc_asus_charging_toggle_open(struct inode *inode, struct file *file) {
+	return single_open(file, asus_charging_toggle_read, NULL);
+}
+
+static const struct file_operations asus_eng_charging_limit_ops = {
+        .open		= proc_asus_charging_toggle_open,
+	.read		= seq_read,
+        .write          = asus_charging_toggle_write,
+	.llseek		= seq_lseek,
+	.release	= seq_release
+};
+
+int init_asus_charging_limit_toggle(void) {
+    struct proc_dir_entry *entry = NULL;
+
+    entry = proc_create("driver/charger_limit_enable", 0666, NULL, &asus_eng_charging_limit_ops);
+    if (!entry) {
+        printk("Unable to create asus_charging_toggle\n");
+        return -EINVAL;
+    }
+    return 0;
+}
+#endif
+
+unsigned char volatile VbusDetach = 1;
+unsigned char vbus_Event = 0;
+#ifndef USB_NOTIFY_CALLBACK
+extern volatile unsigned char PowerStateOk;
+#endif
+extern volatile int Power_State;
+
+static void bq24192_ac_lock(void)
+{
+	unsigned long		flags;
+	local_irq_save(flags);
+	if(chip_extern){
+		printk("bq24192_ac_lock\n");
+		wake_lock(&chip_extern->wakelock);
+	}
+	local_irq_restore(flags);
+
+}
+static void bq24192_ac_unlock()
+{
+	unsigned long		flags;
+	local_irq_save(flags);
+	if(chip_extern){
+		printk("bq24192_ac_unlock\n");
+		wake_unlock(&chip_extern->wakelock);
+	}
+	local_irq_restore(flags);
+}
+#ifndef USB_NOTIFY_CALLBACK
+extern enum power_supply_charger_cable_type
+	GetPowerState(void);
+#endif
+static int bq24192_write_reg(struct i2c_client *client, u8 reg, u8 value);
+extern unsigned char cur_cable_status;
+unsigned char OtgOk = 0;
+static inline int bq24192_set_inlmt(struct bq24192_chip *chip, int inlmt);
+/*-------------------------------------------------------------------------*/
+//--------------2014-1-1----distinction sdp/dcp----------------
+static int USB_STATE,AC_STATE;
+
+extern enum {
+	UG31XX_NO_CABLE = 0,
+	UG31XX_USB_PC_CABLE = 1,
+	UG31XX_PAD_POWER = 2,
+	UG31XX_AC_ADAPTER_CABLE = 3
+};
+
+enum {
+	PWR_SUPPLY_AC = 0,
+	PWR_SUPPLY_USB,
+	PWR_SUPPLY_bq21455
+};
+
+static enum power_supply_property bq24192_pwr_props[] = {
+	POWER_SUPPLY_PROP_ONLINE,
+        POWER_SUPPLY_PROP_PRESENT
+};
+
+static char *supply_list[] = {
+	"ac",
+	"usb",
+};
+
+static int bq24192_power_get_property(struct power_supply *psy,
+				     enum power_supply_property psp,
+				     union power_supply_propval *val)
+{
+	int ret = 0;
+
+	switch (psp)
+	{
+	case POWER_SUPPLY_PROP_ONLINE:
+		if((psy->type == POWER_SUPPLY_TYPE_MAINS))
+		{
+			val->intval = AC_STATE;
+		}
+		else if((psy->type == POWER_SUPPLY_TYPE_USB))
+		{
+			val->intval = USB_STATE;
+		}
+		else
+		{
+			val->intval = 0;
+		}
+		break;
+        case POWER_SUPPLY_PROP_PRESENT:
+            if (psy->type == POWER_SUPPLY_TYPE_USB) {
+                /* for ATD test to acquire the status about charger ic */
+                ret = bq24192_chargeric_status();
+                if (ret >= 0) {
+                   val->intval = 1;
+                } else
+                   val->intval = 0;
+            } else if (psy->type == POWER_SUPPLY_TYPE_MAINS) {
+                ret = bq24192_chargeric_status();
+                if (ret >= 0) {
+                   val->intval = 1;
+                } else
+                   val->intval = 0;
+            } else
+               ret = -EINVAL;
+        break;
+	default:
+		return -EINVAL;
+	}
+	return ret;
+}
+
+static struct power_supply bq24192_supply[] = {
+	{
+		.name			= "ac",
+		.type			= POWER_SUPPLY_TYPE_MAINS,
+		.supplied_to		= supply_list,
+		.num_supplicants	= ARRAY_SIZE(supply_list),
+		.properties 		= bq24192_pwr_props,
+		.num_properties	= ARRAY_SIZE(bq24192_pwr_props),
+		.get_property		= bq24192_power_get_property,
+	},
+	{
+		.name			= "usb",
+		.type			= POWER_SUPPLY_TYPE_USB,
+		.supplied_to		= supply_list,
+		.num_supplicants	= ARRAY_SIZE(supply_list),
+		.properties 		= bq24192_pwr_props,
+		.num_properties 	= ARRAY_SIZE(bq24192_pwr_props),
+		.get_property 		= bq24192_power_get_property,
+	},
+	{
+		.name = "bq24155",
+		.type = POWER_SUPPLY_TYPE_USB,
+		.supplied_to		= supply_list,
+		.num_supplicants	= ARRAY_SIZE(supply_list),
+		.properties 		= bq24192_pwr_props,
+		.num_properties 	= ARRAY_SIZE(bq24192_pwr_props),
+		.get_property = bq24192_power_get_property,
+	},
+};
+
+static unsigned char cable_status = POWER_SUPPLY_CHARGER_TYPE_NONE;
+
+int bq24192_cable_callback(unsigned char usb_cable_state)
+{
+	if(OtgOk){
+		cur_cable_status = UG31XX_NO_CABLE;
+		cable_status = UG31XX_NO_CABLE;
+		AC_STATE   = 0;
+		USB_STATE = 0;
+		power_supply_changed(&bq24192_supply[PWR_SUPPLY_USB]);
+		power_supply_changed(&bq24192_supply[PWR_SUPPLY_AC]);
+		return 0;
+	}
+	printk("%s  usb_cable_state = %x, power source ok ? = %d \n", __func__, usb_cable_state,detect_charging()) ;
+
+	if(usb_cable_state != cable_status)
+	{
+		cable_status = usb_cable_state;
+		if((cable_status == POWER_SUPPLY_CHARGER_TYPE_USB_SDP) && (detect_charging() == true))
+		{
+                        charger_enabled_poweron();
+			if(WakeLockFlag==0){
+				 bq24192_ac_lock();
+				 WakeLockFlag=1;
+			}
+			cur_cable_status = UG31XX_USB_PC_CABLE;
+			AC_STATE   = 0;
+
+			USB_STATE = 1;
+			bq24192_set_inlmt(chip_extern,500);
+
+			printk("%s  USB_IN  \n", __func__) ;
+
+		}else
+		{
+			if((cable_status == POWER_SUPPLY_CHARGER_TYPE_USB_DCP) && (detect_charging() == true))
+			{
+                                charger_enabled_poweron();
+				if(WakeLockFlag==0){
+				      bq24192_ac_lock();
+				      WakeLockFlag=1;
+				}
+				cur_cable_status = UG31XX_AC_ADAPTER_CABLE;
+				AC_STATE   = 1;
+				USB_STATE = 0;
+                bq24192_set_inlmt(chip_extern,1200);
+
+				printk("%s  AC_IN  \n", __func__) ;
+
+			}else if((cable_status == POWER_SUPPLY_CHARGER_TYPE_NONE) && (detect_charging() == false))
+			{
+				if(WakeLockFlag==1){
+					 WakeLockFlag=0;
+					 bq24192_ac_unlock();
+				}
+				cur_cable_status = UG31XX_NO_CABLE;
+				AC_STATE   = 0;
+				USB_STATE = 0;
+
+				printk("%s  CABLE_OUT  \n", __func__) ;
+
+				//bq24192_write_reg(bq24192_client, BQ24192_INPUT_SRC_CNTL_REG, 0x32);
+			}else{
+				printk("%s  other condition ,  state =  %x , power source ok ? %d \n", __func__, usb_cable_state,detect_charging()) ;
+			}
+		}
+		power_supply_changed(&bq24192_supply[PWR_SUPPLY_USB]);
+		power_supply_changed(&bq24192_supply[PWR_SUPPLY_AC]);
+		power_supply_changed(&bq24192_supply[PWR_SUPPLY_bq21455]);
+	}
+	return 0;
+}
+EXPORT_SYMBOL(bq24192_cable_callback);
+
+static int bq24192_powersupply_init(struct i2c_client *client)
+{
+	int i, ret;
+	for (i = 0; i < ARRAY_SIZE(bq24192_supply); i++) {
+		ret = power_supply_register(&client->dev, &bq24192_supply[i]);
+		if (ret) {
+			printk("[%s] Failed to register power supply\n", __func__);
+			do {
+				power_supply_unregister(&bq24192_supply[i]);
+			} while ((--i) >= 0);
+			return ret;
+		}
+	}
+  return 0;
+}
+//--------------2014-1-1----distinction sdp/dcp----------------ends
+
+//Charge Portint Guide 2014-01-20------------------------------start
+static inline int bq24192_set_inlmt(struct bq24192_chip *chip, int inlmt);
+static inline int bq24192_set_iterm(struct bq24192_chip *chip, int iterm);
+static inline int bq24192_set_cc(struct bq24192_chip *chip, int cc);
+static inline int bq24192_set_cv(struct bq24192_chip *chip, int cv);
+static int bq24192_read_reg(struct i2c_client *client, u8 reg);
+static inline int bq24192_get_inlmt(struct bq24192_chip *chip);
+
+static u8 chrg_vindpm_to_reg(int vindpm)
+{
+	u8 reg,reg1,value;
+
+	value = bq24192_read_reg(chip_extern->client, BQ24192_INPUT_SRC_CNTL_REG);
+	reg	= (vindpm-3880)/80;
+	reg1 = (vindpm-3880)%80;
+
+	if((reg1 > 0) && (reg1 < 80))
+		reg += 1;
+
+	reg = reg<<3;
+	value = ((value&0x87)|reg);
+	return value;
+}
+
+static inline int bq24192_set_vindpm(struct bq24192_chip *chip, int vindpm)
+{
+	u8 regval;
+
+	dev_warn(&chip->client->dev, "%s:%d %d\n", __func__, __LINE__, vindpm);
+	regval = chrg_vindpm_to_reg(vindpm);
+
+	return bq24192_write_reg(chip->client, BQ24192_INPUT_SRC_CNTL_REG,
+				regval);
+}
+
+static inline int bq24192_set_boostlim(u8 lim)
+{
+	u8 ret,value;
+
+	dev_warn(&chip_extern->client->dev, "%s\n", __func__);
+
+	value = bq24192_read_reg(chip_extern->client, BQ24192_POWER_ON_CFG_REG);
+	if(lim == 0)
+		value = (value&0xFE);
+	else
+		value = (value|0x01);
+	return bq24192_write_reg(chip_extern->client, BQ24192_POWER_ON_CFG_REG,value);
+}
+
+static inline int bq24192_set_sysmin(int sysmin)
+{
+	int ret,value,regval;
+
+	dev_warn(&chip_extern->client->dev, "%s:%d %d\n", __func__, __LINE__, sysmin);
+
+	value = bq24192_read_reg(chip_extern->client, BQ24192_POWER_ON_CFG_REG);
+
+	regval = (sysmin - 3000) / 100;
+	if(((sysmin - 3000) % 100) > 0)
+		regval += 1;
+	regval = regval<<1;
+	value = (value&0xF1)|regval;
+
+	return bq24192_write_reg(chip_extern->client, BQ24192_POWER_ON_CFG_REG,value);
+}
+
+static int bq24192_clear_hiz(struct bq24192_chip *chip);
+static int program_timers(struct bq24192_chip *chip, int wdt_duration,
+				bool sfttmr_enable);
+/*SDP 32 1d 54 11 b3 b4 73, 4b 6c 90 60*/
+static void ChargeInit(unsigned int power_type)
+{
+	int ret,value;
+
+	/* Clear the charger from Hi-Z */
+	if(AC_STATE||USB_STATE)
+	{
+	   ret = bq24192_clear_hiz(chip_extern);
+	   if (ret < 0)
+		dev_warn(&chip_extern->client->dev, "HiZ clear failed:\n");
+	}
+	/*Set boost_limit 1.5a*/
+	bq24192_set_boostlim(1);
+
+	/*Set minimum system voltage limit 3.6v*/
+	bq24192_set_sysmin(3600);
+
+	/*BCOLD:0 , ICHG as reg02[7:2] programmed*/
+	value = bq24192_read_reg(chip_extern->client, BQ24192_CHRG_CUR_CNTL_REG);
+	value &= 0xFC;
+	bq24192_write_reg(chip_extern->client, BQ24192_CHRG_CUR_CNTL_REG,value);
+
+	/*boost voltage 4.998v,thermal regulation 120c*/
+	bq24192_write_reg(chip_extern->client, BQ24192_CHRG_THRM_REGL_REG,0x73);
+
+
+	if(power_type == POWER_SUPPLY_CHARGER_TYPE_USB_DCP){
+		bq24192_set_inlmt(chip_extern,1200);		//00	inlim:1200mA
+		}else{ //POWER_SUPPLY_CHARGER_TYPE_USB_SDP
+			bq24192_set_inlmt(chip_extern,500);	//00	inlim:500mA
+		}
+
+		bq24192_set_vindpm(chip_extern,4360);	//00	vindpm:4.36v
+		bq24192_set_iterm(chip_extern,256);		//03	BQ24192_PRE_CHRG_CURR_256 & termination current limit
+		bq24192_set_cc(chip_extern,1856);		//02	fast charge current linit 1856ma
+		bq24192_set_cv(chip_extern,4352);		//04	charge voltage 4.352v & pre-charge to fast charge 3.0v & 300mv
+
+	/* Enable the WDT and Disable Safety timer */
+	ret = program_timers(chip_extern, CHRG_TIMER_EXP_CNTL_WDT160SEC, false);
+	if (ret < 0)
+		dev_warn(&chip_extern->client->dev, "TIMER enable failed\n");
+
+	/*Enable termination*/
+	value = bq24192_read_reg(chip_extern->client, BQ24192_CHRG_TIMER_EXP_CNTL_REG);
+	value |= 0x80;
+	bq24192_write_reg(chip_extern->client, BQ24192_CHRG_TIMER_EXP_CNTL_REG,value);
+
+	/*Mask INT*/
+	value = bq24192_read_reg(chip_extern->client, BQ24192_MISC_OP_CNTL_REG);
+	value &= 0xFC;
+	bq24192_write_reg(chip_extern->client, BQ24192_MISC_OP_CNTL_REG,value);
+
+	/*Clear fault register*/
+	bq24192_read_reg(chip_extern->client, BQ24192_FAULT_STAT_REG);
+
+}
+
+
+
+static void otg_worker(struct work_struct *work)
+{
+	int gpio_handle,gpio_data,ret;
+
+	msleep(300);
+	gpio_handle = acpi_get_gpio("\\_SB.GPO2", 22);
+	gpio_data    = __gpio_get_value(gpio_handle);
+	if((gpio_data == 0)&&(OtgOk == 0)){
+		printk("Otg plug in\n");
+		OtgOk = 1;
+		cur_cable_status = UG31XX_NO_CABLE;
+		cable_status = UG31XX_NO_CABLE;
+		bq24192_reg_read_modify(chip_extern->client,BQ24192_POWER_ON_CFG_REG,0x20, true);
+	}
+	else{
+		if((gpio_data == 1)&&(OtgOk == 1))
+		{
+		printk("Otg plug out\n");
+		OtgOk = 0;
+		bq24192_reg_read_modify(chip_extern->client,BQ24192_POWER_ON_CFG_REG,0x20, false);
+		}
+	}
+
+}
+static irqreturn_t otg_irq_thread(int irq, void *devid)
+{
+        // callback from USB notify
+	//schedule_delayed_work(&chip_extern->otg_wrkr, 0*HZ);
+}
+static irqreturn_t otg_irq_isr(int irq, void *devid)
+{
+	return IRQ_WAKE_THREAD;
+}
+
+//Charge Portint Guide 2014-01-20------------------------------end
+
+static int bq24192_reg_read_modify(struct i2c_client *client, u8 reg,
+							u8 val, bool bit_set);
+extern bool is_upi_do_disablecharger;
+void bq24192_charge_enable(int enable) {
+
+        if (is_upi_do_disablecharger) {
+           printk("=========== UPI gauge do stop charging, not do JETIA ==================\n");
+           return;
+        }
+
+	if (enable) {
+		printk("Start charging\n");
+		bq24192_reg_read_modify(chip_extern->client,BQ24192_POWER_ON_CFG_REG,0x10, true);
+	} else {
+		printk("Stop charging\n");
+		bq24192_reg_read_modify(chip_extern->client,BQ24192_POWER_ON_CFG_REG,0x10, false);
+	}
+}
+EXPORT_SYMBOL(bq24192_charge_enable);
+
+//Charge  jeita 2014-02-18------------------------------start
+static int fg_chip_get_property(enum power_supply_property psp);
+static struct power_supply *get_fg_chip_psy(void);
+static int check_batt_psy(struct device *dev, void *data);
+// [Webber]
+// Change Jetia Temp Range according to ME176C Charger Porting Guide +++++++++++++++++++++++++++++++++
+static int TempArry[5][2] = {{1000,500},{490,450},{440,150},{140,50},{40,-200}};
+// [Webber] -----------------------------------------------------------------
+static void JetiaWork(struct work_struct *work)
+{
+	static int temp,oldtemp=0,voltage;
+	static u8 index=2;
+        int capacity;
+        capacity = fg_chip_get_property(POWER_SUPPLY_PROP_CAPACITY);
+
+        if (cur_cable_status == UG31XX_NO_CABLE) {
+            printk("## No charging source, no need do JEITA !!\n");
+            goto End;
+        }
+
+        if (entry_mode == 4 && capacity == 100) {
+            printk("## in charging mode, battery capacity is 100%% and full charger, no need do JEITA !!\n");
+            schedule_delayed_work(&chip_extern->jeita_wrkr, 120*HZ);
+            return;
+        }
+#ifdef ASUS_ENG_BUILD
+        if (capacity > 59 && eng_charging_limit) {
+                printk(" %s: In eng mode, Disable charger on capacity(%d%%) is more than 60 %% \n", __func__, capacity);
+                bq24192_charge_enable(0);
+                goto Done;
+        }
+#endif
+
+	temp = fg_chip_get_property(POWER_SUPPLY_PROP_TEMP);
+	if((temp-oldtemp) > 0){
+		if(temp > TempArry[index][0])
+			index-= 1;
+	}else{
+		if(temp < TempArry[index][1])
+			index+= 1;
+	}
+	printk("## ASUS JEITA rule, temp:%d,oldtemp:%d %d\n",temp,oldtemp,index);
+	oldtemp = temp;
+	if(index >= 4)
+		index = 4;
+	if(index <= 0)
+		index = 0;
+
+	switch (index)
+	{
+		case 0:
+			printk("*** [%s] -  Temp >= (55-5(Debounce)) degree  ***\n",__func__);
+			bq24192_charge_enable(0);
+			// [Webber]
+			// Case : Temp >= (55-5(Debounce)) degree celsius +++++++++++++++++++++++++++
+			bq24192_set_cc(chip_extern,1536);
+			bq24192_set_cv(chip_extern,4096);
+			// [Webber] ---------------------------
+			break;
+		case 1:
+			printk("*** [%s] -  (50-5(Debounce))  <= Temp <  (55-5(Debounce)) degree  ***\n",__func__);
+			voltage = fg_chip_get_property(POWER_SUPPLY_PROP_VOLTAGE_NOW);
+			voltage = voltage/1000;
+			// [Webber]
+			// Case : (50-5(Debounce))  <= Temp <  (55-5(Debounce)) degree celsius +++++++++++++++++++++++++++
+			if(voltage <= 4096)
+				bq24192_charge_enable(1);
+			else
+				bq24192_charge_enable(0);
+			bq24192_set_cc(chip_extern,1536);
+			bq24192_set_cv(chip_extern,4096);
+			// [Webber] ---------------------------
+			break;
+		case 2:
+			printk("*** [%s] -  (10+5(Debounce)) <= Temp <  (50-5(Debounce))  degree  ***\n",__func__);
+			bq24192_charge_enable(1);
+			// [Webber]
+			// Case : (10+5(Debounce)) <= Temp <  (50-5(Debounce))  degree celsius +++++++++++++++++++++++++++
+			bq24192_set_cc(chip_extern,1536);
+			bq24192_set_cv(chip_extern,4352);
+			// [Webber] ---------------------------
+			break;
+		case 3:
+			printk("*** [%s] -  (0+5(Debounce)) <= Temp < (10+5(Debounce)) degree  ***\n",__func__);
+			bq24192_charge_enable(1);
+			// [Webber]
+			// Case : (0+5(Debounce)) <= Temp < (10+5(Debounce)) degree celsius ++++++++++++++++++++++++++++
+			bq24192_set_cc(chip_extern,768);
+			bq24192_set_cv(chip_extern,4352);
+			// [Webber] ----------------------------
+			break;
+		case 4:
+			printk("*** [%s] -  Temp < (0+5(Debounce)) degree  ***\n",__func__);
+			bq24192_charge_enable(0);
+			// [Webber]
+			// Case : Temp < (0+5(Debounce)) degree celsius ++++++++++++++++++++++++++++
+			bq24192_set_cc(chip_extern,768);
+			bq24192_set_cv(chip_extern,4352);
+			// [Webber] ----------------------------
+			break;
+	}
+#ifdef ASUS_ENG_BUILD
+Done:
+        power_supply_changed(&bq24192_supply[PWR_SUPPLY_USB]);
+        power_supply_changed(&bq24192_supply[PWR_SUPPLY_AC]);
+#endif
+End:
+	schedule_delayed_work(&chip_extern->jeita_wrkr, 30*HZ);
+}
+//Charge  jeita 2014-02-18------------------------------end
+/*
+ * Genenric register read/write interfaces to access registers in charger ic
+ */
+
+static int bq24192_write_reg(struct i2c_client *client, u8 reg, u8 value)
+{
+	int ret, i;
+
+	for (i = 0; i < NR_RETRY_CNT; i++) {
+		ret = i2c_smbus_write_byte_data(client, reg, value);
+		if (ret == -EAGAIN || ret == -ETIMEDOUT)
+			continue;
+		else
+			break;
+	}
+
+	if (ret < 0)
+		dev_err(&client->dev, "I2C SMbus Write error:%d\n", ret);
+
+	return ret;
+}
+
+static int bq24192_read_reg(struct i2c_client *client, u8 reg)
+{
+	int ret, i;
+
+	for (i = 0; i < NR_RETRY_CNT; i++) {
+		ret = i2c_smbus_read_byte_data(client, reg);
+		if (ret == -EAGAIN || ret == -ETIMEDOUT)
+			continue;
+		else
+			break;
+	}
+
+	if (ret < 0)
+		dev_err(&client->dev, "I2C SMbus Read error:%d\n", ret);
+
+	return ret;
+}
+
+#ifdef DEBUG
+/*
+ * This function dumps the bq24192 registers
+ */
+static void bq24192_dump_registers(struct bq24192_chip *chip)
+{
+	int ret;
+
+	dev_info(&chip->client->dev, "%s\n", __func__);
+
+	/* Input Src Ctrl register */
+	ret = bq24192_read_reg(chip->client, BQ24192_INPUT_SRC_CNTL_REG);
+	if (ret < 0)
+		dev_warn(&chip->client->dev, "Input Src Ctrl reg read fail\n");
+	dev_info(&chip->client->dev, "REG00 %x\n", ret);
+
+	/* Pwr On Cfg register */
+	ret = bq24192_read_reg(chip->client, BQ24192_POWER_ON_CFG_REG);
+	if (ret < 0)
+		dev_warn(&chip->client->dev, "Pwr On Cfg reg read fail\n");
+	dev_info(&chip->client->dev, "REG01 %x\n", ret);
+
+	/* Chrg Curr Ctrl register */
+	ret = bq24192_read_reg(chip->client, BQ24192_CHRG_CUR_CNTL_REG);
+	if (ret < 0)
+		dev_warn(&chip->client->dev, "Chrg Curr Ctrl reg read fail\n");
+	dev_info(&chip->client->dev, "REG02 %x\n", ret);
+
+	/* Pre-Chrg Term register */
+	ret = bq24192_read_reg(chip->client,
+					BQ24192_PRECHRG_TERM_CUR_CNTL_REG);
+	if (ret < 0)
+		dev_warn(&chip->client->dev, "Pre-Chrg Term reg read fail\n");
+	dev_info(&chip->client->dev, "REG03 %x\n", ret);
+
+	/* Chrg Volt Ctrl register */
+	ret = bq24192_read_reg(chip->client, BQ24192_CHRG_VOLT_CNTL_REG);
+	if (ret < 0)
+		dev_warn(&chip->client->dev, "Chrg Volt Ctrl reg read fail\n");
+	dev_info(&chip->client->dev, "REG04 %x\n", ret);
+
+	/* Chrg Term and Timer Ctrl register */
+	ret = bq24192_read_reg(chip->client, BQ24192_CHRG_TIMER_EXP_CNTL_REG);
+	if (ret < 0) {
+		dev_warn(&chip->client->dev,
+			"Chrg Term and Timer Ctrl reg read fail\n");
+	}
+	dev_info(&chip->client->dev, "REG05 %x\n", ret);
+
+	/* Thermal Regulation register */
+	ret = bq24192_read_reg(chip->client, BQ24192_CHRG_THRM_REGL_REG);
+	if (ret < 0) {
+		dev_warn(&chip->client->dev,
+				"Thermal Regulation reg read fail\n");
+	}
+	dev_info(&chip->client->dev, "REG06 %x\n", ret);
+
+	/* Misc Operations Ctrl register */
+	ret = bq24192_read_reg(chip->client, BQ24192_MISC_OP_CNTL_REG);
+	if (ret < 0)
+		dev_warn(&chip->client->dev, "Misc Op Ctrl reg read fail\n");
+	dev_info(&chip->client->dev, "REG07 %x\n", ret);
+
+	/* System Status register */
+	ret = bq24192_read_reg(chip->client, BQ24192_SYSTEM_STAT_REG);
+	if (ret < 0)
+		dev_warn(&chip->client->dev, "System Status reg read fail\n");
+	dev_info(&chip->client->dev, "REG08 %x\n", ret);
+
+	/* Fault Status register */
+	ret = bq24192_read_reg(chip->client, BQ24192_FAULT_STAT_REG);
+	if (ret < 0)
+		dev_warn(&chip->client->dev, "Fault Status reg read fail\n");
+	dev_info(&chip->client->dev, "REG09 %x\n", ret);
+
+	/* Vendor Revision register */
+	ret = bq24192_read_reg(chip->client, BQ24192_VENDER_REV_REG);
+	if (ret < 0)
+		dev_warn(&chip->client->dev, "Vendor Rev reg read fail\n");
+	dev_info(&chip->client->dev, "REG0A %x\n", ret);
+}
+#endif
+
+/*
+ * If the bit_set is TRUE then val 1s will be SET in the reg else val 1s will
+ * be CLEARED
+ */
+static int bq24192_reg_read_modify(struct i2c_client *client, u8 reg,
+							u8 val, bool bit_set)
+{
+	int ret;
+
+	ret = bq24192_read_reg(client, reg);
+
+	if (bit_set)
+		ret |= val;
+	else
+		ret &= (~val);
+
+	ret = bq24192_write_reg(client, reg, ret);
+
+	return ret;
+}
+
+static int bq24192_reg_multi_bitset(struct i2c_client *client, u8 reg,
+						u8 val, u8 pos, u8 len)
+{
+	int ret;
+	u8 data;
+
+	ret = bq24192_read_reg(client, reg);
+	if (ret < 0) {
+		dev_warn(&client->dev, "I2C SMbus Read error:%d\n", ret);
+		return ret;
+	}
+
+	data = (1 << len) - 1;
+	ret = (ret & ~(data << pos)) | val;
+	ret = bq24192_write_reg(client, reg, ret);
+
+	return ret;
+}
+
+/*
+ * This function verifies if the bq24192i charger chip is in Hi-Z
+ * If yes, then clear the Hi-Z to resume the charger operations
+ */
+static int bq24192_clear_hiz(struct bq24192_chip *chip)
+{
+	int ret, count;
+
+	dev_info(&chip->client->dev, "%s\n", __func__);
+
+	for (count = 0; count < MAX_TRY; count++) {
+		/*
+		 * Read the bq24192i REG00 register for charger Hi-Z mode.
+		 * If it is in Hi-Z, then clear the Hi-Z to resume the charging
+		 * operations.
+		 */
+		ret = bq24192_read_reg(chip->client,
+				BQ24192_INPUT_SRC_CNTL_REG);
+		if (ret < 0) {
+			dev_warn(&chip->client->dev,
+					"Input src cntl read failed\n");
+			goto i2c_error;
+		}
+
+		if (ret & INPUT_SRC_CNTL_EN_HIZ) {
+			dev_warn(&chip->client->dev,
+						"Charger IC in Hi-Z mode\n");
+#ifdef DEBUG
+			bq24192_dump_registers(chip);
+#endif
+			/* Clear the Charger from Hi-Z mode */
+			ret = (chip->inlmt & ~INPUT_SRC_CNTL_EN_HIZ);
+
+			/* Write the values back */
+			ret = bq24192_write_reg(chip->client,
+					BQ24192_INPUT_SRC_CNTL_REG, ret);
+			if (ret < 0) {
+				dev_warn(&chip->client->dev,
+						"Input src cntl write failed\n");
+				goto i2c_error;
+			}
+			msleep(150);
+		} else {
+			dev_info(&chip->client->dev,
+						"Charger is not in Hi-Z\n");
+			break;
+		}
+	}
+	return ret;
+i2c_error:
+	dev_err(&chip->client->dev, "%s\n", __func__);
+	return ret;
+}
+
+/* check_batt_psy -check for whether power supply type is battery
+ * @dev : Power Supply dev structure
+ * @data : Power Supply Driver Data
+ * Context: can sleep
+ *
+ * Return true if power supply type is battery
+ *
+ */
+static int check_batt_psy(struct device *dev, void *data)
+{
+	struct power_supply *psy = dev_get_drvdata(dev);
+
+	/* check for whether power supply type is battery */
+	if (psy->type == POWER_SUPPLY_TYPE_BATTERY) {
+		fg_psy = psy;
+		return 1;
+	}
+	return 0;
+}
+
+/**
+ * get_fg_chip_psy - identify the Fuel Gauge Power Supply device
+ * Context: can sleep
+ *
+ * Return Fuel Gauge power supply structure
+ */
+static struct power_supply *get_fg_chip_psy(void)
+{
+	if (fg_psy)
+		return fg_psy;
+
+	/* loop through power supply class */
+	class_for_each_device(power_supply_class, NULL, NULL,
+			check_batt_psy);
+	return fg_psy;
+}
+
+/**
+ * fg_chip_get_property - read a power supply property from Fuel Gauge driver
+ * @psp : Power Supply property
+ *
+ * Return power supply property value
+ *
+ */
+static int fg_chip_get_property(enum power_supply_property psp)
+{
+	union power_supply_propval val;
+	int ret = -ENODEV;
+
+	if (!fg_psy)
+		fg_psy = get_fg_chip_psy();
+	if (fg_psy) {
+		ret = fg_psy->get_property(fg_psy, psp, &val);
+		if (!ret)
+			return val.intval;
+	}
+	return ret;
+}
+
+/**
+ * bq24192_get_charger_health - to get the charger health status
+ *
+ * Returns charger health status
+ */
+int bq24192_get_charger_health(void)
+{
+	int ret_status, ret_fault;
+	struct bq24192_chip *chip =
+		i2c_get_clientdata(bq24192_client);
+
+	dev_dbg(&chip->client->dev, "%s\n", __func__);
+
+	/* If we do not have any cable connected, return health as UNKNOWN */
+	if (chip->cable_type == POWER_SUPPLY_CHARGER_TYPE_NONE)
+		return POWER_SUPPLY_HEALTH_UNKNOWN;
+
+	ret_fault = bq24192_read_reg(chip->client, BQ24192_FAULT_STAT_REG);
+	if (ret_fault < 0) {
+		dev_warn(&chip->client->dev,
+			"read reg failed %s\n", __func__);
+		return POWER_SUPPLY_HEALTH_UNKNOWN;
+	}
+	/* Check if the error VIN condition occured */
+	ret_status = bq24192_read_reg(chip->client, BQ24192_SYSTEM_STAT_REG);
+	if (ret_status < 0) {
+		dev_warn(&chip->client->dev,
+			"read reg failed %s\n", __func__);
+		return POWER_SUPPLY_HEALTH_UNKNOWN;
+	}
+
+	if (!(ret_status & SYSTEM_STAT_PWR_GOOD) &&
+	((ret_fault & FAULT_STAT_CHRG_BITS) == FAULT_STAT_CHRG_IN_FLT))
+		return POWER_SUPPLY_HEALTH_OVERVOLTAGE;
+
+	if (!(ret_status & SYSTEM_STAT_PWR_GOOD) &&
+	((ret_status & SYSTEM_STAT_VBUS_BITS) == SYSTEM_STAT_VBUS_UNKNOWN))
+		return POWER_SUPPLY_HEALTH_DEAD;
+
+	return POWER_SUPPLY_HEALTH_GOOD;
+}
+
+/**
+ * bq24192_get_battery_health_me176c - to get the battery health status
+ *
+ * Returns battery health status
+ */
+int bq24192_get_battery_health_me176c(void)
+{
+	int  temp,vnow;
+	struct bq24192_chip *chip;
+	if (!bq24192_client)
+		return POWER_SUPPLY_HEALTH_UNKNOWN;
+
+	chip = i2c_get_clientdata(bq24192_client);
+
+	dev_info(&chip->client->dev, "+%s\n", __func__);
+
+	/* If power supply is emulating as battery, return health as good */
+	if (!chip->pdata->sfi_tabl_present)
+		return POWER_SUPPLY_HEALTH_GOOD;
+
+	/* Report the battery health w.r.t battery temperature from FG */
+	temp = fg_chip_get_property(POWER_SUPPLY_PROP_TEMP);
+	if (temp == -ENODEV || temp == -EINVAL) {
+		dev_err(&chip->client->dev,
+				"Failed to read batt profile\n");
+		return POWER_SUPPLY_HEALTH_UNSPEC_FAILURE;
+	}
+
+	temp /= 10;
+
+	if ((temp <= chip->min_temp) ||
+		(temp > chip->max_temp))
+		return POWER_SUPPLY_HEALTH_OVERHEAT;
+	/* read the battery voltage */
+	vnow = fg_chip_get_property(POWER_SUPPLY_PROP_VOLTAGE_NOW);
+	if (vnow == -ENODEV || vnow == -EINVAL) {
+		dev_err(&chip->client->dev, "Can't read voltage from FG\n");
+		return POWER_SUPPLY_HEALTH_UNSPEC_FAILURE;
+	}
+
+	/* convert voltage into millivolts */
+	vnow /= 1000;
+	dev_warn(&chip->client->dev, "vnow = %d\n", vnow);
+
+	if (vnow > chip->max_cv)
+		return POWER_SUPPLY_HEALTH_OVERVOLTAGE;
+
+	dev_dbg(&chip->client->dev, "-%s\n", __func__);
+	return POWER_SUPPLY_HEALTH_GOOD;
+}
+EXPORT_SYMBOL(bq24192_get_battery_health_me176c);
+
+/***********************************************************************/
+
+/* convert the input current limit value
+ * into equivalent register setting.
+ * Note: ilim must be in mA.
+ */
+static u8 chrg_ilim_to_reg(int ilim)
+{
+	u8 reg;
+
+	/* Set the input source current limit
+	 * between 100 to 1500mA */
+	if (ilim <= 100)
+		reg |= INPUT_SRC_CUR_LMT0;
+	else if (ilim <= 150)
+		reg |= INPUT_SRC_CUR_LMT1;
+	else if (ilim <= 500)
+		reg |= INPUT_SRC_CUR_LMT2;
+	else if (ilim <= 900)
+		reg |= INPUT_SRC_CUR_LMT3;
+	else if (ilim <= 1000)
+		reg |= INPUT_SRC_CUR_LMT4;
+	else if (ilim <= 1200)
+		reg |= INPUT_SRC_CUR_LMT5;
+	else if (ilim <= 2000)
+		reg |= INPUT_SRC_CUR_LMT6;
+	else
+		reg |= INPUT_SRC_CUR_LMT7;
+
+	return reg;
+}
+
+static u8 chrg_iterm_to_reg(int iterm)
+{
+	u8 reg;
+
+	if (iterm <= BQ24192_CHRG_ITERM_OFFSET)
+		reg = 0;
+	else
+		reg = ((iterm - BQ24192_CHRG_ITERM_OFFSET) /
+			BQ24192_CHRG_CUR_LSB_TO_ITERM);
+	return reg;
+}
+
+/* convert the charge current value
+ * into equivalent register setting
+ */
+static u8 chrg_cur_to_reg(int cur)
+{
+	u8 reg;
+
+	if (cur <= BQ24192_CHRG_CUR_OFFSET)
+		reg = 0x0;
+	else
+		reg = ((cur - BQ24192_CHRG_CUR_OFFSET) /
+				BQ24192_CHRG_CUR_LSB_TO_CUR);
+
+	if(((cur - BQ24192_CHRG_CUR_OFFSET) % BQ24192_CHRG_CUR_LSB_TO_CUR) > 0)
+		reg += 1;
+
+	/* D0, D1 bits of Charge Current
+	 * register are not used */
+	reg = reg << 2;
+	return reg;
+}
+
+/* convert the charge voltage value
+ * into equivalent register setting
+ */
+static u8 chrg_volt_to_reg(int volt)
+{
+	u8 reg,reg1;
+
+	if (volt <= BQ24192_CHRG_VOLT_OFFSET)
+		reg = 0x0;
+	else
+		reg = (volt - BQ24192_CHRG_VOLT_OFFSET) /
+				BQ24192_CHRG_VOLT_LSB_TO_VOLT;
+
+	reg1 = (volt - BQ24192_CHRG_VOLT_OFFSET) %
+				BQ24192_CHRG_VOLT_LSB_TO_VOLT;
+	if((reg1 >0)&&(reg1 < 16))
+		reg += 1;
+
+	reg = (reg << 2) | CHRG_VOLT_CNTL_BATTLOWV;
+	return reg;
+}
+
+static int bq24192_enable_hw_term(struct bq24192_chip *chip, bool hw_term_en)
+{
+	int ret = 0;
+
+	dev_info(&chip->client->dev, "%s\n", __func__);
+
+	/* Disable and enable charging to restart the charging */
+	ret = bq24192_reg_multi_bitset(chip->client,
+					BQ24192_POWER_ON_CFG_REG,
+					POWER_ON_CFG_CHRG_CFG_DIS,
+					CHR_CFG_BIT_POS,
+					CHR_CFG_BIT_LEN);
+	if (ret < 0) {
+		dev_warn(&chip->client->dev,
+			"i2c reg write failed: reg: %d, ret: %d\n",
+			BQ24192_POWER_ON_CFG_REG, ret);
+		return ret;
+	}
+
+	/* Read the timer control register */
+	ret = bq24192_read_reg(chip->client, BQ24192_CHRG_TIMER_EXP_CNTL_REG);
+	if (ret < 0) {
+		dev_warn(&chip->client->dev, "TIMER CTRL reg read failed\n");
+		return ret;
+	}
+
+	/*
+	 * Enable the HW termination. When disabled the HW termination, battery
+	 * was taking too long to go from charging to full state. HW based
+	 * termination could cause the battery capacity to drop but it would
+	 * result in good battery life.
+	 */
+	if (hw_term_en)
+		ret |= CHRG_TIMER_EXP_CNTL_EN_TERM;
+	else
+		ret &= ~CHRG_TIMER_EXP_CNTL_EN_TERM;
+
+	/* Program the TIMER CTRL register */
+	ret = bq24192_write_reg(chip->client,
+				BQ24192_CHRG_TIMER_EXP_CNTL_REG,
+				ret);
+	if (ret < 0)
+		dev_warn(&chip->client->dev, "TIMER CTRL I2C write failed\n");
+
+	return ret;
+}
+
+/*
+ * chip->event_lock need to be acquired before calling this function
+ * to avoid the race condition
+ */
+static int program_timers(struct bq24192_chip *chip, int wdt_duration,
+				bool sfttmr_enable)
+{
+	int ret;
+
+	/* Read the timer control register */
+	ret = bq24192_read_reg(chip->client, BQ24192_CHRG_TIMER_EXP_CNTL_REG);
+	if (ret < 0) {
+		dev_warn(&chip->client->dev, "TIMER CTRL reg read failed\n");
+		return ret;
+	}
+
+	/* First disable watchdog */
+	ret &= 0xCF;
+	bq24192_write_reg(chip->client,
+				BQ24192_CHRG_TIMER_EXP_CNTL_REG,
+				ret);
+
+	/* Read the timer control register */
+	ret = bq24192_read_reg(chip->client, BQ24192_CHRG_TIMER_EXP_CNTL_REG);
+	if (ret < 0) {
+		dev_warn(&chip->client->dev, "TIMER CTRL reg read failed\n");
+		return ret;
+	}
+
+	/* Program the time with duration passed */
+	ret &= 0xCF;
+	ret |=  wdt_duration;
+
+	/* Enable/Disable the safety timer */
+	if (sfttmr_enable)
+		ret |= CHRG_TIMER_EXP_CNTL_EN_TIMER;
+	else
+		ret &= ~CHRG_TIMER_EXP_CNTL_EN_TIMER;
+
+	/* Program the TIMER CTRL register */
+	ret = bq24192_write_reg(chip->client,
+				BQ24192_CHRG_TIMER_EXP_CNTL_REG,
+				ret);
+	if (ret < 0)
+		dev_warn(&chip->client->dev, "TIMER CTRL I2C write failed\n");
+
+	return ret;
+}
+
+/* This function should be called with the mutex held */
+static int reset_wdt_timer(struct bq24192_chip *chip)
+{
+	int ret = 0, i;
+
+	/* reset WDT timer */
+	for (i = 0; i < MAX_RESET_WDT_RETRY; i++) {
+		ret = bq24192_reg_read_modify(chip->client,
+						BQ24192_POWER_ON_CFG_REG,
+						WDTIMER_RESET_MASK, true);
+		if (ret < 0)
+			dev_warn(&chip->client->dev, "I2C write failed:%s\n",
+							__func__);
+	}
+	return ret;
+}
+
+/*
+ *This function will modify the VINDPM as per the battery voltage
+ */
+static int bq24192_modify_vindpm(u8 vindpm)
+{
+	int ret;
+	u8 vindpm_prev;
+	struct bq24192_chip *chip = i2c_get_clientdata(bq24192_client);
+
+	dev_info(&chip->client->dev, "%s\n", __func__);
+
+	/* Get the input src ctrl values programmed */
+	ret = bq24192_read_reg(chip->client,
+				BQ24192_INPUT_SRC_CNTL_REG);
+
+	if (ret < 0) {
+		dev_warn(&chip->client->dev, "INPUT CTRL reg read failed\n");
+		return ret;
+	}
+
+	/* Assign the return value of REG00 to vindpm_prev */
+	vindpm_prev = ret & INPUT_SRC_VINDPM_MASK;
+	ret &= ~INPUT_SRC_VINDPM_MASK;
+
+	/*
+	 * If both the previous and current values are same do not program
+	 * the register.
+	*/
+	if (vindpm_prev != vindpm) {
+		vindpm |= ret;
+		ret = bq24192_write_reg(chip->client,
+					BQ24192_INPUT_SRC_CNTL_REG, vindpm);
+		if (ret < 0) {
+			dev_info(&chip->client->dev, "VINDPM failed\n");
+			return ret;
+		}
+	}
+	return ret;
+}
+
+/* This function should be called with the mutex held */
+static int bq24192_turn_otg_vbus(struct bq24192_chip *chip, bool votg_on)
+{
+	int ret = 0;
+
+	dev_info(&chip->client->dev, "%s %d\n", __func__, votg_on);
+
+	if (votg_on) {
+			/* Program the timers */
+			ret = program_timers(chip,
+						CHRG_TIMER_EXP_CNTL_WDT80SEC,
+						false);
+			if (ret < 0) {
+				dev_warn(&chip->client->dev,
+					"TIMER enable failed %s\n", __func__);
+				goto i2c_write_fail;
+			}
+			/* Configure the charger in OTG mode */
+			ret = bq24192_reg_read_modify(chip->client,
+					BQ24192_POWER_ON_CFG_REG,
+					POWER_ON_CFG_CHRG_CFG_OTG, true);
+			if (ret < 0) {
+				dev_warn(&chip->client->dev,
+						"read reg modify failed\n");
+				goto i2c_write_fail;
+			}
+
+			/* Put the charger IC in reverse boost mode. Since
+			 * SDP charger can supply max 500mA charging current
+			 * Setting the boost current to 500mA
+			 */
+			ret = bq24192_reg_read_modify(chip->client,
+					BQ24192_POWER_ON_CFG_REG,
+					POWER_ON_CFG_BOOST_LIM, false);
+			if (ret < 0) {
+				dev_warn(&chip->client->dev,
+						"read reg modify failed\n");
+				goto i2c_write_fail;
+			}
+			chip->boost_mode = true;
+			/* Schedule the charger task worker now */
+			schedule_delayed_work(&chip->chrg_task_wrkr,
+						0);
+	} else {
+			/* Clear the charger from the OTG mode */
+			ret = bq24192_reg_read_modify(chip->client,
+					BQ24192_POWER_ON_CFG_REG,
+					POWER_ON_CFG_CHRG_CFG_OTG, false);
+			if (ret < 0) {
+				dev_warn(&chip->client->dev,
+						"read reg modify failed\n");
+				goto i2c_write_fail;
+			}
+
+			/* Put the charger IC out of reverse boost mode 500mA */
+			ret = bq24192_reg_read_modify(chip->client,
+					BQ24192_POWER_ON_CFG_REG,
+					POWER_ON_CFG_BOOST_LIM, false);
+			if (ret < 0) {
+				dev_warn(&chip->client->dev,
+						"read reg modify failed\n");
+				goto i2c_write_fail;
+			}
+			chip->boost_mode = false;
+			/* Cancel the charger task worker now */
+			cancel_delayed_work_sync(&chip->chrg_task_wrkr);
+	}
+
+	/*
+	 *  Drive the gpio to turn ON/OFF the VBUS
+	 */
+	if (chip->pdata->drive_vbus)
+		chip->pdata->drive_vbus(votg_on);
+
+	return ret;
+i2c_write_fail:
+	dev_err(&chip->client->dev, "%s: Failed\n", __func__);
+	return ret;
+}
+
+#ifdef CONFIG_DEBUG_FS
+#define DBGFS_REG_BUF_LEN	3
+
+static int bq24192_show(struct seq_file *seq, void *unused)
+{
+	u16 val;
+	long addr;
+
+	if (kstrtol((char *)seq->private, 16, &addr))
+		return -EINVAL;
+
+	val = bq24192_read_reg(bq24192_client, addr);
+	seq_printf(seq, "%x\n", val);
+
+	return 0;
+}
+
+static int bq24192_dbgfs_open(struct inode *inode, struct file *file)
+{
+	return single_open(file, bq24192_show, inode->i_private);
+}
+
+static ssize_t bq24192_dbgfs_reg_write(struct file *file,
+		const char __user *user_buf, size_t count, loff_t *ppos)
+{
+	char buf[DBGFS_REG_BUF_LEN];
+	long addr;
+	unsigned long value;
+	int ret;
+	struct seq_file *seq = file->private_data;
+
+	if (!seq || kstrtol((char *)seq->private, 16, &addr))
+		return -EINVAL;
+
+	if (copy_from_user(buf, user_buf, DBGFS_REG_BUF_LEN-1))
+		return -EFAULT;
+
+	buf[DBGFS_REG_BUF_LEN-1] = '\0';
+	if (kstrtoul(buf, 16, &value))
+		return -EINVAL;
+
+	dev_info(&bq24192_client->dev,
+			"[dbgfs write] Addr:0x%x Val:0x%x\n",
+			(u32)addr, (u32)value);
+
+
+	ret = bq24192_write_reg(bq24192_client, addr, value);
+	if (ret < 0)
+		dev_warn(&bq24192_client->dev, "I2C write failed\n");
+
+	return count;
+}
+
+static const struct file_operations bq24192_dbgfs_fops = {
+	.owner		= THIS_MODULE,
+	.open		= bq24192_dbgfs_open,
+	.read		= seq_read,
+	.write		= bq24192_dbgfs_reg_write,
+	.llseek		= seq_lseek,
+	.release	= single_release,
+};
+
+static int bq24192_create_debugfs(struct bq24192_chip *chip)
+{
+	int i;
+	struct dentry *entry;
+
+	bq24192_dbgfs_root = debugfs_create_dir(DEV_NAME, NULL);
+	if (IS_ERR(bq24192_dbgfs_root)) {
+		dev_warn(&chip->client->dev, "DEBUGFS DIR create failed\n");
+		return -ENOMEM;
+	}
+
+	for (i = 0; i < BQ24192_MAX_MEM; i++) {
+		sprintf((char *)&bq24192_dbg_regs[i], "%x", i);
+		entry = debugfs_create_file(
+					(const char *)&bq24192_dbg_regs[i],
+					S_IRUGO,
+					bq24192_dbgfs_root,
+					&bq24192_dbg_regs[i],
+					&bq24192_dbgfs_fops);
+		if (IS_ERR(entry)) {
+			debugfs_remove_recursive(bq24192_dbgfs_root);
+			bq24192_dbgfs_root = NULL;
+			dev_warn(&chip->client->dev,
+					"DEBUGFS entry Create failed\n");
+			return -ENOMEM;
+		}
+	}
+
+	return 0;
+}
+static inline void bq24192_remove_debugfs(struct bq24192_chip *chip)
+{
+	if (bq24192_dbgfs_root)
+		debugfs_remove_recursive(bq24192_dbgfs_root);
+}
+#else
+static inline int bq24192_create_debugfs(struct bq24192_chip *chip)
+{
+	return 0;
+}
+static inline void bq24192_remove_debugfs(struct bq24192_chip *chip)
+{
+}
+#endif
+
+static inline int bq24192_enable_charging(
+			struct bq24192_chip *chip, bool val)
+{
+	int ret;
+	u8 regval;
+
+	dev_warn(&chip->client->dev, "%s:%d %d\n", __func__, __LINE__, val);
+
+	ret = program_timers(chip, CHRG_TIMER_EXP_CNTL_WDT160SEC, true);
+	if (ret < 0) {
+		dev_err(&chip->client->dev,
+				"program_timers failed: %d\n", ret);
+		return ret;
+	}
+
+	/*
+	 * Program the inlmt here in case we are asked to resume the charging
+	 * framework would send only set CC/CV commands and not the inlmt. This
+	 * would make sure that we program the last set inlmt into the register
+	 * in case for some reasons WDT expires
+	 */
+	regval = chrg_ilim_to_reg(chip->inlmt);
+
+	ret = bq24192_reg_read_modify(chip->client, BQ24192_INPUT_SRC_CNTL_REG,
+				regval, true);
+	if (ret < 0) {
+		dev_err(&chip->client->dev,
+				"inlmt programming failed: %d\n", ret);
+		return ret;
+	}
+
+	/*
+	 * check if we have the battery emulator connected. We do not start
+	 * charging if the emulator is connected. Disable the charging
+	 * explicitly.
+	 */
+	if (!chip->pdata->sfi_tabl_present) {
+		ret = bq24192_reg_multi_bitset(chip->client,
+						BQ24192_POWER_ON_CFG_REG,
+						POWER_ON_CFG_CHRG_CFG_DIS,
+						CHR_CFG_BIT_POS,
+						CHR_CFG_BIT_LEN);
+		/* Schedule the charger task worker now */
+		schedule_delayed_work(&chip->chrg_task_wrkr,
+						0);
+		return ret;
+	}
+
+	if (val) {
+		/* Schedule the charger task worker now */
+		schedule_delayed_work(&chip->chrg_task_wrkr, 0);
+
+		/*
+		 * Prevent system from entering s3 while charger is connected
+		 */
+		if (!wake_lock_active(&chip->wakelock))
+			wake_lock(&chip->wakelock);
+	} else {
+		/* Release the wake lock */
+		if (wake_lock_active(&chip->wakelock))
+			wake_unlock(&chip->wakelock);
+
+		/*
+		 * Cancel the worker since it need not run when charging is not
+		 * happening
+		 */
+		cancel_delayed_work_sync(&chip->chrg_full_wrkr);
+
+		/* Read the status to know about input supply */
+		ret = bq24192_read_reg(chip->client, BQ24192_SYSTEM_STAT_REG);
+		if (ret < 0) {
+			dev_warn(&chip->client->dev,
+				"read reg failed %s\n", __func__);
+		}
+
+		/* If no charger connected, cancel the workers */
+		if (!(ret & SYSTEM_STAT_VBUS_OTG)) {
+			dev_info(&chip->client->dev, "NO charger connected\n");
+			chip->sfttmr_expired = false;
+			cancel_delayed_work_sync(&chip->chrg_task_wrkr);
+		}
+	}
+
+	ret = val ? POWER_ON_CFG_CHRG_CFG_EN : POWER_ON_CFG_CHRG_CFG_DIS;
+
+	if (!val && chip->sfttmr_expired)
+		return ret;
+
+	ret = bq24192_reg_multi_bitset(chip->client,
+					BQ24192_POWER_ON_CFG_REG,
+					ret, CHR_CFG_BIT_POS,
+					CHR_CFG_BIT_LEN);
+
+	return ret;
+}
+
+static inline int bq24192_enable_charger(
+			struct bq24192_chip *chip, int val)
+{
+	int ret;
+
+	/*stop charger for throttle state 3, by putting it in HiZ mode*/
+	if (chip->cntl_state == 0x3) {
+		ret = bq24192_reg_read_modify(chip->client,
+			BQ24192_INPUT_SRC_CNTL_REG,
+				INPUT_SRC_CNTL_EN_HIZ, true);
+
+		if (ret < 0)
+			dev_warn(&chip->client->dev,
+				"Input src cntl write failed\n");
+	}
+
+	dev_warn(&chip->client->dev, "%s:%d %d\n", __func__, __LINE__, val);
+
+	return bq24192_enable_charging(chip, val);
+}
+
+static inline int bq24192_set_cc(struct bq24192_chip *chip, int cc)
+{
+	u8 regval,value;
+
+	dev_warn(&chip->client->dev, "%s:%d %d\n", __func__, __LINE__, cc);
+	regval = chrg_cur_to_reg(cc);
+	value = bq24192_read_reg(chip->client, BQ24192_CHRG_CUR_CNTL_REG);
+	value = ((value&0x03)|regval);
+
+	return bq24192_write_reg(chip->client, BQ24192_CHRG_CUR_CNTL_REG,
+				value);
+}
+
+static inline int bq24192_set_cv(struct bq24192_chip *chip, int cv)
+{
+	u8 regval;
+
+	dev_warn(&chip->client->dev, "%s:%d %d\n", __func__, __LINE__, cv);
+	regval = chrg_volt_to_reg(cv);
+
+	return bq24192_write_reg(chip->client, BQ24192_CHRG_VOLT_CNTL_REG,
+					(regval | CHRG_VOLT_CNTL_VRECHRG)|CHRG_VOLT_CNTL_BATTLOWV);
+}
+
+static inline int bq24192_set_inlmt(struct bq24192_chip *chip, int inlmt)
+{
+	u8 regval,value;
+
+	dev_warn(&chip->client->dev, "%s:%d %d\n", __func__, __LINE__, inlmt);
+	chip->inlmt = inlmt;
+	regval = chrg_ilim_to_reg(inlmt);
+	value = bq24192_read_reg(chip->client, BQ24192_INPUT_SRC_CNTL_REG);
+	regval = ((value&0xF8)|regval);
+	return bq24192_write_reg(chip->client, BQ24192_INPUT_SRC_CNTL_REG,
+				regval);
+}
+
+static inline int bq24192_set_iterm(struct bq24192_chip *chip, int iterm)
+{
+	u8 reg_val;
+
+	if (iterm > BQ24192_CHRG_ITERM_OFFSET)
+		dev_warn(&chip->client->dev,
+			"%s ITERM set for >128mA", __func__);
+
+	reg_val = chrg_iterm_to_reg(iterm);
+	//msleep(500);
+
+	return bq24192_write_reg(chip->client,
+			BQ24192_PRECHRG_TERM_CUR_CNTL_REG,
+				(BQ24192_PRE_CHRG_CURR_256 | reg_val));
+}
+
+static inline int bq24192_get_inlmt(struct bq24192_chip *chip) {
+	u8 regval;
+        int value = 100;
+
+        regval = bq24192_read_reg(chip->client, BQ24192_INPUT_SRC_CNTL_REG);
+	regval &= 0x07;
+        switch (regval) {
+            case 0:
+               value = 100;
+               break;
+            case 1:
+               value = 150;
+               break;
+            case 2:
+               value = 500;
+               break;
+            case 3:
+               value = 900;
+               break;
+            case 4:
+               value = 1000;
+               break;
+            case 5:
+               value = 1200;
+               break;
+            case 6:
+               value = 2000;
+               break;
+            case 7:
+               value = 3000;
+               break;
+        }
+        dev_warn(&chip->client->dev, "%s:%d ,input current = %d mA\n", __func__, __LINE__, value);
+
+	return value;
+}
+
+int bq24192_chargeric_status (void) {
+	int ret;
+	struct bq24192_chip *chip=NULL;
+
+	chip = chip_extern;
+	if((chip->client == NULL)||(chip == NULL)) {
+		printk("chip->client == null\n");
+		return -1;
+	}
+
+        mutex_lock(&chip_extern->event_lock);
+	ret = bq24192_read_reg(chip->client, BQ24192_SYSTEM_STAT_REG);
+        mutex_unlock(&chip_extern->event_lock);
+
+	if (ret < 0)
+		dev_err(&chip->client->dev, "STATUS register read failed\n");
+
+	return ret;
+}
+
+int bq24192_is_charging(void)
+{
+	int ret;
+	struct bq24192_chip *chip=NULL;
+
+        if(chip_extern == NULL)
+	{
+		printk("chip_extern == null\n");
+		return BQ24192_CHRGR_STAT_FAULT;
+	}
+
+	chip = chip_extern;
+	ret = bq24192_read_reg(chip->client, BQ24192_SYSTEM_STAT_REG);
+	if (ret < 0)
+		dev_err(&chip->client->dev, "STATUS register read failed\n");
+
+	ret &= SYSTEM_STAT_CHRG_MASK;
+
+	switch (ret) {
+	case SYSTEM_STAT_NOT_CHRG:
+		chip->chgr_stat = BQ24192_CHRGR_STAT_FAULT;
+		break;
+	case SYSTEM_STAT_CHRG_DONE:
+		chip->chgr_stat = BQ24192_CHRGR_STAT_BAT_FULL;
+		break;
+	case SYSTEM_STAT_PRE_CHRG:
+	case SYSTEM_STAT_FAST_CHRG:
+		chip->chgr_stat = BQ24192_CHRGR_STAT_CHARGING;
+		break;
+	default:
+		break;
+	}
+
+	return chip->chgr_stat;
+}
+EXPORT_SYMBOL(bq24192_is_charging);
+
+// Webber [TT-559041] ++++++++++++++++++++++++++++++++++++
+bool detect_charging(void)
+{
+	int charger_status;
+	int ret;
+	struct bq24192_chip *chip=NULL;
+
+        if(chip_extern == NULL)
+	{
+		printk("chip_extern == null\n");
+		return BQ24192_CHRGR_STAT_FAULT;
+	}
+
+	chip = chip_extern;
+	ret = bq24192_read_reg(chip->client, BQ24192_SYSTEM_STAT_REG);
+	if (ret < 0)
+		dev_err(&chip->client->dev, "STATUS register read failed\n");
+
+	ret &= SYSTEM_STAT_PWR_GOOD;
+
+	printk("[%s] ret = %d  \n", __func__ , ret);
+
+	if ( ret == SYSTEM_STAT_PWR_GOOD )
+	{
+	        printk("[%s] charging\n", __func__);
+		return (true);
+	}else{
+		printk("[%s] isn't charging\n", __func__);
+		return (false);
+	}
+
+}
+// Webber -----------------------------------
+
+
+static int bq24192_usb_set_property(struct power_supply *psy,
+					enum power_supply_property psp,
+					const union power_supply_propval *val)
+{
+	struct bq24192_chip *chip = container_of(psy,
+						struct bq24192_chip,
+						usb);
+	int ret = 0;
+
+	dev_dbg(&chip->client->dev, "%s %d\n", __func__, psp);
+	if (mutex_is_locked(&chip->event_lock)) {
+		dev_dbg(&chip->client->dev,
+			"%s: mutex is already acquired",
+				__func__);
+	}
+	mutex_lock(&chip->event_lock);
+
+	switch (psp) {
+
+	case POWER_SUPPLY_PROP_PRESENT:
+		chip->present = val->intval;
+		break;
+	case POWER_SUPPLY_PROP_ONLINE:
+		chip->online = val->intval;
+		break;
+	case POWER_SUPPLY_PROP_ENABLE_CHARGING:
+		bq24192_enable_hw_term(chip, val->intval);
+		ret = bq24192_enable_charging(chip, val->intval);
+
+		if (ret < 0)
+			dev_err(&chip->client->dev,
+				"Error(%d) in %s charging", ret,
+				(val->intval ? "enable" : "disable"));
+		else
+			chip->is_charging_enabled = val->intval;
+
+		if (!val->intval)
+			cancel_delayed_work_sync(&chip->chrg_full_wrkr);
+		break;
+	case POWER_SUPPLY_PROP_ENABLE_CHARGER:
+		ret = bq24192_enable_charger(chip, val->intval);
+
+		if (ret < 0) {
+			dev_err(&chip->client->dev,
+			"Error(%d) in %s charger", ret,
+			(val->intval ? "enable" : "disable"));
+		} else
+			chip->is_charger_enabled = val->intval;
+		break;
+	case POWER_SUPPLY_PROP_CHARGE_CURRENT:
+		ret = bq24192_set_cc(chip, val->intval);
+		if (!ret)
+			chip->cc = val->intval;
+		break;
+	case POWER_SUPPLY_PROP_CHARGE_VOLTAGE:
+		ret = bq24192_set_cv(chip, val->intval);
+		if (!ret)
+			chip->cv = val->intval;
+		break;
+	case POWER_SUPPLY_PROP_MAX_CHARGE_CURRENT:
+		chip->max_cc = val->intval;
+		break;
+	case POWER_SUPPLY_PROP_MAX_CHARGE_VOLTAGE:
+		chip->max_cv = val->intval;
+		break;
+	case POWER_SUPPLY_PROP_CHARGE_TERM_CUR:
+		ret = bq24192_set_iterm(chip, val->intval);
+		if (!ret)
+			chip->iterm = val->intval;
+		break;
+	case POWER_SUPPLY_PROP_CABLE_TYPE:
+		chip->cable_type = val->intval;
+		chip->usb.type = get_power_supply_type(chip->cable_type);
+		break;
+	case POWER_SUPPLY_PROP_INLMT:
+		ret = bq24192_set_inlmt(chip, val->intval);
+		if (!ret)
+			chip->inlmt = val->intval;
+		break;
+	case POWER_SUPPLY_PROP_MAX_TEMP:
+		chip->max_temp = val->intval;
+		break;
+	case POWER_SUPPLY_PROP_MIN_TEMP:
+		chip->min_temp = val->intval;
+		break;
+	case POWER_SUPPLY_PROP_CHARGE_CONTROL_LIMIT:
+		chip->cntl_state = val->intval;
+		break;
+	default:
+		ret = -ENODATA;
+	}
+
+	mutex_unlock(&chip->event_lock);
+	return ret;
+}
+
+static int bq24192_usb_get_property(struct power_supply *psy,
+			enum power_supply_property psp,
+			union power_supply_propval *val)
+{
+	struct bq24192_chip *chip = container_of(psy,
+					struct bq24192_chip,
+					usb);
+	enum bq24192_chrgr_stat charging;
+
+	dev_dbg(&chip->client->dev, "%s %d\n", __func__, psp);
+	if (system_state != SYSTEM_RUNNING) {
+		if (!mutex_trylock(&chip->event_lock))
+			return -EBUSY;
+		} else
+			mutex_lock(&chip->event_lock);
+
+	switch (psp) {
+	case POWER_SUPPLY_PROP_PRESENT:
+		val->intval = chip->present;
+		break;
+	case POWER_SUPPLY_PROP_ONLINE:
+		val->intval = chip->online;
+		break;
+	case POWER_SUPPLY_PROP_HEALTH:
+		val->intval = bq24192_get_charger_health();
+		break;
+	case POWER_SUPPLY_PROP_MAX_CHARGE_CURRENT:
+		val->intval = chip->max_cc;
+		break;
+	case POWER_SUPPLY_PROP_MAX_CHARGE_VOLTAGE:
+		val->intval = chip->max_cv;
+		break;
+	case POWER_SUPPLY_PROP_CHARGE_CURRENT:
+		val->intval = chip->cc;
+		break;
+	case POWER_SUPPLY_PROP_CHARGE_VOLTAGE:
+		val->intval = chip->cv;
+		break;
+	case POWER_SUPPLY_PROP_INLMT:
+		val->intval = chip->inlmt;
+		break;
+	case POWER_SUPPLY_PROP_CHARGE_TERM_CUR:
+		val->intval = chip->iterm;
+		break;
+	case POWER_SUPPLY_PROP_CABLE_TYPE:
+		val->intval = chip->cable_type;
+		break;
+	case POWER_SUPPLY_PROP_ENABLE_CHARGING:
+		if (chip->boost_mode)
+			val->intval = false;
+		else {
+			charging = bq24192_is_charging();
+			val->intval = (chip->is_charging_enabled && charging);
+		}
+		break;
+	case POWER_SUPPLY_PROP_ENABLE_CHARGER:
+		val->intval = chip->is_charger_enabled;
+		break;
+	case POWER_SUPPLY_PROP_CHARGE_CONTROL_LIMIT:
+		val->intval = chip->cntl_state;
+		break;
+	case POWER_SUPPLY_PROP_CHARGE_CONTROL_LIMIT_MAX:
+		val->intval = chip->pdata->num_throttle_states;
+		break;
+	case POWER_SUPPLY_PROP_MAX_TEMP:
+		val->intval = chip->max_temp;
+		break;
+	case POWER_SUPPLY_PROP_MIN_TEMP:
+		val->intval = chip->min_temp;
+		break;
+	default:
+		mutex_unlock(&chip->event_lock);
+		return -EINVAL;
+	}
+
+	mutex_unlock(&chip->event_lock);
+	return 0;
+}
+
+static void bq24192_resume_charging(struct bq24192_chip *chip)
+{
+	if (chip->inlmt)
+		bq24192_set_inlmt(chip, chip->inlmt);
+	if (chip->cc)
+		bq24192_set_cc(chip, chip->cc);
+	if (chip->cv)
+		bq24192_set_cv(chip, chip->cv);
+	if (chip->is_charging_enabled)
+		bq24192_enable_charging(chip, true);
+	if (chip->is_charger_enabled)
+		bq24192_enable_charger(chip, true);
+}
+
+static void bq24192_full_worker(struct work_struct *work)
+{
+	struct bq24192_chip *chip = container_of(work,
+						    struct bq24192_chip,
+						    chrg_full_wrkr.work);
+	static int ret,count;
+
+	count += 1;
+	if(count == 4){
+		count = 0;
+		ret = bq24192_read_reg(chip_extern->client, BQ24192_INPUT_SRC_CNTL_REG);
+		printk("Input limit:%x %d\n",ret,cable_status);
+	}
+	//power_supply_changed(NULL);
+	reset_wdt_timer(chip_extern);
+	/* schedule the thread to let the framework know about FULL */
+	schedule_delayed_work(&chip->chrg_full_wrkr, 30*HZ);
+}
+
+static void otg_disable_worker(struct work_struct *work)
+{
+	printk("otg_resume_enable\n");
+	int ret=0;
+	ret=bq24192_reg_read_modify(chip_extern->client,
+		                 BQ24192_POWER_ON_CFG_REG,0x20, true);
+    if (ret < 0) {
+		 printk("Error in writing the control register BQ24192_POWER_ON_CFG_REG\n");
+	}
+}
+
+/* IRQ handler for charger Interrupts configured to GPIO pin */
+static irqreturn_t bq24192_irq_isr(int irq, void *devid)
+{
+	struct bq24192_chip *chip = (struct bq24192_chip *)devid;
+
+	/**TODO: This hanlder will be used for charger Interrupts */
+	dev_dbg(&chip->client->dev,
+		"IRQ Handled for charger interrupt: %d\n", irq);
+
+	return IRQ_WAKE_THREAD;
+}
+
+/* IRQ handler for charger Interrupts configured to GPIO pin */
+static irqreturn_t bq24192_irq_thread(int irq, void *devid)
+{
+	struct bq24192_chip *chip = (struct bq24192_chip *)devid;
+	int reg_status, reg_fault,pending;
+    int ret=0;
+
+	pending = intel_mid_pmic_readb(R_PMIC_CHGRIRQ);
+	if(pending&0x01){
+	  intel_mid_pmic_writeb(R_PMIC_CHGRIRQ,pending);
+	}
+	/* Check if battery fault condition occured. Reading the register
+	   value two times to get reliable reg value, recommended by vendor*/
+	reg_fault = bq24192_read_reg(chip->client, BQ24192_FAULT_STAT_REG);
+	if (reg_fault < 0)
+		dev_err(&chip->client->dev, "FAULT register read failed:\n");
+
+
+	if(reg_fault & FAULT_STAT_OTG_FLT){
+
+        ret=bq24192_reg_read_modify(chip_extern->client,
+		                 BQ24192_POWER_ON_CFG_REG,0x20, false);
+        if (ret < 0) {
+		 printk("Error in writing the control register\n");
+		}
+	   //schedule_delayed_work(&chip->otg_disable_wrkr, 5);
+       printk("bq24192 otg fault\n");
+	}
+	dev_info(&chip->client->dev, "FAULT reg %x\n", reg_fault);
+	reg_fault = bq24192_read_reg(chip->client, BQ24192_FAULT_STAT_REG);
+	if (reg_fault < 0)
+		dev_err(&chip->client->dev, "FAULT register read failed:\n");
+	dev_info(&chip->client->dev, "FAULT reg %x\n", reg_fault);
+	/*
+	 * check the bq24192 status/fault registers to see what is the
+	 * source of the interrupt
+	 */
+	reg_status = bq24192_read_reg(chip->client, BQ24192_SYSTEM_STAT_REG);
+	if (reg_status < 0)
+		dev_err(&chip->client->dev, "STATUS register read failed:\n");
+	dev_info(&chip->client->dev, "STATUS reg %x\n", reg_status);
+
+	if( (reg_status&0x30) == 0x20){
+		if(cable_status == POWER_SUPPLY_CHARGER_TYPE_USB_DCP){
+			ret = bq24192_read_reg(chip->client, BQ24192_INPUT_SRC_CNTL_REG);
+			printk("Input source: %x\n",ret);
+			bq24192_set_inlmt(chip_extern,1200);
+		}
+	}
+	return IRQ_HANDLED;
+}
+
+static void bq24192_PowerState_worker(struct work_struct *work)
+{
+	int type;
+	int ret=0;
+
+#ifndef USB_NOTIFY_CALLBACK
+	if(PowerStateOk){
+		   mutex_lock(&chip_extern->event_lock);
+		    ret=bq24192_reg_read_modify(chip_extern->client,
+		              BQ24192_INPUT_SRC_CNTL_REG,0x80,false);
+		    if (ret < 0) {
+			     mutex_unlock(&chip_extern->event_lock);
+			     printk("Error in writing the control register\n");
+			   return;
+
+		     }
+		   mutex_unlock(&chip_extern->event_lock);
+
+	   	    mutex_lock(&chip_extern->event_lock);
+		    ret=bq24192_reg_read_modify(chip_extern->client,
+		              BQ24192_POWER_ON_CFG_REG,0x10, true);
+		    if (ret < 0) {
+			     mutex_unlock(&chip_extern->event_lock);
+			     printk("Error in writing the control register\n");
+			   return;
+
+		     }
+		    chip_extern->is_charging_enabled=true;
+		    mutex_unlock(&chip_extern->event_lock);
+		 PowerStateOk = 0;
+		 type = GetPowerState();
+
+		 if(OtgOk)
+			type = POWER_SUPPLY_CHARGER_TYPE_NONE;
+		 bq24192_cable_callback(type);
+	   }
+	else{
+		schedule_delayed_work(&chip_extern->power_state_task_wrkr, 1*HZ);
+	}
+#endif
+}
+
+static void bq24192_task_worker(struct work_struct *work)
+{
+	struct bq24192_chip *chip =
+	    container_of(work, struct bq24192_chip, chrg_task_wrkr.work);
+	int ret, jiffy = CHARGER_TASK_JIFFIES, vbatt;
+	static int prev_health = POWER_SUPPLY_HEALTH_GOOD;
+	int curr_health;
+	u8 vindpm = INPUT_SRC_VOLT_LMT_DEF;
+
+	dev_info(&chip->client->dev, "%s\n", __func__);
+
+	/* Reset the WDT */
+	mutex_lock(&chip->event_lock);
+	ret = reset_wdt_timer(chip);
+	mutex_unlock(&chip->event_lock);
+	if (ret < 0)
+		dev_warn(&chip->client->dev, "WDT reset failed:\n");
+
+	/*
+	 * If we have an OTG device connected, no need to modify the VINDPM
+	 * check for Hi-Z
+	 */
+	if (chip->boost_mode) {
+		jiffy = CHARGER_HOST_JIFFIES;
+		goto sched_task_work;
+	}
+
+	if (!(chip->cntl_state == 0x3)) {
+		/* Clear the charger from Hi-Z */
+		ret = bq24192_clear_hiz(chip);
+		if (ret < 0)
+			dev_warn(&chip->client->dev, "HiZ clear failed:\n");
+	}
+
+	/* Modify the VINDPM */
+
+	/* read the battery voltage */
+	vbatt = fg_chip_get_property(POWER_SUPPLY_PROP_VOLTAGE_OCV);
+	if (vbatt == -ENODEV || vbatt == -EINVAL) {
+		dev_err(&chip->client->dev, "Can't read voltage from FG\n");
+		goto sched_task_work;
+	}
+
+	/* convert voltage into millivolts */
+	vbatt /= 1000;
+	dev_warn(&chip->client->dev, "vbatt = %d\n", vbatt);
+
+	/* If vbatt <= 3600mV, leave the VINDPM settings to default */
+	if (vbatt <= INPUT_SRC_LOW_VBAT_LIMIT)
+		goto sched_task_work;
+
+	if (vbatt > INPUT_SRC_LOW_VBAT_LIMIT &&
+		vbatt < INPUT_SRC_MIDL_VBAT_LIMIT)
+		vindpm = INPUT_SRC_VOLT_LMT_444;
+	else if (vbatt > INPUT_SRC_MIDL_VBAT_LIMIT &&
+		vbatt < INPUT_SRC_MIDH_VBAT_LIMIT)
+		vindpm = INPUT_SRC_VOLT_LMT_468;
+	else if (vbatt > INPUT_SRC_MIDH_VBAT_LIMIT &&
+		vbatt < INPUT_SRC_HIGH_VBAT_LIMIT)
+		vindpm = INPUT_SRC_VOLT_LMT_476;
+
+	if (!mutex_trylock(&chip->event_lock))
+		goto sched_task_work;
+	ret = bq24192_modify_vindpm(vindpm);
+	if (ret < 0)
+		dev_err(&chip->client->dev, "%s failed\n", __func__);
+	mutex_unlock(&chip->event_lock);
+
+	/*
+	 * BQ driver depends upon the charger interrupt to send notification
+	 * to the framework about the HW charge termination and then framework
+	 * starts to poll the driver for declaring FULL. Presently the BQ
+	 * interrupts are not coming properly, so the driver would notify the
+	 * framework when battery is nearing FULL.
+	*/
+	if (vbatt >= BATTERY_NEAR_FULL(chip->max_cv))
+		power_supply_changed(NULL);
+
+sched_task_work:
+
+	curr_health = bq24192_get_battery_health();
+	if (prev_health != curr_health) {
+		power_supply_changed(&chip->usb);
+		dev_warn(&chip->client->dev,
+			"%s health status  %d",
+				__func__, prev_health);
+	}
+	prev_health = curr_health;
+
+	if (BQ24192_CHRGR_STAT_BAT_FULL == bq24192_is_charging()) {
+		power_supply_changed(&chip->usb);
+		dev_warn(&chip->client->dev,
+			"%s battery full", __func__);
+	}
+
+	schedule_delayed_work(&chip->chrg_task_wrkr, jiffy);
+}
+
+static void bq24192_otg_evt_worker(struct work_struct *work)
+{
+	struct bq24192_chip *chip =
+	    container_of(work, struct bq24192_chip, otg_evt_work);
+	struct bq24192_otg_event *evt, *tmp;
+	unsigned long flags;
+	int ret = 0;
+
+	dev_info(&chip->client->dev, "%s\n", __func__);
+
+	spin_lock_irqsave(&chip->otg_queue_lock, flags);
+	list_for_each_entry_safe(evt, tmp, &chip->otg_queue, node) {
+		list_del(&evt->node);
+		spin_unlock_irqrestore(&chip->otg_queue_lock, flags);
+
+		dev_info(&chip->client->dev,
+			"%s:%d state=%d\n", __FILE__, __LINE__,
+				evt->is_enable);
+
+		ret = bq24192_turn_otg_vbus(chip, evt->is_enable);
+		if (ret < 0)
+			dev_err(&chip->client->dev, "VBUS ON FAILED:\n");
+
+		spin_lock_irqsave(&chip->otg_queue_lock, flags);
+		kfree(evt);
+
+	}
+	spin_unlock_irqrestore(&chip->otg_queue_lock, flags);
+}
+
+
+static void bq24192_temp_update_worker(struct work_struct *work)
+{
+	struct bq24192_chip *chip =
+	    container_of(work, struct bq24192_chip, chrg_temp_wrkr.work);
+	int fault_reg = 0, fg_temp = 0;
+	static bool is_otp_notified;
+
+	dev_info(&chip->client->dev, "%s\n", __func__);
+	/* Check if battery fault condition occured. Reading the register
+	   value two times to get reliable reg value, recommended by vendor*/
+	fault_reg = bq24192_read_reg(chip->client, BQ24192_FAULT_STAT_REG);
+	if (fault_reg < 0) {
+		dev_err(&chip->client->dev,
+			"Fault status read failed: %d\n", fault_reg);
+		goto temp_wrkr_error;
+	}
+	fault_reg = bq24192_read_reg(chip->client, BQ24192_FAULT_STAT_REG);
+	if (fault_reg < 0) {
+		dev_err(&chip->client->dev,
+			"Fault status read failed: %d\n", fault_reg);
+		goto temp_wrkr_error;
+	}
+
+	fg_temp = fg_chip_get_property(POWER_SUPPLY_PROP_TEMP);
+	if (fg_temp == -ENODEV || fg_temp == -EINVAL) {
+		dev_err(&chip->client->dev,
+			"Failed to read FG temperature\n");
+		/* If failed to read fg temperature, use charger fault
+		 * status to identify the recovery */
+		if (fault_reg & FAULT_STAT_BATT_TEMP_BITS) {
+			schedule_delayed_work(&chip->chrg_temp_wrkr,
+				TEMP_THREAD_JIFFIES);
+		} else {
+			power_supply_changed(&chip->usb);
+		}
+		goto temp_wrkr_error;
+	}
+	fg_temp = fg_temp/10;
+
+	if (fg_temp >= chip->pdata->max_temp
+		|| fg_temp <= chip->pdata->min_temp) {
+		if (!is_otp_notified) {
+			dev_info(&chip->client->dev,
+				"Battery over temp occurred!!!!\n");
+			power_supply_changed(&chip->usb);
+			is_otp_notified = true;
+		}
+	} else if (!(fault_reg & FAULT_STAT_BATT_TEMP_BITS)) {
+		/* over temperature is recovered if battery temp
+		 * is between min_temp to max_temp and charger
+		 * temperature fault bits are cleared */
+		is_otp_notified = false;
+		dev_info(&chip->client->dev,
+			"Battery over temp recovered!!!!\n");
+		power_supply_changed(&chip->usb);
+		/*Return without reschedule as over temp recovered*/
+		return;
+	}
+	schedule_delayed_work(&chip->chrg_temp_wrkr, TEMP_THREAD_JIFFIES);
+	return;
+
+temp_wrkr_error:
+	is_otp_notified = false;
+	return;
+}
+
+
+static int otg_handle_notification(struct notifier_block *nb,
+				   unsigned long event, void *param)
+{
+	struct bq24192_chip *chip =
+	    container_of(nb, struct bq24192_chip, otg_nb);
+	struct bq24192_otg_event *evt;
+
+	dev_info(&chip->client->dev, "OTG notification: %lu\n", event);
+
+    	printk("wigman....%s...vbus_Event=%d\n",__func__,vbus_Event);
+	if((!OtgOk)&&vbus_Event){
+	    vbus_Event = 0;
+	    printk("wigman.....clear vbus_Event%d\n",VbusDetach);
+	    if(VbusDetach){
+#ifndef USB_NOTIFY_CALLBACK
+		   PowerStateOk = 0;
+#endif
+		   Power_State = POWER_SUPPLY_CHARGER_TYPE_NONE;
+		   cancel_delayed_work(&chip_extern->power_state_task_wrkr);
+		   bq24192_cable_callback(POWER_SUPPLY_CHARGER_TYPE_NONE);
+		}else{
+			schedule_delayed_work(&chip->power_state_task_wrkr, 1*HZ);
+		}
+	}
+	if (!param || event != USB_EVENT_DRIVE_VBUS)
+		return NOTIFY_DONE;
+
+	evt = kzalloc(sizeof(*evt), GFP_ATOMIC);
+	if (!evt) {
+		dev_err(&chip->client->dev,
+			"failed to allocate memory for OTG event\n");
+		return NOTIFY_DONE;
+	}
+
+	evt->is_enable = *(bool *)param;
+	dev_info(&chip->client->dev, "evt->is_enable is %d\n", evt->is_enable);
+	INIT_LIST_HEAD(&evt->node);
+
+	spin_lock(&chip->otg_queue_lock);
+	list_add_tail(&evt->node, &chip->otg_queue);
+	spin_unlock(&chip->otg_queue_lock);
+
+	queue_work(system_nrt_wq, &chip->otg_evt_work);
+	return NOTIFY_OK;
+}
+
+static inline int register_otg_notification(struct bq24192_chip *chip)
+{
+
+	int retval;
+
+	INIT_LIST_HEAD(&chip->otg_queue);
+	INIT_WORK(&chip->otg_evt_work, bq24192_otg_evt_worker);
+	spin_lock_init(&chip->otg_queue_lock);
+
+	chip->otg_nb.notifier_call = otg_handle_notification;
+
+	/*
+	 * Get the USB transceiver instance
+	 */
+	chip->transceiver = usb_get_phy(USB_PHY_TYPE_USB2);
+	if (!chip->transceiver) {
+		dev_err(&chip->client->dev, "Failed to get the USB transceiver\n");
+		return -EINVAL;
+	}
+	retval = usb_register_notifier(chip->transceiver, &chip->otg_nb);
+	if (retval) {
+		dev_err(&chip->client->dev,
+			"failed to register otg notifier\n");
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+int bq24192_slave_mode_enable_charging(int volt, int cur, int ilim)
+{
+	struct bq24192_chip *chip = i2c_get_clientdata(bq24192_client);
+	int ret;
+
+	mutex_lock(&chip->event_lock);
+	chip->inlmt = chrg_ilim_to_reg(ilim);
+	if (chip->inlmt >= 0)
+		bq24192_set_inlmt(chip, chip->inlmt);
+	mutex_unlock(&chip->event_lock);
+
+	chip->cc = chrg_cur_to_reg(cur);
+	if (chip->cc)
+		bq24192_set_cc(chip, chip->cc);
+
+	chip->cv = chrg_volt_to_reg(volt);
+	if (chip->cv)
+		bq24192_set_cv(chip, chip->cv);
+
+	mutex_lock(&chip->event_lock);
+	ret = bq24192_enable_charging(chip, true);
+	if (ret < 0)
+		dev_err(&chip->client->dev, "charge enable failed\n");
+
+	mutex_unlock(&chip->event_lock);
+	return ret;
+}
+EXPORT_SYMBOL(bq24192_slave_mode_enable_charging);
+
+int bq24192_slave_mode_disable_charging(void)
+{
+	struct bq24192_chip *chip = i2c_get_clientdata(bq24192_client);
+	int ret;
+
+	mutex_lock(&chip->event_lock);
+	ret = bq24192_enable_charging(chip, false);
+	if (ret < 0)
+		dev_err(&chip->client->dev, "charge enable failed\n");
+
+	mutex_unlock(&chip->event_lock);
+	return ret;
+}
+//--------------------------------------------------------------------
+/* show mode entry (auto, none, host, dedicated or boost) */
+static ssize_t bq2415x_sysfs_show_mode(struct device *dev,
+				       struct device_attribute *attr,
+				       char *buf)
+{
+	ssize_t ret = 0;
+
+	switch(g_charger_mode){
+	case 0:
+		ret += sprintf(buf+ret, "off");
+		break;
+	case 1:
+	case 2:
+		ret += sprintf(buf+ret, "dedicated");
+		break;
+	default: break;
+		}
+
+	ret += sprintf(buf+ret, "\n");
+	return ret;
+}
+static ssize_t bq2415x_sysfs_set_mode(struct device *dev,
+				      struct device_attribute *attr,
+				      const char *buf,
+				      size_t count)
+{
+	int ret = 0;
+	if (strncmp(buf, "off", 3) == 0){
+
+		suspend_flag=0;
+		g_charger_mode=0;
+
+		//--register
+		printk("Find: Stop charge 6\n");
+		mutex_lock(&chip_extern->event_lock);
+		    ret=bq24192_reg_read_modify(chip_extern->client,
+		              BQ24192_INPUT_SRC_CNTL_REG,0x80,true);
+		    if (ret < 0) {
+			     mutex_unlock(&chip_extern->event_lock);
+			     printk("Error in writing the control register\n");
+			   return ret;
+
+		     }
+		mutex_unlock(&chip_extern->event_lock);
+
+		mutex_lock(&chip_extern->event_lock);
+		ret=bq24192_reg_read_modify(chip_extern->client,
+		                 BQ24192_POWER_ON_CFG_REG,0x10, false);
+		if (ret < 0) {
+			mutex_unlock(&chip_extern->event_lock);
+			printk("xia:Error in writing the control register\n");
+			return ret;
+		}
+		chip_extern->is_charging_enabled=false;
+		mutex_unlock(&chip_extern->event_lock);
+		if(WakeLockFlag==1){
+			printk("y1\n");
+			 WakeLockFlag=0;
+			 bq24192_ac_unlock();
+		}
+		cur_cable_status = UG31XX_NO_CABLE;
+		AC_STATE   = 0;
+		USB_STATE = 0;
+		//bq24192_write_reg(bq24192_client, BQ24192_INPUT_SRC_CNTL_REG, 0x32);
+
+	    printk("xia0:g_charger_mode=%d,suspend_flag=%d\n",g_charger_mode,suspend_flag);
+
+ 	}
+	 else if(strncmp(buf,"dedicated",9) == 0){
+
+		suspend_flag=0;
+
+		//--register
+		printk("Find: Open charge 5\n");
+		mutex_lock(&chip_extern->event_lock);
+		    ret=bq24192_reg_read_modify(chip_extern->client,
+		              BQ24192_INPUT_SRC_CNTL_REG,0x80,false);
+		    if (ret < 0) {
+			     mutex_unlock(&chip_extern->event_lock);
+			     printk("Error in writing the control register\n");
+			   return ret;
+
+		     }
+		mutex_unlock(&chip_extern->event_lock);
+
+		mutex_lock(&chip_extern->event_lock);
+		ret=bq24192_reg_read_modify(chip_extern->client,
+		              BQ24192_POWER_ON_CFG_REG,0x10, true);
+		if (ret < 0) {
+			mutex_unlock(&chip_extern->event_lock);
+			printk("xia:Error in writing the control register\n");
+			return ret;
+		}
+		chip_extern->is_charging_enabled=true;
+		mutex_unlock(&chip_extern->event_lock);
+
+		int type;
+		if((!VbusDetach)&&(!OtgOk)){
+#ifndef USB_NOTIFY_CALLBACK
+			type = GetPowerState();
+#endif
+			if(type== POWER_SUPPLY_CHARGER_TYPE_USB_SDP){
+		        if(WakeLockFlag==0){
+					printk("y2\n");
+			    bq24192_ac_lock();
+			    WakeLockFlag=1;
+		        }
+			    cur_cable_status = UG31XX_USB_PC_CABLE;
+			    AC_STATE   = 0;
+			    USB_STATE = 1;
+			   g_charger_mode=1;
+			   bq24192_write_reg(bq24192_client, BQ24192_INPUT_SRC_CNTL_REG, 0x32);
+		    }
+			else if(type== POWER_SUPPLY_CHARGER_TYPE_USB_DCP){
+
+			    if(WakeLockFlag==0){
+					printk("y3\n");
+			      bq24192_ac_lock();
+			      WakeLockFlag=1;
+		         }
+				cur_cable_status = UG31XX_AC_ADAPTER_CABLE;
+				AC_STATE   = 1;
+				USB_STATE = 0;
+				g_charger_mode=2;
+				bq24192_write_reg(bq24192_client, BQ24192_INPUT_SRC_CNTL_REG, 0x35);
+		   }
+		   else {
+		   	    if(WakeLockFlag==1){
+					printk("y4\n");
+			      WakeLockFlag=0;
+			      bq24192_ac_unlock();
+		        }
+		   	    cur_cable_status = UG31XX_NO_CABLE;
+		        AC_STATE   = 0;
+		        USB_STATE = 0;
+		        bq24192_write_reg(bq24192_client, BQ24192_INPUT_SRC_CNTL_REG, 0x32);
+			   g_charger_mode=-1;
+		   }
+
+		}
+        else{
+			if(WakeLockFlag==1){
+				printk("y5\n");
+			      WakeLockFlag=0;
+			      bq24192_ac_unlock();
+		        }
+		   	    cur_cable_status = UG31XX_NO_CABLE;
+		        AC_STATE   = 0;
+		        USB_STATE = 0;
+		        bq24192_write_reg(bq24192_client, BQ24192_INPUT_SRC_CNTL_REG, 0x32);
+            g_charger_mode=-1;
+        }
+		printk("xia1:g_charger_mode=%d,suspend_flag=%d\n",g_charger_mode,suspend_flag);
+
+	}
+
+	power_supply_changed(&bq24192_supply[PWR_SUPPLY_USB]);
+	power_supply_changed(&bq24192_supply[PWR_SUPPLY_AC]);
+	power_supply_changed(&bq24192_supply[PWR_SUPPLY_bq21455]);
+
+	return count;
+}
+
+/* close ac suspend mode */
+static ssize_t bq2415x_sysfs_set_ac_suspend_mode(struct device *dev,
+				       struct device_attribute *attr,
+				       const char *buf,
+				       size_t count)//lambert
+{
+	int ret=0;
+#ifndef USB_NOTIFY_CALLBACK
+	if (strncmp(buf, "close", 5) == 0)
+	{
+		suspend_flag=1;
+		printk("xiahuang2:suspend-flag=%d\n",suspend_flag);
+		printk("Find: Open charge 6\n");
+
+		mutex_lock(&chip_extern->event_lock);
+		    ret=bq24192_reg_read_modify(chip_extern->client,
+		              BQ24192_INPUT_SRC_CNTL_REG,0x80,false);
+		    if (ret < 0) {
+			     mutex_unlock(&chip_extern->event_lock);
+			     printk("Error in writing the control register\n");
+			   return ret;
+
+		     }
+		mutex_unlock(&chip_extern->event_lock);
+
+		mutex_lock(&chip_extern->event_lock);
+		ret=bq24192_reg_read_modify(chip_extern->client,
+		              BQ24192_POWER_ON_CFG_REG,0x10, true);
+		if (ret < 0) {
+			mutex_unlock(&chip_extern->event_lock);
+			printk("xia:Error in writing the control register\n");
+			return ret;
+		}
+		chip_extern->is_charging_enabled=true;
+		mutex_unlock(&chip_extern->event_lock);
+
+		int type;
+		if((!VbusDetach)&&(!OtgOk)){
+			type = GetPowerState();
+			if(type== POWER_SUPPLY_CHARGER_TYPE_USB_SDP){
+		        if(WakeLockFlag==0){
+					printk("y2\n");
+			    bq24192_ac_lock();
+			    WakeLockFlag=1;
+		        }
+			    cur_cable_status = UG31XX_USB_PC_CABLE;
+			    AC_STATE   = 0;
+			    USB_STATE = 1;
+			   g_charger_mode=-1;
+			   bq24192_write_reg(bq24192_client, BQ24192_INPUT_SRC_CNTL_REG, 0x32);
+		    }
+			else if(type== POWER_SUPPLY_CHARGER_TYPE_USB_DCP){
+
+			    if(WakeLockFlag==0){
+					printk("y3\n");
+			      bq24192_ac_lock();
+			      WakeLockFlag=1;
+		         }
+				cur_cable_status = UG31XX_AC_ADAPTER_CABLE;
+				AC_STATE   = 1;
+				USB_STATE = 0;
+				g_charger_mode=-1;
+				bq24192_write_reg(bq24192_client, BQ24192_INPUT_SRC_CNTL_REG, 0x35);
+		   }
+		   else {
+		   	    if(WakeLockFlag==1){
+					printk("y4\n");
+			      WakeLockFlag=0;
+			      bq24192_ac_unlock();
+		        }
+		   	    cur_cable_status = UG31XX_NO_CABLE;
+		        AC_STATE   = 0;
+		        USB_STATE = 0;
+		        bq24192_write_reg(bq24192_client, BQ24192_INPUT_SRC_CNTL_REG, 0x32);
+			   g_charger_mode=-1;
+		   }
+
+		}
+        else{
+			if(WakeLockFlag==1){
+				printk("y5\n");
+			      WakeLockFlag=0;
+			      bq24192_ac_unlock();
+		        }
+		   	    cur_cable_status = UG31XX_NO_CABLE;
+		        AC_STATE   = 0;
+		        USB_STATE = 0;
+		        bq24192_write_reg(bq24192_client, BQ24192_INPUT_SRC_CNTL_REG, 0x32);
+            g_charger_mode=-1;
+        }
+		printk("xia1:g_charger_mode=%d,suspend_flag=%d\n",g_charger_mode,suspend_flag);
+	power_supply_changed(&bq24192_supply[PWR_SUPPLY_USB]);
+	power_supply_changed(&bq24192_supply[PWR_SUPPLY_AC]);
+	power_supply_changed(&bq24192_supply[PWR_SUPPLY_bq21455]);
+	}
+#endif
+	return count;
+}
+
+
+static ssize_t bq2415x_sysfs_show_ac_suspend_mode(struct device *dev,
+					struct device_attribute *attr,
+					char *buf)
+{
+	ssize_t ret = 0;
+    printk("xia2:g_charger_mode=%d,suspend_flag=%d\n",g_charger_mode,suspend_flag);
+	if(suspend_flag==1) ret += sprintf(buf+ret, "close");
+	else ret += sprintf(buf+ret, "open");
+
+	ret += sprintf(buf+ret, "\n");
+	return ret;
+}
+
+static DEVICE_ATTR(ac_suspend_mode, S_IRWXU | S_IRWXG ,
+		bq2415x_sysfs_show_ac_suspend_mode, bq2415x_sysfs_set_ac_suspend_mode);
+static DEVICE_ATTR(mode, S_IRWXU |S_IRWXG ,
+		bq2415x_sysfs_show_mode, bq2415x_sysfs_set_mode);
+
+static struct attribute *bq2415x_sysfs_attributes[] = {
+	/*
+	 * TODO: some (appropriate) of these attrs should be switched to
+	 * use power supply class props.
+	 */
+	&dev_attr_ac_suspend_mode.attr,
+	&dev_attr_mode.attr,
+	NULL,
+};
+
+static const struct attribute_group bq2415x_sysfs_attr_group = {
+	.attrs = bq2415x_sysfs_attributes,
+};
+
+static int bq2415x_sysfs_init(void)
+{
+	return sysfs_create_group(&bq24192_supply[2].dev->kobj,
+			&bq2415x_sysfs_attr_group);
+}
+
+static void bq2415x_sysfs_exit(void)
+{
+	sysfs_remove_group(&bq24192_supply[2].dev->kobj, &bq2415x_sysfs_attr_group);
+}
+//--------------------------------------------------------------------
+extern int intel_mid_pmic_writeb(int reg, u8 val);
+static int g_usb_state;
+struct workqueue_struct *charger_work_queue = NULL;
+struct delayed_work charger_work;
+
+void charger_enabled_poweron() {
+       int ret = 0;
+
+        mutex_lock(&chip_extern->event_lock);
+	ret=bq24192_reg_read_modify(chip_extern->client, BQ24192_INPUT_SRC_CNTL_REG,0x80,false);
+	if (ret < 0) {
+		mutex_unlock(&chip_extern->event_lock);
+		printk("Error in writing the control register\n");
+		return;
+	}
+	mutex_unlock(&chip_extern->event_lock);
+
+	mutex_lock(&chip_extern->event_lock);
+	ret=bq24192_reg_read_modify(chip_extern->client,
+	BQ24192_POWER_ON_CFG_REG,0x10, true);
+	if (ret < 0) {
+		mutex_unlock(&chip_extern->event_lock);
+		printk("Error in writing the control register\n");
+		 return;
+	}
+	chip_extern->is_charging_enabled = true;
+	mutex_unlock(&chip_extern->event_lock);
+}
+
+static void do_charger(struct work_struct *work) {
+        bq24192_cable_callback(g_usb_state);
+}
+
+int setCharger(int usb_state) {
+        g_usb_state = usb_state;
+        queue_delayed_work(charger_work_queue, &charger_work, 0);
+
+	return 0;
+}
+#ifdef USB_NOTIFY_CALLBACK
+extern unsigned int query_cable_status(void);
+
+
+static int cable_status_notify(struct notifier_block *self, unsigned long action, void *dev) {
+
+/*
+   if (ischargerSuspend) {
+       printk(KERN_INFO "%s chager is suspend but USB still notify !!!\n", __func__);
+       wake_lock(&wakelock_smb347);
+       isUSBSuspendNotify = true;
+       return NOTIFY_OK;
+   }
+*/
+
+   switch (action) {
+      case POWER_SUPPLY_CHARGER_TYPE_USB_SDP:
+          printk(KERN_INFO "%s POWER_SUPPLY_CHARGER_TYPE_USB_SDP !!!\n", __func__);
+          setCharger(action);
+          break;
+
+      case POWER_SUPPLY_CHARGER_TYPE_USB_CDP:
+          printk(KERN_INFO "%s POWER_SUPPLY_CHARGER_TYPE_USB_CDP !!!\n", __func__);
+          setCharger(action);
+          break;
+
+      case POWER_SUPPLY_CHARGER_TYPE_USB_DCP:
+          printk(KERN_INFO "%s POWER_SUPPLY_CHARGER_TYPE_USB_DCP !!!\n", __func__);
+          setCharger(action);
+          break;
+
+      case POWER_SUPPLY_CHARGER_TYPE_ACA_DOCK:
+          printk(KERN_INFO "%s POWER_SUPPLY_CHARGER_TYPE_ACA_DOCK !!!\n", __func__);
+          setCharger(action);
+          break;
+
+      case POWER_SUPPLY_CHARGER_TYPE_SE1:
+          printk(KERN_INFO "%s POWER_SUPPLY_CHARGER_TYPE_SE1 !!!\n", __func__);
+          setCharger(action);
+          break;
+
+      case POWER_SUPPLY_CHARGER_TYPE_USB_OTG_CONNECTED:
+          printk(KERN_INFO "%s POWER_SUPPLY_CHARGER_TYPE_USB_OTG_CONNECTED !!!\n", __func__);
+          schedule_delayed_work(&chip_extern->otg_wrkr, 0*HZ);
+          break;
+
+      case POWER_SUPPLY_CHARGER_TYPE_USB_OTG_DISCONNECTED:
+          printk(KERN_INFO "%s POWER_SUPPLY_CHARGER_TYPE_USB_OTG_DISCONNECTED !!!\n", __func__);
+          schedule_delayed_work(&chip_extern->otg_wrkr, 0*HZ);
+          break;
+
+      case POWER_SUPPLY_CHARGER_TYPE_NONE:
+          printk(KERN_INFO "%s POWER_SUPPLY_CHARGER_TYPE_NONE !!!\n", __func__);
+          setCharger(action);
+	  break;
+
+      default:
+          printk(KERN_INFO "%s no status = %d !!!\n", __func__, (int)action);
+	  break;
+   }
+   return NOTIFY_OK;
+}
+
+static struct notifier_block cable_status_notifier = {
+	.notifier_call = cable_status_notify,
+};
+
+extern int cable_status_register_client(struct notifier_block *nb);
+extern int cable_status_unregister_client(struct notifier_block *nb);
+#endif
+
+static int bq24192_probe(struct i2c_client *client,
+			const struct i2c_device_id *id)
+{
+	struct i2c_adapter *adapter = to_i2c_adapter(client->dev.parent);
+	struct bq24192_chip *chip;
+	int ret,gpio_handle,gpio_data,irq,rgrt;
+
+	if (!client->dev.platform_data) {
+		dev_err(&client->dev, "platform Data is NULL");
+		return -EFAULT;
+	}
+
+	if (!i2c_check_functionality(adapter, I2C_FUNC_SMBUS_BYTE_DATA)) {
+		dev_err(&client->dev,
+				"SMBus doesn't support BYTE transactions\n");
+		return -EIO;
+	}
+
+	chip = kzalloc(sizeof(struct bq24192_chip), GFP_KERNEL);
+	if (!chip) {
+		dev_err(&client->dev, "mem alloc failed\n");
+		return -ENOMEM;
+	}
+
+	chip->pdata = client->dev.platform_data;
+	/*assigning default value for min and max temp*/
+	chip->min_temp = BATT_TEMP_MIN_DEF;
+	chip->max_temp = BATT_TEMP_MAX_DEF;
+	i2c_set_clientdata(client, chip);
+
+	ret = bq24192_read_reg(client, BQ24192_VENDER_REV_REG);
+	if (ret < 0) {
+		dev_err(&client->dev, "i2c read err:%d\n", ret);
+		i2c_set_clientdata(client, NULL);
+		kfree(chip);
+		return -EIO;
+	}
+
+	/* D3, D4, D5 indicates the chip model number */
+	ret = (ret >> 3) & 0x07;
+	if (ret != BQ2419x_IC_VERSION) {
+		dev_err(&client->dev, "device version mismatch: %x\n", ret);
+		i2c_set_clientdata(client, NULL);
+		kfree(chip);
+		return -EIO;
+	}
+
+        bq24192_client = client;
+	chip_extern = chip;
+	chip->client = client;
+
+	/*
+	 * Initialize the platform data
+	 */
+	if (chip->pdata->init_platform_data) {
+		ret = chip->pdata->init_platform_data();
+		if (ret < 0) {
+			dev_err(&chip->client->dev,
+					"FAILED: init_platform_data\n");
+		}
+	}
+
+
+	/*
+	 * Request for charger chip gpio.This will be used to
+	 * register for an interrupt handler for servicing charger
+	 * interrupts
+	 */
+
+	if (chip->pdata->get_irq_number) {
+		chip->irq = chip->pdata->get_irq_number();
+		if (chip->irq < 0) {
+			dev_err(&chip->client->dev,
+				"chgr_int_n GPIO is not available\n");
+		} else {
+			ret = request_threaded_irq(chip->irq,
+					bq24192_irq_isr, bq24192_irq_thread,
+					IRQF_TRIGGER_FALLING, "BQ24192", chip);
+			if (ret) {
+				dev_warn(&bq24192_client->dev,
+					"failed to register irq for pin %d\n",
+					chip->irq);
+			} else {
+				dev_warn(&bq24192_client->dev,
+					"registered charger irq for pin %d\n",
+					chip->irq);
+			}
+		}
+	}
+
+        enable_irq_wake(chip->irq);
+	intel_mid_pmic_writeb(R_PMIC_MIRQS0,0x00);
+	intel_mid_pmic_writeb(R_PMIC_MIRQSX,0x00);
+
+	INIT_DELAYED_WORK(&chip->otg_wrkr, otg_worker);
+
+#ifndef USB_NOTIFY_CALLBACK
+	gpio_request(152, "CHRGE_OTG");
+	gpio_handle = acpi_get_gpio("\\_SB.GPO2", 22);
+	gpio_direction_input(gpio_handle);
+	irq = gpio_to_irq(152);
+	ret = request_threaded_irq(irq,
+	otg_irq_isr, otg_irq_thread,
+	IRQF_TRIGGER_FALLING|IRQF_TRIGGER_RISING|IRQF_DISABLED|IRQF_ONESHOT, "OtgTrip", NULL);
+	if(ret)
+		printk("failed to register irq for pin %d\n",irq);
+#endif
+
+	ChargeInit(POWER_SUPPLY_CHARGER_TYPE_USB_SDP);
+
+	gpio_handle = acpi_get_gpio("\\_SB.GPO2", 22);//OTG function
+	gpio_data = __gpio_get_value(gpio_handle);
+	printk("OTG_ID:%d\n",gpio_data);
+	if(gpio_data == 0){
+		printk("[%s] Otg plug in !! \n",__func__);
+		 OtgOk = 1;
+		 bq24192_reg_read_modify(chip->client,BQ24192_POWER_ON_CFG_REG,0x20, true);
+	}else{
+		printk("[%s] OTG plug out !! \n",__func__);
+		OtgOk = 0;
+		bq24192_reg_read_modify(chip->client,BQ24192_POWER_ON_CFG_REG,0x20, false);
+	}
+
+	INIT_DELAYED_WORK(&chip->chrg_full_wrkr, bq24192_full_worker);
+	INIT_DELAYED_WORK(&chip->chrg_task_wrkr, bq24192_task_worker);
+	INIT_DELAYED_WORK(&chip->power_state_task_wrkr, bq24192_PowerState_worker);
+	INIT_DELAYED_WORK(&chip->jeita_wrkr, JetiaWork);
+	INIT_DELAYED_WORK(&chip->otg_disable_wrkr, otg_disable_worker);
+	schedule_delayed_work(&chip->chrg_full_wrkr, 3*HZ);
+#ifdef ASUS_ENG_BUILD
+        schedule_delayed_work(&chip->jeita_wrkr, 20*HZ);
+#else
+	schedule_delayed_work(&chip->jeita_wrkr, 60*HZ);
+#endif
+	//INIT_DELAYED_WORK(&chip->chrg_temp_wrkr, bq24192_temp_update_worker);
+	mutex_init(&chip->event_lock);
+
+	/* Initialize the wakelock */
+	wake_lock_init(&chip->wakelock, WAKE_LOCK_SUSPEND,
+						"ctp_charger_wakelock");
+
+	/* register bq24192 usb with power supply subsystem */
+	if (!chip->pdata->slave_mode) {
+		chip->usb.name = CHARGER_PS_NAME;
+		chip->usb.type = POWER_SUPPLY_TYPE_USB;
+		chip->usb.supplied_to = chip->pdata->supplied_to;
+		chip->usb.num_supplicants = chip->pdata->num_supplicants;
+		chip->usb.throttle_states = chip->pdata->throttle_states;
+		chip->usb.num_throttle_states =
+					chip->pdata->num_throttle_states;
+		chip->usb.supported_cables = chip->pdata->supported_cables;
+		chip->max_cc = 1216;
+		chip->max_cv = 4200;
+		chip->bat_health = POWER_SUPPLY_HEALTH_GOOD;
+		chip->chgr_stat = BQ24192_CHRGR_STAT_UNKNOWN;
+		chip->usb.properties = bq24192_usb_props;
+		chip->usb.num_properties = ARRAY_SIZE(bq24192_usb_props);
+		chip->usb.get_property = bq24192_usb_get_property;
+		chip->usb.set_property = bq24192_usb_set_property;
+		ret = power_supply_register(&client->dev, &chip->usb);
+		if (ret) {
+			dev_err(&client->dev, "failed:power supply register\n");
+			i2c_set_clientdata(client, NULL);
+			kfree(chip);
+			return ret;
+		}
+	}
+	/* Init Runtime PM State */
+	//pm_runtime_put_noidle(&chip->client->dev);
+	//pm_schedule_suspend(&chip->client->dev, MSEC_PER_SEC);
+
+	/* create debugfs for maxim registers */
+	ret = bq24192_create_debugfs(chip);
+	if (ret < 0) {
+		dev_err(&client->dev, "debugfs create failed\n");
+		power_supply_unregister(&chip->usb);
+		i2c_set_clientdata(client, NULL);
+		kfree(chip);
+		return ret;
+	}
+        charger_work_queue = create_singlethread_workqueue("charger_workqueue");
+        INIT_DELAYED_WORK(&charger_work, do_charger);
+#ifdef USB_NOTIFY_CALLBACK
+	cable_status_register_client(&cable_status_notifier);
+        cable_status_notify( NULL, query_cable_status(), &client->dev);
+#else
+	/*
+	 * Register to get USB transceiver events
+	 */
+	ret = register_otg_notification(chip);
+	if (ret) {
+		dev_err(&chip->client->dev,
+					"REGISTER OTG NOTIFICATION FAILED\n");
+	}
+#endif
+	/* Program the safety charge temperature threshold with default value*/
+	ret =  intel_scu_ipc_iowrite8(MSIC_CHRTMPCTRL,
+				(CHRTMPCTRL_TMPH_45 | CHRTMPCTRL_TMPL_00));
+	if (ret) {
+		dev_err(&chip->client->dev,
+				"IPC Failed with %d error\n", ret);
+	}
+
+	bq2415x_sysfs_flag=bq24192_powersupply_init(client);
+	if(!bq2415x_sysfs_flag){
+		bq2415x_sysfs_init();
+	}
+
+	intel_mid_pmic_writeb(0x24, 0xaa);//vaild battery detection threshold 3.5v
+#ifdef  ASUS_ENG_BUILD
+        ret = init_asus_charging_limit_toggle();
+        if (ret) {
+            printk("Unable to create proc file\n");
+            return ret;
+        }
+#endif
+	return 0;
+}
+
+static int bq24192_remove(struct i2c_client *client)
+{
+	struct bq24192_chip *chip = i2c_get_clientdata(client);
+
+	bq24192_remove_debugfs(chip);
+#ifdef USB_NOTIFY_CALLBACK
+	cable_status_unregister_client(&cable_status_notifier);
+#endif
+	if (!chip->pdata->slave_mode)
+		power_supply_unregister(&chip->usb);
+
+	if (chip->irq > 0)
+		free_irq(chip->irq, chip);
+
+    if(!bq2415x_sysfs_flag){
+
+		bq2415x_sysfs_exit();
+	}
+	i2c_set_clientdata(client, NULL);
+	wake_lock_destroy(&chip->wakelock);
+	kfree(chip);
+	return 0;
+}
+
+#ifdef CONFIG_PM
+
+static void bq24192_shutdown(struct i2c_client *client)
+{
+	//disable otg
+	if(OtgOk){
+		bq24192_reg_read_modify(chip_extern->client,
+		   BQ24192_POWER_ON_CFG_REG,
+		   0x20, false);
+		OtgOk = 0;
+		}
+
+	cancel_delayed_work(&chip_extern->chrg_full_wrkr);
+	cancel_delayed_work(&chip_extern->chrg_task_wrkr);
+	cancel_delayed_work(&chip_extern->power_state_task_wrkr);
+	flush_delayed_work(&chip_extern->chrg_full_wrkr);
+	flush_delayed_work(&chip_extern->chrg_task_wrkr);
+	flush_delayed_work(&chip_extern->power_state_task_wrkr);
+}
+
+static int bq24192_suspend(struct device *dev)
+{
+	struct bq24192_chip *chip = dev_get_drvdata(dev);
+	int ret,reg;
+
+	printk("bq24192_suspend\n");
+	flush_delayed_work(&chip->chrg_full_wrkr);
+	flush_delayed_work(&chip->chrg_task_wrkr);
+	flush_delayed_work(&chip->power_state_task_wrkr);
+	if (chip->irq > 0) {
+		/*
+		 * Once the WDT is expired all bq24192 registers gets
+		 * set to default which means WDT is programmed to 40s
+		 * and if there is no charger connected, no point
+		 * feeding the WDT. Since reg07[1] is set to default,
+		 * charger will interrupt SOC every 40s which is not
+		 * good for S3. In this case we need to free chgr_int_n
+		 * interrupt so that no interrupt from charger wakes
+		 * up the platform in case of S3. Interrupt will be
+		 * re-enabled on charger connect.
+		 */
+		if (chip->irq > 0)
+			free_irq(chip->irq, chip);
+	}
+	reset_wdt_timer(chip);
+	ret = program_timers(chip, CHRG_TIMER_EXP_CNTL_WDTDISABLE, false);
+	if (ret < 0)
+		dev_warn(&chip->client->dev, "TIMER enable failed\n");
+	dev_dbg(&chip->client->dev, "bq24192 suspend\n");
+	return 0;
+}
+
+static int bq24192_resume(struct device *dev)
+{
+	struct bq24192_chip *chip = dev_get_drvdata(dev);
+	int ret,gpio_handle,gpio_data;
+
+	printk("bq24192_resume\n");
+	schedule_delayed_work(&chip->chrg_full_wrkr, 0);
+	if (chip->irq > 0) {
+		ret = request_threaded_irq(chip->irq,
+				bq24192_irq_isr, bq24192_irq_thread,
+				IRQF_TRIGGER_FALLING, "BQ24192", chip);
+		if (ret) {
+			dev_warn(&bq24192_client->dev,
+				"failed to register irq for pin %d\n",
+				chip->irq);
+		} else {
+			dev_warn(&bq24192_client->dev,
+				"registered charger irq for pin %d\n",
+				chip->irq);
+		}
+	}
+	ChargeInit(cable_status);
+
+	dev_dbg(&chip->client->dev, "bq24192 resume\n");
+	return 0;
+}
+#else
+#define bq24192_suspend NULL
+#define bq24192_resume NULL
+#endif
+
+#ifdef CONFIG_PM_RUNTIME
+static int bq24192_runtime_suspend(struct device *dev)
+{
+
+	dev_dbg(dev, "%s called\n", __func__);
+	return 0;
+}
+
+static int bq24192_runtime_resume(struct device *dev)
+{
+	dev_dbg(dev, "%s called\n", __func__);
+	return 0;
+}
+
+static int bq24192_runtime_idle(struct device *dev)
+{
+
+	dev_dbg(dev, "%s called\n", __func__);
+	return 0;
+}
+#else
+#define bq24192_runtime_suspend	NULL
+#define bq24192_runtime_resume		NULL
+#define bq24192_runtime_idle		NULL
+#endif
+
+static const struct i2c_device_id bq24192_id[] = {
+	{ DEV_NAME, 0 },
+	{ },
+};
+MODULE_DEVICE_TABLE(i2c, bq24192_id);
+
+static const struct dev_pm_ops bq24192_pm_ops = {
+	.suspend		= bq24192_suspend,
+	.resume			= bq24192_resume,
+	.runtime_suspend	= bq24192_runtime_suspend,
+	.runtime_resume		= bq24192_runtime_resume,
+	.runtime_idle		= bq24192_runtime_idle,
+};
+
+static struct i2c_driver bq24192_i2c_driver = {
+	.driver	= {
+		.name	= DEV_NAME,
+		.owner	= THIS_MODULE,
+		.pm	= &bq24192_pm_ops,
+	},
+	.probe		= bq24192_probe,
+	.remove		= bq24192_remove,
+	.id_table	= bq24192_id,
+	.shutdown   = bq24192_shutdown,
+};
+//--------legacy
+static int __init bq24192_init(void)
+{
+	return i2c_add_driver(&bq24192_i2c_driver);
+}
+module_init(bq24192_init);
+static void __exit bq24192_exit(void)
+{
+	i2c_del_driver(&bq24192_i2c_driver);
+}
+module_exit(bq24192_exit);
+/*
+static int bq24192_init(void)
+{
+	return i2c_add_driver(&bq24192_i2c_driver);
+}
+
+static void bq24192_exit(void)
+{
+	i2c_del_driver(&bq24192_i2c_driver);
+}
+
+static int bq24192_rpmsg_probe(struct rpmsg_channel *rpdev)
+{
+	int ret = 0;
+
+	if (rpdev == NULL) {
+		pr_err("rpmsg channel not created\n");
+		ret = -ENODEV;
+		goto out;
+	}
+
+	dev_info(&rpdev->dev, "Probed bq24192 rpmsg device\n");
+
+	ret = bq24192_init();
+
+out:
+	return ret;
+}
+
+static void bq24192_rpmsg_remove(struct rpmsg_channel *rpdev)
+{
+	bq24192_exit();
+	dev_info(&rpdev->dev, "Removed bq24192 rpmsg device\n");
+}
+
+static void bq24192_rpmsg_cb(struct rpmsg_channel *rpdev, void *data,
+					int len, void *priv, u32 src)
+{
+	dev_warn(&rpdev->dev, "unexpected, message\n");
+
+	print_hex_dump(KERN_DEBUG, __func__, DUMP_PREFIX_NONE, 16, 1,
+		       data, len,  true);
+}
+
+static struct rpmsg_device_id bq24192_rpmsg_id_table[] = {
+	{ .name	= "rpmsg_bq24192" },
+	{ },
+};
+MODULE_DEVICE_TABLE(rpmsg, bq24192_rpmsg_id_table);
+
+static struct rpmsg_driver bq24192_rpmsg = {
+	.drv.name	= KBUILD_MODNAME,
+	.drv.owner	= THIS_MODULE,
+	.id_table	= bq24192_rpmsg_id_table,
+	.probe		= bq24192_rpmsg_probe,
+	.callback	= bq24192_rpmsg_cb,
+	.remove		= bq24192_rpmsg_remove,
+};
+
+static int __init bq24192_rpmsg_init(void)
+{
+	return register_rpmsg_driver(&bq24192_rpmsg);
+}
+module_init(bq24192_rpmsg_init);
+
+static void __exit bq24192_rpmsg_exit(void)
+{
+	return unregister_rpmsg_driver(&bq24192_rpmsg);
+}
+*/
+MODULE_AUTHOR("Ramakrishna Pallala <ramakrishna.pallala@intel.com>");
+MODULE_AUTHOR("Raj Pandey <raj.pandey@intel.com>");
+MODULE_DESCRIPTION("BQ24192 Charger Driver");
+MODULE_LICENSE("GPL");
diff --git a/drivers/power/supply/ASUS_BATTERY/ME176C/ug31xx/Makefile b/drivers/power/supply/ASUS_BATTERY/ME176C/ug31xx/Makefile
new file mode 100644
index 000000000000..6e4438beb9f2
--- /dev/null
+++ b/drivers/power/supply/ASUS_BATTERY/ME176C/ug31xx/Makefile
@@ -0,0 +1,21 @@
+#
+#  Copyright (c) 2012, UPI-SEMI, Inc. All Rights Reserved.
+#
+
+EXTRA_CFLAGS	+= -DBUILD_UG31XX_LINUX_KERNEL -DuG31xx_OS_ANDROID -DUG31XX_USE_DAEMON_AP_FOR_FILE_OP -DUG31XX_SHELL_ALGORITHM -fno-pic
+EXTRA_CFLAGS	+= -DWAKEUP_TIME_THRD_1_HOUR -DENABLE_NTC_CHECK
+EXTRA_CFLAGS  += -DFEATURE_DISABLE_SUSPEND_OPERATION
+#EXTRA_CFLAGS	+= -DUG31XX_ADC_NO_TEMP_COMPENSATION
+
+ug31xx_battery-objs	+= uG31xx_API_Backup.o
+ug31xx_battery-objs	+= uG31xx_API_Capacity.o
+ug31xx_battery-objs	+= uG31xx_API_Measurement.o
+ug31xx_battery-objs	+= uG31xx_API.o
+ug31xx_battery-objs	+= uG31xx_API_Otp.o
+ug31xx_battery-objs	+= uG31xx_API_System.o
+
+ug31xx_battery-objs	+= uG31xx_API_Platform.o
+ug31xx_battery-objs	+= ug31xx_gauge.o
+
+obj-$(CONFIG_ASUS_BATTERY_ME176C_UPI_BATTERY)	+= ug31xx_battery.o
+
diff --git a/drivers/power/supply/ASUS_BATTERY/ME176C/ug31xx/global.h b/drivers/power/supply/ASUS_BATTERY/ME176C/ug31xx/global.h
new file mode 100644
index 000000000000..c1475041bd64
--- /dev/null
+++ b/drivers/power/supply/ASUS_BATTERY/ME176C/ug31xx/global.h
@@ -0,0 +1,28 @@
+#ifndef _GLOBAL_H_
+#define _GLOBAL_H_
+
+//#define UG31XX_RESET_DATABASE     ///< [AT-PM] : DEFAULT off ; 04/13/2013
+
+#ifdef  uG31xx_OS_WINDOWS
+
+#define ALIGNED_ATTRIBUTE
+
+#define ENABLE_BQ27520_SW_CMD
+
+#else   ///< else of uG31xx_OS_WINDOWS
+
+#ifdef  uG31xx_ALIGNED_4
+
+#define ALIGNED_ATTRIBUTE __attribute__((aligned(4)))
+
+#else   ///< else of uG31xx_ALIGNED_4
+
+#define ALIGNED_ATTRIBUTE __attribute__((packed))
+
+#endif  ///< end of uG31xx_ALIGNED_4
+
+#endif  ///< end of uG31xx_OS_WINDOWS
+
+//#define ENABLE_NTC_CHECK
+
+#endif
diff --git a/drivers/power/supply/ASUS_BATTERY/ME176C/ug31xx/stdafx.h b/drivers/power/supply/ASUS_BATTERY/ME176C/ug31xx/stdafx.h
new file mode 100644
index 000000000000..9e20c433920d
--- /dev/null
+++ b/drivers/power/supply/ASUS_BATTERY/ME176C/ug31xx/stdafx.h
@@ -0,0 +1,49 @@
+// stdafx.h : Include the standard system Include files
+// or include files without frequently modified
+
+#pragma once
+
+#ifndef BUILD_UG31XX_LIB
+
+#ifndef	uG31xx_OS_ANDROID
+
+#ifndef CONFIG_ASUS_UG31XX_BATTERY
+
+#ifndef VC_EXTRALEAN
+#define VC_EXTRALEAN            // q Windows Y`
+#endif
+
+#include "targetver.h"
+
+#define _ATL_CSTRING_EXPLICIT_CONSTRUCTORS      // Twq CString c
+
+#include <afxwin.h>         // MFC P
+#include <afxext.h>         // MFC XR\
+
+#ifndef _AFX_NO_OLE_SUPPORT
+#include <afxole.h>         // MFC OLE O
+#include <afxodlgs.h>       // MFC OLE O
+#include <afxdisp.h>        // MFC Automation O
+#endif // _AFX_NO_OLE_SUPPORT
+
+#ifndef _AFX_NO_DB_SUPPORT
+#include <afxdb.h>                      // MFC ODBC wO
+#endif // _AFX_NO_DB_SUPPORT
+
+#ifndef _AFX_NO_DAO_SUPPORT
+#include <afxdao.h>                     // MFC DAO wO
+#endif // _AFX_NO_DAO_SUPPORT
+
+#ifndef _AFX_NO_OLE_SUPPORT
+#include <afxdtctl.h>           // MFC  Internet Explorer 4 q
+#endif
+#ifndef _AFX_NO_AFXCMN_SUPPORT
+#include <afxcmn.h>                     // MFC  Windows q
+#endif // _AFX_NO_AFXCMN_SUPPORT
+
+#endif  ///< end of CONFIG_ASUS_UG31XX_BATTERY
+
+#endif	///< end of uG31xx_OS_ANDROID
+
+#endif  ///< end of BUILD_UG31XX_LIB
+
diff --git a/drivers/power/supply/ASUS_BATTERY/ME176C/ug31xx/typeDefine.h b/drivers/power/supply/ASUS_BATTERY/ME176C/ug31xx/typeDefine.h
new file mode 100644
index 000000000000..3402f9d8c062
--- /dev/null
+++ b/drivers/power/supply/ASUS_BATTERY/ME176C/ug31xx/typeDefine.h
@@ -0,0 +1,400 @@
+/// ===========================================
+/// typeDefine.h
+/// ===========================================
+
+#ifndef _TYPE_DEFINE_H_
+#define _TYPE_DEFINE_H_
+
+#define CELL_PARAMETER_ALARM_EN_UV      (1<<0)
+#define CELL_PARAMETER_ALARM_EN_UET     (1<<1)
+#define CELL_PARAMETER_ALARM_EN_OET     (1<<2)
+
+#define CELL_PARAMETER_STRING_LENGTH    (16)
+
+typedef struct CELL_PARAMETER
+{
+  _upi_u16_ totalSize;     //Total struct size
+  _upi_u16_ fw_ver;            //CellParameter struct version
+
+  char customer[CELL_PARAMETER_STRING_LENGTH];   //Customer name defined by uPI   //####2012/08/29#####
+  char project[CELL_PARAMETER_STRING_LENGTH];    //Project name defined by uPI
+  _upi_u16_ ggb_version;       //0x0102 => 2.1
+
+  char customerSelfDef[CELL_PARAMETER_STRING_LENGTH];  //Customer name record by customer
+  char projectSelfDef[CELL_PARAMETER_STRING_LENGTH];   //Project name record by customer
+  _upi_u16_ cell_type_code;
+
+  _upi_u8_ ICType;  /*[2:0]=000 -> uG3100 [2:0]=001 -> uG3101
+                            [2:0]=010 -> uG3102 [2:0]=100 -> uG3103_2
+                            [2:0]=101 -> uG3103_3 */
+
+  _upi_u8_ gpio1; /*bit[4] cbc_en32
+                         bit[3] cbc_en21
+                         bit[2] pwm
+                         bit[1] alarm
+                         bit[0] gpio */
+  _upi_u8_ gpio2; /*bit[4] cbc_en32
+                        bit[3] cbc_en21
+                        bit[2] pwm
+                        bit[1] alarm
+                        bit[0] gpio */
+  _upi_u8_ gpio34;			//11/22/2011 -->reg92
+
+  _upi_u8_ cellNumber;
+  _upi_u8_ assignCellOneTo;
+  _upi_u8_ assignCellTwoTo;
+  _upi_u8_ assignCellThreeTo;
+
+  _upi_u16_ i2cAddress;    //I2C Address(Hex)
+  _upi_u16_ clock;
+
+  _upi_u8_ tenBitAddressMode;
+  _upi_u8_ highSpeedMode;
+  _upi_u8_ chopCtrl;		//11/22/2011 -->regC1
+  _upi_u8_ rSense;
+
+  _upi_s16_ adc1Offset;		//11/22/2011 -->reg58/59
+  _upi_u16_ ILMD;
+
+  _upi_u16_ edv1Voltage;
+  _upi_u16_ standbyCurrent;
+
+  _upi_u16_ TPCurrent;
+  _upi_u16_ TPVoltage;
+
+  _upi_u16_ TPTime;
+  _upi_u16_ offsetR;
+
+  _upi_u16_ deltaR;
+  _upi_u16_ TpBypassCurrent;			//20121029
+
+  _upi_s16_ uvAlarm;
+  _upi_s16_ uvRelease;
+
+  _upi_s16_ uetAlarm;
+  _upi_s16_ uetRelease;
+
+  _upi_s16_ oetAlarm;
+  _upi_s16_ oetRelease;
+
+  _upi_s16_ oscTuneJ;
+  _upi_s16_ oscTuneK;
+
+  _upi_u8_ maxDeltaQ;
+  _upi_u8_ timeInterval;
+  _upi_u8_ alarm_timer;		//11/22/2011  00:*5,01:*10,10:*15,11:*20
+  _upi_u8_ pwm_timer; /*[1:0]=00:32k [1:0]=01:16k
+                                [1:0]=10:8k  [1:0]=11: 4k */
+
+  _upi_u8_ clkDivA;			//11/22/2011
+  _upi_u8_ clkDivB;			//11/22/2011
+  _upi_u8_ alarmEnable; /*[7]:COC [6]:DOC [5]:IT [4]:ET
+                                    [3]:VP  [2]:V3  [1]:V2 [0]:V1 */
+  _upi_u8_ cbcEnable; /*[1]:CBC_EN32  [0]:CBC_EN21 */
+
+  _upi_u16_ vbat2_gain;	//ideal ADC Code
+  _upi_s16_ vbat2_offset;
+
+  _upi_u16_ vbat3_gain;
+  _upi_s16_ vbat3_offset;
+
+  _upi_s16_ adc1_pgain;
+  _upi_s16_ adc1_ngain;
+
+  _upi_s16_ adc1_pos_offset;
+
+  _upi_u16_ adc2_gain;
+  _upi_s16_ adc2_offset;
+  _upi_u16_ R;
+
+  _upi_u16_ rtTable[ET_NUMS];
+  // SOV_TABLE %
+  _upi_u16_ SOV_TABLE[SOV_NUMS];
+
+  _upi_s16_ adc_d1;				//2012/06/06/update for IT25
+  _upi_s16_ adc_d2;				//2012/06/06/update for IT80
+
+  _upi_s16_ adc_d3;       ///< [AT-PM] : Used for ADC calibration IT code ; 08/15/2012
+  _upi_s16_ adc_d4;
+
+  _upi_s16_ adc_d5;
+  _upi_u16_ CycleCountThrd;
+
+  _upi_u32_ NacLmdAdjustCfg;
+
+}ALIGNED_ATTRIBUTE CELL_PARAMETER;
+
+typedef struct CELL_TABLE
+{
+  _upi_s16_ INIT_OCV[TEMPERATURE_NUMS][OCV_TABLE_IDX_COUNT][OCV_NUMS];							//initial OCV Table,0.1C/0.2C OCV/charge table
+  _upi_s16_ CELL_VOLTAGE_TABLE[TEMPERATURE_NUMS][C_RATE_NUMS][OCV_NUMS];		//cell behavior Model,the voltage data
+  _upi_s16_ CELL_NAC_TABLE[TEMPERATURE_NUMS][C_RATE_NUMS][OCV_NUMS];				//cell behavior Model,the deltaQ
+} ALIGNED_ATTRIBUTE CELL_TABLE;
+
+typedef struct CELL_DATA
+{
+  CELL_PARAMETER cellParameter;
+  CELL_TABLE cellTable1;
+} ALIGNED_ATTRIBUTE CELL_DATA;
+
+typedef struct _GGBX_FILE_HEADER
+{
+  _upi_u32_ ggb_tag;          //'_GG_'
+  _upi_u32_ sum16;            //16 bits checksum, but store as 4 bytes
+  _upi_u64_ time_stamp;       //seconds pass since 1970 year, 00:00:00
+  _upi_u32_ parameter_size;   ///< size of parameter block
+  _upi_u32_ cell_table_size;  ///< size of cell table
+  _upi_u64_ length;           //size that not only include ggb content. (multi-file support)
+  _upi_u64_ num_ggb;          //number of ggb files.
+} ALIGNED_ATTRIBUTE GGBX_FILE_HEADER;
+
+typedef struct ADC_CHECK
+{
+	_upi_u16_ regCounter;	        //check adc counter
+	_upi_u16_ regVbat1Ave;      //check average voltage
+	_upi_u16_ regITAve;
+	_upi_u16_ lastCounter;
+  _upi_u16_ lastVBat1Ave;
+  _upi_u16_ failCounterCurrent;
+  _upi_u16_ failCounterVoltage;
+  _upi_bool_ decimateRst;
+  _upi_u32_ decimateRstTime;
+} ALIGNED_ATTRIBUTE ADC_CHECK;
+
+typedef struct USER_REGISTER
+{
+	_upi_u8_ mode;
+	_upi_u8_ ctrl1;
+	_upi_u8_ charge_low;
+	_upi_u8_ charge_high;
+	_upi_u8_ counter_low;
+	_upi_u8_ counter_high;
+	_upi_u8_ current_low;
+  _upi_u8_ current_high;
+	_upi_u8_ vbat1_low;
+	_upi_u8_ vbat1_high;
+	_upi_u8_ intr_temper_low;
+	_upi_u8_ intr_temper_high;
+	_upi_u8_ ave_current_low;
+	_upi_u8_ ave_current_high;
+	_upi_u8_ extr_temper_low;
+	_upi_u8_ extr_temper_high;
+	_upi_u8_ rid_low;
+	_upi_u8_ rid_high;
+	_upi_u8_ alarm1_status;
+	_upi_u8_ alarm2_status;
+	_upi_u8_ intr_status;
+	_upi_u8_ alram_en;
+	_upi_u8_ ctrl2;
+} ALIGNED_ATTRIBUTE USER_REGISTER;
+
+//2012/08/24/new add for system suspend
+typedef struct _GG_SUSPEND_INFO{
+	_upi_u16_     LMD;						//battery Qmax (maH)
+	_upi_u16_     NAC;						//battery NAC(maH)
+	_upi_u16_     RSOC;						//Battery Current RSOC(%)
+	_upi_u32_	currentTime;			//the time tick
+
+} ALIGNED_ATTRIBUTE GG_SUSPEND_INFO,*PGG_SUSPEND_INFO;
+
+typedef struct _GG_BATTERY_INFO{
+	_upi_u16_     LMD;				//battery Qmax (maH)
+	_upi_u16_     NAC;				//battery NAC(maH)
+	_upi_u16_     RSOC;				//Battery Current RSOC(%)
+
+  _upi_u8_      Ready;
+} ALIGNED_ATTRIBUTE GG_BATTERY_INFO;
+
+/// [AT-PM] : Used for TI bq27520 like command ; 10/11/2012
+typedef struct GG_TI_BQ27520 {
+  _upi_u16_ CntlControlStatus;
+  _upi_u16_ CntlPrevMacWrite;
+
+  _upi_s16_ AR;
+
+  _upi_u16_ Temp;
+
+  _upi_u16_ Flags;
+  _upi_s16_ SINow;
+  _upi_s32_ SIBuf;
+  _upi_s16_ SISample;
+  _upi_u16_ SIWindow;
+
+  _upi_s16_ Mli;
+  _upi_u8_ MliDsgSoc;
+
+  _upi_u16_ AE;
+
+  _upi_s16_ AP;
+  _upi_u16_ APStartChgE;
+  _upi_u16_ APStartDsgE;
+  _upi_u32_ APChgTime;
+  _upi_u32_ APDsgTime;
+
+  _upi_u16_ CC;
+  _upi_u16_ CCBuf;
+  _upi_u16_ CCLastNac;
+
+  _upi_u16_ Dli;
+
+  _upi_u16_ Dlb;
+
+  _upi_s8_ FCSet;
+  _upi_s8_ FCClear;
+  _upi_u8_ Soc1Set;
+  _upi_u8_ Soc1Clear;
+  _upi_s8_ InitSI;
+  _upi_s16_ InitMaxLoadCurrent;
+  _upi_s16_ CCThreshold;
+  _upi_u32_ Opcfg;
+  _upi_u16_ Dcap;
+
+  _upi_u32_ LastTime;
+  _upi_u16_ DeltaSec;
+} ALIGNED_ATTRIBUTE GG_TI_BQ27520, *PGG_TI_BQ27520;
+
+typedef struct GGAdcDeltaCodeMappingST {
+  _upi_s32_ Adc1V100;
+  _upi_s32_ Adc1V200;
+  _upi_s32_ Adc2V100;
+  _upi_s32_ Adc2V200;
+} ALIGNED_ATTRIBUTE GGAdcDeltaCodeMappingType;
+
+/* define the register of uG31xx */
+typedef struct _GG_USER_REG{
+	_upi_u8_ 	regMode;				      ///< [AT-PM] : 0x00 - MODE ; 04/08/2013
+	_upi_u8_ 	regCtrl1;				      ///< [AT-PM] : 0x01 - CTRL1 ; 04/08/2013
+	_upi_s16_	regCharge;				    ///< [AT-PM] : 0x02 - Charge ; 04/08/2013
+	_upi_u16_	regCounter;				    ///< [AT-PM] : 0x04 - Counter ; 04/08/2013
+	_upi_s16_	regCurrentAve;			  ///< [AT-PM] : 0x06 - Ave Current ; 04/08/2013
+	_upi_s16_	regVbat1Ave;			    ///< [AT-PM] : 0x08 - Ave VBat1 ; 04/08/2013
+	_upi_u16_	regITAve;				      ///< [AT-PM] : 0x0A - Ave IT ; 04/08/2013
+	_upi_s16_ regOffsetCurrentAve;  ///< [AT-PM] : 0x0C - Ave Offset Current ; 04/08/2013
+	_upi_u16_ regETAve;				      ///< [AT-PM] : 0x0E - Ave ET ; 04/08/2013
+	_upi_u16_ regRidAve;				    ///< [AT-PM] : 0x10 - Ave RID ; 04/08/2013
+	_upi_u8_  regAlarm1Status;      ///< [AT-PM] : 0x12 - Alarm1 Status ; 04/08/2013
+	_upi_u8_  regAlarm2Status;      ///< [AT-PM] : 0x13 - Alarm2 Status ; 04/08/2013
+	_upi_u8_  regIntrStatus;	      ///< [AT-PM] : 0x14 - INTR Status ; 04/08/2013
+	_upi_u8_  regAlarmEnable;       ///< [AT-PM] : 0x15 - Alarm EN ; 04/08/2013
+  _upi_u8_  regCtrl2;				      ///< [AT-PM] : 0x16 - CTRL2 ; 04/08/2013
+} ALIGNED_ATTRIBUTE GG_USER_REG, *PGG_USER_REG;
+
+/* define the register of uG31xx */
+typedef struct _GG_USER2_REG{
+		_upi_s16_ regVbat2;				//0x40,vBat2
+		_upi_s16_ regVbat3;				//0x42,vBat3
+		_upi_s16_ regVbat1;				//0x44,vBat1 Average
+		_upi_s16_ regVbat2Ave;			//0x46,vBat2 Average
+		_upi_s16_ regVbat3Ave;			//0x48,vBat3 Average
+		_upi_u16_ regV1;					//0x4a,cell 1 Voltage
+		_upi_u16_ regV2;					//0x4c,0xcell 2 Voltage
+		_upi_u16_ regV3;					//0x4e,cell 3 Voltage
+		_upi_s16_ regIT;					//0x50
+		_upi_s16_ regET;					//0x52
+		_upi_u16_ regRID;					//0x54
+		_upi_s16_	regCurrent;				//0x56
+		_upi_s16_ regAdc1Offset;			//0x58ADC1 offset
+} ALIGNED_ATTRIBUTE GG_USER2_REG, *PGG_USER2_REG;
+
+#define ALARM_STATUS_UV     (1<<0)
+#define ALARM_STATUS_UET    (1<<1)
+#define ALARM_STATUS_OET    (1<<2)
+
+/* define device information */
+typedef struct _GG_DEVICE_INFO{
+
+	_upi_s16_	   oldRegCurrent;				//for skip the ADC code Error
+	_upi_s16_	   oldRegVbat1;					//for skip the ADC code Error
+
+	_upi_s16_	   vBat1_AdcCode;				//debug use
+	_upi_s16_	   vBat1_AveAdcCode;
+
+	_upi_s16_	   fwCalAveCurrent_mA;			//f/w calculate average current
+	_upi_u32_	   lastTime;					//
+	_upi_s16_	   chargeRegister;				//coulomb counter register
+	_upi_u16_	   AdcCounter;					//ADC convert counter
+
+	_upi_s16_	   preChargeRegister;			//coulomb counter register
+	_upi_s16_    aveCurrentRegister;			//2012/0711/jacky
+	_upi_u16_	   preAdcCounter;
+	_upi_s32_	   fwChargeData_mAH;			//fw calculate maH (Q= I * T)
+
+	_upi_s32_    chargeData_mAh;				//maH calculate from charge register
+	_upi_u16_    voltage_mV;		            //total voltage
+	_upi_s16_    current_mA;			        // now current
+	_upi_s16_	   AveCurrent_mA;				// average current
+	_upi_s16_    IT;							// internal temperature
+	_upi_s16_    ET;							// external temperature
+
+	_upi_u16_	   v1_mV;						//v1   from hw register
+	_upi_u16_	   v2_mV;						//v2
+	_upi_u16_	   v3_mV;						//v3
+
+	_upi_u16_	   vBat1Average_mV;				//vbat1
+	_upi_u16_	   vBat2Average_mV;
+	_upi_u16_	   vBat3Average_mV;
+
+
+	_upi_u16_    vCell1_mV;					//v Cell1
+	_upi_u16_	   vCell2_mV;					//v Cell2
+	_upi_u16_	   vCell3_mV;					//v Cell3
+
+	_upi_s16_ CaliAdc1Code;				//2012/08/29/Jacky
+	_upi_s16_ CaliAdc2Code;
+
+	_upi_s16_ CoulombCounter;
+
+  _upi_s32_ CaliChargeReg;
+  _upi_u16_ Adc1ConvTime;
+
+  _upi_u8_ alarmStatus;
+} ALIGNED_ATTRIBUTE GG_DEVICE_INFO, *PGG_DEVICE_INFO;
+
+/* define battery capacity */
+typedef struct _GG_CAPACITY {
+	_upi_u16_     LMD;						    //battery Qmax (maH)
+	_upi_u16_     NAC;						    //battery NAC(maH)
+	_upi_u16_     RSOC;					    //Battery Current RSOC(%)
+
+  _upi_u8_      Ready;
+
+  #ifdef  uG31xx_OS_WINDOWS
+    _upi_s32_     DsgCharge;
+  #endif  ///< end of uG31xx_OS_WINDOWS
+} ALIGNED_ATTRIBUTE GG_CAPACITY, *PGG_CAPACITY;
+
+typedef struct GG_MEAS_PARA_ST
+{
+  _upi_s16_ Adc1Gain;
+  _upi_s16_ Adc1Offset;
+
+  _upi_s16_ Adc2Gain;
+  _upi_s16_ Adc2Offset;
+
+  _upi_s16_ ITOffset;
+  _upi_s16_ ETOffset;
+
+  _upi_u8_ ProductType;
+} ALIGNED_ATTRIBUTE GG_MEAS_PARA_TYPE;
+
+#endif
+
+#if defined(uG31xx_OS_WINDOWS)
+
+typedef struct GG_CAP_LOG_ST
+{
+  _upi_u16_ rm;
+  _upi_u16_ fcc;
+  _upi_u8_ rsoc;
+  _upi_u32_ timeTagFromIC;
+  _upi_u8_ tableUpdateIdxFromIC;
+  _upi_s16_ deltaCapFromIC;
+  _upi_u16_ adc1ConvTime;
+}GG_CAP_LOG_TYPE;
+
+#endif
+
+/// ===========================================
+/// End of typeDefine.h
+/// ===========================================
+
diff --git a/drivers/power/supply/ASUS_BATTERY/ME176C/ug31xx/uG31xx.h b/drivers/power/supply/ASUS_BATTERY/ME176C/ug31xx/uG31xx.h
new file mode 100644
index 000000000000..45aa63fec042
--- /dev/null
+++ b/drivers/power/supply/ASUS_BATTERY/ME176C/ug31xx/uG31xx.h
@@ -0,0 +1,159 @@
+/// ===========================================
+/// uG31xx.h
+/// ===========================================
+
+#ifndef _UG31XX_H_
+#define _UG31XX_H_
+
+#define  SECURITY			1		//Security Mode enable
+#define  NORMAL				0		//Security Mode OFF
+
+#define  HIGH_SPEED			1		//HS Mode
+#define  FULL_SPEED			0		//FIL speed
+
+#define  TEN_BIT_ADDR		1		//10-bit address Mode
+#define	 SEVEN_BIT_ADDR		0		//7-bit address Mode
+
+#define  I2C_SUCESS			1		//
+#define  I2C_FAIL			0
+
+/// ===========================================================================
+/// Constant for Calibration
+/// ===========================================================================
+
+#define IT_TARGET_CODE25	  (12155)
+#define IT_TARGET_CODE80	  (14306)
+
+#define IT_CODE_25		(23171)
+#define IT_CODE_80		(27341)
+
+//constant
+//define IC type
+#define uG3100		0
+#define uG3101		1
+#define uG3102		2
+#define uG3103_2	4
+#define uG3103_3	5
+
+//constant
+//GPIO1/2 define
+#define FUN_GPIO				0x01
+#define FUN_ALARM				0x02
+#define FUN_PWM					0x04
+#define FUN_CBC_EN21			0x08
+#define FUN_CBC_EN32			0x10
+
+#define BIT_MACRO(x)		((_upi_u8_)1 << (x))
+
+#define MAX_CRATE_AVAILABLE     (20)
+
+#define I2C_ADDRESS    0x70
+#define I2C_CLOCK      0x100
+
+//const for CELL_TABLE table
+#define TEMPERATURE_NUMS  (4)
+#define C_RATE_NUMS				(3)     ///< [AT-PM] : 0.5, 0.2, 0.1, 0.02 ; 12/17/2013
+#define OCV_NUMS				  (21)			//include the 0% & 100%
+#define SOV_NUMS				  (16)     ///< [FC] : 100, 95, 90, 80, 70, 60, 50, 40, 35, 30, 25, 20, 15, 10, 5, 0 ; 06/14/2013
+#define ET_NUMS           (19)      ///< [AT-PM] : -10, -5, 0, 5, 10, 15, 20, 25, 30, 35, 40, 45, 50, 55, 60, 65, 70, 75, 80 ; 01/25/2013
+
+/// [AT-PM] : Suggested value of NacLmdAdjustCfg is 0x2001 for uG3105 ; 08/07/2013
+/// [AT-PM] : Suggested value of NacLmdAdjustCfg is 0x2041 for uG310x ; 08/07/2013
+#define NAC_LMD_ADJUST_CFG_NO_LMD_UPDATE_LIMIT                (3<<0)
+  #define NAC_LMD_ADJUST_CFG_NO_LMD_UPDATE_NO_LIMIT           (0<<0)
+  #define NAC_LMD_ADJUST_CFG_NO_LMD_UPDATE_BETWEEN_10_90_EN   (1<<0)
+  #define NAC_LMD_ADJUST_CFG_NO_LMD_UPDATE_ABOVE_10_EN        (2<<0)
+#define NAC_LMD_ADJUST_CFG_PARSER_FORCE_0_BELOW_EDVF_DISABLE  (1<<2)
+#define NAC_LMD_ADJUST_CFG_PARSER_LOCK_1_BEFORE_EDVF_DISABLE  (1<<3)
+#define NAC_LMD_ADJUST_CFG_PARSER_FORCE_RSOC_STEP_1_DISABLE   (1<<4)
+#define NAC_LMD_ADJUST_CFG_DISPLAY_CC_AS_FCC                  (1<<5)
+#define NAC_LMD_ADJUST_CFG_PRODUCT_TYPE                       (3<<6)
+  #define NAC_LMD_ADJUST_CFG_PRODUCT_TYPE_UG3105              (0<<6)
+  #define NAC_LMD_ADJUST_CFG_PRODUCT_TYPE_UG310X              (1<<6)
+  #define NAC_LMD_ADJUST_CFG_PRODUCT_TYPE_RSVD2               (2<<6)
+  #define NAC_LMD_ADJUST_CFG_PRODUCT_TYPE_RSVD3               (3<<6)
+#define NAC_LMD_ADJUST_CFG_PARSER_FORCE_100_REACH_TP_DISABLE  (1<<8)
+#define NAC_LMD_ADJUST_CFG_PARSER_FORCE_99_BEFORE_TP_DISABLE  (1<<9)
+#define NAC_LMD_ADJUST_CFG_PARSER_RM_NOT_EXCEED_FCC_DISABLE   (1<<10)
+#define NAC_LMD_ADJUST_CFG_CHG_ALGORITHM_EN                   (1<<12)
+#define NAC_LMD_ADJUST_CFG_ALWAYS_UPDATE_FCC_AT_LAST          (1<<13)
+#define NAC_LMD_ADJUST_CFG_PARSER_RATIO_DISABLE               (1<<14)
+#define NAC_LMD_ADJUST_CFG_CAP_ALGORITHM_VER                  (3<<15)
+  #define NAC_LMD_ADJUST_CFG_CAP_ALGORITHM_ORIGINAL           (0<<15)
+  #define NAC_LMD_ADJUST_CFG_CAP_ALGORITHM_NO_LEARNING        (1<<15)
+  #define NAC_LMD_ADJUST_CFG_CAP_ALGORITHM_FIX_EDV            (2<<15)
+#define NAC_LMD_ADJUST_CFG_NO_MAX_FCC_LIMIT_WITH_TABLE        (1<<17)
+#define NAC_LMD_ADJUST_CFG_COUNT_STANDBY_CURRENT              (1<<18)
+#define NAC_LMD_ADJUST_CFG_REMOVE_INIT_PARSER                 (1<<19)
+#define NAC_LMD_ADJUST_CFG_LIMIT_FCC_CHANGE_RANGE_10          (1<<20)
+#define NAC_LMD_ADJUST_CFG_VOLTAGE_CC_WEIGHT                  (3<<21)
+  #define NAC_LMD_ADJUST_CFG_VOLTAGE_CC_WEIGHT_1              (0<<21)
+  #define NAC_LMD_ADJUST_CFG_VOLTAGE_CC_WEIGHT_2              (1<<21)
+  #define NAC_LMD_ADJUST_CFG_VOLTAGE_CC_WEIGHT_3              (2<<21)
+  #define NAC_LMD_ADJUST_CFG_VOLTAGE_CC_WEIGHT_4              (3<<21)
+#define NAC_LMD_ADJUST_CFG_OCV_REFER_NAC_TABLE_EN             (1<<23)
+#define NAC_LMD_ADJUST_CFG_STANDBY_DYNAMIC_OCV_WEIGHT_EN      (1<<24)
+#define NAC_LMD_ADJUST_CFG_NO_STANDBY_CAP_EST_EN              (1<<25)
+#define NAC_LMD_ADJUST_CFG_RSOC_FILTER_RSOC_TABLE             (1<<26)
+#define NAC_LMD_ADJUST_CFG_RSOC_FILTER_LOCK_TABLE             (1<<27)
+#define NAC_LMD_ADJUST_CFG_BATTERY_REINSERT_DETECT_EN         (1<<28)
+#define NAC_LMD_ADJUST_CFG_INIT_PARSER_FORCE_100_EN           (1<<29)
+#define NAC_LMD_ADJUST_CFG_RSOC_FILTER_STEP_CC                (1<<30)
+#define NAC_LMD_ADJUST_CFG_REMAP_RSOC_EN                      (1<<31)
+
+#define GET_PRODUCT_TYPE(x)       ((x & NAC_LMD_ADJUST_CFG_PRODUCT_TYPE) >> 6)
+#define GET_CAP_ALGORITHM_VER(x)  ((x & NAC_LMD_ADJUST_CFG_CAP_ALGORITHM_VER) >> 15)
+
+enum C_RATE_TABLE_VALUES {
+  C_RATE_TABLE_VALUE_0 = 50,
+  C_RATE_TABLE_VALUE_1 = 20,
+  C_RATE_TABLE_VALUE_2 = 10,
+  C_RATE_TABLE_VALUE_3 = 2
+};
+
+enum OCV_TABLE_IDX {
+  OCV_TABLE_IDX_CHARGE = 0,
+  OCV_TABLE_IDX_STAND_ALONE,
+  OCV_TABLE_IDX_100MA,
+  OCV_TABLE_IDX_COUNT,
+};
+
+#define CONST_PERCENTAGE                  (100)
+#define CONST_ROUNDING                    (10)
+#define CONST_ROUNDING_5                  (5)
+#define TIME_CONVERT_TIME_TO_MSEC         (10)
+#define CONST_CONVERSION_COUNT_THRESHOLD  (500)
+#define TIME_SEC_TO_HOUR                  (3600)
+#define TIME_MSEC_TO_SEC                  (1000)
+#define TIME_SEC_TO_MIN                   (60)
+
+#define ET_AVERAGE_NEW      (1)
+#define ET_AVERAGE_OLD      (7)
+#define ET_AVERAGE_BASE     (ET_AVERAGE_NEW + ET_AVERAGE_OLD)
+
+#define IT_IDEAL_CODE_25      (24310)
+#define IT_IDEAL_CODE_80      (28612)
+
+#endif
+
+#define ENCRIPT_TABLE_SIZE (39)
+
+#define _LKM_OPTIONS_
+#define LKM_OPTIONS_FORCE_RESET             (1<<0)
+#define LKM_OPTIONS_ENABLE_SUSPEND_DATA_LOG (1<<1)
+#define LKM_OPTIONS_ENABLE_DEBUG_LOG        (3<<2)
+  #define LKM_OPTIONS_DEBUG_ERROR           (0<<2)
+  #define LKM_OPTIONS_DEBUG_INFO            (1<<2)
+  #define LKM_OPTIONS_DEBUG_NOTICE          (2<<2)
+  #define LKM_OPTIONS_DEBUG_DEBUG           (3<<2)
+#define LKM_OPTIONS_ENABLE_REVERSE_CURRENT  (1<<4)
+#define LKM_OPTIONS_ADJUST_DESIGN_CAPACITY  (1<<5)
+#define LKM_OPTIONS_DISABLE_BACHUP_FILE     (1<<6)
+#define LKM_OPTIONS_FORCE_RESET_TOTALLY     (1<<7)
+
+#define LKM_OPTIONS_DEBUG_LEVEL(x)          ((x & LKM_OPTIONS_ENABLE_DEBUG_LOG) >> 2)
+
+/// ===========================================
+/// End of uG31xx.h
+/// ===========================================
+
diff --git a/drivers/power/supply/ASUS_BATTERY/ME176C/ug31xx/uG31xx_API.c b/drivers/power/supply/ASUS_BATTERY/ME176C/ug31xx/uG31xx_API.c
new file mode 100644
index 000000000000..fb68cb96189e
--- /dev/null
+++ b/drivers/power/supply/ASUS_BATTERY/ME176C/ug31xx/uG31xx_API.c
@@ -0,0 +1,7134 @@
+/**
+ * Copyright @ 2013 uPI Semiconductor Corp. All right reserved.
+ * The information, images, and/or data contained in this material is copyrighted by uPI
+ * Semiconductor Corp., and may not be distributed, modified, reproduced in whole or in part
+ * without the prior, written consent of uPI Semiconductor Corp.
+ */
+
+/// ===========================================
+/// uG31xx_API.cpp
+/// ===========================================
+
+#include "stdafx.h"     //windows need this??
+#include "uG31xx_API.h"
+
+static _upi_bool_ Ug31BackupFileEnable;
+static _upi_bool_ Ug31SaveDataEnable = _UPI_TRUE_;
+/// [FC] : Add variable MPK_active for MPK intial ; 12/10/2013
+_upi_bool_ MPK_active = _UPI_FALSE_;
+static _upi_bool_ Ug31AdjustCellTableNeed = _UPI_FALSE_;
+static _upi_u16_ new_design_capacity;
+
+#ifdef  uG31xx_BOOT_LOADER
+
+  static _upi_u8_ ug31_uboot_sts;
+
+#endif  ///< end of uG31xx_BOOT_LOADER
+
+#if defined (uG31xx_OS_WINDOWS)
+
+  #define UG31XX_API_VERSION      (_T("UG31XX API $Rev: 684 $"))
+
+#else
+
+  #define UG31XX_API_VERSION      ("UG31XX API $Rev: 684 $")
+
+#endif
+
+/// ===========================================
+/// uG31xx_API.cpp (VAR)
+/// ===========================================
+
+/* uPI ug31xx hardware control interface */
+struct ug31xx_data {
+
+  /// [AT-PM] : Following variables are used for uG31xx operation ; 11/01/2012
+  _upi_u8_  totalCellNums;
+  _upi_bool_ bFirstData;
+
+  // Global variable
+  CELL_TABLE      cellTable;     // data from .GGB file
+  CELL_PARAMETER  cellParameter;  // data from .GGB file
+  GG_BATTERY_INFO batteryInfo;
+  GG_DEVICE_INFO  deviceInfo;
+  GG_USER_REG     userReg;			//user register 0x00 ~0x10
+  GG_USER2_REG	  user2Reg;		//user register 0x40 ~0x4f
+  GG_TI_BQ27520   bq27520Cmd;
+
+  OtpDataType       otpData;
+  MeasDataType      measData;
+  CapacityDataType  capData;
+  SystemDataType    sysData;
+  BackupDataType    backupData;
+
+  _upi_u8_ EncriptTableStatus;
+  _upi_u16_ PreviousITAve;
+  _upi_u8_ Options;
+};
+
+CELL_TABLE *ptrCellTable = _UPI_NULL_;
+CELL_PARAMETER *ptrCellParameter = _UPI_NULL_;
+GGBX_FILE_HEADER *ptrGgbBuf = _UPI_NULL_;
+
+/// ===========================================
+/// End of uG31xx_API.cpp (VAR)
+/// ===========================================
+
+#ifndef uG31xx_BOOT_LOADER
+
+/**
+ * @brief upiGG_GetAlarmStatus
+ *
+ *  Get alarm status
+ *
+ * @para  pAlarmStatus  address of alarm status
+ * @return  UG_READ_DEVICE_ALARM_SUCCESS if success
+ */
+GGSTATUS upiGG_GetAlarmStatus(char *pObj, _upi_u8_ *pAlarmStatus)
+{
+  struct ug31xx_data *pUg31xx;
+
+  pUg31xx = (struct ug31xx_data *)pObj;
+
+  UpiMeasAlarmThreshold(&pUg31xx->measData);
+  *pAlarmStatus = UpiAlarmStatus(&pUg31xx->sysData);
+
+  pUg31xx->userReg.regAlarm1Status = (_upi_u8_)(pUg31xx->sysData.alarmSts & 0x00ff);
+  pUg31xx->userReg.regAlarm2Status = (_upi_u8_)(pUg31xx->sysData.alarmSts >> 8);
+
+  return (UG_READ_DEVICE_ALARM_SUCCESS);
+}
+
+// Read GG_USER_REG from device to global variable and output
+GGSTATUS upiGG_ReadAllRegister(char *pObj, GG_USER_REG* pUserReg, GG_USER2_REG* pUser2Reg)
+{
+  struct ug31xx_data *pUg31xx;
+
+  pUg31xx = (struct ug31xx_data *)pObj;
+
+	if(!API_I2C_Read(NORMAL,
+                   UG31XX_I2C_HIGH_SPEED_MODE,
+                   UG31XX_I2C_TEM_BITS_MODE,
+                   REG_MODE,
+                   sizeof(GG_USER_REG),
+                   &pUg31xx->userReg.regMode))
+  {
+		return (UG_READ_REG_FAIL);
+  }
+  if(!API_I2C_Read(NORMAL,
+                   UG31XX_I2C_HIGH_SPEED_MODE,
+                   UG31XX_I2C_TEM_BITS_MODE,
+                   REG_VBAT2_LOW,
+                   sizeof(GG_USER2_REG),
+                   (_upi_u8_* )&pUg31xx->user2Reg.regVbat2))    //read
+  {
+		return (UG_READ_REG_FAIL);
+  }
+
+  return (UG_READ_REG_SUCCESS);
+}
+
+#endif  ///< end of uG31xx_BOOT_LOADER
+
+// 07/04/1022/Jacky
+_upi_u16_ CalculateVoltageFromUserReg(struct ug31xx_data *pUg31xx, _upi_s16_ voltageAdcCode, _upi_s16_ curr, _upi_u16_ offsetR, _upi_u16_ deltaR)
+{
+	_upi_u16_ voltage_return;
+
+  voltage_return = (_upi_u16_)voltageAdcCode;
+	if(curr < 0) {
+		voltage_return = voltage_return + offsetR*abs(curr)/1000 + deltaR;
+	} else{
+		voltage_return = voltage_return - offsetR*abs(curr)/1000 + deltaR;
+	}
+	return (voltage_return);
+}
+
+#ifdef  uG31xx_BOOT_LOADER
+
+/**
+ * @brief uboot_reset_full_charge
+ *
+ *  Reset full charge function
+ *
+ * @para  address of struct ug31xx_data
+ * @return  NULL
+ */
+void uboot_reset_full_charge(struct ug31xx_data *obj)
+{
+  ug31_uboot_sts = ug31_uboot_sts & (~UPI_BOOT_STATUS_FC);
+
+  obj->capData.tpTime = 0;
+}
+
+/**
+ * @brief uboot_check_full_charge
+ *
+ *  Check full charge condition for uBoot
+ *
+ * @para  obj address of struct ug31xx_data
+ * @return  NULL
+ */
+void uboot_check_full_charge(struct ug31xx_data *obj)
+{
+  _upi_u32_ tmp32;
+
+  if(ug31_uboot_sts & UPI_BOOT_STATUS_FC)
+  {
+    return;
+  }
+
+  /// [AT-PM] : Check taper voltage ; 09/03/2013
+  if(obj->measData.bat1Voltage < obj->cellParameter.TPVoltage)
+  {
+    uboot_reset_full_charge(obj);
+    return;
+  }
+
+  /// [AT-PM] : Check taper current ; 09/03/2013
+  if((obj->measData.curr < obj->cellParameter.standbyCurrent) ||
+     (obj->measData.curr > obj->cellParameter.TPCurrent))
+  {
+    uboot_reset_full_charge(obj);
+    return;
+  }
+
+  /// [AT-PM] : Check taper time ; 09/03/2013
+  obj->capData.tpTime = obj->capData.tpTime + obj->measData.deltaTime;
+  tmp32 = (_upi_u32_)obj->cellParameter.TPTime;
+  tmp32 = tmp32*TIME_MSEC_TO_SEC;
+  if(obj->capData.tpTime < tmp32)
+  {
+    return;
+  }
+
+  /// [AT-PM] : Set full charge status ; 09/03/2013
+  ug31_uboot_sts = ug31_uboot_sts | UPI_BOOT_STATUS_FC;
+  obj->batteryInfo.NAC = obj->batteryInfo.LMD;
+  obj->batteryInfo.RSOC = CONST_PERCENTAGE;
+  obj->capData.tpTime = obj->cellParameter.TPTime;
+}
+
+/**
+ * @brief uboot_check_capacity
+ *
+ *  Check capacity data
+ *
+ * @para  obj address of struct ug31xx_data
+ * @return  NULL
+ */
+void uboot_check_capacity(struct ug31xx_data *obj)
+{
+  _upi_u32_ tmp32;
+
+  /// [AT-PM] : Check full charge release condition ; 09/03/2013
+  if(obj->batteryInfo.RSOC < CONST_PERCENTAGE)
+  {
+    ug31_uboot_sts = ug31_uboot_sts & (~UPI_BOOT_STATUS_FC);
+  }
+
+  /// [AT-PM] : Check RSOC < 100 before FC ; 09/03/2013
+  if((obj->batteryInfo.RSOC >= CONST_PERCENTAGE) &&
+     (!(ug31_uboot_sts & UPI_BOOT_STATUS_FC)))
+  {
+    obj->batteryInfo.RSOC = CONST_PERCENTAGE - 1;
+
+    /// [AT-PM] : Recalculate RM ; 09/03/2013
+    tmp32 = (_upi_u32_)obj->batteryInfo.LMD;
+    tmp32 = tmp32*(obj->batteryInfo.RSOC)/CONST_PERCENTAGE;
+    obj->batteryInfo.NAC = (_upi_u16_)tmp32;
+  }
+
+  /// [AT-PM] : Check RM <= FCC ; 09/03/2013
+  if(obj->batteryInfo.NAC > obj->batteryInfo.LMD)
+  {
+    obj->batteryInfo.NAC = obj->batteryInfo.LMD;
+  }
+}
+
+#endif  ///< end of uG31xx_BOOT_LOADER
+
+#define MAX_DIFF_IN_IT_AVE_CODE     (1000)
+#define MIN_DIFF_IN_IT_AVE_CODE     (-1000)
+
+/**
+ * @brief ChkITAveCode
+ *
+ *  Check IT AVE code, which should be continuous
+ *
+ * @para  pObj  address of struct ug31xx_data
+ * @return  NULL
+ */
+void ChkITAveCode(struct ug31xx_data *pObj)
+{
+  _upi_s32_ tmp;
+
+  if(pObj->PreviousITAve != 0)
+  {
+    tmp = (_upi_s32_)pObj->PreviousITAve;
+    tmp = tmp - pObj->userReg.regITAve;
+    if((tmp > MAX_DIFF_IN_IT_AVE_CODE) || (tmp < MIN_DIFF_IN_IT_AVE_CODE))
+    {
+      UG31_LOGE("[%s]: IT AVE Code abnormal -> %d/%d\n", __func__, pObj->userReg.regITAve, pObj->PreviousITAve);
+      pObj->userReg.regITAve = pObj->PreviousITAve;
+    }
+  }
+  pObj->PreviousITAve = pObj->userReg.regITAve;
+}
+
+/**
+ * @brief CheckOtpData
+ *
+ *  Check OTP data
+ *  1. Check OTP is empty or not
+ *  2. Check product type
+ *
+ * @para  pObj  address of OtpDataType
+ * @return  GGSTATUS
+ */
+GGSTATUS CheckOtpData(OtpDataType *pObj)
+{
+  /// [AT-PM] : Check OTP is empty or not ; 01/25/2013
+  if(pObj->empty == OTP_IS_EMPTY)
+  {
+    return (UG_OTP_ISEMPTY);
+  }
+
+  /// [AT-PM] : Check product type ; 01/25/2013
+  if((pObj->productType != UG31XX_PRODUCT_TYPE_0) &&
+     (pObj->productType != UG31XX_PRODUCT_TYPE_1))
+  {
+    return (UG_OTP_PRODUCT_DISMATCH);
+  }
+  return (UG_READ_DEVICE_INFO_SUCCESS);
+}
+
+// Read GG_USER_REG from device and calculate GG_DEVICE_INFO, then write to global variable and output
+// TODO: offsetR and deltaR will input from .GGB in the future modify
+GGSTATUS upiGG_ReadDeviceInfo(char *pObj, GG_DEVICE_INFO* pExtDeviceInfo)
+{
+	// Get current user register data
+	GGSTATUS status = UG_READ_DEVICE_INFO_SUCCESS;
+  struct ug31xx_data *pUg31xx;
+  MEAS_RTN_CODE rtn;
+  #ifdef  uG31xx_BOOT_LOADER
+    _upi_u8_ tmp;
+  #endif  ///< end of uG31xx_BOOT_LOADER
+
+  pUg31xx = (struct ug31xx_data *)pObj;
+
+  #ifndef uG31xx_BOOT_LOADER
+
+  	if(!API_I2C_Read(NORMAL,
+                     UG31XX_I2C_HIGH_SPEED_MODE,
+                     UG31XX_I2C_TEM_BITS_MODE,
+                     REG_MODE,
+                     REG_AVE_RID_HIGH - REG_MODE + 1,
+                     &pUg31xx->userReg.regMode))
+    {
+  		status = UG_READ_ADC_FAIL;
+    }
+  	else
+    {
+  		if(!API_I2C_Read(NORMAL,
+                       UG31XX_I2C_HIGH_SPEED_MODE,
+                       UG31XX_I2C_TEM_BITS_MODE,
+                       REG_INTR_STATUS,
+                       REG_CTRL2 - REG_INTR_STATUS + 1,
+                       &pUg31xx->userReg.regIntrStatus))
+      {
+        status = UG_READ_ADC_FAIL;
+      }
+      else
+      {
+        if(!API_I2C_Read(NORMAL,
+                         UG31XX_I2C_HIGH_SPEED_MODE,
+                         UG31XX_I2C_TEM_BITS_MODE,
+                         REG_VBAT2_LOW,
+                         sizeof(GG_USER2_REG),
+                         (_upi_u8_* )&pUg31xx->user2Reg.regVbat2))    //read
+        {
+          status = UG_READ_ADC_FAIL;
+        }
+      }
+  	}
+
+    /// [AT-PM] : Check IT AVE code, which should be continuous ; 12/28/2012
+    ChkITAveCode(pUg31xx);
+
+  #endif  ///< end of uG31xx_BOOT_LOADER
+
+  status = CheckOtpData(&pUg31xx->otpData);
+  if(status != UG_READ_DEVICE_INFO_SUCCESS)
+  {
+    return (status);
+  }
+
+  #ifdef  uG31xx_BOOT_LOADER
+
+    pUg31xx->measData.lastTimeTick = DEFAULT_TIME_TICK;
+
+  #endif  ///< end of uG31xx_BOOT_LOADER
+  rtn = UpiMeasurement(&pUg31xx->measData, MEAS_SEL_ALL);
+  UpiAdcStatus(&pUg31xx->sysData);
+  if(rtn != MEAS_RTN_PASS)
+  {
+    return ((GGSTATUS)(rtn + UG_MEAS_FAIL));
+  }
+  pUg31xx->sysData.cycleCount = (_sys_u16_)pUg31xx->measData.cycleCount;
+
+	pUg31xx->deviceInfo.chargeRegister = pUg31xx->userReg.regCharge;					//coulomb counter
+	pUg31xx->deviceInfo.AdcCounter = pUg31xx->userReg.regCounter;						//adc1 convert counter
+	pUg31xx->deviceInfo.aveCurrentRegister = pUg31xx->userReg.regCurrentAve;    //2012/07/11
+	pUg31xx->deviceInfo.current_mA = pUg31xx->measData.curr;
+	pUg31xx->deviceInfo.AveCurrent_mA = pUg31xx->measData.curr;
+  pUg31xx->deviceInfo.IT = pUg31xx->measData.intTemperature;
+  pUg31xx->deviceInfo.ET = pUg31xx->measData.extTemperature;
+	pUg31xx->deviceInfo.v1_mV = pUg31xx->measData.bat1Voltage;
+	pUg31xx->deviceInfo.v2_mV = pUg31xx->measData.bat2Voltage;
+	pUg31xx->deviceInfo.v3_mV = pUg31xx->measData.bat3Voltage;
+
+	pUg31xx->deviceInfo.vCell2_mV = pUg31xx->measData.bat2Voltage;
+	pUg31xx->deviceInfo.vCell3_mV = pUg31xx->measData.bat3Voltage;
+	pUg31xx->deviceInfo.vCell1_mV = pUg31xx->measData.bat1Voltage;
+	pUg31xx->deviceInfo.vBat1Average_mV = CalculateVoltageFromUserReg(pUg31xx,
+                                                                    pUg31xx->measData.bat1Voltage,
+                                                                    pUg31xx->measData.curr,
+                                                                    pUg31xx->cellParameter.offsetR,
+                                                                    0);
+	pUg31xx->deviceInfo.vBat2Average_mV = CalculateVoltageFromUserReg(pUg31xx,
+                                                                    pUg31xx->measData.bat2Voltage,
+                                                                    pUg31xx->measData.curr,
+                                                                    pUg31xx->cellParameter.offsetR,
+                                                                    0);
+	pUg31xx->deviceInfo.vBat3Average_mV = CalculateVoltageFromUserReg(pUg31xx,
+                                                                    pUg31xx->measData.bat3Voltage,
+                                                                    pUg31xx->measData.curr,
+                                                                    pUg31xx->cellParameter.offsetR,
+                                                                    0);
+  /// [RY] : get the differ cell voltage
+  pUg31xx->deviceInfo.vBat3Average_mV = pUg31xx->deviceInfo.vBat3Average_mV - 	pUg31xx->deviceInfo.vBat2Average_mV ;
+  pUg31xx->deviceInfo.vBat2Average_mV = pUg31xx->deviceInfo.vBat2Average_mV - pUg31xx->deviceInfo.vBat1Average_mV;
+  pUg31xx->deviceInfo.vCell3_mV = pUg31xx->deviceInfo.vCell3_mV - pUg31xx->deviceInfo.vCell2_mV;
+  pUg31xx->deviceInfo.vCell2_mV = pUg31xx->deviceInfo.vCell2_mV - pUg31xx->deviceInfo.vCell1_mV;
+
+  /// [RY] : multi - cell setting
+  if(pUg31xx->measData.codeBat3 > 0)
+  {
+    pUg31xx->deviceInfo.voltage_mV = pUg31xx->deviceInfo.vBat1Average_mV +
+                                     pUg31xx->deviceInfo.vBat2Average_mV +
+                                     pUg31xx->deviceInfo.vBat3Average_mV;
+  }
+  else if(pUg31xx->measData.codeBat2 > 0)
+  {
+    pUg31xx->deviceInfo.voltage_mV = pUg31xx->deviceInfo.vBat1Average_mV +
+                                     pUg31xx->deviceInfo.vBat2Average_mV;
+  }
+  else
+  {
+	  pUg31xx->deviceInfo.voltage_mV = pUg31xx->deviceInfo.vBat1Average_mV;
+  }
+	pUg31xx->deviceInfo.chargeData_mAh = pUg31xx->measData.deltaCap;
+
+	UpiCalculateOscFreq(&pUg31xx->sysData);
+
+	upi_memcpy(pExtDeviceInfo, &pUg31xx->deviceInfo, sizeof(GG_DEVICE_INFO));
+
+  #ifdef  uG31xx_BOOT_LOADER
+
+    /// [AT-PM] : Update capacity ; 09/03/2013
+    tmp = (_upi_s32_)pUg31xx->measData.curr;
+    tmp = tmp*(pUg31xx->measData.stepCap);
+    if(tmp < 0)
+    {
+      pUg31xx->measData.stepCap = 0;
+    }
+    pUg31xx->sysData.voltage = (_sys_u16_)pUg31xx->measData.bat1Voltage;
+    pUg31xx->sysData.curr = (_sys_s16_)pUg31xx->measData.curr;
+    UpiUpdateBatInfoFromIC(&pUg31xx->sysData, (_sys_s16_)pUg31xx->measData.stepCap, _UPI_FALSE_);
+
+    pUg31xx->batteryInfo.NAC = pUg31xx->sysData.rmFromIC;
+    pUg31xx->batteryInfo.LMD = pUg31xx->sysData.fccFromIC;
+    pUg31xx->batteryInfo.RSOC = pUg31xx->sysData.rsocFromIC;
+
+    /// [AT-PM] : Reset coulomb counter if necessary ; 09/03/2013
+    tmp = (_upi_s32_)pUg31xx->measData.deltaCap;
+    if(tmp < 0)
+    {
+      tmp = tmp*(-1);
+    }
+    if(tmp > RESET_COULOMB_COUNTER_DELTA_CAP)
+    {
+      UpiResetCoulombCounter(&pUg31xx->measData);
+      UpiAdcStatus(&pUg31xx->sysData);
+      pUg31xx->sysData.cycleCount = (_sys_u16_)pUg31xx->measData.cycleCount;
+    }
+
+    /// [AT-PM] : Check full charge termination ; 09/03/2013
+    uboot_check_full_charge(pUg31xx);
+
+    /// [AT-PM] : Check capacity data ; 09/03/2013
+    uboot_check_capacity(pUg31xx);
+
+    /// [AT-PM] : Save data back to IC ; 09/03/2013
+    if(ug31_uboot_sts & (UPI_BOOT_STATUS_FCC_IS_0 | UPI_BOOT_STATUS_IC_IS_NOT_ACTIVE))
+    {
+      pUg31xx->sysData.fccFromIC = 0;
+    }
+    pUg31xx->sysData.voltage = (_sys_u16_)pUg31xx->measData.bat1Voltage;
+    UpiSaveBatInfoTOIC(&pUg31xx->sysData);
+    pUg31xx->sysData.fccFromIC = pUg31xx->batteryInfo.LMD;
+
+  #endif  ///< end of uG31xx_BOOT_LOADER
+
+	return (status);
+}
+
+#ifndef uG31xx_BOOT_LOADER
+
+void dumpInfo(struct ug31xx_data *pUg31xx)
+{
+        int i=0;
+        int j;
+        int k;
+
+/// dump parameter setting
+        UG31_LOGD("/// 2012/12/16/1611====================================\n");
+        UG31_LOGD("/// CELL_PARAMETER\n");
+        UG31_LOGD("/// ====================================2012/12/16/1611\n");
+        UG31_LOGD("Total struct size: %d\n", pUg31xx->cellParameter.totalSize);
+        UG31_LOGD("firmware version: 0x%02X\n", pUg31xx->cellParameter.fw_ver);
+        UG31_LOGI("customer: %s\n", pUg31xx->cellParameter.customer);
+        UG31_LOGI("project: %s\n", pUg31xx->cellParameter.project);
+        UG31_LOGD("ggb version: 0x%02X\n", pUg31xx->cellParameter.ggb_version);
+        UG31_LOGE("customer self-define: %s\n", pUg31xx->cellParameter.customerSelfDef);
+        UG31_LOGE("project self-define: %s\n", pUg31xx->cellParameter.projectSelfDef);
+        UG31_LOGD("cell type : 0x%04X\n", pUg31xx->cellParameter.cell_type_code);
+        UG31_LOGD("ICType: 0x%02X\n", pUg31xx->cellParameter.ICType);
+        UG31_LOGD("gpio1: 0x%02X\n", pUg31xx->cellParameter.gpio1);
+        UG31_LOGD("gpio2: 0x%02X\n", pUg31xx->cellParameter.gpio2);
+        UG31_LOGD("gpio34: 0x%02X\n", pUg31xx->cellParameter.gpio34);
+        UG31_LOGD("Chop control ?? : 0x%02X\n", pUg31xx->cellParameter.chopCtrl);
+        UG31_LOGD("ADC1 offset ?? : %d\n", pUg31xx->cellParameter.adc1Offset);
+        UG31_LOGD("Cell number ?? : %d\n", pUg31xx->cellParameter.cellNumber);
+        UG31_LOGD("Assign cell one to: %d\n", pUg31xx->cellParameter.assignCellOneTo);
+        UG31_LOGD("Assign cell two to: %d\n", pUg31xx->cellParameter.assignCellTwoTo);
+        UG31_LOGD("Assign cell three to: %d\n", pUg31xx->cellParameter.assignCellThreeTo);
+        UG31_LOGD("I2C Address: : 0x%02X\n", pUg31xx->cellParameter.i2cAddress);
+        UG31_LOGD("I2C 10bit address: : 0x%02X\n", pUg31xx->cellParameter.tenBitAddressMode);
+        UG31_LOGD("I2C high speed: 0x%02X\n", pUg31xx->cellParameter.highSpeedMode);
+        UG31_LOGD("clock(kHz): %d\n", pUg31xx->cellParameter.clock);
+        UG31_LOGI("RSense(m ohm): %d\n", pUg31xx->cellParameter.rSense);
+        UG31_LOGI("ILMD(mAH) ?? : %d\n", pUg31xx->cellParameter.ILMD);
+        UG31_LOGI("EDV1 Voltage(mV): %d\n", pUg31xx->cellParameter.edv1Voltage);
+        UG31_LOGI("Standby current ?? : %d\n", pUg31xx->cellParameter.standbyCurrent);
+        UG31_LOGI("TP Current(mA)?? : %d\n", pUg31xx->cellParameter.TPCurrent);
+        UG31_LOGI("TP Voltage(mV)?? : %d\n", pUg31xx->cellParameter.TPVoltage);
+        UG31_LOGI("TP Time ?? : %d\n", pUg31xx->cellParameter.TPTime);
+        UG31_LOGI("Offset R ?? : %d\n", pUg31xx->cellParameter.offsetR);
+        UG31_LOGD("Delta R ?? : %d\n", pUg31xx->cellParameter.deltaR);
+        UG31_LOGD("max delta Q(%%)  ?? : %d\n", pUg31xx->cellParameter.maxDeltaQ);
+        UG31_LOGD("TP Bypass Current ?? : %d\n", pUg31xx->cellParameter.TpBypassCurrent);    //20121029/Jacky
+        UG31_LOGD("time interval (s) : %d\n", pUg31xx->cellParameter.timeInterval);
+        UG31_LOGI("ADC1 pgain: %d\n", pUg31xx->cellParameter.adc1_pgain);
+        UG31_LOGI("ADC1 ngain: %d\n", pUg31xx->cellParameter.adc1_ngain);
+        UG31_LOGI("ADC1 pos. offset: %d\n", pUg31xx->cellParameter.adc1_pos_offset);
+        UG31_LOGI("ADC2 gain: %d\n", pUg31xx->cellParameter.adc2_gain);
+        UG31_LOGI("ADC2 offset: %d\n", pUg31xx->cellParameter.adc2_offset);
+        UG31_LOGI("ADC2 vbat2 gain: %d\n", pUg31xx->cellParameter.vbat2_gain);
+        UG31_LOGI("ADC2 vbat2 offset: %d\n", pUg31xx->cellParameter.vbat2_offset);
+        UG31_LOGI("ADC2 vbat3 gain: %d\n", pUg31xx->cellParameter.vbat3_gain);
+        UG31_LOGI("ADC2 vbat3 offset: %d\n", pUg31xx->cellParameter.vbat3_offset);
+        UG31_LOGI("R ?? : %d\n", pUg31xx->cellParameter.R);
+        for (i=0; i<(int)(sizeof(pUg31xx->cellParameter.rtTable)/sizeof(_upi_u16_)); i++) {
+                UG31_LOGI("RTTable[%02d]: %d\n", i, pUg31xx->cellParameter.rtTable[i]);
+        }
+        for (i=0; i<(int)(sizeof(pUg31xx->cellParameter.SOV_TABLE)/sizeof(_upi_u16_)); i++) {
+                UG31_LOGD("SOV Table[%02d]: %d\n", i, pUg31xx->cellParameter.SOV_TABLE[i]/10);
+        }
+        UG31_LOGI("ADC d1: %d\n", pUg31xx->cellParameter.adc_d1);
+        UG31_LOGI("ADC d2: %d\n", pUg31xx->cellParameter.adc_d2);
+        UG31_LOGI("ADC d3: %d\n", pUg31xx->cellParameter.adc_d3);
+        UG31_LOGI("ADC d4: %d\n", pUg31xx->cellParameter.adc_d4);
+        UG31_LOGI("ADC d5: %d\n", pUg31xx->cellParameter.adc_d5);
+        UG31_LOGE("NacLmdAdjustCfg: %d\n", pUg31xx->cellParameter.NacLmdAdjustCfg);    //20121124
+
+        /// [AT-PM] : Dump NAC table ; 01/27/2013
+        i = 0;
+        while(i < TEMPERATURE_NUMS)
+        {
+          j = 0;
+          while(j < C_RATE_NUMS)
+          {
+            k = 0;
+            while(k < SOV_NUMS)
+            {
+              UG31_LOGD("NAC Table [%d][%d][%d] = %d\n", i, j, k, pUg31xx->cellTable.CELL_NAC_TABLE[i][j][k]);
+              k = k + 1;
+            }
+            j = j + 1;
+          }
+          i = i + 1;
+        }
+}
+
+/// count Time Elapsed in suspend/power Off
+_upi_u32_ CountTotalTime(_upi_u32_ savedTimeTag)
+{
+	_upi_u32_ totalTime;
+	_upi_u32_ currentTime;
+
+	totalTime = 0;
+#if defined(uG31xx_OS_ANDROID)
+	currentTime = GetSysTickCount();
+#else   ///< else of defined(uG31xx_OS_ANDROID)
+  #if defined(BUILD_UG31XX_LIB)
+  	currentTime = GetSysTickCount();
+  #else   ///< else of defined(BUILD_UG31XX_LIB)
+  	currentTime = GetTickCount();
+  #endif  ///< end of defined(BUILD_UG31XX_LIB)
+#endif  ///< end of defined(uG31xx_OS_ANDROID)
+	if(currentTime > savedTimeTag)
+	{
+		totalTime = currentTime - savedTimeTag;				//count the delta Time
+	}
+  else
+  {
+    totalTime = 0xffffffff;
+    totalTime = totalTime - savedTimeTag;
+    totalTime = totalTime + currentTime;
+  }
+	UG31_LOGE("[%s]current time/save Time/totalTime = %d/%d/%d \n",
+							__func__,
+							currentTime,
+							savedTimeTag,
+							totalTime
+							);
+  return(totalTime);
+}
+
+#define MS_IN_A_DAY                             (86400000)
+#define INIT_CAP_FROM_CC_FACTOR                 (10)
+
+/**
+ * @brief CheckInitCapacityFromCC
+ *
+ *  Check the initial capacity from coulomb counter with time interval
+ *  The delta RSOC should be less than n days x 0.1%
+ *
+ * @para  pUg31xx address of struct ug31xx_data
+ * @return  _UPI_NULL_
+ */
+void CheckInitCapacityFromCC(struct ug31xx_data *pUg31xx)
+{
+  _upi_s32_ tmp32;
+
+  tmp32 = (_upi_s16_)pUg31xx->sysData.rsocFromIC;
+  tmp32 = tmp32 - pUg31xx->sysData.rsocFromICBackup;
+  if(tmp32 < 0)
+  {
+    tmp32 = (_upi_s32_)CountTotalTime(pUg31xx->sysData.timeTagFromIC)/MS_IN_A_DAY/INIT_CAP_FROM_CC_FACTOR;
+    tmp32 = tmp32*(-1) + pUg31xx->sysData.rsocFromICBackup;
+    if(tmp32 < 0)
+    {
+      tmp32 = 1;
+    }
+    UG31_LOGN("[%s]: RSOC should be limited to %d (%d <-> %d)\n", __func__,
+              tmp32, pUg31xx->sysData.rsocFromICBackup, pUg31xx->sysData.rsocFromIC);
+    pUg31xx->sysData.rsocFromIC = (_sys_u8_)tmp32;
+    tmp32 = tmp32*pUg31xx->sysData.fccFromIC/CONST_PERCENTAGE;
+    pUg31xx->sysData.rmFromIC = (_sys_u16_)tmp32;
+  }
+}
+
+#define MAX_DELTA_RSOC_THRESHOLD_FOR_WAKEUP     (20)
+#define MIN_DELTA_RSOC_THRESHOLD_FOR_WAKEUP     (-20)
+#ifdef  WAKEUP_TIME_THRD_1_HOUR
+#define MAX_DELTA_TIME_THRESHOLD_FOR_WAKEUP     (MS_IN_A_DAY/24)
+#else   ///< else of WAKEUP_TIME_THRD_1_HOUR
+#define MAX_DELTA_TIME_THRESHOLD_FOR_WAKEUP     (MS_IN_A_DAY)
+#endif  ///< end of WAKEUP_TIME_THRD_1_HOUR
+#define MAX_DELTA_CC_CNT_THRESHOLD_FOR_WAKEUP   (MAX_DELTA_TIME_THRESHOLD_FOR_WAKEUP/125)
+#define MAX_DELTA_RSOC_THRESHOLD_FOR_TABLE      (10)
+#define MIN_DELTA_RSOC_THRESHOLD_FOR_TABLE      (-10)
+#define DELTA_SOC_TABLE_IDX_FOR_CC_THRD         (10)
+
+typedef struct RsocChkTableST
+{
+  _upi_u32_ time;
+  _upi_s8_ maxRsoc;
+  _upi_s8_ minRsoc;
+} ALIGNED_ATTRIBUTE RsocChkTableType;
+
+static RsocChkTableType RsocChkTable[] =
+{
+  { MAX_DELTA_TIME_THRESHOLD_FOR_WAKEUP*1,  100,  -100, },
+  { MAX_DELTA_TIME_THRESHOLD_FOR_WAKEUP*2,  20,   -20,  },
+  { MAX_DELTA_TIME_THRESHOLD_FOR_WAKEUP*3,  19,   -19,  },
+  { MAX_DELTA_TIME_THRESHOLD_FOR_WAKEUP*4,  18,   -18,  },
+  { MAX_DELTA_TIME_THRESHOLD_FOR_WAKEUP*5,  17,   -17,  },
+  { MAX_DELTA_TIME_THRESHOLD_FOR_WAKEUP*6,  16,   -16,  },
+  { MAX_DELTA_TIME_THRESHOLD_FOR_WAKEUP*7,  15,   -15,  },
+  { MAX_DELTA_TIME_THRESHOLD_FOR_WAKEUP*8,  14,   -14,  },
+  { MAX_DELTA_TIME_THRESHOLD_FOR_WAKEUP*9,  13,   -13,  },
+  { MAX_DELTA_TIME_THRESHOLD_FOR_WAKEUP*10, 12,   -12,  },
+  { MAX_DELTA_TIME_THRESHOLD_FOR_WAKEUP*11, 11,   -11,  },
+  { MAX_DELTA_TIME_THRESHOLD_FOR_WAKEUP*12, 10,   -10,  },
+  { MAX_DELTA_TIME_THRESHOLD_FOR_WAKEUP*14, 9,    -9,   },
+  { MAX_DELTA_TIME_THRESHOLD_FOR_WAKEUP*15, 8,    -8,   },
+  { MAX_DELTA_TIME_THRESHOLD_FOR_WAKEUP*16, 7,    -7,   },
+  { MAX_DELTA_TIME_THRESHOLD_FOR_WAKEUP*17, 6,    -6,   },
+  { MAX_DELTA_TIME_THRESHOLD_FOR_WAKEUP*18, 5,    -5,   },
+  { MAX_DELTA_TIME_THRESHOLD_FOR_WAKEUP*19, 4,    -4,   },
+  { MAX_DELTA_TIME_THRESHOLD_FOR_WAKEUP*20, 3,    -3,   },
+  { MAX_DELTA_TIME_THRESHOLD_FOR_WAKEUP*21, 2,    -2,   },
+  { MAX_DELTA_TIME_THRESHOLD_FOR_WAKEUP*22, 1,    -1,   },
+  { 0,                                      0,    0,    },
+};
+
+/**
+ * @brief CmpCapData
+ *
+ *  Compare capacity data from coulomb counter and table
+ *
+ * @para  pUg31xx address of struct ug31xx_data
+ * @para  initial   set _UPI_TRUE_ for upiGG_Initial procedure
+ * @return  NULL
+ */
+void CmpCapData(struct ug31xx_data *pUg31xx, _upi_bool_ initial)
+{
+  _upi_s16_ deltaQC;
+  _upi_s32_ tmp32;
+  _upi_u8_ idx;
+
+  idx = 0;
+  while(1)
+  {
+    if(CountTotalTime(pUg31xx->sysData.timeTagFromIC) <= RsocChkTable[idx].time)
+    {
+      break;
+    }
+
+    idx = idx + 1;
+    if((RsocChkTable[idx].maxRsoc == 0) && (RsocChkTable[idx].minRsoc == 0))
+    {
+      break;
+    }
+  }
+
+  if(pUg31xx->measData.lastCounter > MAX_DELTA_CC_CNT_THRESHOLD_FOR_WAKEUP)
+  {
+    if(idx < DELTA_SOC_TABLE_IDX_FOR_CC_THRD)
+    {
+      idx = DELTA_SOC_TABLE_IDX_FOR_CC_THRD;
+    }
+  }
+  UG31_LOGE("[%s]: Rsoc threshold = %d ~ %d (%d)\n", __func__,
+            RsocChkTable[idx].maxRsoc,
+            RsocChkTable[idx].minRsoc,
+            RsocChkTable[idx].time);
+
+  if(idx != 0)
+  {
+    /// [AT-PM] : Check the data accuracy ; 01/27/2013
+    deltaQC = (_upi_s16_)pUg31xx->sysData.rsocFromIC;
+    deltaQC = deltaQC - pUg31xx->capData.rsoc;
+    if((deltaQC > RsocChkTable[idx].maxRsoc) || (deltaQC < RsocChkTable[idx].minRsoc))
+    {
+      /// [AT-PM] : Use data from table ; 07/17/2013
+      deltaQC = (_upi_s16_)pUg31xx->capData.rsoc;
+      deltaQC = deltaQC - pUg31xx->sysData.rsocFromICBackup;
+      if((deltaQC <= MAX_DELTA_RSOC_THRESHOLD_FOR_TABLE) && (deltaQC >= MIN_DELTA_RSOC_THRESHOLD_FOR_TABLE))
+      {
+        pUg31xx->capData.rsoc = (_cap_u8_)pUg31xx->sysData.rsocFromICBackup;
+        UG31_LOGE("[%s]: Use data from IC = %d\n", __func__, pUg31xx->sysData.rsocFromICBackup);
+      }
+      pUg31xx->capData.fcc = pUg31xx->sysData.fccFromIC;
+      tmp32 = (_upi_s32_)pUg31xx->capData.fcc;
+      tmp32 = tmp32*pUg31xx->capData.rsoc/CONST_PERCENTAGE;
+      pUg31xx->capData.rm = (_cap_u16_)tmp32;
+      UG31_LOGE("[%s]: Coulomb counter is not available -> Use data from table (%d/%d = %d)\n", __func__,
+                pUg31xx->capData.rm, pUg31xx->capData.fcc, pUg31xx->capData.rsoc);
+    }
+    else
+    {
+      if(initial == _UPI_TRUE_)
+      {
+        CheckInitCapacityFromCC(pUg31xx);
+      }
+      pUg31xx->capData.rm = (_cap_u16_)pUg31xx->sysData.rmFromIC;
+      pUg31xx->capData.fcc = (_cap_u16_)pUg31xx->sysData.fccFromIC;
+      pUg31xx->capData.rsoc = (_cap_u8_)pUg31xx->sysData.rsocFromIC;
+      UG31_LOGE("[%s]: Use data from coulomb counter (%d/%d = %d)\n", __func__,
+                pUg31xx->capData.rm, pUg31xx->capData.fcc, pUg31xx->capData.rsoc);
+    }
+  }
+  else
+  {
+    if(initial == _UPI_TRUE_)
+    {
+      CheckInitCapacityFromCC(pUg31xx);
+    }
+    pUg31xx->capData.rm = (_cap_u16_)pUg31xx->sysData.rmFromIC;
+    pUg31xx->capData.fcc = (_cap_u16_)pUg31xx->sysData.fccFromIC;
+    pUg31xx->capData.rsoc = (_cap_u8_)pUg31xx->sysData.rsocFromIC;
+    UG31_LOGE("[%s]: Within %d mSec -> Use data from coulomb counter (%d/%d = %d)\n", __func__,
+              MAX_DELTA_TIME_THRESHOLD_FOR_WAKEUP, pUg31xx->capData.rm, pUg31xx->capData.fcc, pUg31xx->capData.rsoc);
+  }
+}
+
+#endif  ///< end of uG31xx_BOOT_LOADER
+
+#ifdef  uG31xx_BOOT_LOADER
+
+static _upi_s16_ temperature_table[] = {
+  350,
+  200,
+  100,
+  -1,
+};
+
+static _upi_u8_ ocv_soc_table[] = {
+  100,
+  95,
+  90,
+  85,
+  80,
+  75,
+  70,
+  65,
+  60,
+  55,
+  50,
+  45,
+  40,
+  35,
+  30,
+  25,
+  20,
+  15,
+  10,
+  5,
+  0,
+};
+
+/**
+ * @brief uboot_init_charge
+ *
+ *  Initialize capacity for uBoot
+ *
+ * @para  obj address of struct ug31xx_data
+ * @return  NULL
+ */
+void uboot_init_charge(struct ug31xx_data *obj)
+{
+  _upi_s32_ volt;
+  _upi_s32_ tmp32;
+  _upi_u8_ idx_soc;
+  _upi_u8_ idx_temp;
+
+  /// [AT-PM] : FCC = ILMD ; 09/03/2013
+  obj->batteryInfo.LMD = obj->cellParameter.ILMD;
+
+  /// [AT-PM] : Find the real battery voltage ; 09/03/2013
+  volt = (_upi_s32_)obj->measData.bat1Voltage;
+  tmp32 = (_upi_s32_)obj->measData.curr;
+  tmp32 = tmp32/CHARGE_VOLTAGE_CONST;
+  if(tmp32 > 0)
+  {
+    volt = volt - tmp32;
+  }
+
+  /// [AT-PM] : Find the temperature region ; 09/03/2013
+  idx_temp = 0;
+  while(temperature_table[idx_temp] >= 0)
+  {
+    if(obj->measData.intTemperature > temperature_table[idx_temp])
+    {
+      break;
+    }
+    idx_temp = idx_temp + 1;
+  }
+
+  /// [AT-PM] : Look up OCV table ; 09/03/2013
+  idx_soc = 0;
+  while(ocv_soc_table[idx_soc] > 0)
+  {
+    if(volt >= obj->cellTable.INIT_OCV[idx_temp][OCV_TABLE_IDX_STAND_ALONE][idx_soc])
+    {
+      break;
+    }
+    idx_soc = idx_soc + 1;
+  }
+
+  /// [AT-PM] : Set RSOC ; 09/03/2013
+  obj->batteryInfo.RSOC = (_upi_u16_)ocv_soc_table[idx_soc];
+
+  /// [AT-PM] : Calculate RM ; 09/03/2013
+  tmp32 = (_upi_s32_)obj->batteryInfo.LMD;
+  tmp32 = tmp32*(obj->batteryInfo.RSOC)/CONST_PERCENTAGE;
+  obj->batteryInfo.NAC = (_upi_u16_)tmp32;
+}
+
+#endif  ///< end of uG31xx_BOOT_LOADER
+
+/**
+ * @brief ChkResumeData
+ *
+ *  Check capacity data after resume if no dc in during suspend
+ *
+ * @para  pUg31xx address of struct ug31xx_data
+ * @para  pOldBatInfo address of GG_BATTERY_INFO
+ * @para  totalTime total suspend time in mSec
+ * @para  deltaQC cumulative capacity from coulomb counter
+ * @return  NULL
+ */
+void ChkResumeData(struct ug31xx_data *pUg31xx, GG_BATTERY_INFO *pOldBatInfo, _upi_u32_ totalTime, _upi_s16_ deltaQC)
+{
+  _upi_s32_ tmp32;
+
+  /// [AT-PM] : Check capacity has to be decreased ; 10/25/2013
+  if(deltaQC > 0)
+  {
+    tmp32 = (_upi_s32_)pOldBatInfo->NAC;
+    deltaQC = deltaQC*(-1);
+    tmp32 = tmp32 + deltaQC;
+    UG31_LOGN("[%s]: Estimated capacity = %d (%d)\n", __func__,
+              (int)tmp32,
+              (int)deltaQC);
+
+    tmp32 = tmp32 + pUg31xx->capData.rm;
+    tmp32 = (tmp32 < 0) ? 0 : tmp32;
+    tmp32 = tmp32/2;
+    UG31_LOGN("[%s]: Adjust capacity = %d -> %d\n", __func__, pOldBatInfo->NAC, tmp32);
+
+    pUg31xx->capData.rm = (_cap_u16_)tmp32;
+    pUg31xx->capData.fcc = (_cap_u16_)pOldBatInfo->LMD;
+    pUg31xx->capData.rsoc = (_cap_u8_)CalculateRsoc((_cap_u32_)pUg31xx->capData.rm, pUg31xx->capData.fcc);
+    UG31_LOGN("[%s]: Capacity after resume = %d / %d = %d\n", __func__, pUg31xx->capData.rm, pUg31xx->capData.fcc, pUg31xx->capData.rsoc);
+  }
+
+  /// [AT-PM] : Check coulomb counter offset ; 10/25/2013
+  if(pUg31xx->measData.codeChargeBeforeCal > 0)
+  {
+    UG31_LOGN("[%s]: Coulomb counter offset has to be adjusted (%d).\n", __func__, pUg31xx->measData.codeChargeBeforeCal);
+
+    if(pUg31xx->measData.ccOffsetAdj <= pUg31xx->cellParameter.standbyCurrent)
+    {
+      pUg31xx->measData.ccOffsetAdj = pUg31xx->measData.ccOffsetAdj + 1;
+      UG31_LOGN("[%s]: New offset = %d (%d).\n", __func__, pUg31xx->cellParameter.adc1_pos_offset, pUg31xx->measData.ccOffsetAdj);
+    }
+  }
+}
+
+/**
+ * @brief set_memory_pointer
+ *
+ * Set global memory pointer
+ *
+ * @para pObj address of struct ug31xx_data
+ * @return NULL
+ */
+void set_memory_pointer(struct ug31xx_data *pObj)
+{
+  ptrSysData = &(pObj->sysData);
+  ptrOtpData = &(pObj->otpData);
+  ptrMeasData = &(pObj->measData);
+  ptrCellTable = &(pObj->cellTable);
+  ptrCellParameter = &(pObj->cellParameter);
+  ptrCapData = &(pObj->capData);
+}
+
+// Read GGB file and initial
+#ifdef uG31xx_OS_WINDOWS
+GGSTATUS upiGG_Initial(char **pObj,const wchar_t* GGBFilename,const wchar_t* OtpFileName, unsigned char ForceReset)
+#else
+GGSTATUS upiGG_Initial(char **pObj, GGBX_FILE_HEADER *pGGBXBuf, unsigned char ForceReset)
+#endif
+{
+	_upi_bool_ firstPowerOn;
+	struct ug31xx_data *pUg31xx;
+  SYSTEM_RTN_CODE rtn;
+  _upi_s16_ deltaQC = 0;
+  _upi_s32_ tmp32;
+  MEAS_RTN_CODE rtnMeas;
+  _sys_u8_ lastRsocFromIC;
+  _upi_u32_ totalTime;
+  GG_BATTERY_INFO batInfoBefore;
+  _sys_u8_ *ptr;
+  _meas_u16_ tmpVolt;
+  _meas_s16_ tmpCurr;
+  _meas_s16_ tmpStepCap;
+  _meas_u32_ tmpDeltaTime;
+
+  #ifdef  __TEST_CHARGER_STOP_CHARGING__
+    _upi_u16_ tmp16;
+  #endif  ///< end of __TEST_CHARGER_STOP_CHARGING__
+
+	UG31_LOGE("[%s]: %s (%d-%s)\n", __func__, UG31XX_API_VERSION, UG31XX_DRIVER_VERSION, UG31XX_DRIVER_RELEASE_DATE);
+
+	firstPowerOn = _UPI_FALSE_;
+  #ifdef  uG31xx_BOOT_LOADER
+
+    ug31_uboot_sts = 0;
+
+  #endif  ///< end of uG31xx_BOOT_LOADER
+  *pObj = (char *)upi_malloc(sizeof(struct ug31xx_data));
+	pUg31xx = (struct ug31xx_data *)(*pObj);
+
+  upi_memset(pUg31xx, 0, sizeof(struct ug31xx_data));
+
+  set_memory_pointer(pUg31xx);
+
+  #ifdef uG31xx_OS_WINDOWS
+    pUg31xx->sysData.ggbFilename = GGBFilename;
+    pUg31xx->sysData.otpFileName = OtpFileName;
+  #else
+    ptrGgbBuf = pGGBXBuf;
+    UG31_LOGI("[%s]: ptrGgbBuf = %x (%x)\n", __func__, ptrGgbBuf, pGGBXBuf);
+  #endif
+  rtn = UpiInitSystemData(&pUg31xx->sysData);
+  if(rtn != SYSTEM_RTN_PASS)
+  {
+    if(rtn == SYSTEM_RTN_READ_GGB_FAIL)
+    {
+      return (UG_READ_GGB_FAIL);
+    }
+    return (UG_NOT_DEF);
+  }
+
+  // Initial I2C and Open HID
+  #if defined(uG31xx_OS_WINDOWS) || defined(uG31xx_BOOT_LOADER)
+
+  	if(!API_I2C_Init(pUg31xx->cellParameter.clock, pUg31xx->cellParameter.i2cAddress))
+    {
+  		return UG_I2C_INIT_FAIL;
+  	}
+
+  #endif  ///< end of defined(uG31xx_OS_WINDOWS) || defined(uG31xx_BOOT_LOADER)
+
+  UpiLoadBatInfoFromIC(&pUg31xx->sysData);
+
+	#ifdef UG31XX_ADJUST_CELL_TABLE
+		/// [FC] : Need to adjust cell table ; 06/05/2014
+		if(Ug31AdjustCellTableNeed == _UPI_TRUE_)
+		{
+			UG31_LOGE("[%s] Force reset due to adjust cell table\n",__func__);
+			CapStatusAdjustCellTableSet(&pUg31xx->capData);
+			ForceReset = _UPI_TRUE_;
+		}
+		else
+		{
+			ptrCellParameter->ILMD = new_design_capacity;
+		}
+	#endif	///< end of UG31XX_ADJUST_CELL_TABLE
+
+	#ifndef UG31XX_ADJUST_CELL_TABLE
+  	pUg31xx->measData.cycleCount = (ForceReset == 0) ? (_meas_u16_)pUg31xx->sysData.cycleCount : 0;
+	#endif
+  pUg31xx->measData.cumuCap = 0;
+  pUg31xx->capData.standbyDsgRatio = (ForceReset == 0) ? (_cap_u8_)pUg31xx->sysData.standbyDsgRatio : 0;
+  /// Count total Time
+#ifdef uG31xx_BOOT_LOADER
+  totalTime = 0;
+#else  ///< else of uG31xx_BOOT_LOADER
+  totalTime = CountTotalTime(pUg31xx->sysData.timeTagFromIC);
+#endif ///< end of uG31xx_BOOT_LOADER
+  batInfoBefore.NAC = (_upi_u16_)pUg31xx->sysData.rmFromIC;
+  batInfoBefore.LMD = (_upi_u16_)pUg31xx->sysData.fccFromIC;
+  batInfoBefore.RSOC = (_upi_u16_)pUg31xx->sysData.rsocFromIC;
+
+  #ifdef  uG31xx_BOOT_LOADER
+
+    if(pUg31xx->sysData.fccFromIC == 0)
+    {
+      ug31_uboot_sts = ug31_uboot_sts | UPI_BOOT_STATUS_FCC_IS_0;
+      UG31_LOGI("[%s]: FCC from IC = 0 (%x)\n", __func__, ug31_uboot_sts);
+    }
+
+  #else   ///< else of uG31xx_BOOT_LOADER
+
+    // [FC] : Load table from IC ; 05/30/2013
+    ptr = (_sys_u8_ *)&pUg31xx->capData.encriptTable[0];
+    UpiAllocateTableBuf((_sys_u8_ **)&ptr, &pUg31xx->capData.tableSize);
+    ptr = (_sys_u8_ *)&pUg31xx->capData.encriptBuf[0];
+    UpiAllocateTableBuf((_sys_u8_ **)&ptr, &pUg31xx->capData.tableSize);
+    if((Ug31SaveDataEnable == _UPI_TRUE_) && (ForceReset == 0))
+    {
+      UpiLoadTableFromIC((_sys_u8_ *)pUg31xx->capData.encriptTable);
+    }
+    else
+    {
+      upi_memset(pUg31xx->capData.encriptTable, 0, pUg31xx->capData.tableSize);
+    }
+    UpiInitNacTable(&pUg31xx->capData);
+
+  #endif  ///< end of uG31xx_BOOT_LOADER
+
+  /// [AT-PM] : Check IC is active or not ; 01/28/2013
+  #ifdef  UG31XX_RESET_DATABASE
+
+    firstPowerOn = _UPI_TRUE_;
+
+  #else   ///< else of UG31XX_RESET_DATABASE
+
+    if(ForceReset == 0)
+    {
+      firstPowerOn = UpiCheckICActive(&pUg31xx->sysData);
+    }
+    else
+    {
+      firstPowerOn = _UPI_TRUE_;
+    }
+
+  #endif  ///< end of UG31XX_RESET_DATABASE
+  if(firstPowerOn == _UPI_TRUE_)
+  {
+    #ifdef  uG31xx_BOOT_LOADER
+
+      ug31_uboot_sts = ug31_uboot_sts | UPI_BOOT_STATUS_IC_IS_NOT_ACTIVE;
+      UG31_LOGI("[%s]: first power on (%x)\n", __func__, ug31_uboot_sts);
+
+    #endif  ///< end of uG31xx_BOOT_LOADER
+
+    UG31_LOGE("[%s]#####firstPowerOn= %d \n",__func__,firstPowerOn);
+    rtn = UpiActiveUg31xx();
+    if(rtn != SYSTEM_RTN_PASS)
+    {
+      return (UG_ACTIVE_FAIL);
+    }
+
+    UpiSetupAdc(&pUg31xx->sysData);
+    UpiSetupSystem(&pUg31xx->sysData);
+    /// [FC] : Reset ccOffset if gauge reset ; 05/20/2014
+    pUg31xx->sysData.ccOffset = 0;
+    pUg31xx->measData.ccOffsetAdj = 0;
+
+    #ifdef  UG31XX_RESET_DATABASE
+      pUg31xx->backupData.icDataAvailable = BACKUP_BOOL_TRUE;
+      pUg31xx->backupData.backupFileSts = BACKUP_FILE_STS_NOT_EXIST;
+    #else   ///< else of UG31XX_RESET_DATABASE
+      #ifdef  UG31XX_CELL_REPLACE_TEST
+        ForceReset = 0;
+      #endif  ///< end of UG31XX_CELL_REPLACE_TEST
+      pUg31xx->backupData.icDataAvailable = (ForceReset == 0) ? BACKUP_BOOL_FALSE : BACKUP_BOOL_TRUE;
+      pUg31xx->backupData.backupFileSts = (ForceReset == 0) ? BACKUP_FILE_STS_CHECKING : BACKUP_FILE_STS_NOT_EXIST;
+    #endif  ///< end of UG31XX_RESET_DATABASE
+  }
+  else
+  {
+    #ifndef uG31xx_BOOT_LOADER
+
+      UG31_LOGE("[%s]#####Last time tag = %d, NAC = %d, LMD = %d\n", __func__,
+                (int)pUg31xx->sysData.timeTagFromIC,
+                pUg31xx->sysData.rmFromIC,
+                pUg31xx->sysData.fccFromIC);
+      pUg31xx->measData.lastTimeTick = GetTickCount();
+      pUg31xx->measData.lastDeltaCap = pUg31xx->sysData.deltaCapFromIC;
+      pUg31xx->measData.adc1ConvertTime = pUg31xx->sysData.adc1ConvTime;
+
+    #endif  ///< end of uG31xx_BOOT_LOADER
+
+    /// [AT-PM] : Get board offset from IC ; 08/04/2014
+    pUg31xx->measData.ccOffsetAdj = pUg31xx->sysData.ccOffset;
+
+    pUg31xx->backupData.icDataAvailable = BACKUP_BOOL_TRUE;
+  }
+
+  #ifndef uG31xx_BOOT_LOADER
+
+    /// [FC] : Save table to IC ; 05/30/2013
+    if(Ug31SaveDataEnable == _UPI_TRUE_)
+    {
+      UpiSaveTableToIC((_sys_u8_ *)pUg31xx->capData.encriptTable, (_sys_u8_ *)pUg31xx->capData.encriptBuf, (_sys_u8_)pUg31xx->capData.tableSize);
+    }
+  #endif  ///< end of uG31xx_BOOT_LOADER
+
+  /// [AT-PM] : Fetch ADC code for system stable ; 06/04/2013
+  #ifdef  __TEST_CHARGER_STOP_CHARGING__
+    tmp16 = (_upi_u16_)Ug31DebugEnable;
+    Ug31DebugEnable = 3;
+    tmp32 = 100;
+    while(tmp32)
+    {
+      UpiMeasReadCode(&pUg31xx->measData);
+      SleepMiniSecond(125);
+      tmp32 = tmp32 - 1;
+    }
+    Ug31DebugEnable = (_upi_u8_)tmp16;
+  #else   ///< else of __TEST_CHARGER_STOP_CHARGING__
+    UpiMeasReadCode(&pUg31xx->measData);
+  #endif  ///< end of __TEST_CHARGER_STOP_CHARGING__
+
+  /// [AT-PM] : Load OTP data ; 01/31/2013
+ 	API_I2C_Read(SECURITY, UG31XX_I2C_HIGH_SPEED_MODE, UG31XX_I2C_TEM_BITS_MODE, OTP1_BYTE1, OTP1_SIZE, pUg31xx->otpData.otp1);
+  API_I2C_Read(SECURITY, UG31XX_I2C_HIGH_SPEED_MODE, UG31XX_I2C_TEM_BITS_MODE, OTP2_BYTE1, OTP2_SIZE, pUg31xx->otpData.otp2);
+ 	API_I2C_Read(NORMAL, UG31XX_I2C_HIGH_SPEED_MODE, UG31XX_I2C_TEM_BITS_MODE, OTP6_BYTE1, OTP3_SIZE, pUg31xx->otpData.otp3);
+  UpiConvertOtp(&pUg31xx->otpData);
+
+  /// [AT-PM] : Check product type ; 01/25/2013
+  if((pUg31xx->otpData.productType != UG31XX_PRODUCT_TYPE_0) &&
+     (pUg31xx->otpData.productType != UG31XX_PRODUCT_TYPE_1))
+  {
+    #ifdef  uG31xx_BOOT_LOADER
+
+      ug31_uboot_sts = ug31_uboot_sts | UPI_BOOT_STATUS_WRONG_PRODUCT_TYPE;
+      UG31_LOGI("[%s]: Product type mismatch (%x)\n", __func__, ug31_uboot_sts);
+
+    #endif  ///< end of uG31xx_BOOT_LOADER
+    return (UG_OTP_PRODUCT_DISMATCH);
+  }
+
+  UG31_LOGN("[%s]: Do measurement\n", __func__);
+
+  pUg31xx->measData.status = 0;
+  #ifdef  uG31xx_BOOT_LOADER
+
+    if(ug31_uboot_sts & (UPI_BOOT_STATUS_IC_IS_NOT_ACTIVE | UPI_BOOT_STATUS_FCC_IS_0))
+    {
+      pUg31xx->measData.lastDeltaCap = 0;
+      pUg31xx->measData.adc1ConvertTime = TIME_DEFAULT_ADC1_CONVERT_TIME;
+    }
+    else
+    {
+      pUg31xx->measData.lastDeltaCap = pUg31xx->sysData.deltaCapFromIC;
+      pUg31xx->measData.adc1ConvertTime = pUg31xx->sysData.adc1ConvTime;
+    }
+    pUg31xx->measData.lastTimeTick = DEFAULT_TIME_TICK;
+    UG31_LOGI("[%s]: (lastDeltaCap,adc1ConvertTime,lastTimeTick) = (%d,%d,%d)\n", __func__, pUg31xx->measData.lastDeltaCap, pUg31xx->measData.adc1ConvertTime, pUg31xx->measData.lastTimeTick);
+
+  #endif  ///< end of uG31xx_BOOT_LOADER
+  rtnMeas = UpiMeasurement(&pUg31xx->measData, MEAS_SEL_INITIAL);
+  if(rtnMeas != MEAS_RTN_PASS)
+  {
+    return ((GGSTATUS)(rtnMeas + UG_MEAS_FAIL));
+  }
+  pUg31xx->sysData.cycleCount = (_sys_u16_)pUg31xx->measData.cycleCount;
+
+  /// [AT-PM] : No external temperature average ; 07/04/2013
+  tmp32 = (_upi_s32_)pUg31xx->measData.extTemperature;
+  tmp32 = tmp32*ET_AVERAGE_BASE/ET_AVERAGE_NEW;
+  pUg31xx->measData.extTemperature = (_meas_s16_)tmp32;
+
+  if(firstPowerOn == _UPI_TRUE_)
+  {
+    /// [AT-PM] : Recover ADC1 conversion queue ; 06/04/2013
+    UpiSetupAdc1Queue(&pUg31xx->sysData);
+
+    /// [AT-PM] : Initialize alarm function ; 04/08/2013
+    UpiMeasAlarmThreshold(&pUg31xx->measData);
+    UpiInitAlarm(&pUg31xx->sysData);
+  }
+  UG31_LOGE("[%s]: Current Status 1 = %d mV / %d mA / %d-%d-%d 0.1oC / %d\n", __func__,
+              pUg31xx->measData.bat1Voltage, pUg31xx->measData.curr, pUg31xx->measData.intTemperature, pUg31xx->measData.extTemperature, pUg31xx->measData.instExtTemperature, pUg31xx->measData.stepCap);
+
+  tmpVolt = pUg31xx->measData.bat1Voltage/2;
+  tmpCurr = pUg31xx->measData.curr/2;
+  tmpStepCap = pUg31xx->measData.stepCap;
+  tmpDeltaTime = pUg31xx->measData.deltaTime;
+
+  SleepMiniSecond(500);
+
+  rtnMeas = UpiMeasurement(&pUg31xx->measData, MEAS_SEL_ALL);
+  if(rtnMeas != MEAS_RTN_PASS)
+  {
+    return ((GGSTATUS)(rtnMeas + UG_MEAS_FAIL));
+  }
+
+  tmpVolt = tmpVolt + pUg31xx->measData.bat1Voltage/2;
+  tmpCurr = tmpCurr + pUg31xx->measData.curr/2;
+  tmpStepCap = tmpStepCap + pUg31xx->measData.stepCap;
+  tmpDeltaTime = tmpDeltaTime + pUg31xx->measData.deltaTime;
+
+  pUg31xx->measData.bat1Voltage = tmpVolt;
+  pUg31xx->measData.curr = tmpCurr;
+  pUg31xx->measData.stepCap = tmpStepCap;
+  pUg31xx->measData.deltaTime = tmpDeltaTime;
+
+  UG31_LOGE("[%s]: Current Status 2 = %d mV / %d mA / %d-%d-%d 0.1oC / %d\n", __func__,
+            pUg31xx->measData.bat1Voltage, pUg31xx->measData.curr, pUg31xx->measData.intTemperature, pUg31xx->measData.extTemperature, pUg31xx->measData.instExtTemperature, pUg31xx->measData.stepCap);
+  pUg31xx->measData.extTemperature = pUg31xx->measData.intTemperature;
+  pUg31xx->measData.instExtTemperature = pUg31xx->measData.intTemperature;
+
+  #ifdef  uG31xx_BOOT_LOADER
+
+    if(ug31_uboot_sts & (UPI_BOOT_STATUS_IC_IS_NOT_ACTIVE | UPI_BOOT_STATUS_FCC_IS_0))
+    {
+      uboot_init_charge(pUg31xx);
+
+      pUg31xx->sysData.rmFromIC = (_sys_u16_)pUg31xx->batteryInfo.NAC;
+      pUg31xx->sysData.fccFromIC = (_sys_u16_)pUg31xx->batteryInfo.LMD;
+      pUg31xx->sysData.rsocFromIC = (_sys_u16_)pUg31xx->batteryInfo.RSOC;
+      UG31_LOGI("[%s]: From uboot_init_charge() -> %d,%d,%d\n", __func__, pUg31xx->sysData.rmFromIC, pUg31xx->sysData.fccFromIC, pUg31xx->sysData.rsocFromIC);
+    }
+    else
+    {
+      pUg31xx->batteryInfo.NAC = (_upi_u16_)pUg31xx->sysData.rmFromIC;
+      pUg31xx->batteryInfo.LMD = (_upi_u16_)pUg31xx->sysData.fccFromIC;
+      pUg31xx->batteryInfo.RSOC = (_upi_u8_)pUg31xx->sysData.rsocFromIC;
+    }
+    return (UG_INIT_SUCCESS);
+
+  #endif  ///< end of uG31xx_BOOT_LOADER
+
+  UpiInitCapacity(&pUg31xx->capData);
+	if((firstPowerOn == _UPI_TRUE_) || (pUg31xx->sysData.fccFromIC == 0))
+  {
+    pUg31xx->batteryInfo.NAC = (_upi_u16_)pUg31xx->capData.rm;
+    pUg31xx->batteryInfo.LMD = (_upi_u16_)pUg31xx->capData.fcc;
+    pUg31xx->batteryInfo.RSOC = (_upi_u16_)pUg31xx->capData.rsoc;
+    UG31_LOGE("[%s]: Init data from table -> %d/%d = %d\n", __func__,
+              pUg31xx->batteryInfo.NAC, pUg31xx->batteryInfo.LMD, pUg31xx->batteryInfo.RSOC);
+	}
+  else
+  {
+    pUg31xx->capData.tableUpdateIdx = pUg31xx->sysData.tableUpdateIdxFromIC;
+
+    /// [AT-PM] : Calculate the RSOC/NAC/LMD from coulomb counter ; 01/27/2013
+    deltaQC = (_upi_s16_)pUg31xx->measData.stepCap;
+    pUg31xx->sysData.voltage = pUg31xx->measData.bat1Voltage;
+    pUg31xx->sysData.curr = (_sys_s16_)pUg31xx->measData.curr;
+    lastRsocFromIC = pUg31xx->sysData.rsocFromIC;
+    UpiUpdateBatInfoFromIC(&pUg31xx->sysData, deltaQC, _UPI_FALSE_);
+    CmpCapData(pUg31xx, _UPI_TRUE_);
+    pUg31xx->batteryInfo.NAC = (_upi_u16_)pUg31xx->capData.rm;
+    pUg31xx->batteryInfo.LMD = (_upi_u16_)pUg31xx->capData.fcc;
+    pUg31xx->batteryInfo.RSOC = (_upi_u16_)pUg31xx->capData.rsoc;
+    UpiResetCoulombCounter(&pUg31xx->measData);
+    UpiAdcStatus(&pUg31xx->sysData);
+    pUg31xx->sysData.cycleCount = (_sys_u16_)pUg31xx->measData.cycleCount;
+  }
+  UpiInitDsgCharge(&pUg31xx->capData);
+  UpiAdjustCCRecord(&pUg31xx->capData);
+
+  /// [AT-PM] : Save battery information to IC ; 01/31/2013
+  pUg31xx->sysData.rmFromIC = pUg31xx->batteryInfo.NAC;
+  pUg31xx->sysData.fccFromIC = pUg31xx->batteryInfo.LMD;
+  pUg31xx->sysData.rsocFromIC = (_sys_u8_)pUg31xx->batteryInfo.RSOC;
+  pUg31xx->sysData.tableUpdateIdxFromIC = pUg31xx->capData.tableUpdateIdx;
+  pUg31xx->sysData.deltaCapFromIC = pUg31xx->measData.lastDeltaCap;
+  pUg31xx->sysData.adc1ConvTime = pUg31xx->measData.adc1ConvertTime;
+  pUg31xx->sysData.ccOffset = (_sys_s8_)pUg31xx->measData.ccOffsetAdj;
+  pUg31xx->sysData.standbyDsgRatio = (_sys_u8_)pUg31xx->capData.standbyDsgRatio;
+  pUg31xx->sysData.voltage = (_sys_u16_)pUg31xx->measData.bat1Voltage;
+  UpiSaveBatInfoTOIC(&pUg31xx->sysData);
+
+  /// [AT-PM] : Initialize buffer for suspend / resume data ; 11/07/2013
+  UpiInitBackupData(&pUg31xx->backupData);
+
+	dumpInfo(pUg31xx);
+	return (UG_INIT_SUCCESS);
+}
+
+#if defined(uG31xx_OS_WINDOWS)
+
+GGSTATUS upiGG_MpkActiveGG(char **pObj,const wchar_t* GGBFilename,const wchar_t* OtpFileName, _upi_u16_ i2cAddress)
+{
+	struct ug31xx_data *pUg31xx;
+  SYSTEM_RTN_CODE rtn;
+  MEAS_RTN_CODE rtnMeas;
+  _upi_bool_ first_poweron;
+  *pObj = (char *)upi_malloc(sizeof(struct ug31xx_data));
+	pUg31xx = (struct ug31xx_data *)(*pObj);
+  MPK_active = _UPI_TRUE_;
+
+  upi_memset(pUg31xx, 0, sizeof(struct ug31xx_data));
+  set_memory_pointer(pUg31xx);
+
+  pUg31xx->sysData.ggbFilename = GGBFilename;
+  pUg31xx->sysData.otpFileName = OtpFileName;
+  rtn = UpiInitSystemData(&pUg31xx->sysData);
+  if(rtn != SYSTEM_RTN_PASS)
+  {
+    if(rtn == SYSTEM_RTN_READ_GGB_FAIL)
+    {
+      return (UG_READ_GGB_FAIL);
+    }
+    return (UG_NOT_DEF);
+  }
+
+  // Initial I2C and Open HID
+	if(!API_I2C_Init(pUg31xx->cellParameter.clock, pUg31xx->cellParameter.i2cAddress))
+  {
+		return UG_I2C_INIT_FAIL;
+	}
+
+  first_poweron = UpiCheckICActive(&pUg31xx->sysData);
+  if(first_poweron == _UPI_TRUE_)
+  {
+    // Initial I2C and Open HID
+  	if(!API_I2C_Init(pUg31xx->cellParameter.clock, i2cAddress))
+    {
+  		return UG_I2C_INIT_FAIL;
+  	}
+
+    rtn = UpiActiveUg31xx();
+    if(rtn != SYSTEM_RTN_PASS)
+    {
+      return (UG_ACTIVE_FAIL);
+    }
+    // Initial I2C and Open HID
+  	if(!API_I2C_Init(pUg31xx->cellParameter.clock, pUg31xx->cellParameter.i2cAddress))
+    {
+  		return UG_I2C_INIT_FAIL;
+  	}
+  }
+  UpiSetupAdc(&pUg31xx->sysData);
+  UpiSetupSystem(&pUg31xx->sysData);
+
+  UpiMeasReadCode(&pUg31xx->measData);
+  /// [AT-PM] : Load OTP data ; 01/31/2013
+ 	API_I2C_Read(SECURITY, UG31XX_I2C_HIGH_SPEED_MODE, UG31XX_I2C_TEM_BITS_MODE, OTP1_BYTE1, OTP1_SIZE, pUg31xx->otpData.otp1);
+  API_I2C_Read(SECURITY, UG31XX_I2C_HIGH_SPEED_MODE, UG31XX_I2C_TEM_BITS_MODE, OTP2_BYTE1, OTP2_SIZE, pUg31xx->otpData.otp2);
+ 	API_I2C_Read(NORMAL, UG31XX_I2C_HIGH_SPEED_MODE, UG31XX_I2C_TEM_BITS_MODE, OTP6_BYTE1, OTP3_SIZE, pUg31xx->otpData.otp3);
+  UpiConvertOtp(&pUg31xx->otpData);
+
+  /// [AT-PM] : Check product type ; 01/25/2013
+  if((pUg31xx->otpData.productType != UG31XX_PRODUCT_TYPE_0) &&
+     (pUg31xx->otpData.productType != UG31XX_PRODUCT_TYPE_1))
+  {
+    return (UG_OTP_PRODUCT_DISMATCH);
+  }
+
+  UG31_LOGN("[%s]: Do measurement\n", __func__);
+  pUg31xx->measData.status = 0;
+  rtnMeas = UpiMeasurement(&pUg31xx->measData, MEAS_SEL_ALL);
+  if(rtnMeas != MEAS_RTN_PASS)
+  {
+    return ((GGSTATUS)(rtnMeas + UG_MEAS_FAIL));
+  }
+  /// [AT-PM] : Recover ADC1 conversion queue ; 06/04/2013
+  if(first_poweron == _UPI_TRUE_)
+  {
+    UpiSetupAdc1Queue(&pUg31xx->sysData);
+  }
+  upiGG_BackupFileSwitch(_UPI_FALSE_);
+
+  return UG_INIT_SUCCESS;
+}
+
+#endif  ///< end of defined(uG31xx_OS_WINDOWS)
+
+#ifndef uG31xx_BOOT_LOADER
+
+GGSTATUS upiGG_PreSuspend(char *pObj)
+{
+  GGSTATUS Status = UG_READ_DEVICE_INFO_SUCCESS;
+  struct ug31xx_data *pUg31xx;
+
+  UG31_LOGI("[%s]:*****upiGG_PreSuspend *****\n",  __func__);
+  pUg31xx = (struct ug31xx_data *)pObj;
+
+  UG31_LOGN("[%s]: Reset Coulomb Counter.\n", __func__);
+  UpiResetCoulombCounter(&pUg31xx->measData);
+  UpiAdcStatus(&pUg31xx->sysData);
+  pUg31xx->sysData.cycleCount = (_sys_u16_)pUg31xx->measData.cycleCount;
+
+  /// [AT-PM] : Save battery information to IC ; 01/31/2013
+  pUg31xx->sysData.rmFromIC = pUg31xx->batteryInfo.NAC;
+  pUg31xx->sysData.fccFromIC = pUg31xx->batteryInfo.LMD;
+  pUg31xx->sysData.rsocFromIC = (_sys_u8_)pUg31xx->batteryInfo.RSOC;
+  pUg31xx->sysData.tableUpdateIdxFromIC = pUg31xx->capData.tableUpdateIdx;
+  pUg31xx->sysData.deltaCapFromIC = pUg31xx->measData.lastDeltaCap;
+  pUg31xx->sysData.adc1ConvTime = pUg31xx->measData.adc1ConvertTime;
+  pUg31xx->sysData.voltage = pUg31xx->measData.bat1Voltage;
+  pUg31xx->sysData.curr = (_sys_s16_)pUg31xx->measData.curr;
+  UpiUpdateBatInfoFromIC(&pUg31xx->sysData, (_sys_s16_) pUg31xx->measData.stepCap, _UPI_TRUE_);
+
+  pUg31xx->batteryInfo.NAC = pUg31xx->sysData.rmFromIC;
+  pUg31xx->batteryInfo.LMD = pUg31xx->sysData.fccFromIC;
+  pUg31xx->batteryInfo.RSOC = pUg31xx->sysData.rsocFromIC;
+  pUg31xx->capData.rm = (_cap_u16_)pUg31xx->batteryInfo.NAC;
+  pUg31xx->capData.fcc = (_cap_u16_)pUg31xx->batteryInfo.LMD;
+  pUg31xx->capData.rsoc = (_cap_u8_)pUg31xx->batteryInfo.RSOC;
+  UG31_LOGI("[%s]: %d / %d = %d\n", __func__,
+            pUg31xx->batteryInfo.NAC,
+            pUg31xx->batteryInfo.LMD,
+            pUg31xx->batteryInfo.RSOC);
+
+  pUg31xx->sysData.ccOffset = (_sys_s8_)pUg31xx->measData.ccOffsetAdj;
+  pUg31xx->sysData.standbyDsgRatio = (_sys_u8_)pUg31xx->capData.standbyDsgRatio;
+  pUg31xx->sysData.voltage = (_sys_u16_)pUg31xx->measData.bat1Voltage;
+  UpiSaveBatInfoTOIC(&pUg31xx->sysData);
+  return(Status);
+}
+
+/**
+ * @brief upiGG_ShellUpdateCapacity
+ *
+ *  Run capacity algorithm to update capacity
+ *
+ * @para  pObj  address of memory buffer
+ * @return  NULL
+ */
+void upiGG_ShellUpdateCapacity(char *pObj)
+{
+  struct ug31xx_data *pUg31xx;
+  _upi_u32_ tmpDeltaTime;
+
+  pUg31xx = (struct ug31xx_data *)pObj;
+
+  tmpDeltaTime = pUg31xx->measData.deltaTime;
+
+  pUg31xx->measData.deltaTime = pUg31xx->measData.deltaTimeDaemon;
+
+  #ifndef UG31XX_SHELL_ALGORITHM
+
+    UpiReadCapacity(&pUg31xx->capData);
+
+  #endif  ///< end of UG31XX_SHELL_ALGORITHM
+
+  pUg31xx->measData.deltaTime = tmpDeltaTime;
+  pUg31xx->measData.deltaTimeDaemon = 0;
+
+  UG31_LOGD("[%s]: %d / %d = %d\n", __func__, pUg31xx->capData.rm, pUg31xx->capData.fcc, pUg31xx->capData.rsoc);
+}
+
+/**
+ * @brief upiGG_ShellUpdateCC
+ *
+ *  Update capacity with coulomb counter information
+ *
+ * @para  pObj  address of memory buffer
+ * @return  NULL
+ */
+void upiGG_ShellUpdateCC(char *pObj)
+{
+  struct ug31xx_data *pUg31xx;
+  _upi_s16_ tmp16;
+
+  pUg31xx = (struct ug31xx_data *)pObj;
+
+  if(((MEAS_CABLE_OUT(pUg31xx->measData.status) == _UPI_TRUE_) && (pUg31xx->measData.stepCap > 0)) ||
+     ((MEAS_CABLE_OUT(pUg31xx->measData.status) == _UPI_FALSE_) && (pUg31xx->measData.stepCap < 0)) ||
+     ((pUg31xx->measData.curr > 0) && (pUg31xx->measData.stepCap < 0)) ||
+     ((pUg31xx->measData.curr < 0) && (pUg31xx->measData.stepCap > 0)))
+  {
+    tmp16 = 0;
+    UG31_LOGI("[%s]: Filter stepCap = 0 (%d)\n", __func__,
+              pUg31xx->measData.stepCap);
+  }
+  else
+  {
+    tmp16 = pUg31xx->measData.stepCap;
+  }
+  pUg31xx->sysData.voltage = (_sys_u16_)pUg31xx->measData.bat1Voltage;
+  pUg31xx->sysData.curr = (_sys_s16_)pUg31xx->measData.curr;
+
+  pUg31xx->sysData.rmFromIC = pUg31xx->batteryInfo.NAC;
+  pUg31xx->sysData.fccFromIC = pUg31xx->batteryInfo.LMD;
+  pUg31xx->sysData.rsocFromIC = (_sys_u8_)pUg31xx->batteryInfo.RSOC;
+  UpiUpdateBatInfoFromIC(&pUg31xx->sysData, (_sys_s16_)tmp16, _UPI_FALSE_);
+
+  pUg31xx->batteryInfo.NAC = pUg31xx->sysData.rmFromIC;
+  pUg31xx->batteryInfo.LMD = pUg31xx->sysData.fccFromIC;
+  pUg31xx->batteryInfo.RSOC = pUg31xx->sysData.rsocFromIC;
+  pUg31xx->capData.rm = (_cap_u16_)pUg31xx->batteryInfo.NAC;
+  pUg31xx->capData.fcc = (_cap_u16_)pUg31xx->batteryInfo.LMD;
+  pUg31xx->capData.rsoc = (_cap_u8_)pUg31xx->batteryInfo.RSOC;
+  UG31_LOGI("[%s]: %d / %d = %d\n", __func__,
+            pUg31xx->batteryInfo.NAC,
+            pUg31xx->batteryInfo.LMD,
+            pUg31xx->batteryInfo.RSOC);
+
+  pUg31xx->sysData.rmFromIC = pUg31xx->batteryInfo.NAC;
+  pUg31xx->sysData.fccFromIC = pUg31xx->batteryInfo.LMD;
+  pUg31xx->sysData.rsocFromIC = (_sys_u8_)pUg31xx->batteryInfo.RSOC;
+  pUg31xx->sysData.deltaCapFromIC = pUg31xx->measData.lastDeltaCap;
+  pUg31xx->sysData.adc1ConvTime = pUg31xx->measData.adc1ConvertTime;
+  pUg31xx->sysData.ccOffset = (_sys_s8_)pUg31xx->measData.ccOffsetAdj;
+  pUg31xx->sysData.voltage = (_sys_u16_)pUg31xx->measData.bat1Voltage;
+  UpiSaveBatInfoTOIC(&pUg31xx->sysData);
+}
+
+//====================================================
+//API Call to get the Battery Capacity
+// charge full condition:
+//	if((Iav <TP current) && (Voltage >= TP Voltage))
+//====================================================
+void upiGG_ReadCapacity(char *pObj, GG_CAPACITY *pExtCapacity)
+{
+  struct ug31xx_data *pUg31xx;
+  #ifndef UG31XX_SHELL_ALGORITHM
+    _upi_u8_ prevCapStsFC;
+    _upi_u8_ nowCapStsFC;
+  #endif  ///< end of UG31XX_SHELL_ALGORITHM
+
+  pUg31xx = (struct ug31xx_data *)pObj;
+
+  #ifndef UG31XX_SHELL_ALGORITHM
+
+  prevCapStsFC = ((pUg31xx->capData.fcSts == CAP_TRUE) ? _UPI_TRUE_ : _UPI_FALSE_);
+  UpiReadCapacity(&pUg31xx->capData);
+  nowCapStsFC = ((pUg31xx->capData.fcSts == CAP_TRUE) ? _UPI_TRUE_ : _UPI_FALSE_);
+  UG31_LOGD("[%s]: %d / %d = %d\n", __func__, pUg31xx->capData.rm, pUg31xx->capData.fcc, pUg31xx->capData.rsoc);
+
+  #endif  ///< end of UG31XX_SHELL_ALGORITHM
+
+  pUg31xx->batteryInfo.NAC = (_upi_u16_)pUg31xx->capData.rm;
+  pUg31xx->batteryInfo.LMD = (_upi_u16_)pUg31xx->capData.fcc;
+  pUg31xx->batteryInfo.RSOC = (_upi_u16_)pUg31xx->capData.rsoc;
+  UG31_LOGI("[%s]: %d / %d = %d\n", __func__, pUg31xx->batteryInfo.NAC, pUg31xx->batteryInfo.LMD, pUg31xx->batteryInfo.RSOC);
+
+  #ifdef  uG31xx_OS_WINDOWS
+    if((nowCapStsFC == CAP_TRUE) && (prevCapStsFC == CAP_FALSE))
+    {
+      pUg31xx->batteryInfo.NAC = (_upi_u16_)pUg31xx->capData.rm;
+      pUg31xx->batteryInfo.LMD = (_upi_u16_)pUg31xx->capData.fcc;
+      pUg31xx->batteryInfo.RSOC = (_upi_u16_)pUg31xx->capData.rsoc;
+      UpiSetChargerFull(&pUg31xx->capData, CAP_TRUE);
+      pUg31xx->capData.rm = (_cap_u16_)pUg31xx->batteryInfo.NAC;
+      pUg31xx->capData.fcc = (_cap_u16_)pUg31xx->batteryInfo.LMD;
+      pUg31xx->capData.rsoc = (_cap_u8_)pUg31xx->batteryInfo.RSOC;
+    }
+  #endif  ///< end of uG31xx_OS_WINDOWS
+
+	// Output result by assign value from global variable
+	pExtCapacity->LMD = pUg31xx->batteryInfo.LMD;
+	pExtCapacity->NAC = pUg31xx->batteryInfo.NAC;
+	pExtCapacity->RSOC = pUg31xx->batteryInfo.RSOC;
+  pExtCapacity->Ready = pUg31xx->batteryInfo.Ready;
+  #ifdef  uG31xx_OS_WINDOWS
+    pExtCapacity->DsgCharge = (_upi_s32_)pUg31xx->capData.dsgCharge;
+  #endif  ///< end of uG31xx_OS_WINDOWS
+
+  /// [AT-PM] : If fully charged and keeps charging, reset coulomb counter ; 02/11/2013
+  if((pUg31xx->batteryInfo.RSOC == 100) && (pUg31xx->measData.curr >= pUg31xx->cellParameter.standbyCurrent))
+  {
+    UpiResetCoulombCounter(&pUg31xx->measData);
+    UpiAdcStatus(&pUg31xx->sysData);
+    pUg31xx->sysData.cycleCount = (_sys_u16_)pUg31xx->measData.cycleCount;
+  }
+
+  /// [AT-PM] : Save battery information to IC ; 01/31/2013
+  pUg31xx->sysData.rmFromIC = pUg31xx->batteryInfo.NAC;
+  pUg31xx->sysData.fccFromIC = pUg31xx->batteryInfo.LMD;
+  pUg31xx->sysData.rsocFromIC = (_sys_u8_)pUg31xx->batteryInfo.RSOC;
+  pUg31xx->sysData.tableUpdateIdxFromIC = pUg31xx->capData.tableUpdateIdx;
+  pUg31xx->sysData.deltaCapFromIC = pUg31xx->measData.lastDeltaCap;
+  pUg31xx->sysData.adc1ConvTime = pUg31xx->measData.adc1ConvertTime;
+  pUg31xx->sysData.ccOffset = (_sys_s8_)pUg31xx->measData.ccOffsetAdj;
+  pUg31xx->sysData.standbyDsgRatio = (_sys_u8_)pUg31xx->capData.standbyDsgRatio;
+  pUg31xx->sysData.voltage = (_sys_u16_)pUg31xx->measData.bat1Voltage;
+  UpiSaveBatInfoTOIC(&pUg31xx->sysData);
+  /// [FC] : Save table to IC ; 05/30/2013
+  if(Ug31SaveDataEnable == _UPI_TRUE_)
+  {
+    UpiSaveTableToIC((_sys_u8_ *)pUg31xx->capData.encriptTable, (_sys_u8_ *)pUg31xx->capData.encriptBuf, (_sys_u8_)pUg31xx->capData.tableSize);
+  }
+}
+
+//system wakeup
+// to read back the preSuspend information from uG31xx RAM area
+// re-calculate the deltaQmax( the charge/discharge) during the suspend time
+GGSTATUS upiGG_Wakeup(char *pObj, _upi_bool_ dc_in_before)
+{
+	GGSTATUS Status = UG_READ_DEVICE_INFO_SUCCESS;
+  _upi_s16_ deltaQC = 0;							//coulomb counter's deltaQ
+  _upi_u32_ totalTime;
+  MEAS_RTN_CODE rtn;
+  GG_BATTERY_INFO batInfoBeforeSuspend;
+
+  struct ug31xx_data *pUg31xx;
+  pUg31xx = (struct ug31xx_data *)pObj;
+  batInfoBeforeSuspend = pUg31xx->batteryInfo;
+
+  ///Load the Saved time tag NAC LMD
+  UpiLoadBatInfoFromIC(&pUg31xx->sysData);
+  pUg31xx->measData.cycleCount = (_meas_u16_)pUg31xx->sysData.cycleCount;
+  pUg31xx->measData.ccOffsetAdj = (_meas_s8_)pUg31xx->sysData.ccOffset;
+  pUg31xx->capData.standbyDsgRatio = (_cap_u8_)pUg31xx->sysData.standbyDsgRatio;
+  /// Count total Time
+  totalTime = CountTotalTime(pUg31xx->sysData.timeTagFromIC);
+  /// count the deltaQ during suspend
+  pUg31xx->measData.lastDeltaCap = pUg31xx->sysData.deltaCapFromIC;
+  pUg31xx->measData.adc1ConvertTime = pUg31xx->sysData.adc1ConvTime;
+  rtn = UpiMeasurement(&pUg31xx->measData, MEAS_SEL_ALL);
+  if(rtn != MEAS_RTN_PASS)
+  {
+    return ((GGSTATUS)(rtn + UG_MEAS_FAIL));
+  }
+  pUg31xx->sysData.cycleCount = (_sys_u16_)pUg31xx->measData.cycleCount;
+  deltaQC = (_upi_s16_)pUg31xx->measData.stepCap;
+  /// [AT-PM] : Calculate the RSOC/NAC/LMD from coulomb counter ; 01/27/2013
+  pUg31xx->sysData.voltage = pUg31xx->measData.bat1Voltage;
+  pUg31xx->sysData.curr = (_sys_s16_)pUg31xx->measData.curr;
+  UpiUpdateBatInfoFromIC(&pUg31xx->sysData, deltaQC, _UPI_TRUE_);
+	UG31_LOGI("[%s]: suspend time = %d ms,deltaQ = %d mAh, RSOC =%d, LMD = %d mAh, NAC=%d mAh\n",
+							__func__,
+							totalTime,
+							deltaQC,
+							pUg31xx->sysData.rsocFromIC,
+							pUg31xx->sysData.fccFromIC,
+							pUg31xx->sysData.rmFromIC);
+
+  /// [AT-PM] : Calculate the RSOC/NAC/LMD from table ; 01/28/2013
+  pUg31xx->capData.tableUpdateIdx = pUg31xx->sysData.tableUpdateIdxFromIC;
+  UpiTableCapacity(&pUg31xx->capData);
+  /// [AT-PM] : Check the data accuracy ; 01/27/2013
+  CmpCapData(pUg31xx, _UPI_FALSE_);
+  pUg31xx->capData.dsgCharge = pUg31xx->capData.dsgCharge - (pUg31xx->capData.rm - pUg31xx->batteryInfo.NAC);
+
+  /// [AT-PM] : Check capacity can not be increased if no dc in during suspend ; 10/25/2013
+  if(dc_in_before == _UPI_FALSE_)
+  {
+    UG31_LOGI("[%s]: No dc in during suspend.\n", __func__);
+    ChkResumeData(pUg31xx, &batInfoBeforeSuspend, totalTime, deltaQC);
+  }
+
+  /// [AT-PM] : Update capacity information ; 10/25/2013
+  pUg31xx->batteryInfo.NAC = (_upi_u16_)pUg31xx->capData.rm;
+  pUg31xx->batteryInfo.LMD = (_upi_u16_)pUg31xx->capData.fcc;
+  pUg31xx->batteryInfo.RSOC = (_upi_u16_)pUg31xx->capData.rsoc;
+
+  /// [AT-PM] : Reset coulomb counter ; 10/25/2013
+  UpiResetCoulombCounter(&pUg31xx->measData);
+  UpiAdcStatus(&pUg31xx->sysData);
+  pUg31xx->sysData.cycleCount = (_sys_u16_)pUg31xx->measData.cycleCount;
+
+  /// [AT-PM] : Save battery information to IC ; 01/31/2013
+  pUg31xx->sysData.rmFromIC = pUg31xx->batteryInfo.NAC;
+  pUg31xx->sysData.fccFromIC = pUg31xx->batteryInfo.LMD;
+  pUg31xx->sysData.rsocFromIC = (_sys_u8_)pUg31xx->batteryInfo.RSOC;
+  pUg31xx->sysData.tableUpdateIdxFromIC = pUg31xx->capData.tableUpdateIdx;
+  pUg31xx->sysData.deltaCapFromIC = pUg31xx->measData.lastDeltaCap;
+  pUg31xx->sysData.adc1ConvTime = pUg31xx->measData.adc1ConvertTime;
+  pUg31xx->sysData.ccOffset = (_sys_s8_)pUg31xx->measData.ccOffsetAdj;
+  pUg31xx->sysData.standbyDsgRatio = (_sys_u8_)pUg31xx->capData.standbyDsgRatio;
+  pUg31xx->sysData.voltage = (_sys_u16_)pUg31xx->measData.bat1Voltage;
+  UpiSaveBatInfoTOIC(&pUg31xx->sysData);
+
+  return (Status);
+}
+
+/**
+ * @brief upiGG_AccessMeasurementParameter
+ *
+ *  Access measurement parameter
+ *
+ * @para  read  set _UPI_TRUE_ to read data from API
+ * @para  pMeasPara pointer of GG_MEAS_PARA_TYPE
+ * @return  GGSTATUS
+ */
+GGSTATUS upiGG_AccessMeasurementParameter(char *pObj, _upi_bool_ read, GG_MEAS_PARA_TYPE *pMeasPara)
+{
+  struct ug31xx_data *pUg31xx;
+
+  pUg31xx = (struct ug31xx_data *)pObj;
+
+  /// [AT-PM] : Read data ; 08/29/2012
+  if(read == _UPI_TRUE_)
+  {
+    pMeasPara->Adc1Gain = pUg31xx->cellParameter.adc1_ngain;
+    pMeasPara->Adc1Offset = pUg31xx->cellParameter.adc1_pos_offset;
+    pMeasPara->Adc2Gain = pUg31xx->cellParameter.adc2_gain;
+    pMeasPara->Adc2Offset = pUg31xx->cellParameter.adc2_offset;
+    pMeasPara->ITOffset = pUg31xx->cellParameter.adc_d5;
+    pMeasPara->ETOffset = pUg31xx->cellParameter.adc_d4;
+    pMeasPara->ProductType = pUg31xx->otpData.productType;
+    return (UG_SUCCESS);
+  }
+
+  /// [AT-PM] : Write data ; 08/29/2012
+  pUg31xx->cellParameter.adc1_ngain = pMeasPara->Adc1Gain;
+  pUg31xx->cellParameter.adc1_pos_offset = pMeasPara->Adc1Offset;
+  pUg31xx->cellParameter.adc2_gain = pMeasPara->Adc2Gain;
+  pUg31xx->cellParameter.adc2_offset = pMeasPara->Adc2Offset;
+  pUg31xx->cellParameter.adc_d5 = pMeasPara->ITOffset;
+  pUg31xx->cellParameter.adc_d4 = pMeasPara->ETOffset;
+  return (UG_SUCCESS);
+}
+
+#endif  ///< end of uG31xx_BOOT_LOADER
+
+#ifdef  ENABLE_BQ27520_SW_CMD
+
+/**
+ * @brief TI_Cntl
+ *
+ *  Control() command
+ *
+ * @para  pData address of data
+ * @return  GGSTATUS
+ */
+GGSTATUS TI_Cntl(struct ug31xx_data *pUg31xx, _upi_u16_ *pData)
+{
+  _upi_u16_ CntlData;
+
+  CntlData = *pData;
+  switch(CntlData)
+  {
+    case UG_STD_CMD_CNTL_CONTROL_STATUS:
+      *pData = pUg31xx->bq27520Cmd.CntlControlStatus;
+      break;
+    case UG_STD_CMD_CNTL_DEVICE_TYPE:
+      *pData = 0x3103;
+      break;
+    case UG_STD_CMD_CNTL_FW_VERSION:
+      *pData = 0x0001;
+      break;
+    case UG_STD_CMD_CNTL_PREV_MACWRITE:
+      *pData = pUg31xx->bq27520Cmd.CntlPrevMacWrite;
+      break;
+    case UG_STD_CMD_CNTL_CHEM_ID:
+      *pData = 0x0001;
+      break;
+    case UG_STD_CMD_CNTL_OCV_CMD:
+      break;
+    case UG_STD_CMD_CNTL_BAT_INSERT:
+      if(!(pUg31xx->bq27520Cmd.Opcfg & UG_STD_CMD_OPCFG_BIE))
+      {
+        pUg31xx->bq27520Cmd.Flags = pUg31xx->bq27520Cmd.Flags | UG_STD_CMD_FLAGS_BAT_DET;
+      }
+      break;
+    case UG_STD_CMD_CNTL_BAT_REMOVE:
+      if(!(pUg31xx->bq27520Cmd.Opcfg & UG_STD_CMD_OPCFG_BIE))
+      {
+        pUg31xx->bq27520Cmd.Flags = pUg31xx->bq27520Cmd.Flags & (~UG_STD_CMD_FLAGS_BAT_DET);
+      }
+      break;
+    case UG_STD_CMD_CNTL_SET_HIBERNATE:
+      pUg31xx->bq27520Cmd.CntlControlStatus = pUg31xx->bq27520Cmd.CntlControlStatus | UG_STD_CMD_CNTL_CONTROL_STATUS_HIBERNATE;
+      break;
+    case UG_STD_CMD_CNTL_CLEAR_HIBERNATE:
+      pUg31xx->bq27520Cmd.CntlControlStatus = pUg31xx->bq27520Cmd.CntlControlStatus & (~UG_STD_CMD_CNTL_CONTROL_STATUS_HIBERNATE);
+      break;
+    case UG_STD_CMD_CNTL_SET_SLEEP_PLUS:
+      pUg31xx->bq27520Cmd.CntlControlStatus = pUg31xx->bq27520Cmd.CntlControlStatus | UG_STD_CMD_CNTL_CONTROL_STATUS_SNOOZE;
+      break;
+    case UG_STD_CMD_CNTL_CLEAR_SLEEP_PLUS:
+      pUg31xx->bq27520Cmd.CntlControlStatus = pUg31xx->bq27520Cmd.CntlControlStatus & (~UG_STD_CMD_CNTL_CONTROL_STATUS_SNOOZE);
+      break;
+    case UG_STD_CMD_CNTL_FACTORY_RESTORE:
+      break;
+    case UG_STD_CMD_CNTL_ENABLE_DLOG:
+      pUg31xx->bq27520Cmd.CntlControlStatus = pUg31xx->bq27520Cmd.CntlControlStatus | UG_STD_CMD_CNTL_CONTROL_STATUS_DLOGEN;
+      break;
+    case UG_STD_CMD_CNTL_DISABLE_DLOG:
+      pUg31xx->bq27520Cmd.CntlControlStatus = pUg31xx->bq27520Cmd.CntlControlStatus & (~UG_STD_CMD_CNTL_CONTROL_STATUS_DLOGEN);
+      break;
+    case UG_STD_CMD_CNTL_DF_VERSION:
+      *pData = 0x0000;
+      break;
+    case UG_STD_CMD_CNTL_SEALED:
+      pUg31xx->bq27520Cmd.CntlControlStatus = pUg31xx->bq27520Cmd.CntlControlStatus | UG_STD_CMD_CNTL_CONTROL_STATUS_SS;
+      break;
+    case UG_STD_CMD_CNTL_RESET:
+      if(!(pUg31xx->bq27520Cmd.CntlControlStatus & UG_STD_CMD_CNTL_CONTROL_STATUS_SS))
+      {
+      }
+      break;
+    default:
+      *pData = 0x0000;
+      break;
+  }
+
+  pUg31xx->bq27520Cmd.CntlPrevMacWrite = ((CntlData) > UG_STD_CMD_CNTL_PREV_MACWRITE) ? UG_STD_CMD_CNTL_PREV_MACWRITE : CntlData;
+  return (UG_SUCCESS);
+}
+
+/**
+ * @brief TI_AR
+ *
+ *  AtRate() command
+ *
+ * @para  pData address of data
+ * @return  GGSTATUS
+ */
+GGSTATUS TI_AR(struct ug31xx_data *pUg31xx, _upi_u16_ *pData)
+{
+  _upi_s16_ AR;
+
+  AR = (_upi_s16_)(*pData);
+  if(AR != pUg31xx->bq27520Cmd.AR)
+  {
+    pUg31xx->bq27520Cmd.AR = AR;
+  }
+  return (UG_SUCCESS);
+}
+
+/**
+ * @brief TI_Artte
+ *
+ *  AtRateTimeToEmpty() command
+ *
+ * @para  pData address of data
+ * @return  GGSTATUS
+ */
+GGSTATUS TI_Artte(struct ug31xx_data *pUg31xx, _upi_u16_ *pData)
+{
+  _upi_s32_ Artte;
+
+  if(pUg31xx->bq27520Cmd.AR >= 0)
+  {
+    *pData = 65535;
+  }
+
+  Artte = (_upi_s32_)pUg31xx->batteryInfo.NAC;
+  Artte = Artte*60*(-1)/pUg31xx->bq27520Cmd.AR;
+  *pData = (_upi_u16_)Artte;
+  return (UG_SUCCESS);
+}
+
+/**
+ * @brief TI_Temp
+ *
+ *  Temperature() command
+ *
+ * @para  pData address of data
+ * @return  GGSTATUS
+ */
+GGSTATUS TI_Temp(struct ug31xx_data *pUg31xx, _upi_u16_ *pData)
+{
+  if(pUg31xx->bq27520Cmd.Opcfg & UG_STD_CMD_OPCFG_WRTEMP)
+  {
+    /// [AT-PM] : Temperature is from host ; 10/11/2012
+    pUg31xx->bq27520Cmd.Temp = *pData;
+  }
+  else
+  {
+    /// [AT-PM] : Temperature is measured by uG31xx ; 10/11/2012
+    if(pUg31xx->bq27520Cmd.Opcfg & UG_STD_CMD_OPCFG_TEMPS)
+    {
+      /// [AT-PM] : Report external temperature ; 10/11/2012
+      *pData = pUg31xx->deviceInfo.ET;
+    }
+    else
+    {
+      /// [AT-PM] : Report internal temperature ; 10/11/2012
+      *pData = pUg31xx->deviceInfo.IT;
+    }
+  }
+  return (UG_SUCCESS);
+}
+
+/**
+ * @brief TI_Volt
+ *
+ *  Voltage() command
+ *
+ * @para  pData address of data
+ * @return  GGSTATUS
+ */
+GGSTATUS TI_Volt(struct ug31xx_data *pUg31xx, _upi_u16_ *pData)
+{
+  *pData = pUg31xx->deviceInfo.voltage_mV;
+  return (UG_SUCCESS);
+}
+
+/**
+ * @brief TI_Flags
+ *
+ *  Flags() command
+ *
+ * @para  pData address of data
+ * @return  GGSTATUS
+ */
+GGSTATUS TI_Flags(struct ug31xx_data *pUg31xx, _upi_u16_ *pData)
+{
+  /// [AT-PM] : OTC - Overtemperature in charge ; 10/11/2012
+
+  /// [AT-PM] : OTD - Overtemperature in discharge ; 10/11/2012
+
+  /// [AT-PM] : CHG_INH - Charge inhibit ; 10/11/2012
+
+  /// [AT-PM] : XCHG - Charge suspend alert ; 10/11/2012
+
+  /// [AT-PM] : FC - Full-charged ; 10/11/2012
+  if(pUg31xx->batteryInfo.RSOC < pUg31xx->bq27520Cmd.FCClear)
+  {
+    pUg31xx->bq27520Cmd.Flags = pUg31xx->bq27520Cmd.Flags & (~UG_STD_CMD_FLAGS_FC);
+  }
+  if(pUg31xx->bq27520Cmd.FCSet < 0)
+  {
+    if(pUg31xx->batteryInfo.RSOC == 100)
+    {
+      pUg31xx->bq27520Cmd.Flags = pUg31xx->bq27520Cmd.Flags | UG_STD_CMD_FLAGS_FC;
+    }
+  }
+  else
+  {
+    if(pUg31xx->batteryInfo.RSOC > pUg31xx->bq27520Cmd.FCSet)
+    {
+      pUg31xx->bq27520Cmd.Flags = pUg31xx->bq27520Cmd.Flags | UG_STD_CMD_FLAGS_FC;
+    }
+  }
+
+  /// [AT-PM] : CHG - (Fast) charging allowed ; 10/11/2012
+  if(pUg31xx->bq27520Cmd.Flags & UG_STD_CMD_FLAGS_FC)
+  {
+    pUg31xx->bq27520Cmd.Flags = pUg31xx->bq27520Cmd.Flags & (~UG_STD_CMD_FLAGS_CHG);
+  }
+  else
+  {
+    pUg31xx->bq27520Cmd.Flags = pUg31xx->bq27520Cmd.Flags | UG_STD_CMD_FLAGS_CHG;
+  }
+
+  /// [AT-PM] : OCV_GD - Good OCV measurement taken ; 10/11/2012
+
+  /// [AT-PM] : WAIT_ID - Waiting to identify inserted battery ; 10/11/2012
+
+  /// [AT-PM] : BAT_DET - Battery detected ; 10/11/2012
+  if(pUg31xx->userReg.regAlarm2Status & ALARM2_STATUS_OV1_ALARM)
+  {
+    pUg31xx->bq27520Cmd.Flags = pUg31xx->bq27520Cmd.Flags | UG_STD_CMD_FLAGS_BAT_DET;
+  }
+  else
+  {
+    pUg31xx->bq27520Cmd.Flags = pUg31xx->bq27520Cmd.Flags & (~UG_STD_CMD_FLAGS_BAT_DET);
+  }
+
+  /// [AT-PM] : SOC1 - State-of-charge threshold 1 (SOC1 Set) reached ; 10/11/2012
+  if(pUg31xx->batteryInfo.NAC > pUg31xx->bq27520Cmd.Soc1Clear)
+  {
+    pUg31xx->bq27520Cmd.Flags = pUg31xx->bq27520Cmd.Flags & (~UG_STD_CMD_FLAGS_SOC1);
+  }
+  if(pUg31xx->batteryInfo.NAC < pUg31xx->bq27520Cmd.Soc1Set)
+  {
+    pUg31xx->bq27520Cmd.Flags = pUg31xx->bq27520Cmd.Flags | UG_STD_CMD_FLAGS_SOC1;
+  }
+
+  /// [AT-PM] : SYSDOWN - System should shut down ; 10/11/2012
+
+  /// [AT-PM] : DSG - Discharging detected ; 10/11/2012
+  if(pUg31xx->deviceInfo.AveCurrent_mA <= 0)
+  {
+    pUg31xx->bq27520Cmd.Flags = pUg31xx->bq27520Cmd.Flags | UG_STD_CMD_FLAGS_DSG;
+  }
+  else
+  {
+    pUg31xx->bq27520Cmd.Flags = pUg31xx->bq27520Cmd.Flags & (~UG_STD_CMD_FLAGS_DSG);
+  }
+
+  *pData = pUg31xx->bq27520Cmd.Flags;
+  return (UG_SUCCESS);
+}
+
+/**
+ * @brief TI_Nac
+ *
+ *  NominalAvailableCapacity() command
+ *
+ * @para  pData address of data
+ * @return  GGSTATUS
+ */
+GGSTATUS TI_Nac(struct ug31xx_data *pUg31xx, _upi_u16_ *pData)
+{
+  *pData = pUg31xx->batteryInfo.NAC;
+  return (UG_SUCCESS);
+}
+
+/**
+ * @brief TI_Fac
+ *
+ *  FullAvailableCapacity() command
+ *
+ * @para  pData address of data
+ * @return  GGSTATUS
+ */
+GGSTATUS TI_Fac(struct ug31xx_data *pUg31xx, _upi_u16_ *pData)
+{
+  *pData = pUg31xx->batteryInfo.LMD;
+  return (UG_SUCCESS);
+}
+
+/**
+ * @brief TI_RM
+ *
+ *  RemainingCapacity() command
+ *
+ * @para  pData address of data
+ * @return  GGSTATUS
+ */
+GGSTATUS TI_RM(struct ug31xx_data *pUg31xx, _upi_u16_ *pData)
+{
+  *pData = pUg31xx->batteryInfo.NAC;
+  return (UG_SUCCESS);
+}
+
+/**
+ * @brief TI_Fcc
+ *
+ *  FullChargeCapacity() command
+ *
+ * @para  pData address of data
+ * @return  GGSTATUS
+ */
+GGSTATUS TI_Fcc(struct ug31xx_data *pUg31xx, _upi_u16_ *pData)
+{
+  *pData = pUg31xx->batteryInfo.LMD;
+  return (UG_SUCCESS);
+}
+
+/**
+ * @brief TI_AI
+ *
+ *  AverageCurrent() command
+ *
+ * @para  pData address of data
+ * @return  GGSTATUS
+ */
+GGSTATUS TI_AI(struct ug31xx_data *pUg31xx, _upi_u16_ *pData)
+{
+  *pData = pUg31xx->deviceInfo.AveCurrent_mA;
+  return (UG_SUCCESS);
+}
+
+/**
+ * @brief TI_Tte
+ *
+ *  TimeToEmpty() command
+ *
+ * @para  pData address of data
+ * @return  GGSTATUS
+ */
+GGSTATUS TI_Tte(struct ug31xx_data *pUg31xx, _upi_u16_ *pData)
+{
+  _upi_s32_ Tte;
+
+  if(pUg31xx->deviceInfo.AveCurrent_mA >= 0)
+  {
+    *pData = 65535;
+    return (UG_SUCCESS);
+  }
+
+  Tte = (_upi_s32_)pUg31xx->batteryInfo.NAC;
+  Tte = Tte*60*(-1)/pUg31xx->deviceInfo.AveCurrent_mA;
+  *pData = (_upi_u16_)Tte;
+  return (UG_SUCCESS);
+}
+
+/**
+ * @brief TI_Ttf
+ *
+ *  TimeToFull() command
+ *
+ * @para  pData address of data
+ * @return  GGSTATUS
+ */
+GGSTATUS TI_Ttf(struct ug31xx_data *pUg31xx, _upi_u16_ *pData)
+{
+  _upi_s32_ Ttf;
+
+  if(pUg31xx->deviceInfo.AveCurrent_mA <= 0)
+  {
+    *pData = 65535;
+    return (UG_SUCCESS);
+  }
+
+  Ttf = (_upi_s32_)pUg31xx->batteryInfo.LMD;
+  Ttf = Ttf - pUg31xx->batteryInfo.NAC;
+  Ttf = Ttf*90/pUg31xx->deviceInfo.AveCurrent_mA;
+  *pData = (_upi_u16_)Ttf;
+  return (UG_SUCCESS);
+}
+
+/**
+ * @brief TI_SI
+ *
+ *  StandbyCurrent() command
+ *
+ * @para  pData address of data
+ * @return  GGSTATUS
+ */
+GGSTATUS TI_SI(struct ug31xx_data *pUg31xx, _upi_u16_ *pData)
+{
+  _upi_s16_ LowerBound;
+  _upi_s32_ NewSI;
+
+  /// [AT-PM] : Set initial SI ; 10/11/2012
+  if(pUg31xx->bq27520Cmd.SINow == 0)
+  {
+    pUg31xx->bq27520Cmd.SINow = pUg31xx->bq27520Cmd.InitSI;
+  }
+
+  LowerBound = pUg31xx->bq27520Cmd.InitSI*2;
+  if(LowerBound > 0)
+  {
+    LowerBound = LowerBound*(-1);
+  }
+
+  /// [AT-PM] : SI criteria - 2 x InitSI < Current < 0 ; 10/11/2012
+  if((pUg31xx->deviceInfo.AveCurrent_mA < 0) && (pUg31xx->deviceInfo.AveCurrent_mA > LowerBound))
+  {
+    /// [AT-PM] : Update SI every 1 minute ; 10/11/2012
+    if((pUg31xx->bq27520Cmd.SIWindow >= 60) && (pUg31xx->bq27520Cmd.SISample > 0))
+    {
+      NewSI = pUg31xx->bq27520Cmd.SIBuf/pUg31xx->bq27520Cmd.SISample;
+      NewSI = NewSI*7 + pUg31xx->bq27520Cmd.SINow*93;
+      NewSI = NewSI/100;
+      pUg31xx->bq27520Cmd.SINow = (_upi_s16_)NewSI;
+      pUg31xx->bq27520Cmd.SISample = -1;
+      pUg31xx->bq27520Cmd.SIBuf = 0;
+      pUg31xx->bq27520Cmd.SIWindow = 0;
+    }
+    else
+    {
+      pUg31xx->bq27520Cmd.SISample = pUg31xx->bq27520Cmd.SISample + 1;
+      pUg31xx->bq27520Cmd.SIWindow = pUg31xx->bq27520Cmd.SIWindow + pUg31xx->bq27520Cmd.DeltaSec;
+
+      /// [AT-PM] : Ignore the first sample ; 10/11/2012
+      if(pUg31xx->bq27520Cmd.SISample > 0)
+      {
+        pUg31xx->bq27520Cmd.SIBuf = pUg31xx->bq27520Cmd.SIBuf + pUg31xx->deviceInfo.AveCurrent_mA;
+      }
+    }
+  }
+  else
+  {
+    /// [AT-PM] : Ignore the last sample ; 10/11/2012
+    if(pUg31xx->bq27520Cmd.SISample > 0)
+    {
+      NewSI = pUg31xx->bq27520Cmd.SIBuf/pUg31xx->bq27520Cmd.SISample;
+      NewSI = NewSI*7 + pUg31xx->bq27520Cmd.SINow*93;
+      NewSI = NewSI/100;
+      pUg31xx->bq27520Cmd.SINow = (_upi_s16_)NewSI;
+    }
+    pUg31xx->bq27520Cmd.SISample = -1;
+    pUg31xx->bq27520Cmd.SIBuf = 0;
+    pUg31xx->bq27520Cmd.SIWindow = 0;
+  }
+
+  *pData = pUg31xx->bq27520Cmd.SINow;
+  return (UG_SUCCESS);
+}
+
+/**
+ * @brief TI_Stte
+ *
+ *  StandbyTimeToEmpty() command
+ *
+ * @para  pData address of data
+ * @return  GGSTATUS
+ */
+GGSTATUS TI_Stte(struct ug31xx_data *pUg31xx, _upi_u16_ *pData)
+{
+  _upi_s32_ Stte;
+
+  if(pUg31xx->bq27520Cmd.SINow >= 0)
+  {
+    *pData = 65535;
+    return (UG_SUCCESS);
+  }
+
+  Stte = (_upi_s32_)pUg31xx->batteryInfo.NAC;
+  Stte = Stte*60*(-1)/pUg31xx->bq27520Cmd.SINow;
+  *pData = (_upi_u16_)Stte;
+  return (UG_SUCCESS);
+}
+
+/**
+ * @brief TI_Mli
+ *
+ *  MaxLoadCurrent() command
+ *
+ * @para  pData address of data
+ * @return  GGSTATUS
+ */
+GGSTATUS TI_Mli(struct ug31xx_data *pUg31xx, _upi_u16_ *pData)
+{
+  _upi_s32_ NewMli;
+
+  /// [AT-PM] : Set initial MLI ; 10/11/2012
+  if(pUg31xx->bq27520Cmd.Mli == 0)
+  {
+    pUg31xx->bq27520Cmd.Mli = pUg31xx->bq27520Cmd.InitMaxLoadCurrent;
+  }
+
+  /// [AT-PM] : Get the start charging SOC ; 10/11/2012
+  if(pUg31xx->bq27520Cmd.Flags & UG_STD_CMD_FLAGS_DSG)
+  {
+    pUg31xx->bq27520Cmd.MliDsgSoc = (_upi_u8_)pUg31xx->batteryInfo.RSOC;
+  }
+
+  /// [AT-PM] : MLI criteria - Current < MLI ; 10/11/2012
+  if(pUg31xx->deviceInfo.AveCurrent_mA < pUg31xx->bq27520Cmd.Mli)
+  {
+    pUg31xx->bq27520Cmd.Mli = pUg31xx->deviceInfo.AveCurrent_mA;
+  }
+
+  /// [AT-PM] : Reduce MLI at FC ; 10/11/2012
+  if((pUg31xx->bq27520Cmd.Flags & UG_STD_CMD_FLAGS_FC) && (pUg31xx->bq27520Cmd.MliDsgSoc < 50))
+  {
+    NewMli = (_upi_s32_)pUg31xx->bq27520Cmd.InitMaxLoadCurrent;
+    NewMli = NewMli + pUg31xx->bq27520Cmd.Mli;
+    NewMli = NewMli/2;
+    pUg31xx->bq27520Cmd.Mli = (_upi_s16_)NewMli;
+  }
+
+  *pData = (_upi_u16_)pUg31xx->bq27520Cmd.Mli;
+  return (UG_SUCCESS);
+}
+
+/**
+ * @brief TI_Stte
+ *
+ *  MaxLoadTimeToEmpty() command
+ *
+ * @para  pData address of data
+ * @return  GGSTATUS
+ */
+GGSTATUS TI_Mltte(struct ug31xx_data *pUg31xx, _upi_u16_ *pData)
+{
+  _upi_s32_ Mltte;
+
+  if(pUg31xx->deviceInfo.AveCurrent_mA >= 0)
+  {
+    *pData = 65535;
+    return (UG_SUCCESS);
+  }
+
+  Mltte = (_upi_s32_)pUg31xx->batteryInfo.NAC;
+  Mltte = Mltte*60*(-1)/pUg31xx->bq27520Cmd.Mli;
+  *pData = (_upi_u16_)Mltte;
+  return (UG_SUCCESS);
+}
+
+/**
+ * @brief TI_AE
+ *
+ *  AvailableEnergy() command
+ *
+ * @para  pData address of data
+ * @return  GGSTATUS
+ */
+GGSTATUS TI_AE(struct ug31xx_data *pUg31xx, _upi_u16_ *pData)
+{
+  _upi_u32_ AE;
+
+  AE = (_upi_u32_)pUg31xx->batteryInfo.NAC;
+  AE = AE*pUg31xx->deviceInfo.voltage_mV/1000;
+  pUg31xx->bq27520Cmd.AE = (_upi_u16_)AE;
+  *pData = pUg31xx->bq27520Cmd.AE;
+  return (UG_SUCCESS);
+}
+
+/**
+ * @brief TI_AP
+ *
+ *  AveragePower() command
+ *
+ * @para  pData address of data
+ * @return  GGSTATUS
+ */
+GGSTATUS TI_AP(struct ug31xx_data *pUg31xx, _upi_u16_ *pData)
+{
+  _upi_s32_ AP;
+
+  if((pUg31xx->deviceInfo.AveCurrent_mA == 0) || (pUg31xx->bq27520Cmd.APDsgTime == 0))
+  {
+    pUg31xx->bq27520Cmd.AP = 0;
+    *pData = 0;
+    return (UG_SUCCESS);
+  }
+
+  AP = (_upi_s32_)pUg31xx->batteryInfo.NAC;
+  AP = AP*pUg31xx->deviceInfo.voltage_mV/1000;
+
+  /// [AT-PM] : Average discharging power ; 10/11/2012
+  if(pUg31xx->deviceInfo.AveCurrent_mA > 0)
+  {
+    pUg31xx->bq27520Cmd.APStartDsgE = AP;
+    pUg31xx->bq27520Cmd.APDsgTime = 0;
+
+    pUg31xx->bq27520Cmd.APChgTime = pUg31xx->bq27520Cmd.APChgTime + pUg31xx->bq27520Cmd.DeltaSec;
+    AP = AP - pUg31xx->bq27520Cmd.APStartChgE;
+    AP = AP*3600/pUg31xx->bq27520Cmd.APChgTime;
+    pUg31xx->bq27520Cmd.AP = (_upi_s16_)AP;
+  }
+
+  /// [AT-PM] : Average charging power ; 10/11/2012
+  if(pUg31xx->deviceInfo.AveCurrent_mA < 0)
+  {
+    pUg31xx->bq27520Cmd.APStartChgE = AP;
+    pUg31xx->bq27520Cmd.APChgTime = 0;
+
+    pUg31xx->bq27520Cmd.APDsgTime = pUg31xx->bq27520Cmd.APDsgTime + pUg31xx->bq27520Cmd.DeltaSec;
+    AP = AP - pUg31xx->bq27520Cmd.APStartDsgE;
+    AP = AP*3600/pUg31xx->bq27520Cmd.APDsgTime;
+    pUg31xx->bq27520Cmd.AP = (_upi_s16_)AP;
+  }
+
+  *pData = (_upi_u16_)pUg31xx->bq27520Cmd.AP;
+  return (UG_SUCCESS);
+}
+
+/**
+ * @brief TI_Ttecp
+ *
+ *  TimeToEmptyAtConstantPower() command
+ *
+ * @para  pData address of data
+ * @return  GGSTATUS
+ */
+GGSTATUS TI_Ttecp(struct ug31xx_data *pUg31xx, _upi_u16_ *pData)
+{
+  _upi_s32_ Ttecp;
+
+  if(pUg31xx->bq27520Cmd.AP >= 0)
+  {
+    *pData = 65535;
+    return (UG_SUCCESS);
+  }
+
+  Ttecp = (_upi_s32_)pUg31xx->bq27520Cmd.AE;
+  Ttecp = Ttecp*60*(-1)/pUg31xx->bq27520Cmd.AP;
+  *pData = (_upi_u16_)Ttecp;
+  return (UG_SUCCESS);
+}
+
+/**
+ * @brief TI_Soh
+ *
+ *  StateOfHealth() command
+ *
+ * @para  pData address of data
+ * @return  GGSTATUS
+ */
+GGSTATUS TI_Soh(struct ug31xx_data *pUg31xx, _upi_u16_ *pData)
+{
+  _upi_u32_ Soh;
+
+  Soh = (_upi_u32_)pUg31xx->batteryInfo.LMD;
+  Soh = Soh*100/pUg31xx->bq27520Cmd.Dcap;
+
+  Soh = Soh & UG_STD_CMD_SOH_VALUE_MASK;
+  Soh = Soh | UG_STD_CMD_SOH_STATUS_READY;
+  *pData = (_upi_u16_)Soh;
+  return (UG_SUCCESS);
+}
+
+/**
+ * @brief TI_CC
+ *
+ *  CycleCount() command
+ *
+ * @para  pData address of data
+ * @return  GGSTATUS
+ */
+GGSTATUS TI_CC(struct ug31xx_data *pUg31xx, _upi_u16_ *pData)
+{
+  if(pUg31xx->deviceInfo.AveCurrent_mA < 0)
+  {
+    pUg31xx->bq27520Cmd.CCBuf = pUg31xx->bq27520Cmd.CCBuf + pUg31xx->bq27520Cmd.CCLastNac - pUg31xx->batteryInfo.NAC;
+  }
+  pUg31xx->bq27520Cmd.CCLastNac = pUg31xx->batteryInfo.NAC;
+
+  if(pUg31xx->bq27520Cmd.CCBuf >= pUg31xx->bq27520Cmd.CCThreshold)
+  {
+    pUg31xx->bq27520Cmd.CC = pUg31xx->bq27520Cmd.CC + 1;
+    pUg31xx->bq27520Cmd.CCBuf = pUg31xx->bq27520Cmd.CCBuf - pUg31xx->bq27520Cmd.CCThreshold;
+  }
+
+  *pData = pUg31xx->bq27520Cmd.CC;
+  return (UG_SUCCESS);
+}
+
+/**
+ * @brief TI_Soc
+ *
+ *  StateOfCharge() command
+ *
+ * @para  pData address of data
+ * @return  GGSTATUS
+ */
+GGSTATUS TI_Soc(struct ug31xx_data *pUg31xx, _upi_u16_ *pData)
+{
+  *pData = pUg31xx->batteryInfo.RSOC;
+  return (UG_SUCCESS);
+}
+
+/**
+ * @brief TI_Nic
+ *
+ *  NormalizedImpedanceCal() command
+ *
+ * @para  pData address of data
+ * @return  GGSTATUS
+ */
+GGSTATUS TI_Nic(struct ug31xx_data *pUg31xx, _upi_u16_ *pData)
+{
+  *pData = 0;
+  return (UG_SUCCESS);
+}
+
+/**
+ * @brief TI_Icr
+ *
+ *  InstantaneousCurrentReading() command
+ *
+ * @para  pData address of data
+ * @return  GGSTATUS
+ */
+GGSTATUS TI_Icr(struct ug31xx_data *pUg31xx, _upi_u16_ *pData)
+{
+  *pData = pUg31xx->deviceInfo.current_mA;
+  return (UG_SUCCESS);
+}
+
+/**
+ * @brief TI_Dli
+ *
+ *  DataLogIndex() command
+ *
+ * @para  pData address of data
+ * @return  GGSTATUS
+ */
+GGSTATUS TI_Dli(struct ug31xx_data *pUg31xx, _upi_u16_ *pData)
+{
+  *pData = pUg31xx->bq27520Cmd.Dli;
+  return (UG_SUCCESS);
+}
+
+/**
+ * @brief TI_Dlb
+ *
+ *  DataLogBuffer() command
+ *
+ * @para  pData address of data
+ * @return  GGSTATUS
+ */
+GGSTATUS TI_Dlb(struct ug31xx_data *pUg31xx, _upi_u16_ *pData)
+{
+  *pData = pUg31xx->bq27520Cmd.Dlb;
+  return (UG_SUCCESS);
+}
+
+/**
+ * @brief TI_Itemp
+ *
+ *  InternalTemperature() command
+ *
+ * @para  pData address of data
+ * @return  GGSTATUS
+ */
+GGSTATUS TI_Itemp(struct ug31xx_data *pUg31xx, _upi_u16_ *pData)
+{
+  *pData = pUg31xx->deviceInfo.IT;
+  return (UG_SUCCESS);
+}
+
+/**
+ * @brief TI_Opcfg
+ *
+ *  OperationConfiguration() command
+ *
+ * @para  pData address of data
+ * @return  GGSTATUS
+ */
+GGSTATUS TI_Opcfg(struct ug31xx_data *pUg31xx, _upi_u16_ *pData)
+{
+  *pData = (_upi_u16_)pUg31xx->bq27520Cmd.Opcfg;
+  return (UG_SUCCESS);
+}
+
+/**
+ * @brief TI_Dcap
+ *
+ *  DesignCapacity() command
+ *
+ * @para  pData address of data
+ * @return  GGSTATUS
+ */
+GGSTATUS TI_Dcap(struct ug31xx_data *pUg31xx, _upi_u16_ *pData)
+{
+  *pData = pUg31xx->bq27520Cmd.Dcap;
+  return (UG_SUCCESS);
+}
+
+typedef GGSTATUS (*TIBq27520FuncPtr)(struct ug31xx_data *pUg31xx, _upi_u16_ *pData);
+typedef struct TIBq27520FuncTableST {
+  TIBq27520FuncPtr pFunc;
+  _upi_u8_ CmdCode;
+} TIBq27520FuncTableType;
+
+
+TIBq27520FuncTableType TI_Command[] = {
+  { TI_Cntl,  UG_STD_CMD_CNTL,  },
+  { TI_AR,    UG_STD_CMD_AR,    },
+  { TI_Artte, UG_STD_CMD_ARTTE, },
+  { TI_Temp,  UG_STD_CMD_TEMP,  },
+  { TI_Volt,  UG_STD_CMD_VOLT,  },
+  { TI_Flags, UG_STD_CMD_FLAGS, },
+  { TI_Nac,   UG_STD_CMD_NAC,   },
+  { TI_Fac,   UG_STD_CMD_FAC,   },
+  { TI_RM,    UG_STD_CMD_RM,    },
+  { TI_Fcc,   UG_STD_CMD_FCC,   },
+  { TI_AI,    UG_STD_CMD_AI,    },
+  { TI_Tte,   UG_STD_CMD_TTE,   },
+  { TI_Ttf,   UG_STD_CMD_TTF,   },
+  { TI_SI,    UG_STD_CMD_SI,    },
+  { TI_Stte,  UG_STD_CMD_STTE,  },
+  { TI_Mli,   UG_STD_CMD_MLI,   },
+  { TI_Mltte, UG_STD_CMD_MLTTE, },
+  { TI_AE,    UG_STD_CMD_AE,    },
+  { TI_AP,    UG_STD_CMD_AP,    },
+  { TI_Ttecp, UG_STD_CMD_TTECP, },
+  { TI_Soh,   UG_STD_CMD_SOH,   },
+  { TI_CC,    UG_STD_CMD_CC,    },
+  { TI_Soc,   UG_STD_CMD_SOC,   },
+  { TI_Nic,   UG_STD_CMD_NIC,   },
+  { TI_Icr,   UG_STD_CMD_ICR,   },
+  { TI_Dli,   UG_STD_CMD_DLI,   },
+  { TI_Dlb,   UG_STD_CMD_DLB,   },
+  { TI_Itemp, UG_STD_CMD_ITEMP, },
+  { TI_Opcfg, UG_STD_CMD_OPCFG, },
+  { TI_Dcap,  UG_EXT_CMD_DCAP,  },
+};
+
+/**
+ * @brief upiGG_FetchDataCommand
+ *
+ *  Read the gas gauge status following TI bq27520's interface
+ *
+ * @para  CommandCode command code
+ * @para  pData address of returned data
+ * @return  GGSTATUS
+ */
+GGSTATUS upiGG_FetchDataCommand(char *pObj, _upi_u8_ CommandCode, _upi_u16_ *pData)
+{
+  GGSTATUS Rtn;
+  int TotalCmd;
+  GG_DEVICE_INFO DevInfo;
+  GG_CAPACITY CapData;
+  _upi_u32_ DeltaT;
+  int CmdIdx;
+  struct ug31xx_data *pUg31xx;
+
+  pUg31xx = (struct ug31xx_data *)pObj;
+
+  Rtn = upiGG_ReadDeviceInfo(pObj, &DevInfo);
+  if(Rtn != UG_READ_DEVICE_INFO_SUCCESS)
+  {
+    return (Rtn);
+  }
+
+  DeltaT = pUg31xx->measData.deltaTime;
+  if(DeltaT >= 5000000)
+  {
+    upiGG_ReadCapacity(pObj, &CapData);
+  }
+
+  DeltaT = GetTickCount();
+  DeltaT = DeltaT - pUg31xx->bq27520Cmd.LastTime;
+  pUg31xx->bq27520Cmd.LastTime = GetTickCount();
+  pUg31xx->bq27520Cmd.DeltaSec = (_upi_u16_)(DeltaT/1000);
+
+  Rtn = UG_SUCCESS;
+  TotalCmd = sizeof(TI_Command)/sizeof(TIBq27520FuncTableType);
+  CmdIdx = 0;
+  while(1)
+  {
+    if(TI_Command[CmdIdx].CmdCode == CommandCode)
+    {
+      Rtn = (*TI_Command[CmdIdx].pFunc)(pUg31xx, pData);
+      break;
+    }
+
+    CmdIdx = CmdIdx + 1;
+    if(CmdIdx >= TotalCmd)
+    {
+      Rtn = UG_TI_CMD_OVERFLOW;
+    }
+  }
+
+  return (Rtn);
+}
+
+/**
+ * @brief upiGG_FetchDataParameter
+ *
+ *  Set the parameter for bq27520 like command
+ *
+ * @para  data  parameters of GG_FETCH_DATA_PARA_TYPE
+ * @return  GGSTATUS
+ */
+GGSTATUS upiGG_FetchDataParameter(char *pObj, GG_FETCH_DATA_PARA_TYPE data)
+{
+  GGSTATUS Rtn;
+  struct ug31xx_data *pUg31xx;
+
+  pUg31xx = (struct ug31xx_data *)pObj;
+
+  Rtn = UG_SUCCESS;
+
+  pUg31xx->bq27520Cmd.FCSet = data.FCSet;
+  pUg31xx->bq27520Cmd.FCClear = data.FCClear;
+  pUg31xx->bq27520Cmd.Soc1Set = data.Soc1Set;
+  pUg31xx->bq27520Cmd.Soc1Clear = data.Soc1Clear;
+  pUg31xx->bq27520Cmd.InitSI = data.InitSI;
+  pUg31xx->bq27520Cmd.InitMaxLoadCurrent = data.InitMaxLoadCurrent;
+  pUg31xx->bq27520Cmd.CCThreshold = data.CCThreshold;
+  pUg31xx->bq27520Cmd.Opcfg = data.Opcfg;
+  pUg31xx->bq27520Cmd.Dcap = data.Dcap;
+  return (Rtn);
+}
+
+#endif  ///< end of ENABLE_BQ27520_SW_CMD
+
+#ifndef uG31xx_BOOT_LOADER
+
+/**
+ * @brief upiGG_DumpRegister
+ *
+ *  Dump whole register value
+ *
+ * @para  pBuf  address of register value buffer
+ * @return  data size
+ */
+_upi_u16_ upiGG_DumpRegister(char *pObj, _upi_u8_ * pBuf)
+{
+  _upi_u16_ idx;
+  struct ug31xx_data *pUg31xx;
+
+  pUg31xx = (struct ug31xx_data *)pObj;
+
+  idx = 0;
+  upi_memcpy(pBuf + idx, pUg31xx->otpData.otp1, OTP1_SIZE);
+  idx = idx + OTP1_SIZE;
+  upi_memcpy(pBuf + idx, pUg31xx->otpData.otp2, OTP2_SIZE);
+  idx = idx + OTP2_SIZE;
+  upi_memcpy(pBuf + idx, pUg31xx->otpData.otp3, OTP3_SIZE);
+  idx = idx + OTP3_SIZE;
+  upi_memcpy(pBuf + idx, &pUg31xx->userReg, sizeof(GG_USER_REG));
+  idx = idx + sizeof(GG_USER_REG);
+  upi_memcpy(pBuf + idx, &pUg31xx->user2Reg, sizeof(GG_USER2_REG));
+  idx = idx + sizeof(GG_USER2_REG);
+  return (idx);
+}
+
+/**
+ * @brief upiGG_DumpCellTable
+ *
+ *  Dump cell NAC table
+ *
+ * @para  pTable address of cell table
+ * @return  _UPI_NULL_
+ */
+void upiGG_DumpCellTable(char *pObj, CELL_TABLE *pTable)
+{
+  struct ug31xx_data *pUg31xx;
+
+  pUg31xx = (struct ug31xx_data *)pObj;
+  upi_memcpy(pTable, &pUg31xx->cellTable, sizeof(CELL_TABLE));
+}
+
+#endif  ///< end of uG31xx_BOOT_LOADER
+
+/**
+ * @brief upiGG_UnInitial
+ *
+ *  Un-initialize uG31xx
+ *
+ * @para pObj address of memory buffer allocated for uG31xx
+ * @return GGSTATUS
+ */
+GGSTATUS upiGG_UnInitial(char **pObj)
+{
+	struct ug31xx_data *pUg31xx;
+
+	UG31_LOGE("[%s]***** upiGG_UnInitial() to free memory ***** \n",   __func__);
+
+  if((*pObj) == _UPI_NULL_)
+  {
+      return (UG_SUCCESS);
+  }
+
+	pUg31xx = (struct ug31xx_data *)(*pObj);
+
+  #ifndef uG31xx_BOOT_LOADER
+
+    // [FC] : Free table buffer ; 07/08/2013
+    UpiFreeTableBuf((_sys_u8_ **)&pUg31xx->capData.encriptTable);
+    UpiFreeTableBuf((_sys_u8_ **)&pUg31xx->capData.encriptBuf);
+
+    /// [AT-PM] : Free suspend /resume data buffer ; 11/07/2013
+    UpiFreeBackupData(&pUg31xx->backupData);
+
+  #endif  ///< end of uG31xx_BOOT_LOADER
+
+  upi_free(*pObj);
+  return (UG_SUCCESS);
+}
+
+#ifndef uG31xx_BOOT_LOADER
+
+/**
+ * @brief upiGG_DumpParameter
+ *
+ *  Dump all parameter setting
+ *
+ * @para  pTable address of cell parameter
+ * @return  _UPI_NULL_
+ */
+void upiGG_DumpParameter(char *pObj, CELL_PARAMETER *pTable)
+{
+  struct ug31xx_data *pUg31xx;
+
+  pUg31xx = (struct ug31xx_data *)pObj;
+  upi_memcpy(pTable, &pUg31xx->cellParameter, sizeof(CELL_PARAMETER));
+}
+
+/**
+ * @brief upiGG_FetchDebugData
+ *
+ *  Fetch debug information data
+ *
+ * @para  pObj  address of memory buffer
+ * @para  data  address of GG_FETCH_CAP_DATA_TYPE
+ * @return  _UPI_NULL_
+ */
+void upiGG_FetchDebugData(char *pObj, GG_FETCH_DEBUG_DATA_TYPE *data)
+{
+  struct ug31xx_data *pUg31xx;
+
+  pUg31xx = (struct ug31xx_data *)pObj;
+
+  data->capDelta = pUg31xx->measData.stepCap;
+  data->capDsgCharge = pUg31xx->capData.dsgCharge;
+  data->capDsgChargeStart = pUg31xx->capData.dsgChargeStart;
+  data->capDsgChargeTime = pUg31xx->capData.dsgChargeTime;
+  data->capPreDsgCharge = pUg31xx->capData.preDsgCharge;
+  data->capSelfHour = pUg31xx->capData.selfDsgHour;
+  data->capSelfMilliSec = pUg31xx->capData.selfDsgMilliSec;
+  data->capSelfMin = pUg31xx->capData.selfDsgMin;
+  data->capSelfSec = pUg31xx->capData.selfDsgSec;
+  data->capStatus = pUg31xx->capData.status;
+  data->capTableUpdateIdx = pUg31xx->capData.tableUpdateIdx;
+  data->capTPTime = pUg31xx->capData.tpTime;
+
+  data->measAdc1ConvertTime = pUg31xx->measData.adc1ConvertTime;
+  data->measAdc1Gain = pUg31xx->measData.adc1Gain;
+  data->measAdc1Offset = pUg31xx->measData.adc1Offset;
+  data->measAdc2Gain = pUg31xx->measData.adc2Gain;
+  data->measAdc2Offset = pUg31xx->measData.adc2Offset;
+  data->measCCOffset = pUg31xx->measData.ccOffset;
+  data->measCharge = pUg31xx->measData.codeCharge;
+  data->measCodeBat1 = pUg31xx->measData.codeBat1;
+  data->measCodeCurrent = pUg31xx->measData.codeCurrent;
+  data->measCodeET = pUg31xx->measData.codeExtTemperature;
+  data->measCodeIT = pUg31xx->measData.codeIntTemperature;
+  data->measLastCounter = pUg31xx->measData.lastCounter;
+  data->measLastDeltaQ = pUg31xx->measData.lastDeltaCap;
+  data->measLastTimeTick = pUg31xx->measData.lastTimeTick;
+  data->measAdc1CodeT25V100 = pUg31xx->measData.adc1CodeT25V100;
+  data->measAdc1CodeT25V200 = pUg31xx->measData.adc1CodeT25V200;
+  data->measAdc2CodeT25V100 = pUg31xx->measData.adc2CodeT25V100;
+  data->measAdc2CodeT25V200 = pUg31xx->measData.adc2CodeT25V200;
+  data->measCodeBat1BeforeCal = pUg31xx->measData.codeBat1BeforeCal;
+  data->measCodeCurrentBeforeCal = pUg31xx->measData.codeCurrentBeforeCal;
+  data->measCodeITBeforeCal = pUg31xx->measData.codeIntTemperatureBeforeCal;
+  data->measCodeETBeforeCal = pUg31xx->measData.codeExtTemperatureBeforeCal;
+
+  data->sysOscFrequency = pUg31xx->sysData.oscFreq;
+}
+
+/**
+ * @brief upiGG_DebugSwitch
+ *
+ *  Enable/disable debug information to UART
+ *
+ * @para  Enable  set _UPI_TRUE_ to enable it
+ * @return  NULL
+ */
+void upiGG_DebugSwitch(_upi_u8_ enable)
+{
+  Ug31DebugEnable = enable;
+}
+
+/**
+ * @brief upiGG_BackupFileSwitch
+ *
+ *  Enable/disable backup file operation
+ *
+ * @para  Enable  set _UPI_TRUE_ to enable it
+ * @return  NULL
+ */
+void upiGG_BackupFileSwitch(_upi_bool_ enable)
+{
+  if(Ug31BackupFileEnable != enable)
+  {
+    UG31_LOGN("[%s]: Ug31BackupFileEnable = %d -> %d\n", __func__, Ug31BackupFileEnable, enable);
+  }
+  Ug31BackupFileEnable = enable;
+}
+
+typedef struct BackupFileReloadRsocThrdST {
+  _upi_s16_ rsoc;
+  _upi_s8_ max;
+  _upi_s8_ min;
+} ALIGNED_ATTRIBUTE BackupFileReloadRsocThrdType;
+
+static BackupFileReloadRsocThrdType BackupFileReloadRsocThrdTable[] = {
+  { 80, 10, -10,  },
+  { 60, 10, -20,  },
+  { 20, 10, -30,  },
+  { 10, 10, -20,  },
+  { 0,  10, -10,  },
+};
+
+/**
+ * @brief upiGG_BackupFileCheck
+ *
+ *  Backup file check procedure
+ *
+ * @para  pObj  address of memory buffer
+ * @return  UG_CAP_DATA_STATUS
+ */
+#if defined (uG31xx_OS_WINDOWS)
+
+  _upi_u8_ upiGG_BackupFileCheck(char *pObj, const wchar_t* BackupFileName, const wchar_t* SuspendFileName)
+
+#else   ///< else of defined (uG31xx_OS_WINDOWS)
+
+  _upi_u8_ upiGG_BackupFileCheck(char *pObj, char *BackupFileName, char *SuspendFileName)
+
+#endif  ///< end of defined (uG31xx_OS_WINDOWS)
+{
+  struct ug31xx_data *pUg31xx;
+  _upi_bool_ rtn;
+  _upi_s16_ tmp16;
+  _upi_u8_ idx;
+
+  pUg31xx = (struct ug31xx_data *)pObj;
+
+  if(Ug31BackupFileEnable != _UPI_TRUE_)
+  {
+    return (UG_CAP_DATA_READY);
+  }
+
+  /// [AT-PM] : Backup data to file routine ; 02/21/2013
+  pUg31xx->sysData.predictRsoc = (_sys_u8_)pUg31xx->capData.predictRsoc;
+  pUg31xx->sysData.standbyDsgRatio = (_sys_u8_)pUg31xx->capData.standbyDsgRatio;
+  #if defined (uG31xx_OS_WINDOWS)
+    pUg31xx->backupData.backupFileName = BackupFileName;
+    pUg31xx->backupData.suspendFileName = SuspendFileName;
+  #else  ///< else of defined (uG31xx_OS_WINDOWS)
+    ptrBackupFileName = BackupFileName;
+    ptrSuspendFileName = SuspendFileName;
+  #endif ///< end of defined (uG31xx_OS_WINDOWS)
+  UG31_LOGN("[%s]: Backup file routine START (%d)\n", __func__, pUg31xx->backupData.backupFileSts);
+  UpiBackupVoltage(&pUg31xx->backupData);
+  UpiBackupData(&pUg31xx->backupData);
+  UG31_LOGN("[%s]: Backup file routine END (%d)\n", __func__, pUg31xx->backupData.backupFileSts);
+  if(pUg31xx->Options & LKM_OPTIONS_ENABLE_SUSPEND_DATA_LOG)
+  {
+    UG31_LOGN("[%s]: Backup suspend / resume file routine START\n", __func__);
+    UpiWriteSuspendResumeData(&pUg31xx->backupData);
+    UG31_LOGN("[%s]: Backup suspend / resume file routine END\n", __func__);
+  }
+
+  if((pUg31xx->backupData.backupFileSts >= BACKUP_FILE_STS_EXIST) &&
+     (pUg31xx->backupData.icDataAvailable == BACKUP_BOOL_FALSE))
+  {
+    /// [AT-PM] : Restore data from file ; 09/16/2013
+    pUg31xx->backupData.icDataAvailable = BACKUP_BOOL_TRUE;
+    UG31_LOGI("[%s]: Restore file routine START\n", __func__);
+    rtn = UpiRestoreData(&pUg31xx->backupData);
+    if((rtn == _UPI_TRUE_) &&
+       (pUg31xx->cellParameter.NacLmdAdjustCfg & NAC_LMD_ADJUST_CFG_BATTERY_REINSERT_DETECT_EN))
+    {
+      pUg31xx->sysData.timeTagFromIC = pUg31xx->measData.lastTimeTick;
+      pUg31xx->sysData.deltaCapFromIC = pUg31xx->measData.lastDeltaCap;
+      /// [FC] : Compare rsoc difference between backup file and initial capacity ; 09/26/2013
+      tmp16 = (_upi_s16_)pUg31xx->capData.predictRsoc;
+      tmp16 = tmp16 - pUg31xx->sysData.predictRsoc;
+      UG31_LOGI("[%s]: Check RSOC difference -> %d - %d = %d\n", __func__, pUg31xx->capData.predictRsoc, pUg31xx->sysData.predictRsoc, tmp16);
+
+      idx = 0;
+      while(1)
+      {
+        if(BackupFileReloadRsocThrdTable[idx].rsoc < pUg31xx->capData.predictRsoc)
+        {
+          break;
+        }
+        if(BackupFileReloadRsocThrdTable[idx].rsoc == 0)
+        {
+          break;
+        }
+        idx = idx + 1;
+      }
+      UG31_LOGN("[%s]: RSOC threshold (%d) %d -> %d\n", __func__, BackupFileReloadRsocThrdTable[idx].rsoc, BackupFileReloadRsocThrdTable[idx].max, BackupFileReloadRsocThrdTable[idx].min);
+
+      if((tmp16 < BackupFileReloadRsocThrdTable[idx].max) &&
+         (tmp16 > BackupFileReloadRsocThrdTable[idx].min))
+      {
+        pUg31xx->sysData.voltage = (_sys_u16_)pUg31xx->measData.bat1Voltage;
+        UpiSaveBatInfoTOIC(&pUg31xx->sysData);
+        pUg31xx->capData.rm = (_cap_u16_)pUg31xx->sysData.rmFromIC;
+        pUg31xx->capData.fcc = (_cap_u16_)pUg31xx->sysData.fccFromIC;
+        pUg31xx->capData.rsoc = (_cap_u8_)pUg31xx->sysData.rsocFromIC;
+        pUg31xx->capData.tableUpdateIdx = pUg31xx->sysData.tableUpdateIdxFromIC;
+        UG31_LOGE("[%s]: Refresh driver information from file (%d/%d=%d)\n", __func__, pUg31xx->capData.rm, pUg31xx->capData.fcc, pUg31xx->capData.rsoc);
+      }
+      /// [FC] : Save table to IC ; 05/30/2013
+      if(Ug31SaveDataEnable == _UPI_TRUE_)
+      {
+        UpiSaveTableToIC((_sys_u8_ *)pUg31xx->capData.encriptTable, (_sys_u8_ *)pUg31xx->capData.encriptBuf, (_sys_u8_)pUg31xx->capData.tableSize);
+      }
+      pUg31xx->sysData.rmFromIC = (_sys_u16_)pUg31xx->capData.rm;
+      pUg31xx->sysData.fccFromIC = (_sys_u16_)pUg31xx->capData.fcc;
+      pUg31xx->sysData.rsocFromIC = (_sys_u8_)pUg31xx->capData.rsoc;
+      pUg31xx->batteryInfo.NAC = (_upi_u16_)pUg31xx->capData.rm;
+      pUg31xx->batteryInfo.LMD = (_upi_u16_)pUg31xx->capData.fcc;
+      pUg31xx->batteryInfo.RSOC = (_upi_u16_)pUg31xx->capData.rsoc;
+      pUg31xx->measData.adc1ConvertTime = pUg31xx->sysData.adc1ConvTime;
+    }
+    UG31_LOGI("[%s]: Restore file routine END\n", __func__);
+  }
+
+  if(pUg31xx->backupData.backupFileSts == BACKUP_FILE_STS_VERSION_MISMATCH)
+  {
+    pUg31xx->batteryInfo.Ready = UG_CAP_DATA_VERSION_MISMATCH;
+  }
+  else if(pUg31xx->backupData.backupFileSts == BACKUP_FILE_STS_COMPARE)
+  {
+    pUg31xx->batteryInfo.Ready = UG_CAP_DATA_READY;
+  }
+  else
+  {
+    pUg31xx->batteryInfo.Ready = UG_CAP_DATA_NOT_READY;
+  }
+  return (pUg31xx->batteryInfo.Ready);
+}
+
+#endif  ///< end of uG31xx_BOOT_LOADER
+
+#if defined (uG31xx_OS_WINDOWS)
+
+//====================================================
+//API Call to simulate capacity algorithm
+//====================================================
+void upiGG_AlgorithmSimulatorInit(char **pObj, const wchar_t* GGBFilename,
+                                           MeasDataType *pMeasure, GG_CAP_LOG_TYPE *pCap,
+                                           _upi_u8_ *NacTable)
+{
+  SYSTEM_RTN_CODE rtn;
+  struct ug31xx_data *pUg31xx;
+  _upi_s16_ deltaQC = 0;
+  _sys_u8_ *ptr;
+
+	*pObj = (char *)malloc(sizeof(struct ug31xx_data));
+	pUg31xx = (struct ug31xx_data *)(*pObj);
+  upi_memset(pUg31xx, 0, sizeof(struct ug31xx_data));
+  set_memory_pointer(pUg31xx);
+
+  pUg31xx->sysData.ggbFilename = GGBFilename;
+  rtn = UpiInitSystemData(&pUg31xx->sysData);
+  if(rtn != SYSTEM_RTN_PASS)
+  {
+    if(rtn == SYSTEM_RTN_READ_GGB_FAIL)
+    {
+      return;
+    }
+    return;
+  }
+  // [FC] : Allocate buffer ; 07/08/2013
+  ptr = (_sys_u8_ *)&pUg31xx->capData.encriptTable[0];
+  UpiAllocateTableBuf((_sys_u8_ **)&ptr, &pUg31xx->capData.tableSize);
+  ptr = (_sys_u8_ *)&pUg31xx->capData.encriptBuf[0];
+  UpiAllocateTableBuf((_sys_u8_ **)&ptr, &pUg31xx->capData.tableSize);
+
+  if(NacTable != NULL)
+  {
+    pUg31xx->sysData.rmFromIC = pCap->rm;
+    pUg31xx->sysData.fccFromIC = pCap->fcc;
+    pUg31xx->sysData.rsocFromIC = pCap->rsoc;
+    pUg31xx->sysData.timeTagFromIC = pCap->timeTagFromIC;
+    pUg31xx->sysData.tableUpdateIdxFromIC = pCap->tableUpdateIdxFromIC;
+    pUg31xx->sysData.deltaCapFromIC = pCap->deltaCapFromIC;
+    pUg31xx->sysData.adc1ConvTime = pCap->adc1ConvTime;
+    pUg31xx->sysData.rmFromICBackup = pUg31xx->sysData.rmFromIC;
+    pUg31xx->sysData.fccFromICBackup = pUg31xx->sysData.fccFromIC;
+    pUg31xx->sysData.rsocFromICBackup = pUg31xx->sysData.rsocFromIC;
+    upi_memcpy(pUg31xx->capData.encriptTable, NacTable, pUg31xx->capData.tableSize);
+  }
+  UpiInitNacTable(&pUg31xx->capData);
+  UpiInitCapacity(&pUg31xx->capData);
+  UpiInitDsgCharge(&pUg31xx->capData);
+  if(NacTable != NULL)
+  {
+    pUg31xx->capData.tableUpdateIdx = pUg31xx->sysData.tableUpdateIdxFromIC;
+    deltaQC = (_upi_s16_)pMeasure->stepCap;
+    pUg31xx->sysData.voltage = pMeasure->bat1Voltage;
+    pUg31xx->sysData.curr = (_sys_s16_)pUg31xx->measData.curr;
+    UpiUpdateBatInfoFromIC(&pUg31xx->sysData, deltaQC, _UPI_FALSE_);
+    pUg31xx->capData.rm = (_cap_u16_)pUg31xx->sysData.rmFromIC;
+    pUg31xx->capData.fcc = (_cap_u16_)pUg31xx->sysData.fccFromIC;
+    pUg31xx->capData.rsoc = (_cap_u8_)pUg31xx->sysData.rsocFromIC;
+    UG31_LOGI("[%s]: Use data from coulomb counter (%d/%d = %d)\n", __func__,
+              pUg31xx->capData.rm, pUg31xx->capData.fcc, pUg31xx->capData.rsoc);
+    pUg31xx->capData.dsgCharge = pUg31xx->capData.dsgCharge - (pUg31xx->capData.rm - pUg31xx->batteryInfo.NAC);
+    pUg31xx->batteryInfo.NAC = (_upi_u16_)pUg31xx->capData.rm;
+    pUg31xx->batteryInfo.LMD = (_upi_u16_)pUg31xx->capData.fcc;
+    pUg31xx->batteryInfo.RSOC = (_upi_u16_)pUg31xx->capData.rsoc;
+    UpiAdjustCCRecord(&pUg31xx->capData);
+    /// [FC] : Save battery information to AP ; 06/08/2013
+    pCap->rm = (_upi_u16_)pUg31xx->capData.rm;
+    pCap->fcc = (_upi_u16_)pUg31xx->capData.fcc;
+    pCap->rsoc = (_upi_u16_)pUg31xx->capData.rsoc;
+    pCap->timeTagFromIC = 0;
+    pCap->tableUpdateIdxFromIC = pUg31xx->capData.tableUpdateIdx;
+    pCap->deltaCapFromIC = pUg31xx->measData.lastDeltaCap;
+    pCap->adc1ConvTime = pUg31xx->measData.adc1ConvertTime;
+  }
+}
+
+void upiGG_AlgorithmSimulatorRead(char *pObj, MeasDataType *pMeasure,
+                                              GG_CAP_LOG_TYPE *pCap, _upi_u8_ *NacTable)
+{
+  struct ug31xx_data *pUg31xx;
+
+	pUg31xx = (struct ug31xx_data *)pObj;
+
+  UG31_LOGI("[%s]: %d - %d - %d - %d - %d - %d\n", __func__,
+    pMeasure->bat1Voltage, pMeasure->curr, pMeasure->intTemperature, pMeasure->stepCap, pMeasure->deltaTime, pMeasure->lastCounter);
+
+  memcpy(ptrMeasData, pMeasure, sizeof(MeasDataType));
+
+  UpiReadCapacity(&pUg31xx->capData);
+  pCap->rm = (_upi_u16_)pUg31xx->capData.rm;
+  pCap->fcc = (_upi_u16_)pUg31xx->capData.fcc;
+  pCap->rsoc = (_upi_u16_)pUg31xx->capData.rsoc;
+  pCap->timeTagFromIC = -1;
+  pCap->tableUpdateIdxFromIC = pUg31xx->capData.tableUpdateIdx;
+  pCap->deltaCapFromIC = -1;
+  pCap->adc1ConvTime = -1;
+  UG31_LOGI("[%s]: RM = %d, FCC = %d, RSOC = %d\n", __func__, pCap->rm, pCap->fcc, pCap->rsoc);
+  /// [FC] : Save table to file ; 05/30/2013
+  upi_memcpy(NacTable, pUg31xx->capData.encriptTable, pUg31xx->capData.tableSize);
+}
+
+void upiGG_AlgorithmSimulatorClose(char **pObj)
+{
+  struct ug31xx_data *pUg31xx;
+
+	pUg31xx = (struct ug31xx_data *)(*pObj);
+
+  // [FC] : Allocate buffer ; 07/08/2013
+  UpiFreeTableBuf((_sys_u8_ **)&pUg31xx->capData.encriptTable);
+  UpiFreeTableBuf((_sys_u8_ **)&pUg31xx->capData.encriptBuf);
+
+  upi_free(*pObj);
+  *pObj = NULL;
+}
+
+#endif  ///< end of defined (uG31xx_OS_WINDOWS)
+
+#ifndef uG31xx_BOOT_LOADER
+
+/**
+ * @brief upiGG_InternalSuspendMode
+ *
+ *  Set internal suspend mode
+ *  In internal suspend mode, the adc1 conversion time will not be updated, and the delta time is estimated from adc conversion count
+ *
+ * @para  pObj  address of memory buffer
+ * @para  inSuspend set _UPI_TRUE_ for enable internal suspend mode
+ * @return  NULL
+ */
+void upiGG_InternalSuspendMode(char *pObj, _upi_bool_ inSuspend)
+{
+  struct ug31xx_data *pUg31xx;
+
+	pUg31xx = (struct ug31xx_data *)pObj;
+
+  /// [AT-PM] : Set for measurement module ; 12/10/2013
+  if(MEAS_IN_SUSPEND_MODE(pUg31xx->measData.status) == _UPI_TRUE_)
+  {
+    pUg31xx->measData.status = pUg31xx->measData.status | MEAS_STATUS_LAST_IN_SUSPEND_MODE;
+  }
+  else
+  {
+    pUg31xx->measData.status = pUg31xx->measData.status & (~MEAS_STATUS_LAST_IN_SUSPEND_MODE);
+  }
+  if(inSuspend == _UPI_TRUE_)
+  {
+    pUg31xx->measData.status = pUg31xx->measData.status | MEAS_STATUS_IN_SUSPEND_MODE;
+  }
+  else
+  {
+    pUg31xx->measData.status = pUg31xx->measData.status & (~MEAS_STATUS_IN_SUSPEND_MODE);
+  }
+  return;
+}
+
+/**
+ * @brief upiGG_Reset
+ *
+ *  Reset driver
+ *
+ * @para  pObj  address of buffer
+ * @para  GGBFilename ggb filename
+ * @para  OtpFileName otp data filename
+ * @para  pGGBXBuf  address of ggb data
+ * @return  GGSTATUS
+ */
+#if defined (uG31xx_OS_WINDOWS)
+
+  GGSTATUS upiGG_Reset(char *pObj, const wchar_t* GGBFilename, const wchar_t* OtpFileName)
+
+#else
+
+  GGSTATUS upiGG_Reset(char *pObj, GGBX_FILE_HEADER *pGGBXBuf)
+
+#endif
+{
+	struct ug31xx_data *pUg31xx;
+  SYSTEM_RTN_CODE rtn;
+  _upi_s32_ tmp32;
+  MEAS_RTN_CODE rtnMeas;
+
+	UG31_LOGI("[%s]: %s\n", __func__, UG31XX_API_VERSION);
+
+  Ug31DebugEnable = LOG_LEVEL_ERROR;
+	pUg31xx = (struct ug31xx_data *)pObj;
+
+  #ifdef uG31xx_OS_WINDOWS
+    pUg31xx->sysData.ggbFilename = GGBFilename;
+    pUg31xx->sysData.otpFileName = OtpFileName;
+  #else
+    ptrGgbBuf = pGGBXBuf;
+  #endif
+  rtn = UpiInitSystemData(&pUg31xx->sysData);
+  if(rtn != SYSTEM_RTN_PASS)
+  {
+    if(rtn == SYSTEM_RTN_READ_GGB_FAIL)
+    {
+      return (UG_READ_GGB_FAIL);
+    }
+    return (UG_NOT_DEF);
+  }
+
+  // [FC] : Load table from IC ; 05/30/2013
+
+  UpiInitNacTable(&pUg31xx->capData);
+  /// [FC] : Save table to IC ; 05/30/2013
+  if(Ug31SaveDataEnable == _UPI_TRUE_)
+  {
+    UpiSaveTableToIC((_sys_u8_ *)&pUg31xx->capData.encriptTable, (_sys_u8_ *)&pUg31xx->capData.encriptBuf, (_sys_u8_)pUg31xx->capData.tableSize);
+  }
+  rtn = UpiActiveUg31xx();
+  if(rtn != SYSTEM_RTN_PASS)
+  {
+    return (UG_ACTIVE_FAIL);
+  }
+
+  UpiSetupAdc(&pUg31xx->sysData);
+  UpiSetupSystem(&pUg31xx->sysData);
+
+  pUg31xx->backupData.icDataAvailable = BACKUP_BOOL_TRUE;
+
+  /// [AT-PM] : Fetch ADC code for system stable ; 06/04/2013
+  UpiMeasReadCode(&pUg31xx->measData);
+
+  /// [AT-PM] : Load OTP data ; 01/31/2013
+ 	API_I2C_Read(SECURITY, UG31XX_I2C_HIGH_SPEED_MODE, UG31XX_I2C_TEM_BITS_MODE, OTP1_BYTE1, OTP1_SIZE, pUg31xx->otpData.otp1);
+  API_I2C_Read(SECURITY, UG31XX_I2C_HIGH_SPEED_MODE, UG31XX_I2C_TEM_BITS_MODE, OTP2_BYTE1, OTP2_SIZE, pUg31xx->otpData.otp2);
+ 	API_I2C_Read(NORMAL, UG31XX_I2C_HIGH_SPEED_MODE, UG31XX_I2C_TEM_BITS_MODE, OTP6_BYTE1, OTP3_SIZE, pUg31xx->otpData.otp3);
+  UpiConvertOtp(&pUg31xx->otpData);
+
+  /// [AT-PM] : Check product type ; 01/25/2013
+  if((pUg31xx->otpData.productType != UG31XX_PRODUCT_TYPE_0) &&
+     (pUg31xx->otpData.productType != UG31XX_PRODUCT_TYPE_1))
+  {
+    return (UG_OTP_PRODUCT_DISMATCH);
+  }
+
+  UG31_LOGN("[%s]: Do measurement\n", __func__);
+
+  pUg31xx->measData.status = 0;
+  rtnMeas = UpiMeasurement(&pUg31xx->measData, MEAS_SEL_ALL);
+  if(rtnMeas != MEAS_RTN_PASS)
+  {
+    return ((GGSTATUS)(rtnMeas + UG_MEAS_FAIL));
+  }
+  pUg31xx->sysData.cycleCount = (_sys_u16_)pUg31xx->measData.cycleCount;
+
+  /// [AT-PM] : No external temperature average ; 07/04/2013
+  tmp32 = (_upi_s32_)pUg31xx->measData.extTemperature;
+  tmp32 = tmp32*ET_AVERAGE_BASE/ET_AVERAGE_NEW;
+  pUg31xx->measData.extTemperature = (_meas_s16_)tmp32;
+
+  /// [AT-PM] : Recover ADC1 conversion queue ; 06/04/2013
+  UpiSetupAdc1Queue(&pUg31xx->sysData);
+
+  /// [AT-PM] : Initialize alarm function ; 04/08/2013
+  UpiMeasAlarmThreshold(&pUg31xx->measData);
+  UpiInitAlarm(&pUg31xx->sysData);
+
+  UG31_LOGI("[%s]: Current Status = %d mV / %d mA / %d 0.1oC\n", __func__,
+            pUg31xx->measData.bat1Voltage, pUg31xx->measData.curr, pUg31xx->measData.intTemperature);
+
+  UpiInitCapacity(&pUg31xx->capData);
+  pUg31xx->batteryInfo.NAC = (_upi_u16_)pUg31xx->capData.rm;
+  pUg31xx->batteryInfo.LMD = (_upi_u16_)pUg31xx->capData.fcc;
+  pUg31xx->batteryInfo.RSOC = (_upi_u16_)pUg31xx->capData.rsoc;
+  UG31_LOGN("[%s]: Init data from table -> %d/%d = %d\n", __func__,
+            pUg31xx->batteryInfo.NAC, pUg31xx->batteryInfo.LMD, pUg31xx->batteryInfo.RSOC);
+  UpiInitDsgCharge(&pUg31xx->capData);
+  UpiAdjustCCRecord(&pUg31xx->capData);
+
+  /// [AT-PM] : Save battery information to IC ; 01/31/2013
+  pUg31xx->sysData.rmFromIC = pUg31xx->batteryInfo.NAC;
+  pUg31xx->sysData.fccFromIC = pUg31xx->batteryInfo.LMD;
+  pUg31xx->sysData.rsocFromIC = (_sys_u8_)pUg31xx->batteryInfo.RSOC;
+  pUg31xx->sysData.tableUpdateIdxFromIC = pUg31xx->capData.tableUpdateIdx;
+  pUg31xx->sysData.deltaCapFromIC = pUg31xx->measData.lastDeltaCap;
+  pUg31xx->sysData.adc1ConvTime = pUg31xx->measData.adc1ConvertTime;
+  pUg31xx->sysData.ccOffset = (_sys_s8_)pUg31xx->measData.ccOffsetAdj;
+  pUg31xx->sysData.standbyDsgRatio = (_sys_u8_)pUg31xx->capData.standbyDsgRatio;
+  pUg31xx->sysData.voltage = (_sys_u16_)pUg31xx->measData.bat1Voltage;
+  UpiSaveBatInfoTOIC(&pUg31xx->sysData);
+
+	dumpInfo(pUg31xx);
+	return (UG_INIT_SUCCESS);
+}
+
+#endif  ///< end of uG31xx_BOOT_LOADER
+
+#if defined (uG31xx_OS_WINDOWS)
+
+/**
+ * @brief upiGG_BackupMemory
+ *
+ *  Backup memory in Windows AP
+ *
+ * @para  pObj  address of memory buffer
+ * @para  BackupFileName  filename of backup file
+ * @return  NULL
+ */
+void upiGG_BackupMemory(char *pObj, const wchar_t* BackupFileName)
+{
+  CFile fileObj;
+
+  if(fileObj.Open(BackupFileName, CFile::modeCreate | CFile::modeWrite, NULL) == FALSE)
+  {
+    return;
+  }
+
+  fileObj.Write(pObj, sizeof(struct ug31xx_data));
+  fileObj.Close();
+}
+
+/**
+ * @brief upiGG_RecoveryMemory
+ *
+ *  Recovery memory in Windows AP
+ *
+ * @para  pObj  address of memory buffer
+ * @para  BackupFileName  filename of backup file
+ * @return  NULL
+ */
+void upiGG_RecoveryMemory(char *pObj, const wchar_t* BackupFileName)
+{
+  CFile fileObj;
+  struct ug31xx_data *pUg31xx;
+
+	pUg31xx = (struct ug31xx_data *)pObj;
+
+  if(fileObj.Open(BackupFileName, CFile::modeRead, NULL) == FALSE)
+  {
+    return;
+  }
+
+  fileObj.Read(pObj, sizeof(struct ug31xx_data));
+  fileObj.Close();
+}
+
+#endif  ///< end of defined (uG31xx_OS_WINDOWS)
+
+#ifndef uG31xx_BOOT_LOADER
+
+/**
+ * @brief upiGG_SetBatteryET
+ *
+ *  Set battery temperature from ET
+ *
+ * @para  pObj  address of memory buffer
+ * @return  NULL
+ */
+void upiGG_SetBatteryET(char *pObj)
+{
+  struct ug31xx_data *pUg31xx;
+
+  pUg31xx = (struct ug31xx_data *)pObj;
+  pUg31xx->measData.status = pUg31xx->measData.status | MEAS_STATUS_REFER_ET;
+}
+
+/**
+ * @brief upiGG_SetBatteryIT
+ *
+ *  Set battery temperature from IT
+ *
+ * @para  pObj  address of memory buffer
+ * @return  NULL
+ */
+void upiGG_SetBatteryIT(char *pObj)
+{
+  struct ug31xx_data *pUg31xx;
+
+  pUg31xx = (struct ug31xx_data *)pObj;
+  pUg31xx->measData.status = pUg31xx->measData.status & (~MEAS_STATUS_REFER_ET);
+}
+
+#endif  ///< end of uG31xx_BOOT_LOADER
+
+/**
+ * @brief upiGG_GetCycleCount
+ *
+ *  Get cycle count information
+ *
+ * @para  pObj  address of memory buffer
+ * @return  cycle count
+ */
+int upiGG_GetCycleCount(char *pObj)
+{
+  struct ug31xx_data *pUg31xx;
+
+  if(pObj == _UPI_NULL_)
+  {
+    return (-1);
+  }
+
+	pUg31xx = (struct ug31xx_data *)pObj;
+  return ((int)pUg31xx->measData.cycleCount);
+}
+
+/**
+ * @brief upiGG_SetCycleCount
+ *
+ *  Set cycle count information
+ *
+ * @para  pObj  address of memory buffer
+ * @para  value initial value of cycle count
+ * @return  0 if success
+ */
+int upiGG_SetCycleCount(char *pObj, _upi_u16_ value)
+{
+  struct ug31xx_data *pUg31xx;
+
+  if(pObj == _UPI_NULL_)
+  {
+    return (-1);
+  }
+
+	pUg31xx = (struct ug31xx_data *)pObj;
+  pUg31xx->sysData.cycleCount = (_sys_u16_)value;
+  pUg31xx->measData.cycleCount = (_meas_u16_)value;
+  pUg31xx->measData.cycleCountBuf = 0;
+  return (0);
+}
+
+/**
+ * @brief upiGG_ReverseCurrent
+ *
+ *  Enable reverse current feature
+ *
+ * @para  pObj  address of memory buffer
+ * @para  reverse set to _UPI_TRUE_ to enable reverse current feature
+ * @return  NULL
+ */
+void upiGG_ReverseCurrent(char *pObj, _upi_bool_ reverse)
+{
+  struct ug31xx_data *pUg31xx;
+
+	pUg31xx = (struct ug31xx_data *)pObj;
+  if(reverse == _UPI_TRUE_)
+  {
+    pUg31xx->measData.status = pUg31xx->measData.status | MEAS_STATUS_REVERSE_CURRENT_DIRECTION;
+  }
+  else
+  {
+    pUg31xx->measData.status = pUg31xx->measData.status & (~MEAS_STATUS_REVERSE_CURRENT_DIRECTION);
+  }
+}
+
+#define BACKUP_CYCLE_COUNT_LOW      (REG_CBC32_LOW)
+#define BACKUP_CYCLE_COUNT_HIGH     (REG_CBC32_HIGH)
+
+/**
+ * @brief upiGG_AdjustCellTable
+ *
+ *  Adjust current cell table according to design capacity
+ *
+ * @para  info  address of CapacityDataType
+ * @return  NULL
+ */
+void upiGG_AdjustCellTable(CapacityDataType *data)
+{
+	_upi_u32_ tmp32;
+	_upi_u16_ ratio;
+	_upi_u8_ idxTemp;
+	_upi_u8_ idxCRate;
+	_upi_u8_ idxSov;
+  _upi_u8_ u8Temp;
+  _upi_u8_ u8TempHigh;
+  _upi_u16_ cycleCount;
+
+  /// [FC] : Load cycle count ; 06/09/2014
+  u8Temp = 0;
+  u8TempHigh = 0;
+  API_I2C_Read((BACKUP_CYCLE_COUNT_LOW < 0x80)? NORMAL: SECURITY,
+               UG31XX_I2C_HIGH_SPEED_MODE,
+               UG31XX_I2C_TEM_BITS_MODE,
+               BACKUP_CYCLE_COUNT_LOW,
+               1,
+               &u8Temp);
+  API_I2C_Read(( BACKUP_CYCLE_COUNT_HIGH< 0x80)? NORMAL: SECURITY,
+               UG31XX_I2C_HIGH_SPEED_MODE,
+               UG31XX_I2C_TEM_BITS_MODE,
+               BACKUP_CYCLE_COUNT_HIGH,
+               1,
+               &u8TempHigh);
+  cycleCount = u8TempHigh;
+  cycleCount = cycleCount*256 + u8Temp;
+
+	if(cycleCount == ptrCellParameter->ILMD)
+	{
+		UG31_LOGE("[%s]: Ratio = 1\n", __func__);
+		return;
+	}
+	if(cycleCount == 0)
+	{
+		UG31_LOGE("[%s]: Abnormal design capacity setting\n", __func__);
+		return;
+	}
+
+	/// [AT-PM] : Get ratio between target and current design capacity ; 11/21/2013
+	tmp32 = (_upi_u32_)cycleCount;
+	tmp32 = tmp32*CONST_PERCENTAGE*CONST_ROUNDING/ptrCellParameter->ILMD;
+	ratio = (_upi_u16_)tmp32;
+	UG31_LOGI("[%s]: Ratio of design capacity = %d / %d = %d\n", __func__, cycleCount, ptrCellParameter->ILMD, ratio);
+
+	/// [FC] : Adjust FCC
+	tmp32 = (_upi_u32_)data->fcc;
+	data->fcc = tmp32*ratio/CONST_PERCENTAGE/CONST_ROUNDING;
+	UG31_LOGI("[%s]: Update FCC = %d -> %d with ratio = %d\n", __func__, tmp32, data->fcc, ratio);
+	data->fccBackup = data->fcc;
+
+	/// [FC] : Adjust RM
+	tmp32 = (_upi_u32_)data->rm;
+	data->rm = tmp32*ratio/CONST_PERCENTAGE/CONST_ROUNDING;
+	UG31_LOGI("[%s]: Update RM = %d -> %d with ratio = %d\n", __func__, tmp32, data->rm, ratio);
+
+	/// [AT-PM] : Refresh cell table ; 11/21/2013
+	idxTemp = 0;
+	while(idxTemp < TEMPERATURE_NUMS)
+	{
+		idxCRate = 0;
+		while(idxCRate < C_RATE_NUMS)
+		{
+			ptrCellTable->CELL_NAC_TABLE[idxTemp][idxCRate][0] = 0;
+			idxSov = 1;
+			while(idxSov < SOV_NUMS)
+			{
+				tmp32 = (_upi_u32_)ptrCellTable->CELL_NAC_TABLE[idxTemp][idxCRate][idxSov];
+				tmp32 = tmp32*ratio/CONST_PERCENTAGE/CONST_ROUNDING;
+				if(tmp32 == 0)
+				{
+					tmp32 = 1;
+				}
+				ptrCellTable->CELL_NAC_TABLE[idxTemp][idxCRate][0] = ptrCellTable->CELL_NAC_TABLE[idxTemp][idxCRate][0] + tmp32;
+				UG31_LOGI("[%s]: Table[%d][%d][%d] = %d -> %d (%d)\n", __func__, idxTemp, idxCRate, idxSov,
+									ptrCellTable->CELL_NAC_TABLE[idxTemp][idxCRate][idxSov], tmp32, ptrCellTable->CELL_NAC_TABLE[idxTemp][idxCRate][0]);
+				ptrCellTable->CELL_NAC_TABLE[idxTemp][idxCRate][idxSov] = (_upi_s16_)tmp32;
+				idxSov = idxSov + 1;
+			}
+			UG31_LOGI("[%s]: Table[%d][%d][0] = %d\n", __func__, idxTemp, idxCRate, ptrCellTable->CELL_NAC_TABLE[idxTemp][idxCRate][0]);
+			idxCRate = idxCRate + 1;
+		}
+		idxTemp = idxTemp + 1;
+	}
+	ptrCellParameter->ILMD = cycleCount;
+}
+
+/**
+ * @brief upiGG_GetNtcStatus
+ *
+ *  Report NTC status
+ *
+ * @para  pObj  address of memory buffer
+ * @return  GGSTATUS
+ */
+GGSTATUS upiGG_GetNtcStatus(char *pObj)
+{
+  struct ug31xx_data *pUg31xx;
+
+  pUg31xx = (struct ug31xx_data *)pObj;
+
+  if(MEAS_NTC_OPEN(pUg31xx->measData.status) == _UPI_TRUE_)
+  {
+    #ifdef  STOP_IF_NTC_CHECK_FAIL
+
+      UpiStopUg31xx();
+
+    #endif  ///< end of STOP_IF_NTC_CHECK_FAIL
+    return (UG_MEAS_FAIL_NTC_OPEN);
+  }
+
+  if(MEAS_NTC_SHORT(pUg31xx->measData.status) == _UPI_TRUE_)
+  {
+    #ifdef  STOP_IF_NTC_CHECK_FAIL
+
+      UpiStopUg31xx();
+
+    #endif  ///< end of STOP_IF_NTC_CHECK_FAIL
+    return (UG_MEAS_FAIL_NTC_SHORT);
+  }
+
+  return (UG_SUCCESS);
+}
+
+/**
+ * @brief upiGG_AccessBackupBuffer
+ *
+ *  Access backup data buffer
+ *
+ * @para  pObj  address of memory buffer
+ * @para  size  address of backup buffer size
+ * @return  address of backup buffer
+ */
+_upi_u8_ * upiGG_AccessBackupBuffer(char *pObj, _upi_u8_ *size)
+{
+  struct ug31xx_data *pUg31xx;
+
+  pUg31xx = (struct ug31xx_data *)pObj;
+
+  *size = (_upi_u8_)pUg31xx->backupData.backupBufferSize;
+  return ((_upi_u8_ *)(pUg31xx->backupData.backupBuffer));
+}
+
+/**
+ * @brief upiGG_FetchCurrent
+ *
+ *  Fetch current only
+ *
+ * @para  pObj  address of memory buffer
+ * @return  GGSTATUS
+ */
+GGSTATUS upiGG_FetchCurrent(char *pObj)
+{
+  struct ug31xx_data *pUg31xx;
+  MEAS_RTN_CODE rtn;
+	GGSTATUS status;
+
+  pUg31xx = (struct ug31xx_data *)pObj;
+
+  /// [AT-PM] : Check IT AVE code, which should be continuous ; 12/28/2012
+  ChkITAveCode(pUg31xx);
+
+  status = CheckOtpData(&pUg31xx->otpData);
+  if(status != UG_READ_DEVICE_INFO_SUCCESS)
+  {
+    return (status);
+  }
+
+  rtn = UpiMeasurement(&pUg31xx->measData, MEAS_SEL_CURRENT);
+  if(rtn != MEAS_RTN_PASS)
+  {
+    return ((GGSTATUS)(rtn + UG_MEAS_FAIL));
+  }
+
+	pUg31xx->deviceInfo.aveCurrentRegister = pUg31xx->userReg.regCurrentAve;    //2012/07/11
+	pUg31xx->deviceInfo.current_mA = pUg31xx->measData.curr;
+	pUg31xx->deviceInfo.AveCurrent_mA = pUg31xx->measData.curr;
+  return (UG_READ_DEVICE_INFO_SUCCESS);
+}
+
+/**
+ * @brief upiGG_FetchVoltage
+ *
+ *  Fetch voltage only
+ *
+ * @para  pObj  address of memory buffer
+ * @return  GGSTATUS
+ */
+GGSTATUS upiGG_FetchVoltage(char *pObj)
+{
+  struct ug31xx_data *pUg31xx;
+  MEAS_RTN_CODE rtn;
+	GGSTATUS status;
+
+  pUg31xx = (struct ug31xx_data *)pObj;
+
+  /// [AT-PM] : Check IT AVE code, which should be continuous ; 12/28/2012
+  ChkITAveCode(pUg31xx);
+
+  status = CheckOtpData(&pUg31xx->otpData);
+  if(status != UG_READ_DEVICE_INFO_SUCCESS)
+  {
+    return (status);
+  }
+
+  rtn = UpiMeasurement(&pUg31xx->measData, MEAS_SEL_VOLTAGE);
+  if(rtn != MEAS_RTN_PASS)
+  {
+    return ((GGSTATUS)(rtn + UG_MEAS_FAIL));
+  }
+
+	pUg31xx->deviceInfo.v1_mV = pUg31xx->measData.bat1Voltage;
+	pUg31xx->deviceInfo.vCell1_mV = pUg31xx->measData.bat1Voltage;
+	pUg31xx->deviceInfo.vBat1Average_mV = CalculateVoltageFromUserReg(pUg31xx,
+                                                                    pUg31xx->measData.bat1Voltage,
+                                                                    pUg31xx->measData.curr,
+                                                                    pUg31xx->cellParameter.offsetR,
+                                                                    0);
+
+  /// [RY] : multi-cell setting
+  if(pUg31xx->measData.codeBat2 > 0)
+  {
+	  pUg31xx->deviceInfo.v2_mV = pUg31xx->measData.bat2Voltage;
+	  pUg31xx->deviceInfo.vCell2_mV = pUg31xx->measData.bat2Voltage;
+	  pUg31xx->deviceInfo.vBat2Average_mV = CalculateVoltageFromUserReg(pUg31xx,
+                                                                      pUg31xx->measData.bat2Voltage,
+                                                                      pUg31xx->measData.curr,
+                                                                      pUg31xx->cellParameter.offsetR,
+                                                                      0);
+    pUg31xx->deviceInfo.voltage_mV = pUg31xx->deviceInfo.vBat1Average_mV +
+                                                          pUg31xx->deviceInfo.vBat2Average_mV;
+  }
+
+  if(pUg31xx->measData.codeBat3 > 0)
+  {
+	  pUg31xx->deviceInfo.v3_mV = pUg31xx->measData.bat3Voltage;
+	  pUg31xx->deviceInfo.vCell3_mV = pUg31xx->measData.bat3Voltage;
+	  pUg31xx->deviceInfo.vBat3Average_mV = CalculateVoltageFromUserReg(pUg31xx,
+                                                                      pUg31xx->measData.bat3Voltage,
+                                                                      pUg31xx->measData.curr,
+                                                                      pUg31xx->cellParameter.offsetR,
+                                                                      0);
+    pUg31xx->deviceInfo.voltage_mV = pUg31xx->deviceInfo.vBat1Average_mV +
+                                                          pUg31xx->deviceInfo.vBat2Average_mV +
+                                                          pUg31xx->deviceInfo.vBat3Average_mV;
+  }
+
+  if((pUg31xx->measData.codeBat3 == 0) &&(pUg31xx->measData.codeBat2 == 0))
+  {
+	  pUg31xx->deviceInfo.voltage_mV = pUg31xx->deviceInfo.vBat1Average_mV;
+  }
+  return (UG_READ_DEVICE_INFO_SUCCESS);
+}
+
+/**
+ * @brief upiGG_FetchInternalTemperature
+ *
+ *  Fetch internal temperature only
+ *
+ * @para  pObj  address of memory buffer
+ * @return  GGSTATUS
+ */
+GGSTATUS upiGG_FetchInternalTemperature(char *pObj)
+{
+  struct ug31xx_data *pUg31xx;
+  MEAS_RTN_CODE rtn;
+	GGSTATUS status;
+
+  pUg31xx = (struct ug31xx_data *)pObj;
+
+  /// [AT-PM] : Check IT AVE code, which should be continuous ; 12/28/2012
+  ChkITAveCode(pUg31xx);
+
+  status = CheckOtpData(&pUg31xx->otpData);
+  if(status != UG_READ_DEVICE_INFO_SUCCESS)
+  {
+    return (status);
+  }
+
+  rtn = UpiMeasurement(&pUg31xx->measData, MEAS_SEL_INT_TEMP);
+  if(rtn != MEAS_RTN_PASS)
+  {
+    return ((GGSTATUS)(rtn + UG_MEAS_FAIL));
+  }
+
+  pUg31xx->deviceInfo.IT = pUg31xx->measData.intTemperature;
+  return (UG_READ_DEVICE_INFO_SUCCESS);
+}
+
+/**
+ * @brief upiGG_FetchExternalTemperature
+ *
+ *  Fetch external temperature only
+ *
+ * @para  pObj  address of memory buffer
+ * @return  GGSTATUS
+ */
+GGSTATUS upiGG_FetchExternalTemperature(char *pObj)
+{
+  struct ug31xx_data *pUg31xx;
+  MEAS_RTN_CODE rtn;
+	GGSTATUS status;
+
+  pUg31xx = (struct ug31xx_data *)pObj;
+
+  /// [AT-PM] : Check IT AVE code, which should be continuous ; 12/28/2012
+  ChkITAveCode(pUg31xx);
+
+  status = CheckOtpData(&pUg31xx->otpData);
+  if(status != UG_READ_DEVICE_INFO_SUCCESS)
+  {
+    return (status);
+  }
+
+  rtn = UpiMeasurement(&pUg31xx->measData, MEAS_SEL_EXT_TEMP);
+  if(rtn != MEAS_RTN_PASS)
+  {
+    return ((GGSTATUS)(rtn + UG_MEAS_FAIL));
+  }
+
+  pUg31xx->deviceInfo.ET = pUg31xx->measData.extTemperature;
+  return (UG_READ_DEVICE_INFO_SUCCESS);
+}
+
+#define MAXIMUM_BOARD_OFFSET      (127)
+#define MINIMUM_BOARD_OFFSET      (-127)
+
+/**
+ * @brief upiGG_GetBoardOffset
+ *
+ *  Record measured current as board offset
+ *
+ * @para  pObj  address of memory buffer
+ * @para  fullStep  set _UPI_TRUE_ to full calibration
+ * @para  upper upper bound for calibration
+ * @para  lower lower bound for calibration
+ * @return  GGSTATUS
+ */
+void upiGG_GetBoardOffset(char *pObj, _upi_s16_ fullStep, _upi_s16_ upper, _upi_s16_ lower)
+{
+  struct ug31xx_data *pUg31xx;
+  _upi_s16_ rawCurr;
+  _upi_s8_ oldCCOffsetAdj;
+  _upi_s16_ avgCCOffset;
+
+  pUg31xx = (struct ug31xx_data *)pObj;
+  oldCCOffsetAdj = (_upi_s8_)pUg31xx->measData.ccOffsetAdj;
+
+  UG31_LOGE("[%s]: Board offset information -> Step=%d, I=%d, BO_Org=%d, BO_Adj=%d, UB=%d, LB=%d.\n", __func__,
+            fullStep,
+            pUg31xx->measData.curr,
+            pUg31xx->cellParameter.adc1_pos_offset,
+            pUg31xx->measData.ccOffsetAdj,
+            upper,
+            lower);
+
+  rawCurr = (_upi_s16_)pUg31xx->measData.curr;
+  rawCurr = rawCurr + pUg31xx->measData.ccOffsetAdj;
+
+  if((pUg31xx->measData.curr < upper) && (pUg31xx->measData.curr > lower))
+  {
+    pUg31xx->measData.ccOffsetAdj = (_meas_s8_)rawCurr;
+  }
+  else
+  {
+    upper = upper*2;
+    lower = lower*2;
+
+    if((pUg31xx->measData.curr < upper) && (pUg31xx->measData.curr > lower))
+    {
+      pUg31xx->measData.ccOffsetAdj = (_meas_s8_)rawCurr;
+      pUg31xx->measData.ccOffsetAdj = pUg31xx->measData.ccOffsetAdj/2;
+    }
+  }
+
+  if(fullStep == GET_BOARD_OFFSET_STEP)
+  {
+    if(oldCCOffsetAdj < pUg31xx->measData.ccOffsetAdj)
+    {
+      pUg31xx->measData.ccOffsetAdj = (_meas_s8_)oldCCOffsetAdj;
+      pUg31xx->measData.ccOffsetAdj = pUg31xx->measData.ccOffsetAdj + 1;
+    }
+    if(oldCCOffsetAdj > pUg31xx->measData.ccOffsetAdj)
+    {
+      pUg31xx->measData.ccOffsetAdj = (_meas_s8_)oldCCOffsetAdj;
+      pUg31xx->measData.ccOffsetAdj = pUg31xx->measData.ccOffsetAdj - 1;
+    }
+  }
+  else
+  {
+    UpiSetBoardOffsetKed(&pUg31xx->capData);
+  }
+
+  if(fullStep == GET_BOARD_OFFSET_AVG)
+  {
+    avgCCOffset = (_upi_s16_)pUg31xx->measData.ccOffsetAdj;
+    avgCCOffset = avgCCOffset + oldCCOffsetAdj;
+    avgCCOffset = avgCCOffset/2;
+    pUg31xx->measData.ccOffsetAdj = (_meas_s8_)avgCCOffset;
+  }
+
+  UG31_LOGE("[%s]: (%d) Board offset = %d (%d)\n", __func__, fullStep, pUg31xx->measData.ccOffsetAdj, rawCurr);
+}
+
+/**
+ * @brief upiGG_SetCapacitySuspendMode
+ *
+ *  Set capacity module in suspend mode
+ *
+ * @para  pObj  address of memory buffer
+ * @para  inSuspend set _UPI_TRUE_ for entering suspend mode
+ * @return  NULL
+ */
+void upiGG_SetCapacitySuspendMode(char *pObj, _upi_bool_ inSuspend)
+{
+  struct ug31xx_data *pUg31xx;
+
+  pUg31xx = (struct ug31xx_data *)pObj;
+  pUg31xx->capData.inSuspend = (inSuspend == _UPI_TRUE_) ? CAP_TRUE : CAP_FALSE;
+}
+
+/**
+ * @brief upiGG_SetCapacity
+ *
+ *  Force set capacity to target %
+ *
+ * @para  pObj  address of memory buffer
+ * @para  target  target RSOC
+ * @return  NULL
+ */
+void upiGG_SetCapacity(char *pObj, _upi_u8_ target)
+{
+  struct ug31xx_data *pUg31xx;
+  _upi_u32_ tmp32;
+
+  pUg31xx = (struct ug31xx_data *)pObj;
+
+  tmp32 = pUg31xx->capData.fcc;
+  tmp32 = tmp32*target/CONST_PERCENTAGE;
+
+  pUg31xx->capData.rm = (_cap_u16_)tmp32;
+  pUg31xx->capData.rsoc = (_cap_u8_)target;
+
+  pUg31xx->batteryInfo.NAC = (_upi_u16_)pUg31xx->capData.rm;
+  pUg31xx->batteryInfo.LMD = (_upi_u16_)pUg31xx->capData.fcc;
+  pUg31xx->batteryInfo.RSOC = (_upi_u16_)pUg31xx->capData.rsoc;
+  UG31_LOGI("[%s]: %d / %d = %d ; %d\n", __func__, pUg31xx->batteryInfo.NAC, pUg31xx->batteryInfo.LMD, pUg31xx->batteryInfo.RSOC, target);
+}
+
+#ifndef uG31xx_OS_WINDOWS
+
+#ifdef  uG31xx_BOOT_LOADER
+
+static char *uboot_gauge = _UPI_NULL_;
+
+/**
+ * @brief uboot_initial
+ *
+ *  initial procedure in uBoot
+ *
+ * @para  pGGB  address of GGB data
+ * @para  force_reset set 1 to force uG31xx driver reset as first power on
+ * @return  0 if success
+ */
+int uboot_initial(char *pGGB, unsigned char force_reset)
+{
+  GGSTATUS rtn;
+
+  if(uboot_gauge != _UPI_NULL_)
+  {
+    rtn = upiGG_UnInitial(&uboot_gauge);
+    if(rtn != UG_SUCCESS)
+    {
+      return (rtn);
+    }
+  }
+
+  rtn = upiGG_Initial(&uboot_gauge, (GGBX_FILE_HEADER *)pGGB, force_reset);
+  if(rtn != UG_INIT_SUCCESS)
+  {
+    return ((int)rtn);
+  }
+  return (0);
+}
+
+/**
+ * @brief uboot_uninitial
+ *
+ *  uninitialize procedure in uBoot
+ *
+ * @return  0 if success
+ */
+int uboot_uninitial(void)
+{
+  GGSTATUS rtn;
+
+  rtn = upiGG_UnInitial(&uboot_gauge);
+  if(rtn != UG_SUCCESS)
+  {
+    return (rtn);
+  }
+  return (0);
+}
+
+/**
+ * @brief uboot_update
+ *
+ *  Update battery information in uBoot
+ *
+ * @return  0 if success
+ */
+int uboot_update(void)
+{
+  GGSTATUS rtn;
+  GG_DEVICE_INFO *obj;
+
+  obj = _UPI_NULL_;
+  obj = upi_malloc(sizeof(GG_DEVICE_INFO));
+  if(obj == _UPI_NULL_)
+  {
+    return (-1);
+  }
+
+  rtn = upiGG_ReadDeviceInfo(uboot_gauge, obj);
+  if(rtn != UG_READ_DEVICE_INFO_SUCCESS)
+  {
+    return (rtn);
+  }
+  return (0);
+}
+
+/**
+ * @brief uboot_get_voltage
+ *
+ *  Read voltage
+ *
+ * @return  battery voltage in mV
+ */
+int uboot_get_voltage(void)
+{
+  struct ug31xx_data *pUg31xx;
+
+  pUg31xx = (struct ug31xx_data *)uboot_gauge;
+
+  return ((int)pUg31xx->measData.bat1Voltage);
+}
+
+/**
+ * @brief uboot_get_current
+ *
+ *  Read current
+ *
+ * @return  current in mA
+ */
+int uboot_get_current(void)
+{
+  struct ug31xx_data *pUg31xx;
+
+  pUg31xx = (struct ug31xx_data *)uboot_gauge;
+
+  return ((int)pUg31xx->measData.curr);
+}
+
+/**
+ * @brief uboot_get_internal_temperature
+ *
+ *  Read internal temperature
+ *
+ * @return  internal temperature in 0.1oC
+ */
+int uboot_get_internal_temperature(void)
+{
+  struct ug31xx_data *pUg31xx;
+
+  pUg31xx = (struct ug31xx_data *)uboot_gauge;
+
+  return ((int)pUg31xx->measData.intTemperature);
+}
+
+/**
+ * @brief uboot_get_external_temperature
+ *
+ *  Read external temperature
+ *
+ * @return  external temperature in 0.1oC
+ */
+int uboot_get_external_temperature(void)
+{
+  struct ug31xx_data *pUg31xx;
+
+  pUg31xx = (struct ug31xx_data *)uboot_gauge;
+
+  return ((int)pUg31xx->measData.extTemperature);
+}
+
+/**
+ * @brief uboot_get_remaining_capacity
+ *
+ *  Read remaining capacity
+ *
+ * @return  remaining capacity in mAh
+ */
+int uboot_get_remaining_capacity(void)
+{
+  struct ug31xx_data *pUg31xx;
+
+  pUg31xx = (struct ug31xx_data *)uboot_gauge;
+
+  return ((int)pUg31xx->batteryInfo.NAC);
+}
+
+/**
+ * @brief uboot_get_full_charge_capacity
+ *
+ *  Read full charge capacity
+ *
+ * @return  full charge capacity in mAh
+ */
+int uboot_get_full_charge_capacity(void)
+{
+  struct ug31xx_data *pUg31xx;
+
+  pUg31xx = (struct ug31xx_data *)uboot_gauge;
+
+  return ((int)pUg31xx->batteryInfo.LMD);
+}
+
+/**
+ * @brief uboot_get_relative_state_of_charge
+ *
+ *  Read relative state of charge
+ *
+ * @return  relative state of charge in %
+ */
+int uboot_get_relative_state_of_charge(void)
+{
+  struct ug31xx_data *pUg31xx;
+
+  pUg31xx = (struct ug31xx_data *)uboot_gauge;
+
+  return ((int)pUg31xx->batteryInfo.RSOC);
+}
+
+/**
+ * @brief uboot_get_full_charge_status
+ *
+ *  Read full charge status
+ *
+ * @return  1 if full charge reached
+ */
+int uboot_get_full_charge_status(void)
+{
+  if(ug31_uboot_sts & UPI_BOOT_STATUS_FC)
+  {
+    return (1);
+  }
+  return (0);
+}
+
+/**
+ * @brief uboot_get_rsense
+ *
+ *  Get R-Sense value
+ *
+ * @return  R-Sense in mOhm
+ */
+int uboot_get_rsense(void)
+{
+  struct ug31xx_data *pUg31xx;
+
+  pUg31xx = (struct ug31xx_data *)uboot_gauge;
+
+  return ((int)pUg31xx->cellParameter.rSense);
+}
+
+/**
+ * @brief uboot_set_rsense
+ *
+ *  Set R-Sense value
+ *
+ * @para  rsense  R-Sense in mOhm
+ * @return  0 if success
+ */
+int uboot_set_rsense(int rsense)
+{
+  struct ug31xx_data *pUg31xx;
+
+  pUg31xx = (struct ug31xx_data *)uboot_gauge;
+  pUg31xx->cellParameter.rSense = (_upi_u8_)rsense;
+  return (0);
+}
+
+struct ug31xx_uboot_interface ug31xx_uboot_module = {
+  .initial                      = uboot_initial,
+  .uninitial                    = uboot_uninitial,
+  .update                       = uboot_update,
+
+  .get_voltage                  = uboot_get_voltage,
+  .get_current                  = uboot_get_current,
+  .get_internal_temperature     = uboot_get_internal_temperature,
+  .get_external_temperature     = uboot_get_external_temperature,
+  .get_remaining_capacity       = uboot_get_remaining_capacity,
+  .get_full_charge_capacity     = uboot_get_full_charge_capacity,
+  .get_relative_state_of_charge = uboot_get_relative_state_of_charge,
+  .get_full_charge_status       = uboot_get_full_charge_status,
+  .get_rsense                   = uboot_get_rsense,
+
+  .set_rsense                   = uboot_set_rsense,
+};
+
+#else   ///< else of uG31xx_BOOT_LOADER
+
+#ifdef  ANDROID_SHELL_ALGORITHM
+
+#define EXTERNAL_PROGRAM_PATH       ("/Removable/MicroSD/upi_fg")
+#define EXTERNAL_PROGRAM_KEY_START  (0x9306)
+#define EXTERNAL_PROGRAM_KEY_END    (0x8837)
+
+typedef struct UpiLibExtProgInterfaceST {
+  int rm;
+  int fcc;
+  int rsoc;
+} __attribute__((packed)) UpiLibExtProgInterfaceType;
+
+/**
+ * @brief upi_lib_exec_external_program
+ *
+ *  Execute external program
+ *
+ * @para  pObj  address of struct ug31xx_data
+ * @return  NULL
+ */
+void upi_lib_exec_external_program(struct ug31xx_data *pObj)
+{
+  UpiLibExtProgInterfaceType extProgData;
+  unsigned int tmpKey;
+  FILE *fp;
+
+  /// [AT-PM] : Open file from external program ; 03/17/2014
+  fp = NULL;
+  fp = fopen(EXTERNAL_PROGRAM_PATH, "rt");
+  if(fp == NULL)
+  {
+    return;
+  }
+
+  /// [AT-PM] : Get start key ; 03/17/2014
+  fscanf(fp, "%x", &tmpKey);
+  if(tmpKey != EXTERNAL_PROGRAM_KEY_START)
+  {
+    UG31_LOGE("[%s]: Start key check fail (%x)\n", __func__,
+              tmpKey);
+    return;
+  }
+
+  /// [AT-PM] : Get capacity data ; 03/17/2014
+  fscanf(fp, "%d,%d,%d", &extProgData.rm, &extProgData.fcc, &extProgData.rsoc);
+
+  /// [AT-PM] : Get end key ; 03/17/2014
+  fscanf(fp, "%x", &tmpKey);
+  if(tmpKey != EXTERNAL_PROGRAM_KEY_END)
+  {
+    UG31_LOGE("[%s]: End key check fail (%x)\n", __func__,
+              tmpKey);
+    return;
+  }
+
+  /// [AT-PM] : Use data from external program ; 03/16/2014
+  pObj->capData.rm = (_cap_u16_)extProgData.rm;
+  pObj->capData.fcc = (_cap_u16_)extProgData.fcc;
+  pObj->capData.rsoc = (_cap_u16_)extProgData.rsoc;
+  UG31_LOGE("[%s]: %d / %d = %d\n", __func__,
+            pObj->capData.rm,
+            pObj->capData.fcc,
+            pObj->capData.rsoc);
+}
+
+/**
+ * @brief upi_lib_print_obj_version
+ *
+ *  Print obj version in log
+ *
+ * @return  NULL
+ */
+void upi_lib_print_obj_version(void)
+{
+  UG31_LOGE("[%s]: %s\n", __func__,
+            UG31XX_API_VERSION);
+
+  UpiPrintBackupVersion();
+  UpiPrintCapacityVersion();
+  UpiPrintMeasurementVersion();
+  UpiPrintOtpVersion();
+  UpiPrintSystemVersion();
+}
+
+/**
+ * @brief upi_lib_debug_switch
+ *
+ *  Debug switch API for user space program
+ *
+ * @para  op_options  operation from kernel
+ * @return  NULL
+ */
+void upi_lib_debug_switch(unsigned char op_option)
+{
+  upiGG_DebugSwitch(LKM_OPTIONS_DEBUG_LEVEL(op_option));
+}
+
+/**
+ * @brief PrintDebugLog
+ *
+ *  Print debug log for capacity module
+ *
+ * @para  ug31xx  address of struct ug31xx_data
+ * @para  action  string of kernel driver action
+ * @return  NULL
+ */
+void PrintDebugLog(struct ug31xx_data *ug31xx, const char *action)
+{
+  UG31_LOGE("<BATT> M:%s, P:%d(%d-%d)%%, V:%dmV, C:%dmA, T:%d.%dC(%d), S:0x%08x(%d%d%d), R:%dmAh, F:%dmAh, Q:%dmAh, CC:%d, P:%d.%d(%d-%d)s, BO:%d, %s:%s-%04x-%s:%s-%s (%d)\n",
+            action,
+            (int)ug31xx->capData.rsoc,
+            (int)ug31xx->capData.rsoc,
+            (int)ug31xx->capData.predictRsoc,
+            (int)ug31xx->measData.bat1Voltage,
+            (int)ug31xx->measData.curr,
+            (int)(ug31xx->measData.extTemperature/10),
+            (int)(((ug31xx->measData.extTemperature%10) < 0) ?
+                  (ug31xx->measData.extTemperature*(-1)%10) :
+                  (ug31xx->measData.extTemperature%10)),
+            (int)ug31xx->measData.intTemperature,
+            (unsigned int)ug31xx->capData.status,
+            (int)ug31xx->capData.fcSts,
+            (int)ug31xx->capData.fcStep100,
+            (int)ug31xx->capData.inSuspend,
+            (int)ug31xx->capData.rm,
+            (int)ug31xx->capData.fcc,
+            (int)ug31xx->measData.cumuCap,
+            (int)ug31xx->measData.cycleCount,
+            (int)(ug31xx->measData.deltaTime/1000),
+            (int)(ug31xx->measData.deltaTime%1000),
+            (int)ug31xx->capData.dsgCharge,
+            (int)ug31xx->capData.reverseCap,
+            (int)(ug31xx->cellParameter.adc1_pos_offset + ug31xx->measData.ccOffsetAdj),
+            UG31XX_DRIVER_VERSION_STR,
+            UG31XX_DRIVER_RELEASE_NOTE,
+            ug31xx->cellParameter.ggb_version,
+            ug31xx->cellParameter.customerSelfDef,
+            ug31xx->cellParameter.projectSelfDef,
+            UG31XX_DRIVER_RELEASE_DATE,
+            (int)ug31xx->capData.tableUpdateIdx);
+}
+
+/**
+ * @brief upi_lib_print_log
+ *
+ *  Print debug log
+ *
+ * @para  obj address of memory buffer from kernel
+ * @para  action  string of kernel driver action
+ * @return  NULL
+ */
+void upi_lib_print_log(char *obj, const char *action)
+{
+  struct ug31xx_data *pUg31xx;
+
+  pUg31xx = (struct ug31xx_data *)obj;
+
+  set_memory_pointer(pUg31xx);
+
+  PrintDebugLog(pUg31xx, action);
+}
+
+static int upi_lib_first_update_capacity_delay = 5;
+
+/**
+ * @brief upi_lib_update_capacity
+ *
+ *  Capacity algorithm API for user space program
+ *
+ * @para  obj address of memory buffer from kernel
+ * @return  NULL
+ */
+void upi_lib_update_capacity(char *obj)
+{
+  struct ug31xx_data *pUg31xx;
+
+  pUg31xx = (struct ug31xx_data *)obj;
+  UG31_LOGI("[%s]: Time Tick = %d (%d)\n", __func__, pUg31xx->measData.lastTimeTick, pUg31xx->measData.lastCounter);
+
+  set_memory_pointer(pUg31xx);
+
+  if(upi_lib_first_update_capacity_delay != 0)
+  {
+    upi_lib_first_update_capacity_delay = upi_lib_first_update_capacity_delay - 1;
+    UG31_LOGE("[%s]: First update capacity ... %d (%d -> %d)\n", __func__,
+              upi_lib_first_update_capacity_delay,
+              pUg31xx->measData.deltaTimeDaemon,
+              pUg31xx->measData.deltaTime);
+    pUg31xx->measData.deltaTimeDaemon = pUg31xx->measData.deltaTime;
+    return;
+  }
+  upiGG_ShellUpdateCapacity(obj);
+
+  upi_lib_exec_external_program(pUg31xx);
+}
+
+/**
+ * @brief upi_lib_backup_data
+ *
+ *  Backup data operation for user space program
+ *
+ * @para  obj address of memory buffer from kernel
+ * @para  backup_file address of backup filename
+ * @para  suspend_file  address of suspend filename
+ * @return  0 if success, 1 if driver version mismatch, -1 if not ready
+ */
+int upi_lib_backup_data(char *obj, char *backup_file, char *suspend_file)
+{
+  int rtn;
+  struct ug31xx_data *pUg31xx;
+
+  pUg31xx = (struct ug31xx_data *)obj;
+  UG31_LOGI("[%s]: Time Tick = %d (%d)\n", __func__, pUg31xx->measData.lastTimeTick, pUg31xx->measData.lastCounter);
+
+  set_memory_pointer(pUg31xx);
+
+  upiGG_BackupFileSwitch(_UPI_TRUE_);
+  rtn = upiGG_BackupFileCheck(obj, backup_file, suspend_file);
+  upiGG_BackupFileSwitch(_UPI_FALSE_);
+
+  if(rtn == UG_CAP_DATA_VERSION_MISMATCH)
+  {
+    UG31_LOGE("[%s]: Driver version mismatched.\n", __func__);
+    return (1);
+  }
+  if(rtn == UG_CAP_DATA_NOT_READY)
+  {
+    UG31_LOGE("[%s]: Driver backup data not ready.\n", __func__);
+    return (-1);
+  }
+  return (0);
+}
+
+/**
+ * @brief upi_lib_malloc_memory
+ *
+ *  Malloc memory buffer for userspace program
+ *
+ * @para  obj address of memory buffer pointer
+ * @return  size of memory buffer
+ */
+int upi_lib_malloc_memory(char **obj)
+{
+  if((*obj) != NULL)
+  {
+    upi_free(*obj);
+  }
+
+  *obj = (char *)upi_malloc(sizeof(struct ug31xx_data));
+  UG31_LOGE("[%s]: %d,%d,%d,%d,%d\n", __func__,
+            sizeof(OtpDataType),
+            sizeof(MeasDataType),
+            sizeof(CapacityDataType),
+            sizeof(SystemDataType),
+            sizeof(BackupDataType));
+  return (((*obj) == NULL) ? 0 : sizeof(struct ug31xx_data));
+}
+
+/**
+ * @brief upi_lib_get_memory_size
+ *
+ *  Get memory size used by userspace program
+ *
+ * @return  size of memory
+ */
+int upi_lib_get_memory_size(void)
+{
+  int total_size;
+  int rtn;
+
+  total_size = 0;
+
+  rtn = (int)UpiGetBackupMemorySize();
+  total_size = total_size + rtn;
+
+  rtn = (int)UpiGetCapacityMemorySize();
+  total_size = total_size + rtn;
+
+  rtn = (int)UpiGetMeasurementMemorySize();
+  total_size = total_size + rtn;
+
+  UG31_LOGD("[%s]: Total memory size = %d\n", __func__, total_size);
+  return (total_size);
+}
+
+#else   ///< else of ANDROID_SHELL_ALGORITHM
+
+enum  LKM_OPERATION_MODE {
+  LKM_OPERATION_MODE_NORMAL = 0,
+  LKM_OPERATION_MODE_ENTER_SUSPEND,
+  LKM_OPERATION_MODE_SUSPEND,
+  LKM_OPERATION_MODE_FORCE_EXIT_SUSPEND = 20,
+};
+
+#define LKM_CHECK_BACKUP_FILE_INTERVAL    (20)
+#define LKM_SUSPEND_UPDATE_INTERVAL       (1)
+#define LKM_AVG_TEMPERATURE_COUNT         (4)
+#define LKM_AVG_TEMPERATURE_INIT_WITH_25  (LKM_AVG_TEMPERATURE_COUNT/2)
+#define LKM_MAX_OPERATION_FAIL_CNT        (3)
+#define LKM_MAX_DECIMATE_RST_CNT          (10)
+#define LKM_MAX_RESET_DELTA_SOC           (10)
+
+static _upi_u8_ lkm_alarm_status;
+static _upi_u8_ lkm_battery_removed;
+static _upi_u8_ lkm_chk_backup_file_interval;
+static char *lkm_version_string = _UPI_NULL_;
+static _upi_u8_ lkm_operation_mode;
+static _upi_u8_ lkm_suspend_update_delay;
+static char *lkm_gauge = _UPI_NULL_;
+static char *lkm_backup_filename = _UPI_NULL_;
+static char *lkm_suspend_filename = _UPI_NULL_;
+static unsigned char lkm_options = 0;
+static _upi_bool_ lkm_dc_in_before_suspend = _UPI_FALSE_;
+static _upi_s16_ lkm_avg_ext_temperature_buf[LKM_AVG_TEMPERATURE_COUNT];
+static char *lkm_shell_ap_name = _UPI_NULL_;
+static _upi_u8_ lkm_operation_fail_cnt = 0;
+static _upi_u32_ lkm_last_update_time_tag = 0;
+static _upi_u8_ lkm_polling_init_cnt = 0;
+static _upi_u8_ lkm_decimate_rst_cnt = 0;
+static _upi_u32_ lkm_suspend_time_tag = 0;
+
+#define GGB_VERSION_LENGTH      (4)
+
+static char lkm_string_table[] = {
+  '0',
+  '1',
+  '2',
+  '3',
+  '4',
+  '5',
+  '6',
+  '7',
+  '8',
+  '9',
+  'a',
+  'b',
+  'c',
+  'd',
+  'e',
+  'f',
+};
+
+/**
+ * @brief lkm_set_version
+ *
+ *  Set version string
+ *
+ * @para  ug31xx  address of struct ug31xx_data
+ * @return  NULL
+ */
+void lkm_set_version(struct ug31xx_data *ug31xx)
+{
+  _upi_u32_ size;
+  _upi_u32_ idxVerNote;
+  _upi_u32_ idxGgb;
+  _upi_u32_ idxCell;
+  _upi_u8_ idx;
+  _upi_u16_ value;
+  _upi_u8_ fwOffset;
+  _upi_u8_ bkOffset;
+
+  idxVerNote = upi_strlen(UG31XX_DRIVER_VERSION_STR) + 1;
+  idxGgb = idxVerNote + upi_strlen(UG31XX_DRIVER_RELEASE_NOTE) + 1;
+  idxCell = idxGgb + GGB_VERSION_LENGTH + 1;
+  size = idxCell + CELL_PARAMETER_STRING_LENGTH + CELL_PARAMETER_STRING_LENGTH + 1;
+
+  if(lkm_version_string != _UPI_NULL_)
+  {
+    upi_free(lkm_version_string);
+  }
+  lkm_version_string = (char *)upi_malloc(size);
+
+  /// [AT-PM] : Set driver version ; 11/13/2013
+  upi_memcpy(lkm_version_string, UG31XX_DRIVER_VERSION_STR, upi_strlen(UG31XX_DRIVER_VERSION_STR));
+  lkm_version_string[upi_strlen(UG31XX_DRIVER_VERSION_STR)] = ':';
+  upi_memcpy(&lkm_version_string[idxVerNote], UG31XX_DRIVER_RELEASE_NOTE, upi_strlen(UG31XX_DRIVER_RELEASE_NOTE));
+  lkm_version_string[idxVerNote + upi_strlen(UG31XX_DRIVER_RELEASE_NOTE)] = '-';
+
+
+  /// [AT-PM] : Set ggb version ; 11/15/2013
+  idx = 0;
+  fwOffset = 0;
+  bkOffset = 12;
+  while(idx < GGB_VERSION_LENGTH)
+  {
+    value = ug31xx->cellParameter.ggb_version;
+
+    value = value << fwOffset;
+    value = value >> bkOffset;
+
+    lkm_version_string[idxGgb + idx] = lkm_string_table[value];
+
+    idx = idx + 1;
+    fwOffset = fwOffset + 4;
+  }
+  lkm_version_string[idxGgb + idx] = '-';
+
+  /// [AT-PM] : Set cell manufacturer ; 11/13/2013
+  idx = 0;
+  while(idx < CELL_PARAMETER_STRING_LENGTH)
+  {
+    lkm_version_string[idxCell] = ug31xx->cellParameter.customerSelfDef[idx];
+    idxCell = idxCell + 1;
+    idx = idx + 1;
+
+    if(ug31xx->cellParameter.customerSelfDef[idx] == 0)
+    {
+      break;
+    }
+  }
+
+  lkm_version_string[idxCell] = ':';
+  idxCell = idxCell + 1;
+
+  /// [AT-PM] : Set cell type number ; 11/13/2013
+  idx = 0;
+  while(idx < CELL_PARAMETER_STRING_LENGTH)
+  {
+    lkm_version_string[idxCell] = ug31xx->cellParameter.projectSelfDef[idx];
+    idxCell = idxCell + 1;
+    idx = idx + 1;
+
+    if(ug31xx->cellParameter.projectSelfDef[idx] == 0)
+    {
+      break;
+    }
+  }
+
+  lkm_version_string[idxCell] = '\0';
+  UG31_LOGE("[%s]: Version = %s\n", __func__, lkm_version_string);
+}
+
+/**
+ * @brief lkm_initial
+ *
+ *  Initialization procedure for linux kernel module
+ *
+ * @para  ggb address of ggb data array
+ * @para  cable cable status
+ * @return  0 if success
+ */
+int lkm_initial(char *ggb, unsigned char cable)
+{
+  GGSTATUS rtn;
+  struct ug31xx_data *ug31xx;
+  int idx;
+
+  upiGG_DebugSwitch(LKM_OPTIONS_DEBUG_LEVEL(lkm_options));
+
+  lkm_last_update_time_tag = GetSysTickCount();
+  lkm_suspend_time_tag = GetSysTickCount();
+
+  if(lkm_gauge != _UPI_NULL_)
+  {
+    rtn = upiGG_UnInitial(&lkm_gauge);
+  }
+
+  #ifdef  UG31XX_CELL_REPLACE_TEST
+
+  rtn = upiGG_Initial(&lkm_gauge, (GGBX_FILE_HEADER *)ggb, LKM_OPTIONS_FORCE_RESET);
+
+  #else   ///< else of UG31XX_CELL_REPLACE_TEST
+
+  rtn = upiGG_Initial(&lkm_gauge, (GGBX_FILE_HEADER *)ggb, (lkm_options & LKM_OPTIONS_FORCE_RESET));
+
+  #endif  ///< end of UG31XX_CELL_REPLACE_TEST
+
+  ug31xx = (struct ug31xx_data *)lkm_gauge;
+  ug31xx->Options = (_upi_u8_)lkm_options;
+
+  /// [AT-PM] : Check 0% RSOC ; 01/14/2014
+  if((ug31xx->measData.curr > 0) &&
+     (cable == UG31XX_CABLE_IN) &&
+     (ug31xx->batteryInfo.RSOC == 0))
+  {
+    upiGG_SetCapacity(lkm_gauge, 1);
+  }
+
+  lkm_set_version(ug31xx);
+
+  lkm_alarm_status = 0;
+  lkm_battery_removed = UPI_UG31XX_BATTERY_INSERTED;
+  lkm_chk_backup_file_interval = LKM_CHECK_BACKUP_FILE_INTERVAL;
+  lkm_operation_mode = LKM_OPERATION_MODE_NORMAL;
+  lkm_suspend_update_delay = 0;
+  lkm_options = lkm_options & (~LKM_OPTIONS_FORCE_RESET);
+  lkm_polling_init_cnt = 0;
+
+  /// [AT-PM] : Initialize average external temperature buffer ; 11/27/2013
+  idx = 0;
+  while(idx < LKM_AVG_TEMPERATURE_COUNT)
+  {
+    if(idx < LKM_AVG_TEMPERATURE_INIT_WITH_25)
+    {
+      lkm_avg_ext_temperature_buf[idx] = (_upi_s16_)ug31xx->measData.extTemperature;
+    }
+    else
+    {
+      lkm_avg_ext_temperature_buf[idx] = 250;
+    }
+    idx = idx + 1;
+  }
+  return ((rtn == UG_INIT_SUCCESS) ? 0 : -1);
+}
+
+/**
+ * @brief lkm_uninitial
+ *
+ *  Uninitialization procedure for linux kernel module
+ *
+ * @return  0 if success
+ */
+int lkm_uninitial(void)
+{
+  GGSTATUS rtn;
+
+  rtn = UG_SUCCESS;
+  if(lkm_gauge != _UPI_NULL_)
+  {
+    rtn = upiGG_UnInitial(&lkm_gauge);
+  }
+  if(lkm_version_string != _UPI_NULL_)
+  {
+    upi_free(lkm_version_string);
+  }
+  return ((rtn == UG_SUCCESS) ? 0 : -1);
+}
+
+/**
+ * @brief lkm_check_fail_cnt
+ *
+ *  Check operation fail count
+ *
+ * @para  reset set _UPI_TRUE_ to reset fail count
+ * @return  0 if not exceed MAX count
+ */
+int lkm_check_fail_cnt(_upi_bool_ reset)
+{
+  if(reset == _UPI_TRUE_)
+  {
+    lkm_operation_fail_cnt = 0;
+    return (0);
+  }
+
+  lkm_operation_fail_cnt = lkm_operation_fail_cnt + 1;
+  if(lkm_operation_fail_cnt < LKM_MAX_OPERATION_FAIL_CNT)
+  {
+    return (0);
+  }
+  return (1);
+}
+
+/**
+ * @brief lkm_suspend
+ *
+ *  Suspend procedure for linux kernel module
+ *
+ * @para  dc_in set 1 if dc is in
+ * @return  0 if success
+ */
+int lkm_suspend(char dc_in)
+{
+  GGSTATUS rtn;
+
+  rtn = 0;
+  upiGG_BackupFileSwitch(_UPI_FALSE_);
+
+  lkm_last_update_time_tag = GetSysTickCount();
+  lkm_suspend_time_tag = GetSysTickCount();
+
+  lkm_dc_in_before_suspend = (dc_in == 1) ? _UPI_TRUE_ : _UPI_FALSE_;
+
+  if((lkm_operation_mode == LKM_OPERATION_MODE_NORMAL) ||
+     (lkm_operation_mode == LKM_OPERATION_MODE_FORCE_EXIT_SUSPEND))
+  {
+    lkm_operation_mode = LKM_OPERATION_MODE_ENTER_SUSPEND;
+    lkm_suspend_update_delay = 0;
+    upiGG_InternalSuspendMode(lkm_gauge, _UPI_TRUE_);
+#ifndef FEATURE_DISABLE_SUSPEND_OPERATION
+    rtn = upiGG_PreSuspend(lkm_gauge);
+    rtn = lkm_check_fail_cnt((rtn == UG_READ_DEVICE_INFO_SUCCESS) ? _UPI_TRUE_ : _UPI_FALSE_);
+    return (rtn);
+#endif  ///< end of FEATURE_DISABLE_SUSPEND_OPERATION
+  }
+  return (rtn);
+}
+
+/**
+ * @brief lkm_update_avg_external_temperature
+ *
+ *  Update average external temperature buffer
+ *
+ * @para  extTemp current measured external temperature
+ * @return  NULL
+ */
+void lkm_update_avg_external_temperature(_upi_s16_ extTemp)
+{
+  _upi_u8_ tmp;
+
+  tmp = LKM_AVG_TEMPERATURE_COUNT - 1;
+  while(tmp)
+  {
+    lkm_avg_ext_temperature_buf[tmp] = lkm_avg_ext_temperature_buf[tmp - 1];
+    tmp = tmp - 1;
+  }
+  lkm_avg_ext_temperature_buf[tmp] = extTemp;
+}
+
+/**
+ * @brief lkm_update_procedure
+ *
+ *  Update battery information procedure
+ *
+ * @para  user_space_response true if user space algorithm has responsed
+ * @return  GGSTATUS
+ */
+GGSTATUS lkm_update_procedure(_upi_bool_ user_space_response)
+{
+  GGSTATUS rtn;
+  GG_DEVICE_INFO *devInfo;
+  GG_CAPACITY *devCapacity;
+  struct ug31xx_data *ug31xx;
+
+  ug31xx = (struct ug31xx_data *)lkm_gauge;
+
+  devInfo = (GG_DEVICE_INFO *)upi_malloc(sizeof(GG_DEVICE_INFO));
+  if(devInfo == _UPI_NULL_)
+  {
+    return (-1);
+  }
+  devCapacity = (GG_CAPACITY *)upi_malloc(sizeof(GG_CAPACITY));
+  if(devCapacity == _UPI_NULL_)
+  {
+    upi_free(devInfo);
+    return (-1);
+  }
+
+  rtn = upiGG_ReadDeviceInfo(lkm_gauge, devInfo);
+  if(rtn == UG_READ_DEVICE_INFO_SUCCESS)
+  {
+    #ifndef UG31XX_SHELL_ALGORITHM
+
+    if(ug31xx->sysData.adcCheckData.decimateRst == _UPI_FALSE_)
+    {
+      upiGG_ReadCapacity(lkm_gauge, devCapacity);
+    }
+
+    #endif  ///< end of UG31XX_SHELL_ALGORITHM
+
+    if(user_space_response == _UPI_FALSE_)
+    {
+      upiGG_ShellUpdateCC(lkm_gauge);
+      UG31_LOGE("[%s]: User space daemon no response.\n", __func__);
+    }
+
+    rtn = upiGG_GetAlarmStatus(lkm_gauge, &lkm_alarm_status);
+  }
+
+  #ifndef UG31XX_SHELL_ALGORITHM
+
+  UG31_LOGI("[%s]: %d / %d = %d\n", __func__, devCapacity->NAC, devCapacity->LMD, devCapacity->RSOC);
+
+  #endif  ///< end of UG31XX_SHELL_ALGORITHM
+
+  if(rtn == UG_MEAS_FAIL_BATTERY_REMOVED)
+  {
+    lkm_battery_removed = UPI_UG31XX_BATTERY_REMOVED;
+  }
+  else
+  {
+    lkm_battery_removed = UPI_UG31XX_BATTERY_INSERTED;
+  }
+
+  /// [AT-PM] : Update average external temperature buffer ; 11/27/2013
+  lkm_update_avg_external_temperature((_upi_s16_)ug31xx->measData.instExtTemperature);
+
+  upi_free(devInfo);
+  upi_free(devCapacity);
+  return (rtn);
+}
+
+/**
+ * @brief lkm_resume
+ *
+ *  Resume procedure for linux kernel module
+ *
+ * @para  user_space_response true if user space algorithm has responsed
+ * @return  0 if success
+ */
+int lkm_resume(char user_space_response)
+{
+  GGSTATUS rtn;
+  GG_DEVICE_INFO *devInfo;
+
+  rtn = 0;
+  lkm_last_update_time_tag = GetSysTickCount();
+
+  if(lkm_operation_mode == LKM_OPERATION_MODE_ENTER_SUSPEND)
+  {
+    lkm_operation_mode = LKM_OPERATION_MODE_SUSPEND;
+    lkm_suspend_update_delay = 0;
+    lkm_chk_backup_file_interval = 0;
+
+    devInfo = (GG_DEVICE_INFO *)upi_malloc(sizeof(GG_DEVICE_INFO));
+    if(devInfo == _UPI_NULL_)
+    {
+      return (-1);
+    }
+#ifndef FEATURE_DISABLE_SUSPEND_OPERATION
+    rtn = upiGG_Wakeup(lkm_gauge, lkm_dc_in_before_suspend);
+    if(rtn == UG_READ_DEVICE_INFO_SUCCESS)
+    {
+      rtn = upiGG_GetAlarmStatus(lkm_gauge, &lkm_alarm_status);
+    }
+#endif  ///< end of FEATURE_DISABLE_SUSPEND_OPERATION
+    upiGG_InternalSuspendMode(lkm_gauge, _UPI_FALSE_);
+
+    if(rtn == UG_MEAS_FAIL_BATTERY_REMOVED)
+    {
+      lkm_battery_removed = UPI_UG31XX_BATTERY_REMOVED;
+    }
+    else
+    {
+      lkm_battery_removed = UPI_UG31XX_BATTERY_INSERTED;
+    }
+
+    upi_free(devInfo);
+    rtn = lkm_check_fail_cnt((rtn == UG_READ_DEVICE_ALARM_SUCCESS) ? _UPI_TRUE_ : _UPI_FALSE_);
+    return (rtn);
+  }
+
+  if(lkm_operation_mode >= LKM_OPERATION_MODE_SUSPEND)
+  {
+    UG31_LOGI("[%s]: RESUME -> %d / %d\n", __func__, lkm_suspend_update_delay, lkm_operation_mode);
+
+    lkm_suspend_update_delay = lkm_suspend_update_delay + 1;
+    if(lkm_suspend_update_delay >= LKM_SUSPEND_UPDATE_INTERVAL)
+    {
+      lkm_suspend_update_delay = 0;
+      lkm_operation_mode = lkm_operation_mode + 1;
+
+      rtn = lkm_update_procedure((user_space_response == UG31XX_USER_SPACE_RESPONSE) ? _UPI_TRUE_ : _UPI_FALSE_);
+      rtn = lkm_check_fail_cnt((rtn == UG_READ_DEVICE_ALARM_SUCCESS) ? _UPI_TRUE_ : _UPI_FALSE_);
+      return (rtn);
+    }
+  }
+  return (0);
+}
+
+/**
+ * @brief lkm_shutdown
+ *
+ *  Shutdown procedure for linux kernel module
+ *
+ * @returen 0 if success
+ */
+int lkm_shutdown(void)
+{
+  GGSTATUS rtn;
+
+  rtn = upiGG_PrePowerOff(lkm_gauge);
+  return ((rtn == UG_READ_DEVICE_INFO_SUCCESS) ? 0 : -1);
+}
+
+#define UPI_POLLING_TIME_INIT_THRD      (15)
+
+/**
+ * @brief lkm_update
+ *
+ *  Update battery information procedure for linux kernel module
+ *
+ * @para  user_space_response true if user space algorithm has responsed
+ * @return  0 if success
+ */
+int lkm_update(char user_space_response)
+{
+  GGSTATUS rtn;
+  int oldRsoc;
+  struct ug31xx_data *ug31xx;
+
+  lkm_last_update_time_tag = GetSysTickCount();
+
+  if(lkm_operation_mode >= LKM_OPERATION_MODE_SUSPEND)
+  {
+    lkm_operation_mode = LKM_OPERATION_MODE_NORMAL;
+  }
+
+  upiGG_DebugSwitch(LKM_OPTIONS_DEBUG_LEVEL(lkm_options));
+  upiGG_ReverseCurrent(lkm_gauge, ((lkm_options & LKM_OPTIONS_ENABLE_REVERSE_CURRENT) ? _UPI_TRUE_ : _UPI_FALSE_));
+
+  ug31xx = (struct ug31xx_data *)lkm_gauge;
+  oldRsoc = (int)ug31xx->batteryInfo.RSOC;
+  rtn = lkm_update_procedure((user_space_response == UG31XX_USER_SPACE_RESPONSE) ? _UPI_TRUE_ : _UPI_FALSE_);
+
+  /// [AT-PM] : Check 0% RSOC ; 01/14/2014
+  if((lkm_polling_init_cnt < UPI_POLLING_TIME_INIT_THRD) &&
+     (ug31xx->measData.curr > 0) &&
+     (MEAS_CABLE_OUT(ug31xx->measData.status) == _UPI_FALSE_) &&
+     (ug31xx->batteryInfo.RSOC == 0))
+  {
+    upiGG_SetCapacity(lkm_gauge, 1);
+    UG31_LOGI("[%s]: Force to 1%%. (%d)\n", __func__,
+               lkm_polling_init_cnt);
+  }
+
+  /// [AT-PM] : Check backup file if RSOC is changed ; 05/16/2013
+  if(oldRsoc != ((int)ug31xx->batteryInfo.RSOC))
+  {
+    lkm_chk_backup_file_interval = LKM_CHECK_BACKUP_FILE_INTERVAL;
+  }
+  rtn = lkm_check_fail_cnt((rtn == UG_READ_DEVICE_ALARM_SUCCESS) ? _UPI_TRUE_ : _UPI_FALSE_);
+  return (rtn);
+}
+
+/**
+ * @brief lkm_reset
+ *
+ *  Reset linux kernel module
+ *
+ * @para  ggb address of ggb data
+ * @para  whether keep previous RSOC or not
+ * @return  0 if success
+ */
+int lkm_reset(char *ggb, char keep_rsoc)
+{
+  GGSTATUS rtn;
+  struct ug31xx_data *ug31xx;
+  _upi_u16_ rsoc;
+
+  upiGG_DebugSwitch(LKM_OPTIONS_DEBUG_LEVEL(lkm_options));
+
+  lkm_last_update_time_tag = GetSysTickCount();
+
+  ug31xx = (struct ug31xx_data *)lkm_gauge;
+  rsoc = ug31xx->batteryInfo.RSOC;
+
+  upiGG_UnInitial(&lkm_gauge);
+  rtn = upiGG_Initial(&lkm_gauge, (GGBX_FILE_HEADER *)ggb, _UPI_TRUE_);
+
+  ug31xx = (struct ug31xx_data *)lkm_gauge;
+  ug31xx->Options = (_upi_u8_)lkm_options;
+
+	if(keep_rsoc == _UPI_TRUE_)
+	{
+	  if(rsoc >= (ug31xx->batteryInfo.RSOC))
+	  {
+	    if((rsoc - (ug31xx->batteryInfo.RSOC)) <= LKM_MAX_RESET_DELTA_SOC)
+	    {
+	      upiGG_SetCapacity(lkm_gauge, (_upi_u8_)rsoc);
+	   }
+	  }
+	  else
+	  {
+	    if(((ug31xx->batteryInfo.RSOC) - rsoc) <= LKM_MAX_RESET_DELTA_SOC)
+	    {
+	      upiGG_SetCapacity(lkm_gauge, (_upi_u8_)rsoc);
+	    }
+	  }
+	}
+  lkm_set_version(ug31xx);
+
+  lkm_alarm_status = 0;
+  lkm_battery_removed = UPI_UG31XX_BATTERY_INSERTED;
+  lkm_chk_backup_file_interval = LKM_CHECK_BACKUP_FILE_INTERVAL;
+  lkm_operation_mode = LKM_OPERATION_MODE_NORMAL;
+  lkm_suspend_update_delay = LKM_CHECK_BACKUP_FILE_INTERVAL;
+  return ((rtn == UG_INIT_SUCCESS) ? 0 : -1);
+}
+
+/**
+ * @brief lkm_get_voltage
+ *
+ *  Get voltage for linux kernel module
+ *
+ * @return  voltage
+ */
+int lkm_get_voltage(void)
+{
+  struct ug31xx_data *ug31xx;
+
+  ug31xx = (struct ug31xx_data *)lkm_gauge;
+
+  return ((int)ug31xx->measData.bat1Voltage);
+}
+
+/**
+ * @brief lkm_get_current
+ *
+ *  Get current for linux kernel module
+ *
+ * @return  current
+ */
+int lkm_get_current(void)
+{
+  struct ug31xx_data *ug31xx;
+
+  ug31xx = (struct ug31xx_data *)lkm_gauge;
+
+  return ((int)ug31xx->measData.curr);
+}
+
+/**
+ * @brief lkm_get_external_temperature
+ *
+ *  Get external temperature for linux kernel module
+ *
+ * @return  external temperature
+ */
+int lkm_get_external_temperature(void)
+{
+  struct ug31xx_data *ug31xx;
+
+  ug31xx = (struct ug31xx_data *)lkm_gauge;
+
+  return ((int)ug31xx->measData.extTemperature);
+}
+
+/**
+ * @brief lkm_get_internal_temperature
+ *
+ *  Get internal temperature for linux kernel module
+ *
+ * @return  internal temperature
+ */
+int lkm_get_internal_temperature(void)
+{
+  struct ug31xx_data *ug31xx;
+
+  ug31xx = (struct ug31xx_data *)lkm_gauge;
+
+  return ((int)ug31xx->measData.intTemperature);
+}
+
+/**
+ * @brief lkm_get_remaining_capacity
+ *
+ *  Get remaining capacity for linux kernel module
+ *
+ * @return  remaining capacity
+ */
+int lkm_get_remaining_capacity(void)
+{
+  struct ug31xx_data *ug31xx;
+
+  ug31xx = (struct ug31xx_data *)lkm_gauge;
+
+  return ((int)ug31xx->batteryInfo.NAC);
+}
+
+/**
+ * @brief lkm_get_full_charge_capacity
+ *
+ *  Get full charge capacity for linux kernel module
+ *
+ * @return  full charge capacity
+ */
+int lkm_get_full_charge_capacity(void)
+{
+  struct ug31xx_data *ug31xx;
+
+  ug31xx = (struct ug31xx_data *)lkm_gauge;
+
+  return ((int)ug31xx->batteryInfo.LMD);
+}
+
+/**
+ * @brief lkm_get_relative_state_of_charge
+ *
+ *  Get relative state of charge for linux kernel module
+ *
+ * @return  relative state of charge
+ */
+int lkm_get_relative_state_of_charge(void)
+{
+  struct ug31xx_data *ug31xx;
+
+  ug31xx = (struct ug31xx_data *)lkm_gauge;
+  return ((int)ug31xx->batteryInfo.RSOC);
+}
+
+/**
+ * @brief lkm_get_version
+ *
+ *  Get version string for linux kernel module
+ *
+ * @return  version address
+ */
+char* lkm_get_version(void)
+{
+  return (lkm_version_string);
+}
+
+#define UPI_POLLING_TIME_CONST          (60)
+#define UPI_POLLING_TIME_NEAR_FULL      (10)
+#define UPI_POLLING_TIME_NEAR_FULL_SOC  (90)
+#define UPI_POLLING_TIME_MINIMUM        (5)
+#define UPI_POLLING_TIME_MAXIMUM        (30)
+#define UPI_POLLING_TIME_NOT_READY      (UPI_POLLING_TIME_MINIMUM - 1)      ///< [AT-PM] : Set to 4s ; 04/02/2014
+#define UPI_POLLING_TIME_VER_MISMATCH   (UPI_POLLING_TIME_NOT_READY - 1)    ///< [AT-PM] : Set to 3s ; 04/02/2014
+#define UPI_POLLING_TIME_FAIL_RETRY     (UPI_POLLING_TIME_VER_MISMATCH - 1) ///< [AT-PM] : Set to 2s ; 04/02/2014
+#define UPI_POLLING_TIME_DECIMATE_RST   (UPI_POLLING_TIME_FAIL_RETRY - 1)   ///< [AT-PM] : Set to 1s ; 04/02/2014
+#define UPI_POLLING_TIME_NTC_ABNORMAL   (60)
+#define UPI_POLLING_TIME_NEAR_OT        (10)
+#define UPI_POLLING_TIME_NEAR_UT        (10)
+#define UPI_POLLING_TIME_OT             (5)
+#define UPI_POLLING_TIME_UT             (5)
+#define UPI_POLLING_TIME_NEAR_OT_THRD   (400)
+#define UPI_POLLING_TIME_NEAR_UT_THRD   (50)
+#define UPI_POLLING_TIME_OT_THRD        (500)
+#define UPI_POLLING_TIME_UT_THRD        (0)
+
+_upi_s32_ polling_time_algorithm(void)
+{
+  struct ug31xx_data *ug31xx;
+  _upi_s32_ polling_time;
+
+  ug31xx = (struct ug31xx_data *)lkm_gauge;
+
+  if(lkm_operation_fail_cnt != 0)
+  {
+    polling_time = UPI_POLLING_TIME_FAIL_RETRY;
+  }
+  else if(ug31xx->backupData.backupFileSts == BACKUP_FILE_STS_VERSION_MISMATCH)
+  {
+    polling_time = UPI_POLLING_TIME_VER_MISMATCH;
+  }
+  else if(ug31xx->backupData.backupFileSts <= BACKUP_FILE_STS_EXIST)
+  {
+    polling_time = UPI_POLLING_TIME_NOT_READY;
+  }
+  else
+  {
+    if(ug31xx->capData.fcSts == CAP_TRUE)
+    {
+      polling_time = 60;
+    }
+    else if((ug31xx->measData.curr > 0) &&
+            ((ug31xx->capData.predictRsoc >= UPI_POLLING_TIME_NEAR_FULL_SOC) ||
+             (ug31xx->capData.tpTime > 0)))
+    {
+      polling_time = UPI_POLLING_TIME_NEAR_FULL;
+    }
+    else
+    {
+      if(ug31xx->capData.predictRsoc >= 50)
+      {
+        polling_time = 60;
+      }
+      else if(ug31xx->capData.predictRsoc >= 20)
+      {
+        polling_time = 30;
+      }
+      else if(ug31xx->capData.predictRsoc >= 5)
+      {
+        polling_time = 10;
+      }
+      else
+      {
+        polling_time = 5;
+      }
+    }
+
+    if(polling_time < UPI_POLLING_TIME_MINIMUM)
+    {
+      polling_time = UPI_POLLING_TIME_MINIMUM;
+    }
+    if(polling_time > UPI_POLLING_TIME_MAXIMUM)
+    {
+      polling_time = UPI_POLLING_TIME_MAXIMUM;
+    }
+  }
+
+  /// [AT-PM] : Check temperature range ; 11/28/2013
+  if((ug31xx->measData.extTemperature >= UPI_POLLING_TIME_OT_THRD) &&
+     (polling_time > UPI_POLLING_TIME_OT))
+  {
+    polling_time = UPI_POLLING_TIME_OT;
+  }
+  if((ug31xx->measData.extTemperature >= UPI_POLLING_TIME_NEAR_OT_THRD) &&
+     (polling_time > UPI_POLLING_TIME_NEAR_OT))
+  {
+    polling_time = UPI_POLLING_TIME_NEAR_OT;
+  }
+  if((ug31xx->measData.extTemperature <= UPI_POLLING_TIME_UT_THRD) &&
+     (polling_time > UPI_POLLING_TIME_UT))
+  {
+    polling_time = UPI_POLLING_TIME_UT;
+  }
+  if((ug31xx->measData.extTemperature <= UPI_POLLING_TIME_NEAR_UT_THRD) &&
+     (polling_time > UPI_POLLING_TIME_NEAR_UT))
+  {
+    polling_time = UPI_POLLING_TIME_NEAR_UT;
+  }
+
+  lkm_polling_init_cnt = lkm_polling_init_cnt + 1;
+  if(lkm_polling_init_cnt < UPI_POLLING_TIME_INIT_THRD)
+  {
+    polling_time = UPI_POLLING_TIME_NOT_READY;
+    UG31_LOGI("[%s]: Force polling time to %d seconds. (%d)\n", __func__,
+              polling_time,
+              lkm_polling_init_cnt);
+  }
+  else
+  {
+    lkm_polling_init_cnt = UPI_POLLING_TIME_INIT_THRD;
+  }
+
+  #ifdef  ENABLE_NTC_CHECK
+
+    if(upiGG_GetNtcStatus(lkm_gauge) == UG_MEAS_FAIL_NTC_SHORT)
+    {
+      polling_time = UPI_POLLING_TIME_NTC_ABNORMAL;
+      UG31_LOGE("[%s]: Force polling time to %d seconds because of UG_MEAS_FAIL_NTC_SHORT\n", __func__,
+                polling_time);
+    }
+    if(upiGG_GetNtcStatus(lkm_gauge) == UG_MEAS_FAIL_NTC_OPEN)
+    {
+      polling_time = UPI_POLLING_TIME_NTC_ABNORMAL;
+      UG31_LOGE("[%s]: Force polling time to %d seconds because of UG_MEAS_FAIL_NTC_OPEN\n", __func__,
+                polling_time);
+    }
+
+  #endif  ///< end of ENABLE_NTC_CHECK
+
+  if(ug31xx->sysData.adcCheckData.decimateRst == _UPI_TRUE_)
+  {
+    polling_time = UPI_POLLING_TIME_DECIMATE_RST;
+    UG31_LOGE("[%s]: Force polling time to %d seconds because of DECIMATE_RST\n", __func__,
+              polling_time);
+  }
+  UG31_LOGN("[%s]: Time interval = %d seconds (%d)\n", __func__,
+            polling_time,
+            lkm_polling_init_cnt);
+  return (polling_time);
+}
+
+/**
+ * @brief lkm_get_polling_time
+ *
+ *  Get polling time interval for linux kernel module
+ *
+ * @return  polling time interval
+ */
+int lkm_get_polling_time(void)
+{
+  struct ug31xx_data *ug31xx;
+  _upi_s32_ polling_time;
+
+  ug31xx = (struct ug31xx_data *)lkm_gauge;
+
+  /// [AT-PM] : Check SOC range ; 12/10/2013
+  if(ug31xx->capData.predictRsoc >= 50)
+  {
+    polling_time = 60;
+  }
+  else if(ug31xx->capData.predictRsoc >= 20)
+  {
+    polling_time = 30;
+  }
+  else if(ug31xx->capData.predictRsoc >= 5)
+  {
+    polling_time = 10;
+  }
+  else
+  {
+    polling_time = 5;
+  }
+
+  /// [AT-PM] : Check temperature range ; 11/28/2013
+  if((ug31xx->measData.extTemperature >= UPI_POLLING_TIME_OT_THRD) &&
+     (polling_time > UPI_POLLING_TIME_OT))
+  {
+    polling_time = UPI_POLLING_TIME_OT;
+  }
+  if((ug31xx->measData.extTemperature >= UPI_POLLING_TIME_NEAR_OT_THRD) &&
+     (polling_time > UPI_POLLING_TIME_NEAR_OT))
+  {
+    polling_time = UPI_POLLING_TIME_NEAR_OT;
+  }
+  if((ug31xx->measData.extTemperature <= UPI_POLLING_TIME_UT_THRD) &&
+     (polling_time > UPI_POLLING_TIME_UT))
+  {
+    polling_time = UPI_POLLING_TIME_UT;
+  }
+  if((ug31xx->measData.extTemperature <= UPI_POLLING_TIME_NEAR_UT_THRD) &&
+     (polling_time > UPI_POLLING_TIME_NEAR_UT))
+  {
+    polling_time = UPI_POLLING_TIME_NEAR_UT;
+  }
+  UG31_LOGN("[%s]: Polling time = %d seconds\n", __func__, polling_time);
+  return (polling_time);
+}
+
+/**
+ * @brief lkm_get_module_ready
+ *
+ *  Get module is ready or not for linux kernel module
+ *
+ * @return  UPI_UG31XX_MODULE_READY or UPI_UG31XX_MODULE_NOT_READY
+ */
+int lkm_get_module_ready(void)
+{
+  struct ug31xx_data *ug31xx;
+
+  ug31xx = (struct ug31xx_data *)lkm_gauge;
+
+  return ((ug31xx->batteryInfo.Ready == UG_CAP_DATA_READY) ? UPI_UG31XX_MODULE_READY : UPI_UG31XX_MODULE_NOT_READY);
+}
+
+/**
+ * @brief lkm_get_battery_removed
+ *
+ *  Get battery is removed or not for linux kernel module
+ *
+ * @return  UPI_UG31XX_BATTERY_REMOVED or UPI_UG31XX_BATTERY_INSERTED
+ */
+int lkm_get_battery_removed(void)
+{
+  return (lkm_battery_removed);
+}
+
+/**
+ * @brief lkm_get_alarm_status
+ *
+ *  Get alarm status for linux kernel module
+ *
+ * @return  alarm status
+ */
+int lkm_get_alarm_status(void)
+{
+  GGSTATUS rtn;
+  _upi_u8_ alarmSts;
+
+  lkm_alarm_status = 0;
+  alarmSts = 0;
+
+  rtn = upiGG_GetAlarmStatus(lkm_gauge, &alarmSts);
+  if(rtn == UG_READ_DEVICE_ALARM_SUCCESS)
+  {
+    if(alarmSts & ALARM_STATUS_UV)
+    {
+      lkm_alarm_status = lkm_alarm_status | UPI_UG31XX_ALARM_STATUS_UV;
+    }
+    if(alarmSts & ALARM_STATUS_UET)
+    {
+      lkm_alarm_status = lkm_alarm_status | UPI_UG31XX_ALARM_STATUS_UET;
+    }
+    if(alarmSts & ALARM_STATUS_OET)
+    {
+      lkm_alarm_status = lkm_alarm_status | UPI_UG31XX_ALARM_STATUS_OET;
+    }
+  }
+  return (lkm_alarm_status);
+}
+
+/**
+ * @brief lkm_set_backup_file
+ *
+ *  Enable/disable backup file operation
+ *
+ * @para  enable  set 0 to disable backup file operation
+ * @return  0 if success
+ */
+int lkm_set_backup_file(char enable)
+{
+  _upi_bool_ backupEN;
+
+  backupEN = (enable == 0) ? _UPI_FALSE_ : _UPI_TRUE_;
+  upiGG_BackupFileSwitch(backupEN);
+  return (0);
+}
+
+/**
+ * @brief lkm_chk_backup_file
+ *
+ *  Check backup file procedure
+ *
+ * @return  0 if success, 1 if version mismatched, -1 if fail
+ */
+int lkm_chk_backup_file(void)
+{
+  _upi_u8_ rtn;
+  struct ug31xx_data *ug31xx;
+
+  ug31xx = (struct ug31xx_data *)lkm_gauge;
+
+  if(ug31xx->batteryInfo.Ready != UG_CAP_DATA_READY)
+  {
+    lkm_chk_backup_file_interval = LKM_CHECK_BACKUP_FILE_INTERVAL;
+  }
+
+  lkm_chk_backup_file_interval = lkm_chk_backup_file_interval + 1;
+  UG31_LOGN("[%s]: lkm_chk_backup_file_interval = %d (%d)\n", __func__,
+            lkm_chk_backup_file_interval, LKM_CHECK_BACKUP_FILE_INTERVAL);
+  if(lkm_chk_backup_file_interval > LKM_CHECK_BACKUP_FILE_INTERVAL)
+  {
+    rtn = upiGG_BackupFileCheck(lkm_gauge, lkm_backup_filename, lkm_suspend_filename);
+    if(rtn == UG_CAP_DATA_VERSION_MISMATCH)
+    {
+      UG31_LOGE("[%s]: Driver version mismatched.\n", __func__);
+      return (1);
+    }
+    if(rtn == UG_CAP_DATA_READY)
+    {
+      lkm_chk_backup_file_interval = 0;
+    }
+  }
+  return (0);
+}
+
+#define LKM_SET_CHARGER_FULL_STEP_THRESHOLD (95)
+
+/**
+ * @brief lkm_set_charger_full
+ *
+ *  Set charger full signal
+ *
+ * @para  is_full set 0 if charger does not detect full
+ * @return  0 if success
+ */
+int lkm_set_charger_full(char is_full)
+{
+  struct ug31xx_data *ug31xx;
+  _upi_u8_ soc;
+
+  ug31xx = (struct ug31xx_data *)lkm_gauge;
+
+  if(is_full == UG31XX_CHARGER_NO_DETECTS_FULL)
+  {
+    /// [AT-PM] : No full charge detects ; 09/03/2013
+    UpiSetChargerFull(&ug31xx->capData, _UPI_FALSE_);
+    return (0);
+  }
+
+  if((is_full != UG31XX_CHARGER_DETECTS_FULL) &&
+     (is_full != UG31XX_CHARGER_DETECTS_FULL_STEP) &&
+     (is_full != UG31XX_CHARGER_DETECTS_FULL_CHECK) &&
+     (is_full != UG31XX_TAPER_REACHED))
+  {
+    return (0);
+  }
+
+  /// [AT-PM] : Full charge detects ; 09/03/2013
+  ug31xx->batteryInfo.NAC = (_upi_u16_)ug31xx->capData.rm;
+  ug31xx->batteryInfo.LMD = (_upi_u16_)ug31xx->capData.fcc;
+  ug31xx->batteryInfo.RSOC = (_upi_u16_)ug31xx->capData.rsoc;
+
+  /// [AT-PM] : Get current soc ; 03/20/2014
+  soc = UpiGetOcvSoc(&ug31xx->capData, ug31xx->measData.bat1Voltage);
+
+  /// [AT-PM] : Check full charge threshold ; 03/20/2014
+  if(((is_full == UG31XX_CHARGER_DETECTS_FULL_STEP) ||
+      (is_full == UG31XX_CHARGER_DETECTS_FULL_CHECK)) &&
+     (soc < LKM_SET_CHARGER_FULL_STEP_THRESHOLD))
+  {
+    UG31_LOGE("[%s]: (%d) %d < %d -> No full status and keep %d (T:%d)\n", __func__,
+              is_full,
+              soc,
+              LKM_SET_CHARGER_FULL_STEP_THRESHOLD,
+              ug31xx->batteryInfo.RSOC,
+              ug31xx->measData.extTemperature);
+    return (0);
+  }
+
+  UpiSetChargerFull(&ug31xx->capData, _UPI_TRUE_);
+
+  if((is_full == UG31XX_TAPER_REACHED) ||
+     (is_full == UG31XX_CHARGER_DETECTS_FULL_STEP))
+  {
+    /// [AT-PM] : Avoid RSOC jumping ; 09/03/2013
+    UpiSetChargerFullStep(&ug31xx->capData, &ug31xx->batteryInfo);
+  }
+
+  /// [AT-PM] : Reset coulomb counter ; 07/18/2013^M
+  UpiResetCoulombCounter(&ug31xx->measData);
+  UpiAdcStatus(&ug31xx->sysData);
+  ug31xx->sysData.cycleCount = (_sys_u16_)ug31xx->measData.cycleCount;
+
+  /// [AT-PM] : Save battery information to IC ; 01/31/2013
+  ug31xx->sysData.rmFromIC = (_sys_u16_)ug31xx->capData.rm;
+  ug31xx->sysData.fccFromIC = (_sys_u16_)ug31xx->capData.fcc;
+  ug31xx->sysData.rsocFromIC = (_sys_u8_)ug31xx->capData.rsoc;
+  ug31xx->sysData.tableUpdateIdxFromIC = ug31xx->capData.tableUpdateIdx;
+  ug31xx->sysData.deltaCapFromIC = ug31xx->measData.lastDeltaCap;
+  ug31xx->sysData.adc1ConvTime = ug31xx->measData.adc1ConvertTime;
+  ug31xx->sysData.ccOffset = (_sys_s8_)ug31xx->measData.ccOffsetAdj;
+  ug31xx->sysData.standbyDsgRatio = (_sys_u8_)ug31xx->capData.standbyDsgRatio;
+  ug31xx->sysData.voltage = (_sys_u16_)ug31xx->measData.bat1Voltage;
+  UpiSaveBatInfoTOIC(&ug31xx->sysData);
+
+  ug31xx->batteryInfo.NAC = (_upi_u16_)ug31xx->capData.rm;
+  ug31xx->batteryInfo.LMD = (_upi_u16_)ug31xx->capData.fcc;
+  ug31xx->batteryInfo.RSOC = (_upi_u16_)ug31xx->capData.rsoc;
+  UG31_LOGI("[%s]: %d / %d = %d (%d)\n", __func__, ug31xx->batteryInfo.NAC, ug31xx->batteryInfo.LMD, ug31xx->batteryInfo.RSOC, is_full);
+  return (0);
+}
+
+/**
+ * @brief lkm_set_taper_current
+ *
+ *  Set taper current
+ *
+ * @para  curr  new taper current
+ * @return  0 if success
+ */
+int lkm_set_taper_current(int curr)
+{
+  struct ug31xx_data *ug31xx;
+
+  ug31xx = (struct ug31xx_data *)lkm_gauge;
+
+  ug31xx->cellParameter.TPCurrent = (_upi_u16_)curr;
+  UG31_LOGE("[%s]: TPCurrent = %d\n", __func__,
+            curr);
+  return (0);
+}
+
+/**
+ * @brief lkm_set_taper_voltage
+ *
+ *  Set taper voltage
+ *
+ * @para  curr  new taper voltage
+ * @return  0 if success
+ */
+int lkm_set_taper_voltage(int volt)
+{
+  struct ug31xx_data *ug31xx;
+
+  ug31xx = (struct ug31xx_data *)lkm_gauge;
+
+  ug31xx->cellParameter.TPVoltage = (_upi_u16_)volt;
+  UG31_LOGE("[%s]: TPVoltage = %d\n", __func__,
+            volt);
+  return (0);
+}
+
+/**
+ * @brief lkm_get_taper_current
+ *
+ *  Get taper current setting
+ *
+ * @return  taper current
+ */
+int lkm_get_taper_current(void)
+{
+  struct ug31xx_data *ug31xx;
+
+  ug31xx = (struct ug31xx_data *)lkm_gauge;
+
+  return ((int)ug31xx->cellParameter.TPCurrent);
+}
+
+/**
+ * @brief lkm_get_taper_voltage
+ *
+ *  Get taper voltage setting
+ *
+ * @return  taper voltage
+ */
+int lkm_get_taper_voltage(void)
+{
+  struct ug31xx_data *ug31xx;
+
+  ug31xx = (struct ug31xx_data *)lkm_gauge;
+
+  return ((int)ug31xx->cellParameter.TPVoltage);
+}
+
+/**
+ * @brief lkm_get_full_charge_status
+ *
+ *  Get full charge status is reached or not
+ *
+ * @return  1 if full charge status is reached
+ */
+int lkm_get_full_charge_status(void)
+{
+  struct ug31xx_data *ug31xx;
+
+  ug31xx = (struct ug31xx_data *)lkm_gauge;
+
+  if(ug31xx->capData.fcSts == CAP_TRUE)
+  {
+    return (1);
+  }
+
+  if(ug31xx->capData.fcStep100 == CAP_TRUE)
+  {
+    return (-1);
+  }
+
+  return (0);
+}
+
+/**
+ * @brief lkm_get_design_capacity
+ *
+ *  Get design capacity
+ *
+ * @return  design capacity in mAh
+ */
+int lkm_get_design_capacity(void)
+{
+  struct ug31xx_data *ug31xx;
+
+  ug31xx = (struct ug31xx_data *)lkm_gauge;
+  return ((int)ug31xx->cellParameter.ILMD);
+}
+
+/**
+ * @brief lkm_set_battery_temp_external
+ *
+ *  Set battery temperature from external
+ *
+ * @return  0 if success
+ */
+int lkm_set_battery_temp_external(void)
+{
+  upiGG_SetBatteryET(lkm_gauge);
+  return (0);
+}
+
+/**
+ * @brief lkm_set_battery_temp_internal
+ *
+ *  Set battery temperature from internal
+ *
+ * @return  0 if success
+ */
+int lkm_set_battery_temp_internal(void)
+{
+  upiGG_SetBatteryIT(lkm_gauge);
+  return (0);
+}
+
+/**
+ * @brief lkm_get_rsense
+ *
+ *  Get R-Sense value
+ *
+ * @return  R-Sense value in mOhm
+ */
+int lkm_get_rsense(void)
+{
+  struct ug31xx_data *ug31xx;
+
+  ug31xx = (struct ug31xx_data *)lkm_gauge;
+  return ((int)ug31xx->cellParameter.rSense);
+}
+
+/**
+ * @brief lkm_set_rsense
+ *
+ *  Set R-Sense value
+ *
+ * @para  rsense  R-Sense value in mOhm
+ * @return  0 if success
+ */
+int lkm_set_rsense(int rsense)
+{
+  struct ug31xx_data *ug31xx;
+
+  ug31xx = (struct ug31xx_data *)lkm_gauge;
+
+  ug31xx->cellParameter.rSense = (_upi_u8_)rsense;
+  UG31_LOGE("[%s]: rSense = %d\n", __func__,
+            rsense);
+  return (0);
+}
+
+/**
+ * @brief lkm_get_predict_rsoc
+ *
+ *  Get predicted RSOC
+ *
+ * @return  predicted RSOC in %
+ */
+int lkm_get_predict_rsoc(void)
+{
+  struct ug31xx_data *ug31xx;
+
+  ug31xx = (struct ug31xx_data *)lkm_gauge;
+
+  return ((int)(ug31xx->capData.predictRsoc));
+}
+
+/**
+ * @brief lkm_saveDataToIC_switch
+ *
+ *  Enable/Disable the function of save table to IC
+ *
+ * @return  0 if success
+ */
+int lkm_saveDataToIC_switch(_upi_bool_ enable)
+{
+  Ug31SaveDataEnable = enable;
+  return (0);
+}
+
+/**
+ * @brief lkm_change_to_pri_batt
+ *
+ *  Change current cell table to primary battery
+ *
+ * @return  0 if success
+ */
+int lkm_change_to_pri_batt(char *ggb, char pri_batt)
+{
+  struct ug31xx_data *ug31xx;
+  SYSTEM_RTN_CODE rtn;
+
+  ug31xx = (struct ug31xx_data *)lkm_gauge;
+  ptrGgbBuf = (GGBX_FILE_HEADER *)ggb;
+  rtn = UpiInitSystemData(&ug31xx->sysData);
+  if(rtn != SYSTEM_RTN_PASS)
+  {
+    if(rtn == SYSTEM_RTN_READ_GGB_FAIL)
+    {
+      return (UG_READ_GGB_FAIL);
+    }
+    return (UG_NOT_DEF);
+  }
+  /// Reset coulomb counter
+  UpiResetCoulombCounter(&ug31xx->measData);
+  UpiAdcStatus(&ug31xx->sysData);
+  ug31xx->sysData.cycleCount = (_sys_u16_)ug31xx->measData.cycleCount;
+  /// Inital capacity
+  UpiInitCapacity(&ug31xx->capData);
+  ug31xx->batteryInfo.NAC = (_upi_u16_)ug31xx->capData.rm;
+  ug31xx->batteryInfo.LMD = (_upi_u16_)ug31xx->capData.fcc;
+  ug31xx->batteryInfo.RSOC = (_upi_u16_)ug31xx->capData.rsoc;
+  UG31_LOGN("[%s]: Init data from table -> %d/%d = %d\n", __func__,
+            ug31xx->batteryInfo.NAC, ug31xx->batteryInfo.LMD, ug31xx->batteryInfo.RSOC);
+  UpiInitDsgCharge(&ug31xx->capData);
+  UpiAdjustCCRecord(&ug31xx->capData);
+
+  if(pri_batt == _UPI_TRUE_)
+  {
+    ug31xx->sysData.rmFromIC = ug31xx->batteryInfo.NAC;
+    ug31xx->sysData.fccFromIC = ug31xx->batteryInfo.LMD;
+    ug31xx->sysData.rsocFromIC = (_sys_u8_)ug31xx->batteryInfo.RSOC;
+    ug31xx->sysData.tableUpdateIdxFromIC = SOV_NUMS;
+    ug31xx->sysData.deltaCapFromIC = 0;
+    ug31xx->sysData.adc1ConvTime = ug31xx->measData.adc1ConvertTime;
+    ug31xx->sysData.ccOffset = (_sys_s8_)ug31xx->measData.ccOffsetAdj;
+    ug31xx->sysData.standbyDsgRatio = (_sys_u8_)ug31xx->capData.standbyDsgRatio;
+    ug31xx->sysData.voltage = (_sys_u16_)ug31xx->measData.bat1Voltage;
+    UpiSaveBatInfoTOIC(&ug31xx->sysData);
+    /// Load table
+    UpiLoadTableFromIC((_sys_u8_ *)ug31xx->capData.encriptTable);
+    UpiInitNacTable(&ug31xx->capData);
+  }
+  return (0);
+}
+
+/**
+ * @brief lkm_set_backup_file_name
+ *
+ *  Set backup filename
+ *
+ * @para  filename  filename of backup file
+ * @para  length  length of filename
+ * @return  0 if success
+ */
+int lkm_set_backup_file_name(char *filename, int length)
+{
+  if(lkm_backup_filename != _UPI_NULL_)
+  {
+    upi_free(lkm_backup_filename);
+  }
+  lkm_backup_filename = (char *)upi_malloc((_upi_u32_)length);
+  upi_memcpy(lkm_backup_filename, filename, (_upi_u32_)length);
+  return (0);
+}
+
+/**
+ * @brief lkm_set_suspend_file_name
+ *
+ *  Set suspend data backup filename
+ *
+ * @para  filename  filename of suspend backup file
+ * @para  length  length of filename
+ * @return  0 if success
+ */
+int lkm_set_suspend_file_name(char *filename, int length)
+{
+  if(lkm_suspend_filename != _UPI_NULL_)
+  {
+    upi_free(lkm_suspend_filename);
+  }
+  lkm_suspend_filename = (char *)upi_malloc((_upi_u32_)length);
+  upi_memcpy(lkm_suspend_filename, filename, (_upi_u32_)length);
+  return (0);
+}
+
+/**
+ * @brief lkm_set_options
+ *
+ *  Set kernel module operation options
+ *
+ * @para  options options from insmod
+ * @return  0 if success
+ */
+int lkm_set_options(unsigned char options)
+{
+  lkm_options = options;
+  return (0);
+}
+
+/**
+ * @brief lkm_get_gpio
+ *
+ *  Get GPIO status
+ *
+ * @para  gpio  uG31xx gpio index
+ * @return  ug31xx_gpio_status_t
+ */
+int lkm_get_gpio(ug31xx_gpio_idx_t gpio)
+{
+  _upi_bool_ rtn;
+  _upi_u16_ addr;
+  _upi_u8_ mask;
+  _upi_u8_ value;
+
+  switch(gpio)
+  {
+    case  UG31XX_GPIO_1:
+      addr = REG_CTRL1;
+      mask = CTRL1_IO1DATA;
+      break;
+    case  UG31XX_GPIO_2:
+      addr = REG_CTRL2;
+      mask = CTRL2_IO2DATA;
+      break;
+    case  UG31XX_GPIO_3:
+      addr = REG_CTRL2;
+      mask = CTRL2_IO3DATA;
+      break;
+    case  UG31XX_GPIO_4:
+      addr = REG_CTRL2;
+      mask = CTRL2_IO4DATA;
+      break;
+    default:
+      return (UG31XX_GPIO_STS_UNKNOWN);
+  }
+
+  rtn = API_I2C_Read(_UPI_FALSE_, _UPI_FALSE_, _UPI_FALSE_, addr, 1, &value);
+  if(rtn != _UPI_TRUE_)
+  {
+    return (UG31XX_GPIO_STS_UNKNOWN);
+  }
+
+  return ((value & mask) ? UG31XX_GPIO_STS_HIGH : UG31XX_GPIO_STS_LOW);
+}
+
+/**
+ * @brief lkm_set_gpio
+ *
+ *  Set GPIO status
+ *
+ * @para  gpio  uG31xx gpio index
+ * @para  status  uG31xx gpio status
+ * @return  0 if success
+ */
+int lkm_set_gpio(ug31xx_gpio_idx_t gpio, int status)
+{
+  _upi_bool_ rtn;
+  _upi_u16_ addr;
+  _upi_u8_ mask;
+  _upi_u8_ value;
+
+  switch (gpio)
+  {
+    case  UG31XX_GPIO_1:
+      addr = REG_CTRL1;
+      mask = CTRL1_IO1DATA;
+      break;
+    case  UG31XX_GPIO_2:
+      addr = REG_CTRL2;
+      mask = CTRL2_IO2DATA;
+      break;
+    case  UG31XX_GPIO_3:
+      addr = REG_CTRL2;
+      mask = CTRL2_IO3DATA;
+      break;
+    case  UG31XX_GPIO_4:
+      addr = REG_CTRL2;
+      mask = CTRL2_IO4DATA;
+      break;
+    default:
+      return (-1);
+  }
+
+  rtn = API_I2C_Read(_UPI_FALSE_, _UPI_FALSE_, _UPI_FALSE_, addr, 1, &value);
+  if(rtn != _UPI_TRUE_)
+  {
+    return (-1);
+  }
+
+  if(status == UG31XX_GPIO_STS_LOW)
+  {
+    value = value & (~mask);
+  }
+  else if(status == UG31XX_GPIO_STS_HIGH)
+  {
+    value = value | mask;
+  }
+  else
+  {
+    return (-1);
+  }
+
+  rtn = API_I2C_Write(_UPI_FALSE_, _UPI_FALSE_, _UPI_FALSE_, addr, 1, &value);
+  return ((rtn == _UPI_TRUE_) ? 0 : -1);
+}
+
+/**
+ * @brief lkm_get_cycle_count
+ *
+ *  Get cycle count information
+ *
+ * @return  cycle count
+ */
+int lkm_get_cycle_count(void)
+{
+  int cycleCount;
+
+  cycleCount = upiGG_GetCycleCount(lkm_gauge);
+  return (cycleCount);
+}
+
+/**
+ * @brief lkm_reset_cycle_count
+ *
+ *  Reset cycle count information
+ *
+ * @return  0 if success
+ */
+int lkm_reset_cycle_count(void)
+{
+  int rtn;
+
+  rtn = upiGG_SetCycleCount(lkm_gauge, 0);
+  return (rtn);
+}
+
+int lkm_i2c_read(unsigned short addr, unsigned char *data)
+{
+  int rtn;
+  rtn = API_I2C_Read((addr < 0x80)? NORMAL: SECURITY,
+                     UG31XX_I2C_HIGH_SPEED_MODE,
+                     UG31XX_I2C_TEM_BITS_MODE,
+                     addr,
+                     1,
+                     data);
+  return ((rtn == _UPI_TRUE_) ? 0 : -1);
+}
+
+int lkm_i2c_write(unsigned short addr, unsigned char *data)
+{
+  int rtn;
+  rtn = API_I2C_Write((addr < 0x80)? NORMAL: SECURITY,
+                      UG31XX_I2C_HIGH_SPEED_MODE,
+                      UG31XX_I2C_TEM_BITS_MODE,
+                      addr,
+                      1,
+                      data);
+  return ((rtn == _UPI_TRUE_) ? 0 : -1);
+}
+
+/**
+ * @brief lkm_adjust_cell_table
+ *
+ *  Adjust current cell table according to design capacity
+ *
+ * @para  origianl_design_capacity original design capacity
+ * @para  adjust_design_capacity target design capacity
+ * @return  0 if success
+ */
+int lkm_adjust_cell_table(unsigned short adjust_design_capacity, char force_reset)
+{
+  _upi_u8_ u8Temp;
+  _upi_u8_ u8TempHigh;
+  _upi_u16_ cycleCount;
+
+  /// [FC] : Load cycle count ; 06/09/2014
+  API_I2C_Read((BACKUP_CYCLE_COUNT_LOW < 0x80)? NORMAL: SECURITY,
+               UG31XX_I2C_HIGH_SPEED_MODE,
+               UG31XX_I2C_TEM_BITS_MODE,
+               BACKUP_CYCLE_COUNT_LOW,
+               1,
+               &u8Temp);
+  API_I2C_Read(( BACKUP_CYCLE_COUNT_HIGH< 0x80)? NORMAL: SECURITY,
+               UG31XX_I2C_HIGH_SPEED_MODE,
+               UG31XX_I2C_TEM_BITS_MODE,
+               BACKUP_CYCLE_COUNT_HIGH,
+               1,
+               &u8TempHigh);
+  cycleCount = u8TempHigh;
+  cycleCount = cycleCount*256 + u8Temp;
+
+	if((adjust_design_capacity != cycleCount) || (force_reset == _UPI_TRUE_))
+	{
+		Ug31AdjustCellTableNeed = _UPI_TRUE_;
+		/// [FC] : Save cycle count ; 06/09/2014
+		u8Temp = adjust_design_capacity >> 8;
+		API_I2C_Write((BACKUP_CYCLE_COUNT_HIGH < 0x80)? NORMAL: SECURITY,
+									UG31XX_I2C_HIGH_SPEED_MODE,
+									UG31XX_I2C_TEM_BITS_MODE,
+									BACKUP_CYCLE_COUNT_HIGH,
+									1,
+									&u8Temp);
+		u8Temp = adjust_design_capacity & 0x00ff;
+		API_I2C_Write((BACKUP_CYCLE_COUNT_LOW < 0x80)? NORMAL: SECURITY,
+									UG31XX_I2C_HIGH_SPEED_MODE,
+									UG31XX_I2C_TEM_BITS_MODE,
+									BACKUP_CYCLE_COUNT_LOW,
+									1,
+									&u8Temp);
+		UG31_LOGE("[%s]: Save Cycle Count = %d\n", __func__, adjust_design_capacity);
+	}
+	else
+	{
+		Ug31AdjustCellTableNeed = _UPI_FALSE_;
+	  new_design_capacity = adjust_design_capacity;
+		UG31_LOGE("[%s]: Don't need adjust table than set ILMD = %d\n", __func__, adjust_design_capacity);
+	}
+  return (0);
+}
+
+/**
+ * @brief lkm_get_avg_external_temperature
+ *
+ *  Get average instant external temperature
+ *
+ * @return  average instant external temperature
+ */
+int lkm_get_avg_external_temperature(void)
+{
+  _upi_u8_ idx;
+  _upi_s32_ avgTemp;
+
+  /// [AT-PM] : Calculate average external temperature from buffer ; 11/27/2013
+  avgTemp = 0;
+  idx = 0;
+  while(idx < LKM_AVG_TEMPERATURE_COUNT)
+  {
+    avgTemp = avgTemp + lkm_avg_ext_temperature_buf[idx];
+    idx = idx + 1;
+  }
+  avgTemp = avgTemp/LKM_AVG_TEMPERATURE_COUNT;
+  return ((int)avgTemp);
+}
+
+/**
+ * @brief lkm_get_ntc_status
+ *
+ *  Get NTC status
+ *
+ * @return  0 if normal
+ */
+int lkm_get_ntc_status(void)
+{
+  if(upiGG_GetNtcStatus(lkm_gauge) == UG_MEAS_FAIL_NTC_SHORT)
+  {
+    return (UPI_UG31XX_NTC_SHORT);
+  }
+
+  if(upiGG_GetNtcStatus(lkm_gauge) == UG_MEAS_FAIL_NTC_OPEN)
+  {
+    return (UPI_UG31XX_NTC_OPEN);
+  }
+
+  return (UPI_UG31XX_NTC_NORMAL);
+}
+
+/**
+ * @brief lkm_get_backup_buffer
+ *
+ *  Get backup buffer address and size
+ *
+ * @para  size  address of backup buffer size
+ * @return  address of backup buffer
+ */
+unsigned char * lkm_get_backup_buffer(int *size)
+{
+  unsigned char *bufAddr;
+  unsigned char bufSize;
+
+  bufAddr = upiGG_AccessBackupBuffer(lkm_gauge, (_upi_u8_ *)&bufSize);
+  *size = (int)bufSize;
+  return (bufAddr);
+}
+
+/**
+ * @brief lkm_set_shell_ap
+ *
+ *  Set shell AP name
+ *
+ * @para  apname  AP name
+ * @para  length  length of filename
+ * @return  0 if success
+ */
+int lkm_set_shell_ap(char *apname, int length)
+{
+  if(lkm_shell_ap_name != _UPI_NULL_)
+  {
+    upi_free(lkm_shell_ap_name);
+  }
+  lkm_shell_ap_name = (char *)upi_malloc((_upi_u32_)length);
+  upi_memcpy(lkm_shell_ap_name, apname, (_upi_u32_)length);
+  set_shell_ap_name(lkm_shell_ap_name);
+  return (0);
+}
+
+/**
+ * @brief lkm_get_backup_daemon_cntl
+ *
+ *  Get control for backup daemon
+ *
+ * @return  control
+ */
+unsigned char lkm_get_backup_daemon_cntl(void)
+{
+  unsigned char cntl;
+
+  cntl = (unsigned char)get_file_op_status();
+  return (cntl);
+}
+
+/**
+ * @brief lkm_set_backup_daemon_cntl
+ *
+ *  Set control for backup daemon
+ *
+ * @para  cntl  control to be set
+ * @return  0 if success
+ */
+int lkm_set_backup_daemon_cntl(unsigned char cntl)
+{
+  cntl = cntl & (~(UG31XX_KERNEL_FILE_EXIST | UG31XX_KERNEL_FILE_READ | UG31XX_KERNEL_FILE_WRITE));
+
+  clear_file_op_status_bit(UG31XX_KERNEL_FILE_FINISH);
+  clear_file_op_status_bit(UG31XX_USER_FILE_EXIST);
+  clear_file_op_status_bit(UG31XX_USER_FILE_READ);
+  clear_file_op_status_bit(UG31XX_USER_FILE_WRITE);
+
+  set_file_op_status_bit(cntl);
+  return (0);
+}
+
+/**
+ * @brief lkm_get_backup_daemon_period
+ *
+ *  Get period of backup daemon
+ *
+ * @return  period time in second
+ */
+unsigned char lkm_get_backup_daemon_period(void)
+{
+  unsigned char period;
+  _upi_s32_ tmp32;
+
+  period = (unsigned char)polling_time_algorithm();
+
+  tmp32 = LKM_CHECK_BACKUP_FILE_INTERVAL;
+  tmp32 = tmp32 - lkm_chk_backup_file_interval;
+  if(tmp32 > 1)
+  {
+    tmp32 = tmp32*period;
+    if(tmp32 > 255)
+    {
+      tmp32 = 255;
+    }
+    period = (unsigned char)tmp32;
+  }
+  return (period);
+}
+
+/**
+ * @brief lkm_get_current_now
+ *
+ *  Get current now
+ *
+ * @return  current in mA
+ */
+int lkm_get_current_now(void)
+{
+  struct ug31xx_data *ug31xx;
+
+  ug31xx = (struct ug31xx_data *)lkm_gauge;
+
+  upiGG_FetchCurrent(lkm_gauge);
+  return (ug31xx->measData.curr);
+}
+
+/**
+ * @brief lkm_get_voltage_now
+ *
+ *  Get voltage now
+ *
+ * @return  voltage in mA
+ */
+int lkm_get_voltage_now(void)
+{
+  struct ug31xx_data *ug31xx;
+
+  ug31xx = (struct ug31xx_data *)lkm_gauge;
+
+  upiGG_FetchVoltage(lkm_gauge);
+  return (ug31xx->measData.bat1Voltage);
+}
+
+/**
+ * @brief lkm_get_external_temperature_now
+ *
+ *  Get external temperature now
+ *
+ * @return  voltage in mA
+ */
+int lkm_get_external_temperature_now(void)
+{
+  struct ug31xx_data *ug31xx;
+
+  ug31xx = (struct ug31xx_data *)lkm_gauge;
+
+  upiGG_FetchExternalTemperature(lkm_gauge);
+  lkm_update_avg_external_temperature((_upi_s16_)ug31xx->measData.instExtTemperature);
+  return(ug31xx->measData.extTemperature);
+}
+
+/**
+ * @brief lkm_get_internal_temperature_now
+ *
+ *  Get internal temperature now
+ *
+ * @return  voltage in mA
+ */
+int lkm_get_internal_temperature_now(void)
+{
+  struct ug31xx_data *ug31xx;
+
+  ug31xx = (struct ug31xx_data *)lkm_gauge;
+
+  upiGG_FetchInternalTemperature(lkm_gauge);
+  return (ug31xx->measData.intTemperature);
+}
+
+/**
+ * @brief lkm_get_update_interval
+ *
+ *  Get update time interval
+ *
+ * @return  time interval in second
+ */
+int lkm_get_update_interval(void)
+{
+  _upi_u32_ curr_time_tag;
+
+  curr_time_tag = GetSysTickCount();
+  curr_time_tag = curr_time_tag - lkm_last_update_time_tag;
+  curr_time_tag = curr_time_tag/1000;
+  UG31_LOGN("[%s]: LKM update interval = %d seconds\n", __func__, curr_time_tag);
+
+  if(!(curr_time_tag % UPI_POLLING_TIME_CONST))
+  {
+    UG31_LOGI("[%s]: LKM update interval = %d minutes\n", __func__, curr_time_tag/UPI_POLLING_TIME_CONST);
+  }
+  return (curr_time_tag);
+}
+
+/**
+ * @brief lkm_get_update_time
+ *
+ *  Get battery information update time
+ *
+ * @return  time interval in second
+ */
+int lkm_get_update_time(void)
+{
+  int update_time;
+
+  update_time = (int)polling_time_algorithm();
+  return (update_time);
+}
+
+#define CALIBRATE_CURRENT_UPPER_BOUND     (20)
+#define CALIBRATE_CURRENT_LOWER_BOUND     (-20)
+#define CALIBRATE_CURRENT_NO_UPPER_BOUND  (10000)
+
+/**
+ * @brief lkm_calibrate_offset
+ *
+ *  Calibrate board current offset
+ *
+ * @para  options UG31XX_BOARD_OFFSET_CALI_STEP or UG31XX_BOARD_OFFSET_CALI_FULL
+ * @return  0 if success
+ */
+int lkm_calibrate_offset(unsigned char options)
+{
+  _upi_s16_ upper;
+  _upi_s16_ lower;
+  _upi_s8_ fullStep;
+
+  upiGG_FetchCurrent(lkm_gauge);
+
+  upper = CALIBRATE_CURRENT_UPPER_BOUND;
+  lower = CALIBRATE_CURRENT_LOWER_BOUND;
+
+  if(options == UG31XX_BOARD_OFFSET_CALI_FULL_NO_UPPER)
+  {
+    upper = CALIBRATE_CURRENT_NO_UPPER_BOUND;
+    options = UG31XX_BOARD_OFFSET_CALI_FULL;
+  }
+
+  if(options == UG31XX_BOARD_OFFSET_CALI_FULL)
+  {
+    fullStep = GET_BOARD_OFFSET_FULL;
+  }
+  else if(options == UG31XX_BOARD_OFFSET_CALI_AVG)
+  {
+    fullStep = GET_BOARD_OFFSET_AVG;
+  }
+  else
+  {
+    fullStep = GET_BOARD_OFFSET_STEP;
+  }
+  upiGG_GetBoardOffset(lkm_gauge, fullStep, upper, lower);
+  return (0);
+}
+
+/**
+ * @brief lkm_get_board_offset
+ *
+ *  Get current board offset
+ *
+ * @return  effective board offset
+ */
+int lkm_get_board_offset(void)
+{
+  struct ug31xx_data *ug31xx;
+  int offset;
+
+  ug31xx = (struct ug31xx_data *)lkm_gauge;
+
+  offset = (int)ug31xx->cellParameter.adc1_pos_offset;
+  offset = offset + ug31xx->measData.ccOffsetAdj;
+  return (offset);
+}
+
+/**
+ * @brief lkm_get_ggb_board_offset
+ *
+ *  Get GGB board offset
+ *
+ * @return  GGB board offset
+ */
+int lkm_get_ggb_board_offset(void)
+{
+  struct ug31xx_data *ug31xx;
+
+  ug31xx = (struct ug31xx_data *)lkm_gauge;
+  return ((int)ug31xx->cellParameter.adc1_pos_offset);
+}
+
+/**
+ * @brief lkm_set_ggb_board_offset
+ *
+ *  Set GGB board offset
+ *
+ * @para  offset  target GGB board offset
+ * @return  0 if success
+ */
+int lkm_set_ggb_board_offset(int offset)
+{
+  struct ug31xx_data *ug31xx;
+
+  ug31xx = (struct ug31xx_data *)lkm_gauge;
+  ug31xx->cellParameter.adc1_pos_offset = (_upi_s16_)offset;
+  UG31_LOGE("[%s]: adc1_pos_offset = %d\n", __func__,
+            offset);
+  return (0);
+}
+
+#define LKM_MAX_CC_OFFSET_ADJ     (100)
+#define LKM_MIN_CC_OFFSET_ADJ     (-100)
+
+/**
+ * @brief lkm_set_board_offset
+ *
+ *  Set effective board offset
+ *
+ * @para  offset  target effective offset
+ * @para  from_upi_bo set UG31XX_BOARD_OFFSET_FROM_UPI_BO for board offset from upi_bo file
+ * @return  0 if success
+ */
+int lkm_set_board_offset(int offset, char from_upi_bo)
+{
+  struct ug31xx_data *ug31xx;
+
+  ug31xx = (struct ug31xx_data *)lkm_gauge;
+
+  offset = offset - ug31xx->cellParameter.adc1_pos_offset;
+  if(offset > LKM_MAX_CC_OFFSET_ADJ)
+  {
+    offset = LKM_MAX_CC_OFFSET_ADJ;
+  }
+  if(offset < LKM_MIN_CC_OFFSET_ADJ)
+  {
+    offset = LKM_MIN_CC_OFFSET_ADJ;
+  }
+  ug31xx->measData.ccOffsetAdj = (_meas_s8_)offset;
+  UG31_LOGI("[%s]: Set board offset to %d + %d\n", __func__,
+            ug31xx->cellParameter.adc1_pos_offset,
+            ug31xx->measData.ccOffsetAdj);
+
+  if((from_upi_bo == UG31XX_BOARD_OFFSET_FROM_UPI_BO) ||
+     (from_upi_bo == UG31XX_BOARD_OFFSET_FROM_UPI_COS))
+  {
+    UpiSetFactoryBoardOffset(&ug31xx->capData);
+  }
+  return (0);
+}
+
+/**
+ * @brief lkm_set_ntc_offset
+ *
+ *  Set NTC offset to GGB file
+ *
+ * @para  offset  target NTC offset
+ * @return  0 if success
+ */
+int lkm_set_ntc_offset(int offset)
+{
+  struct ug31xx_data *ug31xx;
+
+  ug31xx = (struct ug31xx_data *)lkm_gauge;
+  ug31xx->cellParameter.offsetR = (_upi_u16_)offset;
+  UG31_LOGE("[%s]: offsetR = %d\n", __func__,
+            offset);
+  return (0);
+}
+
+/**
+ * @brief lkm_get_ntc_offset
+ *
+ *  Get NTC offset from GGB file
+ *
+ * @return  NTC offset in mOhm
+ */
+int lkm_get_ntc_offset(void)
+{
+  struct ug31xx_data *ug31xx;
+
+  ug31xx = (struct ug31xx_data *)lkm_gauge;
+  return ((int)ug31xx->cellParameter.offsetR);
+}
+
+/**
+ * @brief lkm_set_standby_current
+ *
+ *  Set standby current for suspend
+ *
+ * @para  curr  standby current in mA
+ * @return  0 if success
+ */
+int lkm_set_standby_current(int curr)
+{
+  struct ug31xx_data *ug31xx;
+
+  ug31xx = (struct ug31xx_data *)lkm_gauge;
+  ug31xx->cellParameter.deltaR = (_upi_u16_)curr;
+  UG31_LOGE("[%s]: deltaR = %d\n", __func__,
+            curr);
+  return (0);
+}
+
+/**
+ * @brief lkm_get_standby_current
+ *
+ *  Get standby current in suspend
+ *
+ * @return  standby current in mA
+ */
+int lkm_get_standby_current(void)
+{
+  struct ug31xx_data *ug31xx;
+
+  ug31xx = (struct ug31xx_data *)lkm_gauge;
+  return ((int)ug31xx->cellParameter.deltaR);
+}
+
+/**
+ * @brief lkm_get_ggb_board_gain
+ *
+ *  Get board gain in GGB
+ *
+ * @return  board gain in GGB
+ */
+int lkm_get_ggb_board_gain(void)
+{
+  struct ug31xx_data *ug31xx;
+
+  ug31xx = (struct ug31xx_data *)lkm_gauge;
+  return ((int)ug31xx->cellParameter.adc1_ngain);
+}
+
+/**
+ * @brief lkm_set_ggb_board_gain
+ *
+ *  Set board gain in GGB
+ *
+ * @para  gain  board gain
+ * @return   0 if success
+ */
+int lkm_set_ggb_board_gain(int gain)
+{
+  struct ug31xx_data *ug31xx;
+
+  ug31xx = (struct ug31xx_data *)lkm_gauge;
+  ug31xx->cellParameter.adc1_pgain = (_upi_s16_)gain;
+  ug31xx->cellParameter.adc1_ngain = (_upi_s16_)gain;
+  UG31_LOGE("[%s]: adc1_pgain = adc1_ngain = %d\n", __func__,
+            gain);
+  return (0);
+}
+
+/**
+ * @brief lkm_get_ggb_config
+ *
+ *  Get NacLmdAdjustCfg from GGB
+ *
+ * @return  NacLmdAdjustCfg
+ */
+unsigned int lkm_get_ggb_config(void)
+{
+  struct ug31xx_data *ug31xx;
+
+  ug31xx = (struct ug31xx_data *)lkm_gauge;
+  return ((unsigned int)ug31xx->cellParameter.NacLmdAdjustCfg);
+}
+
+/**
+ * @brief lkm_set_ggb_config
+ *
+ *  Set NacLmdAdjustCfg to GGB
+ *
+ * @para  config  new NacLmdAdjustCfg
+ * @return  0 if success
+ */
+int lkm_set_ggb_config(unsigned int config)
+{
+  struct ug31xx_data *ug31xx;
+
+  ug31xx = (struct ug31xx_data *)lkm_gauge;
+  ug31xx->cellParameter.NacLmdAdjustCfg = (_upi_u32_)config;
+  UG31_LOGE("[%s]: NacLmdAdjustCfg = 0x%x\n", __func__,
+            config);
+  return (0);
+}
+
+/**
+ * @brief lkm_get_cumulative_capacity
+ *
+ *  Get cumulative capacity from coulomb counter
+ *
+ * @return  cumulative capacity in mAh
+ */
+int lkm_get_cumulative_capacity(void)
+{
+  struct ug31xx_data *ug31xx;
+
+  ug31xx = (struct ug31xx_data *)lkm_gauge;
+  return ((int)ug31xx->measData.cumuCap);
+}
+
+/**
+ * @brief lkm_get_delta_q
+ *
+ *  Get delta capacity from coulomb counter
+ *
+ * @return  delta capacity in mAh
+ */
+int lkm_get_delta_q(void)
+{
+  struct ug31xx_data *ug31xx;
+
+  ug31xx = (struct ug31xx_data *)lkm_gauge;
+  return ((int)ug31xx->measData.stepCap);
+}
+
+/**
+ * @brief lkm_set_capacity_suspend_mode
+ *
+ *  Set capacity module in suspend mode
+ *
+ * @para  in_suspend  set 0 to disable suspend mode
+ * @return  0 if success
+ */
+int lkm_set_capacity_suspend_mode(char in_suspend)
+{
+  _upi_bool_ enable;
+
+  enable = (in_suspend == 0) ? _UPI_FALSE_ : _UPI_TRUE_;
+  upiGG_SetCapacitySuspendMode(lkm_gauge, enable);
+  return (0);
+}
+
+/**
+ * @brief lkm_shell_update
+ *
+ *  Interaction with shell algorithm after lkm_update_procedure
+ *
+ * @return  0 if success
+ */
+int lkm_shell_update(void)
+{
+  #ifdef  UG31XX_SHELL_ALGORITHM
+
+  GG_CAPACITY *devCapacity;
+  struct ug31xx_data *ug31xx;
+
+  ug31xx = (struct ug31xx_data *)lkm_gauge;
+
+  devCapacity = (GG_CAPACITY *)upi_malloc(sizeof(GG_CAPACITY));
+  if(devCapacity == _UPI_NULL_)
+  {
+    return (-1);
+  }
+
+  upiGG_ReadCapacity(lkm_gauge, devCapacity);
+  UG31_LOGI("[%s]: %d / %d = %d\n", __func__, devCapacity->NAC, devCapacity->LMD, devCapacity->RSOC);
+  upi_free(devCapacity);
+
+  #endif  ///< end of UG31XX_SHELL_ALGORITHM
+
+  return (0);
+}
+
+/**
+ * @brief lkm_set_cable_out
+ *
+ *  Set current cable status
+ *
+ * @para  cntl  UG31XX_CABLE_OUT or UG31XX_CABLE_IN
+ * @return  0 if success
+ */
+int lkm_set_cable_out(unsigned char cntl)
+{
+  struct ug31xx_data *ug31xx;
+
+  ug31xx = (struct ug31xx_data *)lkm_gauge;
+
+  if(cntl == UG31XX_CABLE_OUT)
+  {
+    ug31xx->measData.status = ug31xx->measData.status | MEAS_STATUS_CABLE_OUT;
+  }
+  else
+  {
+    ug31xx->measData.status = ug31xx->measData.status & (~MEAS_STATUS_CABLE_OUT);
+  }
+  return (0);
+}
+
+/**
+ * @brief lkm_shell_backup
+ *
+ *  Backup file operation
+ *
+ * @return  backup file status
+ */
+int lkm_shell_backup(void)
+{
+  struct ug31xx_data *ug31xx;
+
+  ug31xx = (struct ug31xx_data *)lkm_gauge;
+
+  if(ug31xx->batteryInfo.Ready == UG_CAP_DATA_VERSION_MISMATCH)
+  {
+    return (1);
+  }
+
+  if(ug31xx->batteryInfo.Ready == UG_CAP_DATA_NOT_READY)
+  {
+    return (-1);
+  }
+  return (0);
+}
+
+/**
+ * @brief lkm_shell_memory
+ *
+ *  Get memory buffer address and size
+ *
+ * @para  mem_size  address of memory size
+ * @return  memory buffer address
+ */
+unsigned char * lkm_shell_memory(int *mem_size)
+{
+  *mem_size = (int)sizeof(struct ug31xx_data);
+  UG31_LOGN("[%s]: memory[0] = %02x (%x-%d) (%d,%d,%d,%d,%d)\n", __func__,
+            lkm_gauge[0],
+            (unsigned int)lkm_gauge,
+            (*mem_size),
+            sizeof(OtpDataType),
+            sizeof(MeasDataType),
+            sizeof(CapacityDataType),
+            sizeof(SystemDataType),
+            sizeof(BackupDataType));
+  return (lkm_gauge);
+}
+
+/**
+ * @brief lkm_shell_backup_memory
+ *
+ *  Get backup memory buffer and size
+ *
+ * @para  mem_size  address of memory size
+ * @return  memory buffer address
+ */
+unsigned char * lkm_shell_backup_memory(int *mem_size)
+{
+  struct ug31xx_data *ug31xx;
+
+  ug31xx = (struct ug31xx_data *)lkm_gauge;
+
+  *mem_size = ug31xx->backupData.backupBufferSize;
+  UG31_LOGN("[%s]: memory[0] = %02x (%x-%d)\n", __func__, ug31xx->backupData.backupBuffer[0], (unsigned int)ug31xx->backupData.backupBuffer, (*mem_size));
+  return (ug31xx->backupData.backupBuffer);
+}
+
+/**
+ * @brief lkm_shell_table_memory
+ *
+ *  Get capacity table memory buffer and size
+ *
+ * @para  mem_size  address of memory size
+ * @return  memory buffer address
+ */
+unsigned char * lkm_shell_table_memory(int *mem_size)
+{
+  struct ug31xx_data *ug31xx;
+
+  ug31xx = (struct ug31xx_data *)lkm_gauge;
+
+  *mem_size = ug31xx->capData.tableSize;
+  UG31_LOGN("[%s]: memory[0] = %02x (%x-%d)\n", __func__, ug31xx->capData.encriptBuf[0], (unsigned int)ug31xx->capData.encriptBuf, (*mem_size));
+  return (ug31xx->capData.encriptBuf);
+}
+
+/**
+ * @brief lkm_shell_table_buf_memory
+ *
+ *  Get capacity table buffer memory buffer and size
+ *
+ * @para  mem_size  address of memory size
+ * @return  memory buffer address
+ */
+unsigned char * lkm_shell_table_buf_memory(int *mem_size)
+{
+  struct ug31xx_data *ug31xx;
+
+  ug31xx = (struct ug31xx_data*)lkm_gauge;
+
+  *mem_size = ug31xx->capData.tableSize;
+  UG31_LOGN("[%s]: memory[0] = %02x (%x-%d)\n", __func__, ug31xx->capData.encriptBuf[0], (unsigned int)ug31xx->capData.encriptBuf, (*mem_size));
+  return (ug31xx->capData.encriptBuf);
+}
+
+static SystemDataType *backup_ptrSysData;
+static OtpDataType *backup_ptrOtpData;
+static MeasDataType *backup_ptrMeasData;
+static CELL_TABLE *backup_ptrCellTable;
+static CELL_PARAMETER *backup_ptrCellParameter;
+static CapacityDataType *backup_ptrCapData;
+
+/**
+ * @brief lkm_backup_pointer
+ *
+ *  Backup pointer in memory buffer
+ *
+ * @return  NULL
+ */
+int lkm_backup_pointer(void)
+{
+  backup_ptrSysData = ptrSysData;
+  backup_ptrOtpData = ptrOtpData;
+  backup_ptrMeasData = ptrMeasData;
+  backup_ptrCellTable = ptrCellTable;
+  backup_ptrCellParameter = ptrCellParameter;
+  backup_ptrCapData = ptrCapData;
+  return (0);
+}
+
+/**
+ * @brief lkm_restore_pointer
+ *
+ *  Restore pointer in memory buffer
+ *
+ * @return  NULL
+ */
+int lkm_restore_pointer(void)
+{
+  ptrSysData = backup_ptrSysData;
+  ptrOtpData = backup_ptrOtpData;
+  ptrMeasData = backup_ptrMeasData;
+  ptrCellTable = backup_ptrCellTable;
+  ptrCellParameter = backup_ptrCellParameter;
+  ptrCapData = backup_ptrCapData;
+  return (0);
+}
+
+/**
+ * @brief lkm_get_decimate_rst_sts
+ *
+ *  Get DECIMATE_RST status
+ *
+ * @return  UG31XX_DECIMATE_RST_ACTIVE if DECIMATE_RST is active
+ */
+unsigned char lkm_get_decimate_rst_sts(void)
+{
+  struct ug31xx_data *ug31xx;
+
+  ug31xx = (struct ug31xx_data *)lkm_gauge;
+
+  if(ug31xx->sysData.adcCheckData.decimateRst == _UPI_TRUE_)
+  {
+    lkm_decimate_rst_cnt = lkm_decimate_rst_cnt + 1;
+    if(lkm_decimate_rst_cnt > LKM_MAX_DECIMATE_RST_CNT)
+    {
+      lkm_decimate_rst_cnt = 0;
+    }
+  }
+  else
+  {
+    lkm_decimate_rst_cnt = 0;
+  }
+  return ((lkm_decimate_rst_cnt != 0) ? UG31XX_DECIMATE_RST_ACTIVE : UG31XX_DECIMATE_RST_NOT_ACTIVE);
+}
+
+/**
+ * @brief lkm_get_delta_time
+ *
+ * Get delta time
+ *
+ * @return delta time in msec
+ */
+int lkm_get_delta_time(void)
+{
+  struct ug31xx_data *ug31xx;
+
+  ug31xx = (struct ug31xx_data *)lkm_gauge;
+  return ((int)ug31xx->measData.deltaTime);
+}
+
+/**
+ * @brief lkm_reset_q_from_cc
+ *
+ * Reset qFromCC
+ *
+ * @return 0 if success
+ */
+int lkm_reset_q_from_cc(void)
+{
+  struct ug31xx_data *ug31xx;
+
+  ug31xx = (struct ug31xx_data *)lkm_gauge;
+
+  ug31xx->capData.qFromCC = (_cap_s32_)ug31xx->cellParameter.ILMD;
+  return (0);
+}
+
+/**
+ * @brief lkm_get_cc_chg_offset
+ *
+ * Get CC mode charging offset
+ *
+ * @para offset_25 address of offset below 25%
+ * @para offset_50 address of offset below 50%
+ * @para offset_75 address of offset below 75%
+ * @para offset_100 address of offset below 100%
+ * @return NULL
+ */
+void lkm_get_cc_chg_offset(unsigned int *offset_25, unsigned int *offset_50, unsigned int *offset_75, unsigned int *offset_100)
+{
+  struct ug31xx_data *ug31xx;
+
+  ug31xx = (struct ug31xx_data *)lkm_gauge;
+
+  *offset_25  = (unsigned int)ug31xx->capData.ccChgOffset25;
+  *offset_50  = (unsigned int)ug31xx->capData.ccChgOffset50;
+  *offset_75  = (unsigned int)ug31xx->capData.ccChgOffset75;
+  *offset_100 = (unsigned int)ug31xx->capData.ccChgOffset100;
+  return;
+}
+
+/**
+ * @brief lkm_set_cc_chg_offset
+ *
+ * Set CC mode charging offset
+ *
+ * @para offset_25 CC mode charging offset below 25%
+ * @para offset_50 CC mode charging offset below 50%
+ * @para offset_75 CC mode charging offset below 75%
+ * @para offset_100 CC mode charging offset below 100%
+ * @return 0 if success
+ */
+int lkm_set_cc_chg_offset(unsigned int offset_25, unsigned int offset_50, unsigned int offset_75, unsigned int offset_100)
+{
+  struct ug31xx_data *ug31xx;
+
+  ug31xx = (struct ug31xx_data *)lkm_gauge;
+
+  ug31xx->capData.ccChgOffset25  = (_cap_u8_)offset_25;
+  ug31xx->capData.ccChgOffset50  = (_cap_u8_)offset_50;
+  ug31xx->capData.ccChgOffset75  = (_cap_u8_)offset_75;
+  ug31xx->capData.ccChgOffset100 = (_cap_u8_)offset_100;
+  return (0);
+}
+
+int lkm_get_suspend_time(void)
+{
+  _upi_u32_ delta_time;
+
+  delta_time = GetSysTickCount();
+  delta_time = delta_time - lkm_suspend_time_tag;
+  delta_time = delta_time / 1000;
+  UG31_LOGN("[%s]: Suspend time interval = %d seconds\n", __func__,
+            delta_time);
+  return ((int)delta_time);
+}
+
+int lkm_get_table_rsoc(void)
+{
+  struct ug31xx_data *ug31xx;
+
+  ug31xx = (struct ug31xx_data *)lkm_gauge;
+
+  return ((int)(ug31xx->capData.tableRsoc));
+}
+
+int lkm_set_capacity_force(int rsoc)
+{
+  UG31_LOGE("[%s]: Force RSOC = %d\n", __func__, rsoc);
+  upiGG_SetCapacity(lkm_gauge, (_cap_u8_)rsoc);
+  return (0);
+}
+
+struct ug31xx_module_interface ug31_module = {
+	.initial    = lkm_initial,
+	.uninitial  = lkm_uninitial,
+	.suspend    = lkm_suspend,
+	.resume     = lkm_resume,
+	.shutdown   = lkm_shutdown,
+	.update     = lkm_update,
+	.reset      = lkm_reset,
+
+	.shell_update           = lkm_shell_update,
+	.shell_memory           = lkm_shell_memory,
+	.shell_backup           = lkm_shell_backup,
+	.shell_backup_memory    = lkm_shell_backup_memory,
+	.shell_table_memory     = lkm_shell_table_memory,
+	.shell_table_buf_memory = lkm_shell_table_buf_memory,
+
+	.get_voltage                    = lkm_get_voltage,
+	.get_voltage_now                = lkm_get_voltage_now,
+	.get_current                    = lkm_get_current,
+	.get_current_now                = lkm_get_current_now,
+	.get_external_temperature       = lkm_get_external_temperature,
+	.get_external_temperature_now   = lkm_get_external_temperature_now,
+	.get_internal_temperature       = lkm_get_internal_temperature,
+	.get_internal_temperature_now   = lkm_get_internal_temperature_now,
+	.get_remaining_capacity         = lkm_get_remaining_capacity,
+	.get_full_charge_capacity       = lkm_get_full_charge_capacity,
+	.get_relative_state_of_charge   = lkm_get_relative_state_of_charge,
+	.get_version                    = lkm_get_version,
+	.get_polling_time               = lkm_get_polling_time,
+	.get_module_ready               = lkm_get_module_ready,
+	.get_battery_removed            = lkm_get_battery_removed,
+	.get_alarm_status               = lkm_get_alarm_status,
+	.get_charge_termination_current = lkm_get_taper_current,
+	.get_charge_termination_voltage = lkm_get_taper_voltage,
+	.get_full_charge_status         = lkm_get_full_charge_status,
+	.get_design_capacity            = lkm_get_design_capacity,
+	.get_rsense                     = lkm_get_rsense,
+	.get_predict_rsoc               = lkm_get_predict_rsoc,
+	.get_gpio                       = lkm_get_gpio,
+	.get_cycle_count                = lkm_get_cycle_count,
+	.get_avg_external_temperature   = lkm_get_avg_external_temperature,
+	.get_ntc_status                 = lkm_get_ntc_status,
+	.get_backup_buffer              = lkm_get_backup_buffer,
+	.get_backup_daemon_cntl         = lkm_get_backup_daemon_cntl,
+	.get_backup_daemon_period       = lkm_get_backup_daemon_period,
+	.get_update_interval            = lkm_get_update_interval,
+	.get_update_time                = lkm_get_update_time,
+	.get_board_offset               = lkm_get_board_offset,
+	.get_delta_q                    = lkm_get_delta_q,
+	.get_ggb_board_offset           = lkm_get_ggb_board_offset,
+	.get_ntc_offset                 = lkm_get_ntc_offset,
+	.get_cumulative_capacity        = lkm_get_cumulative_capacity,
+	.get_standby_current            = lkm_get_standby_current,
+	.get_ggb_board_gain             = lkm_get_ggb_board_gain,
+	.get_ggb_config                 = lkm_get_ggb_config,
+	.get_decimate_rst_sts           = lkm_get_decimate_rst_sts,
+	.get_delta_time                 = lkm_get_delta_time,
+  .get_cc_chg_offset              = lkm_get_cc_chg_offset,
+  .get_suspend_time               = lkm_get_suspend_time,
+  .get_table_rsoc                 = lkm_get_table_rsoc,
+
+	.set_backup_file                = lkm_set_backup_file,
+	.set_charger_full               = lkm_set_charger_full,
+	.set_charge_termination_current = lkm_set_taper_current,
+	.set_charge_termination_voltage = lkm_set_taper_voltage,
+	.set_battery_temp_external      = lkm_set_battery_temp_external,
+	.set_battery_temp_internal      = lkm_set_battery_temp_internal,
+	.set_rsense                     = lkm_set_rsense,
+	.set_backup_file_name           = lkm_set_backup_file_name,
+	.set_suspend_file_name          = lkm_set_suspend_file_name,
+	.set_options                    = lkm_set_options,
+	.set_gpio                       = lkm_set_gpio,
+	.set_shell_ap                   = lkm_set_shell_ap,
+	.set_backup_daemon_cntl         = lkm_set_backup_daemon_cntl,
+	.set_capacity_suspend_mode      = lkm_set_capacity_suspend_mode,
+	.set_cable_out                  = lkm_set_cable_out,
+	.set_ggb_board_offset           = lkm_set_ggb_board_offset,
+	.set_board_offset               = lkm_set_board_offset,
+	.set_ntc_offset                 = lkm_set_ntc_offset,
+	.set_standby_current            = lkm_set_standby_current,
+	.set_ggb_board_gain             = lkm_set_ggb_board_gain,
+	.set_ggb_config                 = lkm_set_ggb_config,
+  .set_cc_chg_offset              = lkm_set_cc_chg_offset,
+  .set_capacity_force             = lkm_set_capacity_force,
+
+	.chk_backup_file                = lkm_chk_backup_file,
+	.enable_save_data               = lkm_saveDataToIC_switch,
+	.change_to_pri_batt             = lkm_change_to_pri_batt,
+	.ug31xx_i2c_read                = lkm_i2c_read,
+	.ug31xx_i2c_write               = lkm_i2c_write,
+	.reset_cycle_count              = lkm_reset_cycle_count,
+	.adjust_cell_table              = lkm_adjust_cell_table,
+	.calibrate_offset               = lkm_calibrate_offset,
+	.backup_pointer                 = lkm_backup_pointer,
+	.restore_pointer                = lkm_restore_pointer,
+  .reset_q_from_cc                = lkm_reset_q_from_cc,
+};
+
+#endif  ///< end of ANDROID_SHELL_ALGORITHM
+
+#endif  ///< end of uG31xx_BOOT_LOADER
+
+#endif  ///< end of uG31xx_OS_WINDOWS
+
+/// ===========================================
+/// End of uG31xx_API.cpp
+/// ===========================================
+
+
+/**
+ * Copyright @ 2013 uPI Semiconductor Corp. All right reserved.
+ * The information, images, and/or data contained in this material is copyrighted by uPI
+ * Semiconductor Corp., and may not be distributed, modified, reproduced in whole or in part
+ * without the prior, written consent of uPI Semiconductor Corp.
+ */
diff --git a/drivers/power/supply/ASUS_BATTERY/ME176C/ug31xx/uG31xx_API.h b/drivers/power/supply/ASUS_BATTERY/ME176C/ug31xx/uG31xx_API.h
new file mode 100644
index 000000000000..65179ec80305
--- /dev/null
+++ b/drivers/power/supply/ASUS_BATTERY/ME176C/ug31xx/uG31xx_API.h
@@ -0,0 +1,549 @@
+/// ===========================================
+/// uG31xx_API.h
+/// ===========================================
+
+#ifndef _UG31XXAPI_H_
+#define _UG31XXAPI_H_
+
+#include "uG31xx_Platform.h"
+#include "global.h"
+#include "uG31xx.h"
+#include "uG31xx_API_Platform.h"
+#include "typeDefine.h"
+#include "uG31xx_Reg_Def.h"
+#include "uG31xx_API_Otp.h"
+#include "uG31xx_API_System.h"
+#include "uG31xx_API_Measurement.h"
+#include "uG31xx_API_Capacity.h"
+#include "uG31xx_API_Backup.h"
+
+#ifndef uG31xx_OS_WINDOWS
+
+  #ifdef  uG31xx_BOOT_LOADER
+
+    #include "ug31xx_boot.h"
+
+  #else   ///< else of uG31xx_BOOT_LOADER
+
+    #ifdef  ANDROID_SHELL_ALGORITHM
+
+      #include "upi_algorithm.h"
+
+    #else   ///< else of ANDROID_SHELL_ALGORITHM
+
+      #include "ug31xx_gauge.h"
+
+    #endif  ///< end of ANDROID_SHELL_ALGORITHM
+
+  #endif	///< end of uG31xx_BOOT_LOADER
+
+  #include "ug31xx_version.h"
+
+#else   ///< else of uG31xx_OS_WINDOWS
+
+  #define UG31XX_DRIVER_VERSION       (_UPI_NULL_)
+  #define UG31XX_DRIVER_VERSION_STR   (_T("Windows"))
+  #define UG31XX_DRIVER_RELEASE_NOTE  (_T("API"))
+  #define UG31XX_DRIVER_RELEASE_DATE  (_T("No Release Date"))
+
+#endif  ///< end of uG31xx_OS_WINDOWS
+
+#define UG31XX_I2C_HIGH_SPEED_MODE    (_UPI_FALSE_)
+#define UG31XX_I2C_TEM_BITS_MODE      (_UPI_FALSE_)
+
+extern CELL_TABLE *ptrCellTable;
+extern CELL_PARAMETER *ptrCellParameter;
+extern GGBX_FILE_HEADER *ptrGgbBuf;
+
+/* data struct */
+typedef enum _GGSTATUS{
+  UG_SUCCESS                    = 0x00,
+  UG_FAIL		                    = 0x01,
+  UG_NOT_DEF                    = 0x02,
+  UG_INIT_OCV_FAIL	            = 0x03,
+  UG_READ_GGB_FAIL              = 0x04,
+  UG_ACTIVE_FAIL                = 0x05,
+  UG_INIT_SUCCESS               = 0x06,
+  UG_OTP_ISEMPTY                = 0x07,
+  UG_OTP_PRODUCT_DISMATCH       = 0x08,
+
+  UG_I2C_INIT_FAIL              = 0x10,
+  UG_I2C_READ_SUCCESS           = 0x11,
+  UG_I2C_READ_FAIL              = 0x12,
+  UG_I2C_WRITE_SUCCESS          = 0x13,
+  UG_I2C_WRITE_FAIL             = 0x14,
+
+  UG_READ_REG_SUCCESS           = 0x20,
+  UG_READ_REG_FAIL              = 0x21,
+
+  UG_READ_DEVICE_INFO_SUCCESS   = 0x22,
+  UG_READ_DEVICE_INFO_FAIL      = 0x23,
+  UG_READ_DEVICE_ALARM_SUCCESS  = 0x24,
+  UG_READ_DEVICE_ALARM_FAIL     = 0x25,
+  UG_READ_DEVICE_RID_SUCCESS	  = 0x26,
+  UG_READ_DEVICE_RID_FAIL		    = 0x27,
+  UG_READ_ADC_FAIL						  = 0x28,			//new add for filter ADC Error Code
+
+  UG_TI_CMD_OVERFLOW            = 0x30,
+
+  UG_MEAS_FAIL                  = 0x40,
+  UG_MEAS_FAIL_BATTERY_REMOVED  = 0x41,
+  UG_MEAS_FAIL_ADC_ABNORMAL     = 0x42,
+  UG_MEAS_FAIL_NTC_SHORT        = 0x43,
+  UG_MEAS_FAIL_NTC_OPEN         = 0x44,
+
+  UG_CAP_DATA_READY             = 0x50,
+  UG_CAP_DATA_NOT_READY         = 0x51,
+  UG_CAP_DATA_VERSION_MISMATCH  = 0x52,
+}GGSTATUS;
+
+/*
+    GGSTATUS upiGG_Initial
+    Description: Initial and active uG31xx function
+    Input: .GGB(gas gauge battery) setting filename, need include complete path
+	Output: UG_INIT_SUCCESS -> initial uG31xx success
+	        UG_READ_GGB_FAIL -> read GGB file fail
+			UG_INIT_I2C_FAIL -> initial I2C to open HID fail
+			UG_ACTIVE_FAIL -> active uG31xx fail
+*/
+#if defined (uG31xx_OS_WINDOWS)
+
+  EXPORTS GGSTATUS upiGG_Initial(char **pObj, const wchar_t* GGBFilename, const wchar_t* OtpFileName, unsigned char ForceReset = 0);
+
+#else
+
+  GGSTATUS upiGG_Initial(char **pObj, GGBX_FILE_HEADER *pGGBXBuf, unsigned char ForceReset);
+
+#endif
+
+/*
+    GGSTATUS upiGG_CountInitQmax
+    Description:
+    Input: None
+	Output: None
+*/
+//EXPORTS void upiGG_CountInitQmax(void);
+
+/*
+    GGSTATUS upiGG_ReadDevieRegister
+    Description: Read GG_USER_REG from device to global variable and output
+    Input: Pointer of sturct GG_USER_REG
+	Output: UG_READ_REG_SUCCESS -> read success
+	        UG_READ_REG_FAIL -> read fail
+*/
+EXPORTS GGSTATUS upiGG_ReadAllRegister(char *pObj,GG_USER_REG* pExtUserReg, GG_USER2_REG* pExtUserReg2);
+
+/*
+    GGSTATUS upiGG_ReadDeviceInfo
+    Description: Read GG_USER_REG from device and calculate GG_DEVICE_INFO, then write to global variable and output
+    Input: Pointer of struct GG_DEVICE_INFO
+	Output: UG_READ_DEVICE_INFO_SUCCESS -> calculate derive information sucess
+	        UG_READ_DEVICE_INFO_FAIL -> calculate derive information fail
+*/
+EXPORTS GGSTATUS upiGG_ReadDeviceInfo(char *pObj,GG_DEVICE_INFO* pExtDeviceInfo);
+
+/* GGSTATUS upiGG_ReadCapacity
+    Description:
+    Input:
+	Output: None
+*/
+EXPORTS void upiGG_ReadCapacity(char *pObj,GG_CAPACITY *pExtCapacity);
+
+#if defined (uG31xx_OS_WINDOWS)
+
+EXPORTS void upiGG_AlgorithmSimulatorInit(char **pObj, const wchar_t* GGBFilename,
+                                                   MeasDataType *pMeasure, GG_CAP_LOG_TYPE *pCap,
+                                                   _upi_u8_ *NacTable);
+EXPORTS void upiGG_AlgorithmSimulatorRead(char *pObj, MeasDataType *pMeasure,
+                                                      GG_CAP_LOG_TYPE *pCap, _upi_u8_ *NacTable);
+EXPORTS void upiGG_AlgorithmSimulatorClose(char **pObj);
+
+#endif  ///< end of defined (uG31xx_OS_WINDOWS)
+
+/**
+ * @brief upiGG_GetAlarmStatus
+ *
+ *  Get alarm status
+ *
+ * @para  pAlarmStatus  address of alarm status
+ * @return  UG_READ_DEVICE_ALARM_SUCCESS if success
+ */
+EXPORTS GGSTATUS upiGG_GetAlarmStatus(char *pObj, _upi_u8_ *pAlarmStatus);
+
+/*
+new add function for System suspend & wakeup
+
+*/
+EXPORTS GGSTATUS upiGG_PreSuspend(char *pObj);
+EXPORTS GGSTATUS upiGG_Wakeup(char *pObj, _upi_bool_ dc_in_before);
+
+/**
+ * @brief upiGG_DumpRegister
+ *
+ *  Dump whole register value
+ *
+ * @para  pBuf  address of register value buffer
+ * @return  data size
+ */
+EXPORTS _upi_u16_ upiGG_DumpRegister(char *pObj, _upi_u8_ *pBuf);
+
+/**
+ * @brief upiGG_DumpCellTable
+ *
+ *  Dump cell NAC table
+ *
+ * @para  pTable address of cell table
+ * @return  _UPI_NULL_
+ */
+EXPORTS void upiGG_DumpCellTable(char *pObj, CELL_TABLE *pTable);
+EXPORTS GGSTATUS upiGG_UnInitial(char **pObj);
+EXPORTS void upiGG_DumpParameter(char *pObj, CELL_PARAMETER *pTable);
+
+#define upiGG_PrePowerOff (upiGG_PreSuspend)
+
+#ifdef ENABLE_BQ27520_SW_CMD
+
+/**
+ * @brief upiGG_AccessMeasurementParameter
+ *
+ *  Access measurement parameter
+ *
+ * @para  read  set _UPI_TRUE_ to read data from API
+ * @para  pMeasPara pointer of GG_MEAS_PARA_TYPE
+ * @return  GGSTATUS
+ */
+EXPORTS GGSTATUS upiGG_AccessMeasurementParameter(char *pObj, _upi_bool_ read, GG_MEAS_PARA_TYPE *pMeasPara);
+
+#define UG_STD_CMD_CNTL     (0x00)
+  #define UG_STD_CMD_CNTL_CONTROL_STATUS    (0x0000)
+    #define UG_STD_CMD_CNTL_CONTROL_STATUS_DLOGEN     (1<<15)
+    #define UG_STD_CMD_CNTL_CONTROL_STATUS_FAS        (1<<14)
+    #define UG_STD_CMD_CNTL_CONTROL_STATUS_SS         (1<<13)
+    #define UG_STD_CMD_CNTL_CONTROL_STATUS_CSV        (1<<12)
+    #define UG_STD_CMD_CNTL_CONTROL_STATUS_CCA        (1<<11)
+    #define UG_STD_CMD_CNTL_CONTROL_STATUS_BCA        (1<<10)
+    #define UG_STD_CMD_CNTL_CONTROL_STATUS_OCVCMDCOMP (1<<9)
+    #define UG_STD_CMD_CNTL_CONTROL_STATUS_OCVFAIL    (1<<8)
+    #define UG_STD_CMD_CNTL_CONTROL_STATUS_INITCOMP   (1<<7)
+    #define UG_STD_CMD_CNTL_CONTROL_STATUS_HIBERNATE  (1<<6)
+    #define UG_STD_CMD_CNTL_CONTROL_STATUS_SNOOZE     (1<<5)
+    #define UG_STD_CMD_CNTL_CONTROL_STATUS_SLEEP      (1<<4)
+    #define UG_STD_CMD_CNTL_CONTROL_STATUS_LDMD       (1<<3)
+    #define UG_STD_CMD_CNTL_CONTROL_STATUS_RUP_DIS    (1<<2)
+    #define UG_STD_CMD_CNTL_CONTROL_STATUS_VOK        (1<<1)
+    #define UG_STD_CMD_CNTL_CONTROL_STATUS_QEN        (1<<0)
+  #define UG_STD_CMD_CNTL_DEVICE_TYPE       (0x0001)
+  #define UG_STD_CMD_CNTL_FW_VERSION        (0x0002)
+  #define UG_STD_CMD_CNTL_PREV_MACWRITE     (0x0007)
+  #define UG_STD_CMD_CNTL_CHEM_ID           (0x0008)
+  #define UG_STD_CMD_CNTL_OCV_CMD           (0x000C)      ///< [AT-PM] : Not implemented ; 10/11/2012
+  #define UG_STD_CMD_CNTL_BAT_INSERT        (0x000D)
+  #define UG_STD_CMD_CNTL_BAT_REMOVE        (0x000E)
+  #define UG_STD_CMD_CNTL_SET_HIBERNATE     (0x0011)
+  #define UG_STD_CMD_CNTL_CLEAR_HIBERNATE   (0x0012)
+  #define UG_STD_CMD_CNTL_SET_SLEEP_PLUS    (0x0013)
+  #define UG_STD_CMD_CNTL_CLEAR_SLEEP_PLUS  (0x0014)
+  #define UG_STD_CMD_CNTL_FACTORY_RESTORE   (0x0015)
+  #define UG_STD_CMD_CNTL_ENABLE_DLOG       (0x0018)
+  #define UG_STD_CMD_CNTL_DISABLE_DLOG      (0x0019)
+  #define UG_STD_CMD_CNTL_DF_VERSION        (0x001F)
+  #define UG_STD_CMD_CNTL_SEALED            (0x0020)
+  #define UG_STD_CMD_CNTL_RESET             (0x0041)
+#define UG_STD_CMD_AR       (0x02)
+#define UG_STD_CMD_ARTTE    (0x04)
+#define UG_STD_CMD_TEMP     (0x06)
+#define UG_STD_CMD_VOLT     (0x08)
+#define UG_STD_CMD_FLAGS    (0x0A)
+  #define UG_STD_CMD_FLAGS_OTC            (1<<15)
+  #define UG_STD_CMD_FLAGS_OTD            (1<<14)
+  #define UG_STD_CMD_FLAGS_RSVD13         (1<<13)
+  #define UG_STD_CMD_FLAGS_RSVD12         (1<<12)
+  #define UG_STD_CMD_FLAGS_CHG_INH        (1<<11)
+  #define UG_STD_CMD_FLAGS_XCHG           (1<<10)
+  #define UG_STD_CMD_FLAGS_FC             (1<<9)
+  #define UG_STD_CMD_FLAGS_CHG            (1<<8)
+  #define UG_STD_CMD_FLAGS_RSVD7          (1<<7)
+  #define UG_STD_CMD_FLAGS_RSVD6          (1<<6)
+  #define UG_STD_CMD_FLAGS_OCV_GD         (1<<5)
+  #define UG_STD_CMD_FLAGS_WAIT_ID        (1<<4)
+  #define UG_STD_CMD_FLAGS_BAT_DET        (1<<3)
+  #define UG_STD_CMD_FLAGS_SOC1           (1<<2)
+  #define UG_STD_CMD_FLAGS_SYSDOWN        (1<<1)
+  #define UG_STD_CMD_FLAGS_DSG            (1<<0)
+#define UG_STD_CMD_NAC      (0x0C)
+#define UG_STD_CMD_FAC      (0x0E)
+#define UG_STD_CMD_RM       (0x10)
+#define UG_STD_CMD_FCC      (0x12)
+#define UG_STD_CMD_AI       (0x14)
+#define UG_STD_CMD_TTE      (0x16)
+#define UG_STD_CMD_TTF      (0x18)
+#define UG_STD_CMD_SI       (0x1A)
+#define UG_STD_CMD_STTE     (0x1C)
+#define UG_STD_CMD_MLI      (0x1E)
+#define UG_STD_CMD_MLTTE    (0x20)
+#define UG_STD_CMD_AE       (0x22)
+#define UG_STD_CMD_AP       (0x24)
+#define UG_STD_CMD_TTECP    (0x26)
+#define UG_STD_CMD_SOH      (0x28)
+  #define UG_STD_CMD_SOH_VALUE_MASK   (0x00FF)
+  #define UG_STD_CMD_SOH_STATUS_MASK  (0xFF00)
+    #define UG_STD_CMD_SOH_STATUS_NOT_VALID     (0x0000)
+    #define UG_STD_CMD_SOH_STATUS_INSTANT_READY (0x0100)
+    #define UG_STD_CMD_SOH_STATUS_INITIAL_READY (0x0200)
+    #define UG_STD_CMD_SOH_STATUS_READY         (0x0300)
+#define UG_STD_CMD_CC       (0x2A)
+#define UG_STD_CMD_SOC      (0x2C)
+#define UG_STD_CMD_NIC      (0x2E)      ///< [AT-PM] : Not implemented ; 10/11/2012
+#define UG_STD_CMD_ICR      (0x30)
+#define UG_STD_CMD_DLI      (0x32)
+#define UG_STD_CMD_DLB      (0x34)
+#define UG_STD_CMD_ITEMP    (0x36)
+#define UG_STD_CMD_OPCFG    (0x3A)
+  #define UG_STD_CMD_OPCFG_RESCAP     (1<<31)
+  #define UG_STD_CMD_OPCFG_BATG_OVR   (1<<30)
+  #define UG_STD_CMD_OPCFG_INT_BERM   (1<<29)
+  #define UG_STD_CMD_OPCFG_PFC_CFG1   (1<<28)
+  #define UG_STD_CMD_OPCFG_PFC_CFG0   (1<<27)
+  #define UG_STD_CMD_OPCFG_IWAKE      (1<<26)
+  #define UG_STD_CMD_OPCFG_RSNS1      (1<<25)
+  #define UG_STD_CMD_OPCFG_RSNS0      (1<<24)
+  #define UG_STD_CMD_OPCFG_INT_FOCV   (1<<23)
+  #define UG_STD_CMD_OPCFG_IDSELEN    (1<<22)
+  #define UG_STD_CMD_OPCFG_SLEEP      (1<<21)
+  #define UG_STD_CMD_OPCFG_RMFCC      (1<<20)
+  #define UG_STD_CMD_OPCFG_SOCI_POL   (1<<19)
+  #define UG_STD_CMD_OPCFG_BATG_POL   (1<<18)
+  #define UG_STD_CMD_OPCFG_BATL_POL   (1<<17)
+  #define UG_STD_CMD_OPCFG_TEMPS      (1<<16)
+  #define UG_STD_CMD_OPCFG_WRTEMP     (1<<15)
+  #define UG_STD_CMD_OPCFG_BIE        (1<<14)
+  #define UG_STD_CMD_OPCFG_BL_INT     (1<<13)
+  #define UG_STD_CMD_OPCFG_GNDSEL     (1<<12)
+  #define UG_STD_CMD_OPCFG_FCE        (1<<11)
+  #define UG_STD_CMD_OPCFG_DFWRINDBL  (1<<10)
+  #define UG_STD_CMD_OPCFG_RFACTSTEP  (1<<9)
+  #define UG_STD_CMD_OPCFG_INDFACRES  (1<<8)
+  #define UG_STD_CMD_OPCFG_BATGSPUEN  (1<<7)
+  #define UG_STD_CMD_OPCFG_BATGWPUEN  (1<<6)
+  #define UG_STD_CMD_OPCFG_BATLSPUEN  (1<<5)
+  #define UG_STD_CMD_OPCFG_BATLWSPUEN (1<<4)
+  #define UG_STD_CMD_OPCFG_RSVD3      (1<<3)
+  #define UG_STD_CMD_OPCFG_SLPWKCHG   (1<<2)
+  #define UG_STD_CMD_OPCFG_DELTAVOPT1 (1<<1)
+  #define UG_STD_CMD_OPCFG_DELTAVOPT0 (1<<0)
+#define UG_EXT_CMD_DCAP     (0x3C)
+
+/**
+ * @brief upiGG_FetchDataCommand
+ *
+ *  Fetch bq27520 like command
+ *
+ * @para  read  set _UPI_TRUE_ to read data from API
+ * @para  pMeasPara pointer of GG_MEAS_PARA_TYPE
+ * @return  GGSTATUS
+ */
+EXPORTS GGSTATUS upiGG_FetchDataCommand(char *pObj, _upi_u8_ CommandCode, _upi_u16_ *pData);
+
+typedef struct GG_FETCH_DATA_PARA_ST {
+  _upi_s8_ FCSet;
+  _upi_s8_ FCClear;
+  _upi_u8_ Soc1Set;
+  _upi_u8_ Soc1Clear;
+  _upi_s8_ InitSI;
+  _upi_s16_ InitMaxLoadCurrent;
+  _upi_u16_ CCThreshold;
+  _upi_u32_ Opcfg;
+  _upi_u16_ Dcap;
+} ALIGNED_ATTRIBUTE GG_FETCH_DATA_PARA_TYPE;
+
+/**
+ * @brief upiGG_FetchDataParameter
+ *
+ *  Set the parameter for bq27520 like command
+ *
+ * @para  data  parameters of GG_FETCH_DATA_PARA_TYPE
+ * @return  GGSTATUS
+ */
+EXPORTS GGSTATUS upiGG_FetchDataParameter(char *pObj, GG_FETCH_DATA_PARA_TYPE data);
+
+#endif     //endif ENABLE_BQ27520_SW_CMD
+
+typedef struct GG_FETCH_DEBUG_DATA_ST {
+  /// [AT-PM] : Capacity related ; 01/30/2013
+  int capStatus;
+  int capSelfHour;
+  int capSelfMin;
+  int capSelfSec;
+  int capSelfMilliSec;
+  int capTPTime;
+  int capDelta;
+  int capDsgCharge;
+  int capDsgChargeStart;
+  int capDsgChargeTime;
+  int capPreDsgCharge;
+  int capTableUpdateIdx;
+
+  /// [AT-PM] : Measurement related ; 01/30/2013
+  int measCodeBat1;
+  int measCodeCurrent;
+  int measCodeIT;
+  int measCodeET;
+  int measCharge;
+  int measCCOffset;
+  int measAdc1ConvertTime;
+  int measAdc1Gain;
+  int measAdc1Offset;
+  int measAdc2Gain;
+  int measAdc2Offset;
+  int measLastCounter;
+  int measLastTimeTick;
+  int measLastDeltaQ;
+  int measAdc1CodeT25V100;
+  int measAdc1CodeT25V200;
+  int measAdc2CodeT25V100;
+  int measAdc2CodeT25V200;
+  int measCodeBat1BeforeCal;
+  int measCodeCurrentBeforeCal;
+  int measCodeITBeforeCal;
+  int measCodeETBeforeCal;
+
+  int sysOscFrequency;
+
+} ALIGNED_ATTRIBUTE GG_FETCH_DEBUG_DATA_TYPE;
+
+/**
+ * @brief upiGG_FetchDebugData
+ *
+ *  Fetch debug information data
+ *
+ * @para  pObj  address of memory buffer
+ * @para  data  address of GG_FETCH_CAP_DATA_TYPE
+ * @return  _UPI_NULL_
+ */
+EXPORTS void upiGG_FetchDebugData(char *pObj, GG_FETCH_DEBUG_DATA_TYPE *data);
+
+/**
+ * @brief upiGG_DebugSwitch
+ *
+ *  Enable/disable debug information to UART
+ *
+ * @para  Enable  set debug level
+ * @return  NULL
+ */
+EXPORTS void upiGG_DebugSwitch(_upi_u8_ enable);
+
+/**
+ * @brief upiGG_BackupFileSwitch
+ *
+ *  Enable/disable backup file operation
+ *
+ * @para  Enable  set _UPI_TRUE_ to enable it
+ * @return  NULL
+ */
+EXPORTS void upiGG_BackupFileSwitch(_upi_bool_ enable);
+
+/**
+ * @brief upiGG_BackupFileCheck
+ *
+ *  Backup file check procedure
+ *
+ * @para  pObj  address of memory buffer
+ * @para  BackupFileName  backup filename
+ * @para  SuspendFileName suspend filename
+ * @return  UG_CAP_DATA_STATUS
+ */
+#if defined (uG31xx_OS_WINDOWS)
+
+    EXPORTS _upi_u8_ upiGG_BackupFileCheck(char *pObj, const wchar_t* BackupFileName, const wchar_t *SuspendFileName);
+
+#else
+
+    _upi_u8_ upiGG_BackupFileCheck(char *pObj, char *BackupFileName, char *SuspendFileName);
+
+#endif
+
+/**
+ * @brief upiGG_InternalSuspendMode
+ *
+ *  Set internal suspend mode
+ *  In internal suspend mode, the adc1 conversion time will not be updated, and the delta time is estimated from adc conversion count
+ *
+ * @para  pObj  address of memory buffer
+ * @para  inSuspend set _UPI_TRUE_ for enable internal suspend mode
+ * @return  NULL
+ */
+EXPORTS void upiGG_InternalSuspendMode(char *pObj, _upi_bool_ inSuspend);
+
+/**
+ * @brief upiGG_Reset
+ *
+ *  Reset driver
+ *
+ * @para  pObj  address of buffer
+ * @para  GGBFilename ggb filename
+ * @para  OtpFileName otp data filename
+ * @para  pGGBXBuf  address of ggb data
+ * @return  GGSTATUS
+ */
+#if defined (uG31xx_OS_WINDOWS)
+
+  EXPORTS GGSTATUS upiGG_Reset(char *pObj, const wchar_t* GGBFilename, const wchar_t* OtpFileName);
+
+#else
+
+  GGSTATUS upiGG_Reset(char *pObj, GGBX_FILE_HEADER *pGGBXBuf);
+
+#endif
+
+#if defined (uG31xx_OS_WINDOWS)
+
+  EXPORTS void upiGG_BackupMemory(char *pObj, const wchar_t* BackupFileName);
+  EXPORTS void upiGG_RecoveryMemory(char *pObj, const wchar_t* BackupFileName);
+
+#endif  ///< end of defined (uG31xx_OS_WINDOWS)
+
+#ifndef uG31xx_BOOT_LOADER
+
+EXPORTS void upiGG_SetBatteryET(char *pObj);
+EXPORTS void upiGG_SetBatteryIT(char *pObj);
+
+#endif  ///< end of uG31xx_BOOT_LOADER
+
+EXPORTS int upiGG_GetCycleCount(char *pObj);
+EXPORTS int upiGG_SetCycleCount(char *pObj, _upi_u16_ value);
+
+EXPORTS void upiGG_ReverseCurrent(char *pObj, _upi_bool_ reverse);
+
+EXPORTS void upiGG_AdjustCellTable(CapacityDataType *data);
+
+EXPORTS GGSTATUS upiGG_GetNtcStatus(char *pObj);
+
+EXPORTS _upi_u8_ * upiGG_AccessBackupBuffer(char *pObj, _upi_u8_ *size);
+
+EXPORTS GGSTATUS upiGG_FetchCurrent(char *pObj);
+EXPORTS GGSTATUS upiGG_FetchVoltage(char *pObj);
+EXPORTS GGSTATUS upiGG_FetchInternalTemperature(char *pObj);
+EXPORTS GGSTATUS upiGG_FetchExternalTemperature(char *pObj);
+
+#define GET_BOARD_OFFSET_FULL     (1)
+#define GET_BOARD_OFFSET_AVG      (-1)
+#define GET_BOARD_OFFSET_STEP     (0)
+
+EXPORTS void upiGG_GetBoardOffset(char *pObj, _upi_s16_ fullStep, _upi_s16_ upper, _upi_s16_ lower);
+
+EXPORTS void upiGG_SetCapacitySuspendMode(char *pObj, _upi_bool_ inSuspend);
+EXPORTS void upiGG_SetCapacity(char *pObj, _upi_u8_ target);
+
+#if defined (uG31xx_OS_WINDOWS)
+EXPORTS GGSTATUS upiGG_MpkActiveGG(char **pObj,const wchar_t* GGBFilename,const wchar_t* OtpFileName, _upi_u16_ i2cAddress);
+#endif  ///< end of uG31xx_OS_WINDOWS
+
+EXPORTS void upiGG_ShellUpdateCapacity(char *pObj);
+EXPORTS void upiGG_ShellUpdateCC(char *pObj);
+
+#endif  ///< end of _UG31XXAPI_H_
+
+/// ===========================================
+/// End of uG31xx_API.h
+/// ===========================================
+
diff --git a/drivers/power/supply/ASUS_BATTERY/ME176C/ug31xx/uG31xx_API_Backup.c b/drivers/power/supply/ASUS_BATTERY/ME176C/ug31xx/uG31xx_API_Backup.c
new file mode 100644
index 000000000000..bba46246cda7
--- /dev/null
+++ b/drivers/power/supply/ASUS_BATTERY/ME176C/ug31xx/uG31xx_API_Backup.c
@@ -0,0 +1,793 @@
+/**
+ * Copyright @ 2013 uPI Semiconductor Corp. All right reserved.
+ * The information, images, and/or data contained in this material is copyrighted by uPI
+ * Semiconductor Corp., and may not be distributed, modified, reproduced in whole or in part
+ * without the prior, written consent of uPI Semiconductor Corp.
+ */
+
+/**
+ * @filename  uG31xx_API_Backup.cpp
+ *
+ *  Backup data on uG31xx to a file in system
+ *
+ * @author  AllenTeng <allen_teng@upi-semi.com>
+ * @revision  $Revision: 107 $
+ */
+
+#include "stdafx.h"     //windows need this??
+#include "uG31xx_API.h"
+
+#ifdef  uG31xx_OS_WINDOWS
+
+  #define BACKUP_VERSION      (_T("Backup $Rev: 107 $ "))
+
+#else   ///< else of uG31xx_OS_WINDOWS
+
+  #define BACKUP_VERSION      ("Backup $Rev: 107 $ ")
+
+#endif  ///< end of uG31xx_OS_WINDOWS
+
+#define UG31XX_BACKUP_FILE_ENABLE
+
+#ifndef UG31XX_SHELL_ALGORITHM
+
+static CapacityDataType CheckBackupFile_orgCapData;
+static SystemDataType CheckBackupFile_orgSysData;
+static BackupSuspendDataType UpiWriteSuspendResumeData_buf[BACKUP_MAX_LOG_SUSPEND_DATA];
+
+#endif  ///< end of UG31XX_SHELL_ALGORITHM
+
+char *ptrBackupFileName = _UPI_NULL_;
+char *ptrSuspendFileName = _UPI_NULL_;
+
+/**
+ * @brief CreateBackupBuffer
+ *
+ *  Create buffer for backup file operation
+ *
+ * @para  data  address of BackupDataType
+ * @return  NULL
+ */
+void CreateBackupBuffer(BackupDataType *data)
+{
+  /// [AT-PM] : Count total size to be written to file ; 07/12/2013
+  data->backupBufferSize = ptrCapData->tableSize;
+  data->backupBufferSize = data->backupBufferSize + sizeof(ptrSysData->rmFromIC);
+  data->backupBufferSize = data->backupBufferSize + sizeof(ptrSysData->fccFromIC);
+  data->backupBufferSize = data->backupBufferSize + sizeof(ptrSysData->timeTagFromIC);
+  data->backupBufferSize = data->backupBufferSize + sizeof(ptrSysData->tableUpdateIdxFromIC);
+  data->backupBufferSize = data->backupBufferSize + sizeof(ptrSysData->deltaCapFromIC);
+  data->backupBufferSize = data->backupBufferSize + sizeof(ptrSysData->adc1ConvTime);
+  data->backupBufferSize = data->backupBufferSize + sizeof(ptrSysData->rsocFromIC);
+  data->backupBufferSize = data->backupBufferSize + sizeof(ptrSysData->cycleCount);
+  data->backupBufferSize = data->backupBufferSize + sizeof(ptrSysData->ccOffset);
+  data->backupBufferSize = data->backupBufferSize + sizeof(ptrSysData->predictRsoc);
+  data->backupBufferSize = data->backupBufferSize + sizeof(ptrSysData->standbyDsgRatio);
+  data->backupBufferSize = data->backupBufferSize + sizeof(data->backupVolt1);
+  data->backupBufferSize = data->backupBufferSize + sizeof(data->backupVolt2);
+  data->backupBufferSize = data->backupBufferSize + sizeof(ptrCapData->preDsgCharge);
+  data->backupBufferSize = data->backupBufferSize + CELL_PARAMETER_STRING_LENGTH;
+  data->backupBufferSize = data->backupBufferSize + CELL_PARAMETER_STRING_LENGTH;
+  data->backupBufferSize = data->backupBufferSize + sizeof(_backup_u32_);     ///< [AT-PM] : Used for driver version ; 11/07/2013
+  UG31_LOGN("[%s]: Total %d bytes need to be created for written to file.\n", __func__, data->backupBufferSize);
+
+  /// [AT-PM] : Set memory buffer ; 07/12/2013
+  if(data->backupBufferSize > MAX_BACKUP_BUFFER_SIZE)
+  {
+    UG31_LOGE("[%s]: Exceed maximum backup buffer size\n", __func__);
+    data->backupBufferSize = MAX_BACKUP_BUFFER_SIZE;
+  }
+  upi_memset(data->backupBuffer, 0, (_upi_u32_)data->backupBufferSize);
+}
+
+/**
+ * @brief PrepareData
+ *
+ *  Prepare data to be written to file
+ *
+ * @para  data  address of BackupDataType
+ * @return  NULL
+ */
+void PrepareData(BackupDataType *data)
+{
+  _backup_u8_ *ptr;
+  _backup_u32_ driverVer;
+
+  driverVer = (_backup_u32_)UG31XX_DRIVER_VERSION;
+  UG31_LOGN("[%s]: Driver version = %d (%d)\n", __func__, (int)driverVer, UG31XX_DRIVER_VERSION);
+
+  upi_memcpy(&data->backupCustomerSelfDef[0], (_backup_u8_ *)&ptrCellParameter->customerSelfDef, CELL_PARAMETER_STRING_LENGTH);
+  UG31_LOGN("[%s]: CustomerSelfDef = %s\n", __func__,
+            data->backupCustomerSelfDef);
+  upi_memcpy(&data->backupProjectSelfDef[0], (_backup_u8_ *)&ptrCellParameter->projectSelfDef, CELL_PARAMETER_STRING_LENGTH);
+  UG31_LOGN("[%s]: ProjectSelfDef = %s\n", __func__,
+            data->backupProjectSelfDef);
+
+  ptr = data->backupBuffer;
+  upi_memcpy(ptr, (_backup_u8_ *)ptrCapData->encriptTable, (_upi_u32_)ptrCapData->tableSize);
+  ptr = ptr + ptrCapData->tableSize;
+  upi_memcpy(ptr, (_backup_u8_ *)&ptrSysData->rmFromIC, sizeof(ptrSysData->rmFromIC)/sizeof(_backup_u8_));
+  ptr = ptr + sizeof(ptrSysData->rmFromIC)/sizeof(_backup_u8_);
+  upi_memcpy(ptr, (_backup_u8_ *)&ptrSysData->fccFromIC, sizeof(ptrSysData->fccFromIC)/sizeof(_backup_u8_));
+  ptr = ptr + sizeof(ptrSysData->fccFromIC)/sizeof(_backup_u8_);
+  upi_memcpy(ptr, (_backup_u8_ *)&ptrSysData->timeTagFromIC, sizeof(ptrSysData->timeTagFromIC)/sizeof(_backup_u8_));
+  ptr = ptr + sizeof(ptrSysData->timeTagFromIC)/sizeof(_backup_u8_);
+  upi_memcpy(ptr, (_backup_u8_ *)&ptrSysData->tableUpdateIdxFromIC, sizeof(ptrSysData->tableUpdateIdxFromIC)/sizeof(_backup_u8_));
+  ptr = ptr + sizeof(ptrSysData->tableUpdateIdxFromIC)/sizeof(_backup_u8_);
+  upi_memcpy(ptr, (_backup_u8_ *)&ptrSysData->deltaCapFromIC, sizeof(ptrSysData->deltaCapFromIC)/sizeof(_backup_u8_));
+  ptr = ptr + sizeof(ptrSysData->deltaCapFromIC)/sizeof(_backup_u8_);
+  upi_memcpy(ptr, (_backup_u8_ *)&ptrSysData->adc1ConvTime, sizeof(ptrSysData->adc1ConvTime)/sizeof(_backup_u8_));
+  ptr = ptr + sizeof(ptrSysData->adc1ConvTime)/sizeof(_backup_u8_);
+  upi_memcpy(ptr, (_backup_u8_ *)&ptrSysData->rsocFromIC, sizeof(ptrSysData->rsocFromIC)/sizeof(_backup_u8_));
+  ptr = ptr + sizeof(ptrSysData->rsocFromIC)/sizeof(_backup_u8_);
+  upi_memcpy(ptr, (_backup_u8_ *)&ptrSysData->cycleCount, sizeof(ptrSysData->cycleCount)/sizeof(_backup_u8_));
+  ptr = ptr + sizeof(ptrSysData->cycleCount)/sizeof(_backup_u8_);
+  upi_memcpy(ptr, (_backup_u8_ *)&ptrSysData->ccOffset, sizeof(ptrSysData->ccOffset)/sizeof(_backup_u8_));
+  ptr = ptr + sizeof(ptrSysData->ccOffset)/sizeof(_backup_u8_);
+  upi_memcpy(ptr, (_backup_u8_ *)&ptrSysData->predictRsoc, sizeof(ptrSysData->predictRsoc)/sizeof(_backup_u8_));
+  ptr = ptr + sizeof(ptrSysData->predictRsoc)/sizeof(_backup_u8_);
+  upi_memcpy(ptr, (_backup_u8_ *)&ptrSysData->standbyDsgRatio, sizeof(ptrSysData->standbyDsgRatio)/sizeof(_backup_u8_));
+  ptr = ptr + sizeof(ptrSysData->standbyDsgRatio)/sizeof(_backup_u8_);
+  upi_memcpy(ptr, (_backup_u8_ *)&data->backupVolt1, sizeof(data->backupVolt1)/sizeof(_backup_u8_));
+  ptr = ptr + sizeof(data->backupVolt1)/sizeof(_backup_u8_);
+  upi_memcpy(ptr, (_backup_u8_ *)&data->backupVolt2, sizeof(data->backupVolt2)/sizeof(_backup_u8_));
+  ptr = ptr + sizeof(data->backupVolt2)/sizeof(_backup_u8_);
+  upi_memcpy(ptr, (_backup_u8_ *)&ptrCapData->preDsgCharge, sizeof(ptrCapData->preDsgCharge)/sizeof(_backup_u8_));
+  ptr = ptr + sizeof(ptrCapData->preDsgCharge)/sizeof(_backup_u8_);
+  upi_memcpy(ptr, &data->backupCustomerSelfDef[0], CELL_PARAMETER_STRING_LENGTH);
+  ptr = ptr + CELL_PARAMETER_STRING_LENGTH;
+  upi_memcpy(ptr, &data->backupProjectSelfDef[0], CELL_PARAMETER_STRING_LENGTH);
+  ptr = ptr + CELL_PARAMETER_STRING_LENGTH;
+  upi_memcpy(ptr, (_backup_u8_ *)&driverVer, sizeof(driverVer)/sizeof(_backup_u8_));
+}
+
+/**
+ * @brief ConvertData
+ *
+ *  Convert data from buffer
+ *
+ * @para  data  address of BackupDataType structure
+ * @return  driver version
+ */
+_backup_u32_ ConvertData(BackupDataType *data)
+{
+  _backup_u8_ *ptr;
+  _backup_u32_ driverVer;
+
+  ptr = data->backupBuffer;
+  upi_memcpy((_backup_u8_ *)ptrCapData->encriptTable, ptr, (_upi_u32_)ptrCapData->tableSize);
+  ptr = ptr + ptrCapData->tableSize;
+  upi_memcpy((_backup_u8_ *)&ptrSysData->rmFromIC, ptr, sizeof(ptrSysData->rmFromIC)/sizeof(_backup_u8_));
+  ptr = ptr + sizeof(ptrSysData->rmFromIC)/sizeof(_backup_u8_);
+  upi_memcpy((_backup_u8_ *)&ptrSysData->fccFromIC, ptr, sizeof(ptrSysData->fccFromIC)/sizeof(_backup_u8_));
+  ptr = ptr + sizeof(ptrSysData->fccFromIC)/sizeof(_backup_u8_);
+  upi_memcpy((_backup_u8_ *)&ptrSysData->timeTagFromIC, ptr, sizeof(ptrSysData->timeTagFromIC)/sizeof(_backup_u8_));
+  ptr = ptr + sizeof(ptrSysData->timeTagFromIC)/sizeof(_backup_u8_);
+  upi_memcpy((_backup_u8_ *)&ptrSysData->tableUpdateIdxFromIC, ptr, sizeof(ptrSysData->tableUpdateIdxFromIC)/sizeof(_backup_u8_));
+  ptr = ptr + sizeof(ptrSysData->tableUpdateIdxFromIC)/sizeof(_backup_u8_);
+  upi_memcpy((_backup_u8_ *)&ptrSysData->deltaCapFromIC, ptr, sizeof(ptrSysData->deltaCapFromIC)/sizeof(_backup_u8_));
+  ptr = ptr + sizeof(ptrSysData->deltaCapFromIC)/sizeof(_backup_u8_);
+  upi_memcpy((_backup_u8_ *)&ptrSysData->adc1ConvTime, ptr, sizeof(ptrSysData->adc1ConvTime)/sizeof(_backup_u8_));
+  ptr = ptr + sizeof(ptrSysData->adc1ConvTime)/sizeof(_backup_u8_);
+  upi_memcpy((_backup_u8_ *)&ptrSysData->rsocFromIC, ptr, sizeof(ptrSysData->rsocFromIC)/sizeof(_backup_u8_));
+  ptr = ptr + sizeof(ptrSysData->rsocFromIC)/sizeof(_backup_u8_);
+  upi_memcpy((_backup_u8_ *)&ptrSysData->cycleCount, ptr, sizeof(ptrSysData->cycleCount)/sizeof(_backup_u8_));
+  ptr = ptr + sizeof(ptrSysData->cycleCount)/sizeof(_backup_u8_);
+  upi_memcpy((_backup_u8_ *)&ptrSysData->ccOffset, ptr, sizeof(ptrSysData->ccOffset)/sizeof(_backup_u8_));
+  ptr = ptr + sizeof(ptrSysData->ccOffset)/sizeof(_backup_u8_);
+  upi_memcpy((_backup_u8_ *)&ptrSysData->predictRsoc, ptr, sizeof(ptrSysData->predictRsoc)/sizeof(_backup_u8_));
+  ptr = ptr + sizeof(ptrSysData->predictRsoc)/sizeof(_backup_u8_);
+  upi_memcpy((_backup_u8_ *)&ptrSysData->standbyDsgRatio, ptr, sizeof(ptrSysData->standbyDsgRatio)/sizeof(_backup_u8_));
+  ptr = ptr + sizeof(ptrSysData->standbyDsgRatio)/sizeof(_backup_u8_);
+  upi_memcpy((_backup_u8_ *)&data->backupVolt1, ptr, sizeof(data->backupVolt1)/sizeof(_backup_u8_));
+  ptr = ptr + sizeof(data->backupVolt1)/sizeof(_backup_u8_);
+  upi_memcpy((_backup_u8_ *)&data->backupVolt2, ptr, sizeof(data->backupVolt2)/sizeof(_backup_u8_));
+  ptr = ptr + sizeof(data->backupVolt2)/sizeof(_backup_u8_);
+  upi_memcpy((_backup_u8_ *)&ptrCapData->preDsgCharge, ptr, sizeof(ptrCapData->preDsgCharge)/sizeof(_backup_u8_));
+  ptr = ptr + sizeof(ptrCapData->preDsgCharge)/sizeof(_backup_u8_);
+  upi_memcpy(&data->backupCustomerSelfDef[0], ptr, CELL_PARAMETER_STRING_LENGTH);
+  ptr = ptr + CELL_PARAMETER_STRING_LENGTH;
+  upi_memcpy(&data->backupProjectSelfDef[0], ptr, CELL_PARAMETER_STRING_LENGTH);
+  ptr = ptr + CELL_PARAMETER_STRING_LENGTH;
+  upi_memcpy((_backup_u8_ *)&driverVer, ptr, sizeof(driverVer)/sizeof(_backup_u8_));
+  UG31_LOGI("[%s]: Read driver version = %d (%d)\n", __func__, (int)driverVer, UG31XX_DRIVER_VERSION);
+  return (driverVer);
+}
+
+enum CHECK_BACKUP_FILE_STS {
+  CHECK_BACKUP_FILE_STS_PASS = 0,
+  CHECK_BACKUP_FILE_STS_VERSION_MISMATCH,
+  CHECK_BACKUP_FILE_STS_READ_FAIL,
+  CHECK_BACKUP_FILE_STS_NEED_UPDATE,
+  CHECK_BACKUP_FILE_STS_WRITE_FAIL,
+};
+
+/**
+ * @brief CheckBackupFile
+ *
+ *  Check backup file is consisted with IC or not
+ *
+ * @para  data  address of BackupDataType
+ * @return  CHECK_BACKUP_FILE_STS
+ */
+_backup_u8_ CheckBackupFile(BackupDataType *data)
+{
+  CapacityDataType *orgCapData;
+  SystemDataType *orgSysData;
+  _upi_bool_ rtn;
+  _backup_u32_ driverVer;
+  _backup_u8_ rtnU8;
+  _backup_u16_ volt1;
+  _backup_u16_ volt2;
+
+  /// [AT-PM] : Create buffer ; 02/21/2013
+  #ifndef UG31XX_SHELL_ALGORITHM
+    orgCapData = &CheckBackupFile_orgCapData;
+    orgSysData = &CheckBackupFile_orgSysData;
+  #else   ///< else of UG31XX_SHELL_ALGORITHM
+    orgCapData = (CapacityDataType *)upi_malloc(sizeof(CapacityDataType));
+    orgSysData = (SystemDataType *)upi_malloc(sizeof(SystemDataType));
+  #endif  ///< end of UG31XX_SHELL_ALGORITHM
+  upi_memcpy(orgCapData, ptrCapData, sizeof(CapacityDataType));
+  upi_memcpy(orgSysData, ptrSysData, sizeof(SystemDataType));
+  volt1 = data->backupVolt1;
+  volt2 = data->backupVolt2;
+
+  /// [AT-PM] : Get data from file ; 02/21/2013
+  #if defined (uG31xx_OS_WINDOWS)
+  rtn = read_backup_file(data->backupFileName, data->backupBuffer, data->backupBufferSize);
+  #else  ///< else of defined (uG31xx_OS_WINDOWS)
+  rtn = read_backup_file(ptrBackupFileName, data->backupBuffer, data->backupBufferSize);
+  #endif ///< end of defined (uG31xx_OS_WINDOWS)
+  if(rtn == _UPI_FALSE_)
+  {
+    UG31_LOGD("[%s]: Read data from backup file fail.\n", __func__);
+    #ifdef  UG31XX_SHELL_ALGORITHM
+      upi_free(orgCapData);
+      upi_free(orgSysData);
+    #endif  ///< end of UG31XX_SHELL_ALGORITHM
+    return (CHECK_BACKUP_FILE_STS_READ_FAIL);
+  }
+  driverVer = ConvertData(data);
+
+  /// [AT-PM] : Following information is not checked ; 02/21/2013
+  ptrSysData->rmFromIC = orgSysData->rmFromIC;
+  ptrSysData->timeTagFromIC = orgSysData->timeTagFromIC;
+  ptrSysData->deltaCapFromIC = orgSysData->deltaCapFromIC;
+  ptrSysData->adc1ConvTime = orgSysData->adc1ConvTime;
+  ptrCapData->preDsgCharge = orgCapData->preDsgCharge;
+
+  /// [AT-PM] : Check data ; 02/21/2013
+  if(driverVer != UG31XX_DRIVER_VERSION)
+  {
+    UG31_LOGN("[%s]: Backup file version mismatched.\n", __func__);
+    rtnU8 = CHECK_BACKUP_FILE_STS_VERSION_MISMATCH;
+  }
+  else if((upi_memcmp(data->backupCustomerSelfDef, ptrCellParameter->customerSelfDef, CELL_PARAMETER_STRING_LENGTH) != 0) ||
+           (upi_memcmp(data->backupProjectSelfDef, ptrCellParameter->projectSelfDef, CELL_PARAMETER_STRING_LENGTH) != 0))
+  {
+    UG31_LOGN("[%s]: Backup file cell information mismatched.\n", __func__);
+    rtnU8 = CHECK_BACKUP_FILE_STS_VERSION_MISMATCH;
+  }
+  else if((upi_memcmp(orgCapData, ptrCapData, sizeof(CapacityDataType)) != 0) ||
+          (upi_memcmp(orgSysData, ptrSysData, sizeof(SystemDataType)) != 0) ||
+          (volt1 != data->backupVolt1) ||
+          (volt2 != data->backupVolt2))
+  {
+    UG31_LOGN("[%s]: Backup file needs to be updated\n", __func__);
+    rtnU8 = CHECK_BACKUP_FILE_STS_NEED_UPDATE;
+  }
+  else
+  {
+    rtnU8 = CHECK_BACKUP_FILE_STS_PASS;
+  }
+  #ifdef  UG31XX_SHELL_ALGORITHM
+    upi_free(orgCapData);
+    upi_free(orgSysData);
+  #endif  ///< end of UG31XX_SHELL_ALGORITHM
+  return (rtnU8);
+}
+
+/**
+ * @brief UpdateBackupFile
+ *
+ *  Update backup file
+ *
+ * @para  data  address of BackupDataType
+ * @return  CHECK_BACKUP_FILE_STS
+ */
+_backup_u8_ UpdateBackupFile(BackupDataType *data)
+{
+  _upi_bool_ rtn;
+
+  PrepareData(data);
+  #if defined (uG31xx_OS_WINDOWS)
+  rtn = write_backup_file(data->backupFileName, data->backupBuffer, data->backupBufferSize);
+  #else  ///< else of defined (uG31xx_OS_WINDOWS)
+  rtn = write_backup_file(ptrBackupFileName, data->backupBuffer, data->backupBufferSize);
+  #endif ///< end of defined (uG31xx_OS_WINDOWS)
+  if(rtn == _UPI_FALSE_)
+  {
+    UG31_LOGD("[%s]: Write data to backup file fail.\n", __func__);
+    return (CHECK_BACKUP_FILE_STS_WRITE_FAIL);
+  }
+  return (CHECK_BACKUP_FILE_STS_PASS);
+}
+
+/// =============================================
+/// Extern Function Region
+/// =============================================
+
+#ifdef  UG31XX_SHELL_ALGORITHM
+
+#define RETRY_CHECKING_THRESHOLD      (20)
+
+#else   ///< else of UG31XX_SHELL_ALGORITHM
+
+#define RETRY_CHECKING_THRESHOLD      (5)
+
+#endif  ///< end of UG31XX_SHELL_ALGORITHM
+
+/**
+ * @brief UpiBackupData
+ *
+ *  Backup data from IC to system routine
+ *
+ * @para  data  address of BackupDataType
+ * @return  _UPI_NULL_
+ */
+void UpiBackupData(BackupDataType *data)
+{
+  _backup_bool_ rtnBool;
+  _backup_u8_ rtnU8;
+
+  #ifndef UG31XX_BACKUP_FILE_ENABLE
+    rtnBool = _UPI_TRUE_;
+    data->backupFileSts = BACKUP_FILE_STS_COMPARE;
+  #endif  ///< end of UG31XX_BACKUP_FILE_ENABLE
+
+  switch(data->backupFileSts)
+  {
+    case  BACKUP_FILE_STS_CHECKING:
+      /// [AT-PM] : Check backup file existed or not ; 02/21/2013
+      #if defined (uG31xx_OS_WINDOWS)
+      rtnBool = is_file_exist(data->backupFileName);
+      #else  ///< else of defined (uG31xx_OS_WINDOWS)
+      rtnBool = is_file_exist(ptrBackupFileName);
+      #endif ///< end of defined (uG31xx_OS_WINDOWS)
+      UG31_LOGN("[%s]: is_file_exist() = %d.\n", __func__, rtnBool);
+      if(rtnBool == BACKUP_BOOL_TRUE)
+      {
+        data->backupFileSts = BACKUP_FILE_STS_EXIST;
+        data->backupFileRetryCnt = 0;
+      }
+      else
+      {
+        data->backupFileRetryCnt = data->backupFileRetryCnt + 1;
+        UG31_LOGN("[%s]: Check backup file retry count = %d\n", __func__, data->backupFileRetryCnt);
+        if(data->backupFileRetryCnt > RETRY_CHECKING_THRESHOLD)
+        {
+          data->backupFileSts = BACKUP_FILE_STS_NOT_EXIST;
+          UG31_LOGE("[%s]: Backup file is not exist.\n", __func__);
+        }
+      }
+      break;
+    case  BACKUP_FILE_STS_NOT_EXIST:
+      /// [AT-PM] : Create backup file ; 02/21/2013
+      PrepareData(data);
+      #if defined (uG31xx_OS_WINDOWS)
+      rtnBool = create_backup_file(data->backupFileName, data->backupBuffer, data->backupBufferSize);
+      #else  ///< else of defined (uG31xx_OS_WINDOWS)
+      rtnBool = create_backup_file(ptrBackupFileName, data->backupBuffer, data->backupBufferSize);
+      #endif ///< end of defined (uG31xx_OS_WINDOWS)
+      UG31_LOGN("[%s]: create_backup_file() = %d.\n", __func__, rtnBool);
+      if(rtnBool == BACKUP_BOOL_TRUE)
+      {
+        data->backupFileSts = BACKUP_FILE_STS_EXIST;
+        data->icDataAvailable = BACKUP_BOOL_TRUE;
+      }
+      else
+      {
+        UG31_LOGE("[%s]: Create backup file fail.\n", __func__);
+      }
+      break;
+    case  BACKUP_FILE_STS_EXIST:
+      data->backupFileSts = BACKUP_FILE_STS_COMPARE;
+    case  BACKUP_FILE_STS_COMPARE:
+      if(data->icDataAvailable == BACKUP_BOOL_TRUE)
+      {
+        /// [AT-PM] : Check content of file is consist with IC or not ; 02/21/2013
+        rtnU8 = CheckBackupFile(data);
+        UG31_LOGN("[%s]: CheckBackupFile() = %d.\n", __func__, rtnU8);
+        if(rtnU8 == CHECK_BACKUP_FILE_STS_VERSION_MISMATCH)
+        {
+          data->backupFileSts = BACKUP_FILE_STS_UPDATE_BY_VERSION;
+        }
+        else if(rtnU8 == CHECK_BACKUP_FILE_STS_NEED_UPDATE)
+        {
+          data->backupFileSts = BACKUP_FILE_STS_UPDATE;
+        }
+        else if(rtnU8 == CHECK_BACKUP_FILE_STS_PASS)
+        {
+          data->backupFileSts = BACKUP_FILE_STS_COMPARE;
+        }
+        else
+        {
+          data->backupFileSts = BACKUP_FILE_STS_UPDATE;
+        }
+      }
+      else
+      {
+        data->backupFileSts = BACKUP_FILE_STS_CHECKING;
+      }
+      break;
+    case  BACKUP_FILE_STS_UPDATE:
+    case  BACKUP_FILE_STS_UPDATE_BY_VERSION:
+      if(data->icDataAvailable == BACKUP_BOOL_TRUE)
+      {
+        rtnU8 = UpdateBackupFile(data);
+        UG31_LOGN("[%s]: UpdateBackupFile() = %d.\n", __func__, rtnU8);
+        if(rtnU8 == CHECK_BACKUP_FILE_STS_PASS)
+        {
+          if(data->backupFileSts == BACKUP_FILE_STS_UPDATE_BY_VERSION)
+          {
+            data->backupFileSts = BACKUP_FILE_STS_VERSION_MISMATCH;
+          }
+          else
+          {
+            data->backupFileSts = BACKUP_FILE_STS_COMPARE;
+          }
+        }
+      }
+      else
+      {
+        data->backupFileSts = BACKUP_FILE_STS_CHECKING;
+      }
+      break;
+    default:
+      /// [AT-PM] : Un-known state ; 02/21/2013
+      data->backupFileSts = BACKUP_FILE_STS_NOT_EXIST;
+      break;
+  }
+}
+
+#define RESTORE_ABNORMAL_VOLT_RANGE_UPBND (100)
+#define RESTORE_ABNORMAL_VOLT_RANGE_LWBND (-100)
+
+/**
+ * @brief UpiRestoreData
+ *
+ *  Restore data from system to IC routine
+ *
+ * @para  data  address of BackupDataType
+ * @return  BACKUP_BOOL_TRUE if success
+ */
+_backup_bool_ UpiRestoreData(BackupDataType *data)
+{
+  _backup_bool_ rtn;
+  _backup_u32_ driverVer;
+  SystemDataType *orgSysData;
+  _backup_s32_ tmp32;
+
+  /// [AT-PM] : Create buffer ; 02/21/2013
+  #ifndef UG31XX_SHELL_ALGORITHM
+    orgSysData = &CheckBackupFile_orgSysData;
+  #else   ///< else of UG31XX_SHELL_ALGORITHM
+    orgSysData = (SystemDataType *)upi_malloc(sizeof(SystemDataType));
+  #endif  ///< end of UG31XX_SHELL_ALGORITHM
+  upi_memcpy(orgSysData, ptrSysData, sizeof(SystemDataType));
+
+  /// [AT-PM] : Get data from file ; 02/21/2013
+  #if defined (uG31xx_OS_WINDOWS)
+  rtn = read_backup_file(data->backupFileName, data->backupBuffer, data->backupBufferSize);
+  #else  ///< else of defined (uG31xx_OS_WINDOWS)
+  rtn = read_backup_file(ptrBackupFileName, data->backupBuffer, data->backupBufferSize);
+  #endif ///< end of defined (uG31xx_OS_WINDOWS)
+  if(rtn == _UPI_FALSE_)
+  {
+    UG31_LOGE("[%s]: Read data from backup file fail.\n", __func__);
+    #ifdef  UG31XX_SHELL_ALGORITHM
+      upi_free(orgSysData);
+    #endif  ///< end of UG31XX_SHELL_ALGORITHM
+    return (BACKUP_BOOL_FALSE);
+  }
+  driverVer = ConvertData(data);
+  UG31_LOGI("[%s]: Driver version = %d\n", __func__, (int)driverVer);
+
+  /// [AT-PM] : Keep following information ; 01/22/2014
+  ptrSysData->timeTagFromIC = orgSysData->timeTagFromIC;
+  ptrSysData->tableUpdateIdxFromIC = orgSysData->tableUpdateIdxFromIC;
+
+  /// [AT-PM] : Check abnormal condition ; 01/22/2014
+  if((data->backupVolt1 != 0) && (data->backupVolt2 != 0))
+  {
+    tmp32 = (_backup_s32_)data->backupVolt1;
+    tmp32 = tmp32 - data->backupVolt2;
+    if((tmp32 < RESTORE_ABNORMAL_VOLT_RANGE_UPBND) && (tmp32 > RESTORE_ABNORMAL_VOLT_RANGE_LWBND))
+    {
+      ptrSysData->rmFromIC = orgSysData->rmFromIC;
+      ptrSysData->fccFromIC = orgSysData->fccFromIC;
+      ptrSysData->rsocFromIC = orgSysData->rsocFromIC;
+    }
+  }
+  #ifdef  UG31XX_SHELL_ALGORITHM
+    upi_free(orgSysData);
+  #endif  ///< end of UG31XX_SHELL_ALGORITHM
+  return (BACKUP_BOOL_TRUE);
+}
+
+/**
+ * @brief UpiInitBackupData
+ *
+ *  Initialize memory buffer of BackupDataType structure
+ *
+ * @para  data  address of BackupDataType
+ * @return  NULL
+ */
+void UpiInitBackupData(BackupDataType *data)
+{
+  /// [AT-PM] : Backup data in GGB file ; 12/10/2013
+  data->backupNacLmdAdjustCfg = (_backup_u32_)ptrCellParameter->NacLmdAdjustCfg;
+
+  /// [AT-PM] : Memory buffer for backup file ; 12/03/2013
+  data->backupFileRetryCnt = 0;
+  CreateBackupBuffer(data);
+
+  /// [AT-PM] : Memory buffer for suspend/resume data ; 12/03/2013
+  data->backupSuspendIdx = BACKUP_MAX_LOG_SUSPEND_DATA;
+  while(data->backupSuspendIdx)
+  {
+    data->backupSuspendIdx = data->backupSuspendIdx - 1;
+    upi_memset(&data->backupSuspendData[data->backupSuspendIdx], 0, sizeof(BackupSuspendDataType));
+    UG31_LOGN("[%s]: data->backupSuspendData[%d] = %d\n", __func__,
+              data->backupSuspendIdx, (int)(&data->backupSuspendData[data->backupSuspendIdx]));
+  }
+
+  /// [AT-PM] : Initialize backup voltage variables ; 01/24/2014
+  data->backupVolt1 = 0;
+  data->backupVolt2 = 0;
+  data->backupDeltaQ = 0;
+}
+
+/**
+ * @brief UpiFreeBackupData
+ *
+ *  Free memory for BackupDataType
+ *
+ * @para  data  address of BackupDataType
+ * @return  NULL
+ */
+void UpiFreeBackupData(BackupDataType *data)
+{
+  /// [AT-PM] : Memory buffer for backup file ; 12/03/2013
+
+  /// [AT-PM] : Memory buffer for suspend/resume data ; 12/03/2013
+  data->backupSuspendIdx = BACKUP_MAX_LOG_SUSPEND_DATA;
+  while(data->backupSuspendIdx)
+  {
+    data->backupSuspendIdx = data->backupSuspendIdx - 1;
+    UG31_LOGN("[%s]: data->backupSuspendData[%d] = %d\n", __func__,
+              data->backupSuspendIdx, (int)&data->backupSuspendData[data->backupSuspendIdx]);
+  }
+}
+
+/**
+ * @brief UpiSaveSuspendData
+ *
+ *  Save suspend data for backup
+ *
+ * @para  data  address of BackupDataType
+ * @return  NULL
+ */
+void UpiSaveSuspendData(BackupDataType *data)
+{
+  data->backupSuspendData[data->backupSuspendIdx].beforeCapData = *(ptrCapData);
+  data->backupSuspendData[data->backupSuspendIdx].beforeMeasData = *(ptrMeasData);
+  UG31_LOGN("[%s]: Save suspend data to buffer %d\n", __func__, data->backupSuspendIdx);
+}
+
+/**
+ * @brief UpiSaveResumeData
+ *
+ *  Save resume data for backup
+ *
+ * @para  data  address of BackupDataType
+ * @return  NULL
+ */
+void UpiSaveResumeData(BackupDataType *data)
+{
+  data->backupSuspendData[data->backupSuspendIdx].afterCapData = *(ptrCapData);
+  data->backupSuspendData[data->backupSuspendIdx].afterMeasData = *(ptrMeasData);
+  UG31_LOGN("[%s]: Save resume data to buffer %d\n", __func__, data->backupSuspendIdx);
+
+  data->backupSuspendIdx = data->backupSuspendIdx + 1;
+  if(data->backupSuspendIdx >= BACKUP_MAX_LOG_SUSPEND_DATA)
+  {
+    data->backupSuspendIdx = 0;
+    while(data->backupSuspendIdx < (BACKUP_MAX_LOG_SUSPEND_DATA - 1))
+    {
+      upi_memcpy(&data->backupSuspendData[data->backupSuspendIdx],
+                 &data->backupSuspendData[data->backupSuspendIdx + 1],
+                 sizeof(BackupSuspendDataType));
+      data->backupSuspendIdx = data->backupSuspendIdx + 1;
+    }
+
+    upi_memset(&data->backupSuspendData[data->backupSuspendIdx], 0, sizeof(BackupSuspendDataType));
+    UG31_LOGN("[%s]: Next suspend / resume data buffer is %d\n", __func__, data->backupSuspendIdx);
+  }
+}
+
+/**
+ * @brief UpiWriteSuspendResumeData
+ *
+ *  Write suspend / resume data to file
+ *
+ * @para  data  address of BackupDataType
+ * @return  NULL
+ */
+void UpiWriteSuspendResumeData(BackupDataType *data)
+{
+  _backup_bool_ rtn;
+  _backup_u8_ *buf;
+  _backup_u32_ size;
+  _backup_u32_ cmpResult;
+
+  size = sizeof(BackupSuspendDataType)*BACKUP_MAX_LOG_SUSPEND_DATA;
+  #ifndef UG31XX_SHELL_ALGORITHM
+    buf = (_backup_u8_ *)&UpiWriteSuspendResumeData_buf[0];
+  #else   ///< else of UG31XX_SHELL_ALGORITHM
+    buf = (_backup_u8_ *)upi_malloc(size);
+  #endif  ///< end of UG31XX_SHELL_ALGORITHM
+
+  #if defined (uG31xx_OS_WINDOWS)
+    rtn = read_backup_file(data->suspendFileName, (_upi_u8_ *)buf, size);
+  #else  ///< else of defined (uG31xx_OS_WINDOWS)
+    rtn = read_backup_file(ptrSuspendFileName, (_upi_u8_ *)buf, size);
+  #endif ///< end of defined (uG31xx_OS_WINDOWS)
+  UG31_LOGN("[%s]: Read suspend / resume data from file -> %d\n", __func__, rtn);
+
+  if(rtn != _UPI_TRUE_)
+  {
+    #if defined (uG31xx_OS_WINDOWS)
+      rtn = write_backup_file(data->suspendFileName, (_upi_u8_ *)(&data->backupSuspendData[0]), size);
+    #else  ///< else of defined (uG31xx_OS_WINDOWS)
+      rtn = write_backup_file(ptrSuspendFileName, (_upi_u8_ *)(&data->backupSuspendData[0]), size);
+    #endif ///< end of defined (uG31xx_OS_WINDOWS)
+    UG31_LOGN("[%s]: Write suspend / resume data to file -> %d\n", __func__, rtn);
+    #ifdef  UG31XX_SHELL_ALGORITHM
+      upi_free(buf);
+    #endif  ///< end of UG31XX_SHELL_ALGORITHM
+    return;
+  }
+
+  cmpResult = upi_memcmp(buf, (_backup_u8_ *)(&data->backupSuspendData[0]), size);
+  UG31_LOGN("[%s]: Compare suspend / resume data with file -> %d\n", __func__, (int)cmpResult);
+
+  if(cmpResult != 0)
+  {
+    #if defined (uG31xx_OS_WINDOWS)
+      rtn = write_backup_file(data->suspendFileName, (_upi_u8_ *)(&data->backupSuspendData[0]), size);
+    #else  ///< else of defined (uG31xx_OS_WINDOWS)
+      rtn = write_backup_file(ptrSuspendFileName, (_upi_u8_ *)(&data->backupSuspendData[0]), size);
+    #endif ///< end of defined (uG31xx_OS_WINDOWS)
+    UG31_LOGN("[%s]: Write suspend / resume data to file -> %d\n", __func__, rtn);
+  }
+  #ifdef  UG31XX_SHELL_ALGORITHM
+    upi_free(buf);
+  #endif  ///< end of UG31XX_SHELL_ALGORITHM
+}
+
+/**
+ * @brief UpiGetBackupMemorySize
+ *
+ *  Get memory size used in backup module
+ *
+ * @return  memory size
+ */
+_backup_u32_ UpiGetBackupMemorySize(void)
+{
+  _backup_u32_ totalSize;
+  #ifndef UG31XX_SHELL_ALGORITHM
+  _backup_u32_ tmp;
+  #endif  ///< end of UG31XX_SHELL_ALGORITHM
+
+  totalSize = 0;
+
+  #ifndef UG31XX_SHELL_ALGORITHM
+
+  tmp = (_backup_u32_)sizeof(CheckBackupFile_orgCapData);
+  totalSize = totalSize + tmp;
+  UG31_LOGD("[%s]: memory size for CheckBackupFile_orgCapData = %d (%d)\n", __func__, (int)tmp, (int)totalSize);
+
+  tmp = (_backup_u32_)sizeof(CheckBackupFile_orgSysData);
+  totalSize = totalSize + tmp;
+  UG31_LOGD("[%s]: memory size for CheckBackupFile_orgSysData = %d (%d)\n", __func__, (int)tmp, (int)totalSize);
+
+  tmp = (_backup_u32_)sizeof(UpiWriteSuspendResumeData_buf[0]);
+  totalSize = totalSize + tmp*BACKUP_MAX_LOG_SUSPEND_DATA;
+  UG31_LOGD("[%s]: memory size for UpiWriteSuspendResumeData_buf = %d (%d)\n", __func__, (int)tmp, (int)totalSize);
+
+  #endif  ///< end of UG31XX_SHELL_ALGORITHM
+
+  return (totalSize);
+}
+
+#define BACKUP_VOLTAGE_DELTA_Q_THRESHOLD  (10)
+
+/**
+ * @brief UpiBackupVoltage
+ *
+ *  Backup voltage points for abnormal battery checking
+ *
+ * @para  data  address of BackupDataType
+ * @return  NULL
+ */
+void UpiBackupVoltage(BackupDataType *data)
+{
+  _backup_s32_ tmp32;
+
+  /// [AT-PM] : Cumulate delta Q ; 01/22/2014
+  tmp32 = (_backup_s32_)ptrMeasData->stepCap;
+  tmp32 = tmp32*ptrMeasData->curr;
+  if(tmp32 < 0)
+  {
+    tmp32 = 0;
+  }
+  else
+  {
+    tmp32 = (_backup_s32_)ptrMeasData->stepCap;
+  }
+  tmp32 = tmp32 + data->backupDeltaQ;
+  data->backupDeltaQ = (_backup_u16_)tmp32;
+
+  /// [AT-PM] : Update voltage point 1 ; 01/22/2014
+  data->backupVolt1 = (_backup_u16_)ptrMeasData->bat1Voltage;
+  UG31_LOGN("[%s]: Update backup voltage point 1 = %d (%d)\n", __func__, data->backupVolt1, data->backupDeltaQ);
+
+  /// [AT-PM] : Check delta Q ; 01/22/2014
+  tmp32 = ptrCellParameter->ILMD;
+  tmp32 = tmp32*BACKUP_VOLTAGE_DELTA_Q_THRESHOLD/CONST_PERCENTAGE;
+  if(data->backupDeltaQ < 0)
+  {
+    tmp32 = tmp32*(-1);
+    if(data->backupDeltaQ > tmp32)
+    {
+      UG31_LOGN("[%s]: data->backupDeltaQ not reach threshold %d\n", __func__, tmp32);
+      return;
+    }
+  }
+  else
+  {
+    if(data->backupDeltaQ < tmp32)
+    {
+      UG31_LOGN("[%s]: data->backupDeltaQ not reach threshold %d\n", __func__, tmp32);
+      return;
+    }
+  }
+
+  /// [AT-PM] : Update voltage point 2 ; 01/22/2014
+  data->backupVolt2 = data->backupVolt1;
+  data->backupDeltaQ = 0;
+  UG31_LOGI("[%s]: Update backup voltage point 2 = %d (%d)\n", __func__, data->backupVolt1, data->backupDeltaQ);
+}
+
+/**
+ * @brief UpiPrintBackupVersion
+ *
+ *  Print backup module version
+ *
+ * @return  NULL
+ */
+void UpiPrintBackupVersion(void)
+{
+  UG31_LOGE("[%s]: %s\n", __func__,
+            BACKUP_VERSION);
+}
+
+
+/**
+ * Copyright @ 2013 uPI Semiconductor Corp. All right reserved.
+ * The information, images, and/or data contained in this material is copyrighted by uPI
+ * Semiconductor Corp., and may not be distributed, modified, reproduced in whole or in part
+ * without the prior, written consent of uPI Semiconductor Corp.
+ */
diff --git a/drivers/power/supply/ASUS_BATTERY/ME176C/ug31xx/uG31xx_API_Backup.h b/drivers/power/supply/ASUS_BATTERY/ME176C/ug31xx/uG31xx_API_Backup.h
new file mode 100644
index 000000000000..f6d21834e654
--- /dev/null
+++ b/drivers/power/supply/ASUS_BATTERY/ME176C/ug31xx/uG31xx_API_Backup.h
@@ -0,0 +1,167 @@
+/**
+ * @filename  uG31xx_API_Backup.h
+ *
+ *  Header of uG31xx_API_Backup.cpp
+ *
+ * @author  AllenTeng <allen_teng@upi-semi.com>
+ * @revision  $Revision: 107 $
+ */
+
+#define BACKUP_BOOL_TRUE      (1)
+#define BACKUP_BOOL_FALSE     (0)
+
+enum BACKUP_FILE_STS {
+  BACKUP_FILE_STS_CHECKING = 0,         ///< [AT-PM] : Initial state and check file exist at next time ; 11/18/2013
+  BACKUP_FILE_STS_NOT_EXIST,            ///< [AT-PM] : Create backup file at next time ; 11/18/2013
+  BACKUP_FILE_STS_EXIST,                ///< [AT-PM] : Check backup file at next time ; 11/18/2013
+  BACKUP_FILE_STS_COMPARE,              ///< [AT-PM] : Check backup file after a period of time ; 11/18/2013
+  BACKUP_FILE_STS_UPDATE,               ///< [AT-PM] : Update backup file ; 12/04/2013
+  BACKUP_FILE_STS_UPDATE_BY_VERSION,    ///< [AT-PM] : Update backup file by version mistached ; 12/04/2013
+  BACKUP_FILE_STS_VERSION_MISMATCH,     ///< [AT-PM] : Do full reset ; 11/18/2013
+};
+
+typedef unsigned char _backup_bool_;
+typedef unsigned char _backup_u8_;
+typedef unsigned short _backup_u16_;
+typedef signed short _backup_s16_;
+typedef unsigned int _backup_u32_;
+typedef signed int _backup_s32_;
+
+#define BACKUP_MAX_LOG_SUSPEND_DATA     (8)
+
+typedef struct BackupSuspendDataST {
+  CapacityDataType beforeCapData;
+  MeasDataType beforeMeasData;
+
+  CapacityDataType afterCapData;
+  MeasDataType afterMeasData;
+} ALIGNED_ATTRIBUTE BackupSuspendDataType;
+
+#define MAX_BACKUP_BUFFER_SIZE      (128)
+
+typedef struct BackupDataST {
+
+  _backup_bool_ icDataAvailable;
+  _backup_u8_ backupFileSts;
+  _backup_u8_ backupBuffer[MAX_BACKUP_BUFFER_SIZE];
+  _backup_u8_ backupBufferSize;
+  _backup_u8_ backupFileRetryCnt;
+  _backup_u32_ backupNacLmdAdjustCfg;
+  _backup_u8_ backupCustomerSelfDef[CELL_PARAMETER_STRING_LENGTH];
+  _backup_u8_ backupProjectSelfDef[CELL_PARAMETER_STRING_LENGTH];
+
+  _backup_u8_ backupSuspendIdx;
+  BackupSuspendDataType backupSuspendData[BACKUP_MAX_LOG_SUSPEND_DATA];
+
+  _backup_u16_ backupVolt1;
+  _backup_u16_ backupVolt2;
+  _backup_s16_ backupDeltaQ;
+
+  #if defined (uG31xx_OS_WINDOWS)
+    const wchar_t* backupFileName;
+    const wchar_t* suspendFileName;
+  #endif
+
+} ALIGNED_ATTRIBUTE BackupDataType;
+
+extern char *ptrBackupFileName;
+extern char *ptrSuspendFileName;
+
+/**
+ * @brief UpiBackupData
+ *
+ *  Backup data from IC to system routine
+ *
+ * @para  data  address of BackupDataType
+ * @return  _UPI_NULL_
+ */
+extern void UpiBackupData(BackupDataType *data);
+
+/**
+ * @brief UpiRestoreData
+ *
+ *  Restore data from system to IC routine
+ *
+ * @para  data  address of BackupDataType
+ * @return  BACKUP_BOOL_TRUE if success
+ */
+extern _backup_bool_ UpiRestoreData(BackupDataType *data);
+
+/**
+ * @brief UpiInitBackupData
+ *
+ *  Initialize memory buffer of BackupDataType structure
+ *
+ * @para  data  address of BackupDataType
+ * @return  NULL
+ */
+extern void UpiInitBackupData(BackupDataType *data);
+
+/**
+ * @brief UpiFreeBackupData
+ *
+ *  Free memory for BackupDataType
+ *
+ * @para  data  address of BackupDataType
+ * @return  NULL
+ */
+extern void UpiFreeBackupData(BackupDataType *data);
+
+/**
+ * @brief UpiSaveSuspendData
+ *
+ *  Save suspend data for backup
+ *
+ * @para  data  address of BackupDataType
+ * @return  NULL
+ */
+extern void UpiSaveSuspendData(BackupDataType *data);
+
+/**
+ * @brief UpiSaveResumeData
+ *
+ *  Save resume data for backup
+ *
+ * @para  data  address of BackupDataType
+ * @return  NULL
+ */
+extern void UpiSaveResumeData(BackupDataType *data);
+
+/**
+ * @brief UpiWriteSuspendResumeData
+ *
+ *  Write suspend / resume data to file
+ *
+ * @para  data  address of BackupDataType
+ * @return  NULL
+ */
+extern void UpiWriteSuspendResumeData(BackupDataType *data);
+
+/**
+ * @brief UpiGetBackupMemorySize
+ *
+ *  Get memory size used in backup module
+ *
+ * @return  memory size
+ */
+extern _backup_u32_ UpiGetBackupMemorySize(void);
+
+/**
+ * @brief UpiBackupVoltage
+ *
+ *  Backup voltage points for abnormal battery checking
+ *
+ * @para  data  address of BackupDataType
+ * @return  NULL
+ */
+extern void UpiBackupVoltage(BackupDataType *data);
+
+/**
+ * @brief UpiPrintBackupVersion
+ *
+ *  Print backup module version
+ *
+ * @return  NULL
+ */
+extern void UpiPrintBackupVersion(void);
+
diff --git a/drivers/power/supply/ASUS_BATTERY/ME176C/ug31xx/uG31xx_API_Capacity.c b/drivers/power/supply/ASUS_BATTERY/ME176C/ug31xx/uG31xx_API_Capacity.c
new file mode 100644
index 000000000000..16616eed9934
--- /dev/null
+++ b/drivers/power/supply/ASUS_BATTERY/ME176C/ug31xx/uG31xx_API_Capacity.c
@@ -0,0 +1,2967 @@
+/**
+ * Copyright @ 2013 uPI Semiconductor Corp. All right reserved.
+ * The information, images, and/or data contained in this material is copyrighted by uPI
+ * Semiconductor Corp., and may not be distributed, modified, reproduced in whole or in part
+ * without the prior, written consent of uPI Semiconductor Corp.
+ */
+
+/**
+ * @filename  uG31xx_API_Capacity.cpp
+ *
+ *  Capacity algorithm
+ *
+ * @author  AllenTeng <allen_teng@upi-semi.com>
+ * @revision  $Revision: 112 $
+ */
+
+#include "stdafx.h"     //windows need this??
+#include "uG31xx_API.h"
+
+#ifdef  uG31xx_OS_ANDROID
+
+  #define CAPACITY_VERSION      ("Capacity $Rev: 112 $")
+  //#define CAP_LOG_UPDATE_TABLE                              ///< [AT-PM] : Log updated table to a file ; 03/25/2013
+
+  #ifdef  CAP_LOG_UPDATE_TABLE
+
+    #define CAP_LOG_UPDATE_TABLE_PATH ("/sdcard/upi_table")
+
+  #endif  ///< end of CAP_LOG_UPDATE_TABLE
+
+#else   ///< else of uG31xx_OS_ANDROID
+
+  #if defined(BUILD_UG31XX_LIB)
+
+    #define CAPACITY_VERSION      ("Capacity $Rev: 112 $")
+
+  #else   ///< else of defined(BUILD_UG31XX_LIB)
+
+    #define CAPACITY_VERSION      (_T("Capacity $Rev: 112 $"))
+
+  #endif  ///< end of defined(BUILD_UG31XX_LIB)
+
+#endif  ///< end of uG31xx_OS_ANDROID
+
+#define CAP_STS_LAST_STATE          (3<<0)
+  #define CAP_STS_LAST_STANDBY      (0<<0)
+  #define CAP_STS_LAST_CHG          (1<<0)
+  #define CAP_STS_LAST_DSG          (2<<0)
+#define CAP_STS_CURR_STATE          (3<<2)
+  #define CAP_STS_CURR_STANDBY      (0<<2)
+  #define CAP_STS_CURR_CHG          (1<<2)
+  #define CAP_STS_CURR_DSG          (2<<2)
+#define CAP_STS_FC                  (1<<4)
+#define CAP_STS_UPDATE_FCC          (1<<5)
+#define CAP_STS_FCC_START_DSG       (1<<6)
+#define CAP_STS_REFRESH_FCC         (1<<7)
+#define CAP_STS_INIT_TIMER_PASS     (1<<8)
+#define CAP_STS_INIT_PROCEDURE      (1<<9)
+#define CAP_STS_NAC_UPDATE_DISQ     (1<<10)
+#define CAP_STS_CHARGER_FULL        (1<<11)
+#define CAP_STS_CHG_CV_MODE         (1<<12)
+#define CAP_STS_RELEASE_100         (1<<13)
+#define CAP_STS_DSGCHARGE_INITED    (1<<16)
+#define CAP_STS_DSG_AFTER_FC        (1<<17)
+#define CAP_STS_DSG_REACH_EDVF      (1<<18)
+#define CAP_STS_V_OVER_MAX_TABLE    (1<<19)
+#define CAP_STS_V_UNDER_MIN_TABLE   (1<<20)
+#define CAP_STS_BOARD_OFFSET_KED    (1<<21)
+#define CAP_STS_FORCE_STEP_TO_100   (1<<22)
+#define CAP_STS_PREV_FC             (1<<23)
+#define CAP_STS_FILTER_LOCK_OVER    (1<<24)
+#define CAP_STS_NO_STANDBY_CAP_EST  (1<<25)
+#define CAP_STS_NO_INIT_FORCE_100   (1<<26)
+#define CAP_STS_LAST_CABLE_OUT      (1<<27)
+#define CAP_STS_REMAPPING_RSOC_DIS  (1<<28)
+#define CAP_STS_VOLT_CHECK_POINT    (1<<29)
+#define CAP_STS_ADJUST_CELL_TABLE   (1<<30)
+
+enum INDEX_BOUNDARY {
+  INDEX_BOUNDARY_LOW = 0,
+  INDEX_BOUNDARY_HIGH,
+  INDEX_BOUNDARY_COUNT,
+};
+
+typedef struct CapacityInternalDataST {
+
+  CapacityDataType *info;
+
+  _cap_s16_ stepCap;
+  _cap_u8_ cRate;
+
+  _cap_u8_ idxTemperature[INDEX_BOUNDARY_COUNT];
+  _cap_u8_ idxOcvVoltage[INDEX_BOUNDARY_COUNT];
+  _cap_u8_ idxNacCRate[INDEX_BOUNDARY_COUNT];
+  _cap_u8_ idxNacVoltage[INDEX_BOUNDARY_COUNT];
+
+  _cap_s16_ tableNacVoltage[OCV_NUMS];
+  _cap_s16_ tableNac[OCV_NUMS];
+
+  _cap_u16_ rm;
+  _cap_u16_ fcc;
+  _cap_u16_ fccRM;
+
+  _cap_u8_ filterNewRsoc;
+  _cap_u8_ filterLastRsoc;
+
+#if defined(uG31xx_OS_ANDROID)
+  } __attribute__ ((packed)) CapacityInternalDataType;
+#else   ///< else of defined(uG31xx_OS_ANDROID)
+  } CapacityInternalDataType;
+#endif  ///< end of defined(uG31xx_OS_ANDROID)
+
+
+CapacityDataType *ptrCapData = _UPI_NULL_;
+
+typedef void (*VerFuncArguObjRtnNull)(CapacityInternalDataType *obj);
+typedef void (*VerFuncArguObjS16RtnNull)(CapacityInternalDataType *obj, _cap_s16_ argu);
+
+#ifndef MEAS_STATUS_REFER_ET
+
+#define MEAS_STATUS_REFER_ET      (1<<4)
+
+#endif  ///< end of MEAS_STATUS_REFER_ET
+
+#define LIMIT_FCC_WITH_ILMD_RANGE       (20)
+#define LIMIT_FCC_WITH_ILMD_UPPER_RATIO (10)
+
+/**
+ * @brief LimitValue
+ *
+ *  Limit the input value within the percent range of reference value
+ *
+ * @para  input input value
+ * @para  reference reference value
+ * @para  percent range in percentage
+ * @return  limited value
+ */
+_cap_s32_ LimitValue(_cap_s32_ input, _cap_s32_ reference, _cap_u8_ percent)
+{
+  if(input == reference)
+  {
+    return (input);
+  }
+
+  /// [AT-PM] : Check lower bound ; 04/02/2014
+  if(input < reference)
+  {
+    reference = reference - reference*percent/CONST_PERCENTAGE;
+    if(input >= reference)
+    {
+      return (input);
+    }
+
+    UG31_LOGE("[%s]: Lower than boundary (%d < %d) (%d%%)\n", __func__,
+              (int)input,
+              (int)reference,
+              percent);
+    return (reference);
+  }
+
+  /// [AT-PM] : Check upper bound ; 04/02/2014
+  percent = percent/LIMIT_FCC_WITH_ILMD_UPPER_RATIO;
+  percent = (percent == 0) ? 1 : percent;
+  reference = reference + reference*percent/CONST_PERCENTAGE;
+  if(input <= reference)
+  {
+    return (input);
+  }
+
+  UG31_LOGE("[%s]: Higher than boundary (%d > %d) (%d%%)\n", __func__,
+            (int)input,
+            (int)reference,
+            percent);
+  return (reference);
+}
+
+
+/**
+ * @brief GetBatteryTemperature
+ *
+ *  Get battery temperature from internal or external temperature
+ *
+ * @para  obj address of CapacityInternalDataType
+ * @return  temperature in 0.1oC
+ */
+_cap_s16_ GetBatteryTemperature(CapacityInternalDataType *obj)
+{
+  if(ptrMeasData->status & MEAS_STATUS_REFER_ET)
+  {
+    return ((_cap_s16_)ptrMeasData->extTemperature);
+  }
+  else
+  {
+    return ((_cap_s16_)ptrMeasData->intTemperature);
+  }
+}
+
+/**
+ * @brief GetBatteryState
+ *
+ *  Get battery state, charging/discharging/standby
+ *
+ * @para  obj address of CapacityInternalDataType
+ * @return  _UPI_NULL_
+ */
+void GetBatteryState(CapacityInternalDataType *obj)
+{
+  _cap_u32_ tmp32;
+
+  /// [AT-PM] : Update last state ; 01/25/2013
+  tmp32 = (obj->info->status & CAP_STS_CURR_STATE) >> 2;
+
+  if(ptrMeasData->currAvg < -(ptrCellParameter->standbyCurrent))
+  {
+    /// [AT-PM] : Discharging mode ; 01/25/2013
+    tmp32 = tmp32 | CAP_STS_CURR_DSG;
+  }
+  else if(ptrMeasData->currAvg > ptrCellParameter->standbyCurrent)
+  {
+    /// [AT-PM] : Charging mode ; 01/25/2013
+    tmp32 = tmp32 | CAP_STS_CURR_CHG;
+  }
+  else
+  {
+    /// [AT-PM] : Standby mode ; 01/25/2013
+    tmp32 = tmp32 | CAP_STS_CURR_STANDBY;
+  }
+
+  obj->info->status = obj->info->status & (~(CAP_STS_LAST_STATE | CAP_STS_CURR_STATE));
+  obj->info->status = obj->info->status | tmp32;
+}
+
+
+/**
+ * @brief ResetSelfD
+ *
+ *  Reset self-discharging capacity
+ *
+ * @para  obj address of CapacityInternalDataType
+ * @return _UPI_NULL_
+ */
+void ResetSelfD(CapacityInternalDataType *obj)
+{
+  obj->info->selfDsgMilliSec = 0;
+  obj->info->selfDsgSec = 0;
+  obj->info->selfDsgMin = 0;
+  obj->info->selfDsgHour = 0;
+  UG31_LOGD("[%s]: Reset self-discharge calculation\n", __func__);
+}
+
+/**
+ * @brief CapStatusFCSet
+ *
+ *  Set CAP_STS_FC
+ *
+ * @para  info  address of CapacityDataType
+ * @return  NULL
+ */
+void CapStatusFCSet(CapacityDataType *info)
+{
+  info->status = info->status | CAP_STS_FC;
+  info->fcSts = CAP_TRUE;
+}
+
+/**
+ * @brief CapStatusFCClear
+ *
+ *  Clear CAP_STS_FC
+ *
+ * @para  info  address of CapacityDataType
+ * @return  NULL
+ */
+void CapStatusFCClear(CapacityDataType *info)
+{
+  info->status = info->status & (~CAP_STS_FC);
+  info->fcSts = CAP_FALSE;
+}
+
+/**
+ * @brief CapStatusFCGet
+ *
+ *  Get CAP_STS_FC value
+ *
+ * @para  info  address of CapacityDataType
+ * @return  CAP_TRUE if set
+ */
+_cap_bool_ CapStatusFCGet(CapacityDataType *info)
+{
+  return ((info->status & CAP_STS_FC) ? CAP_TRUE : CAP_FALSE);
+}
+
+/**
+ * @brief FullChargeRelease
+ *
+ *  Release full charge state
+ *
+ * @para  obj address of CapacityInternalDataType
+ * @return  _UPI_NULL_
+ */
+void FullChargeRelease(CapacityInternalDataType *obj)
+{
+  CapStatusFCClear(obj->info);
+  obj->info->status = obj->info->status & (~CAP_STS_CHARGER_FULL);
+  obj->info->tpTime = 0;
+}
+
+#define FULL_CHARGE_RSOC            (100)
+#define CHG_PREDICT_SOC_STEP_RATIO  (10)
+
+/**
+ * @brief CalChgRsocWithCurrent
+ *
+ *  Calculate charging RSOC with charging current and taper current
+ *
+ * @para  obj address of CapacityInternalDataType
+ * @return  rsoc
+ */
+_cap_u8_ CalChgRsocWithCurrent(CapacityInternalDataType *obj)
+{
+  _cap_s16_ curr;
+  _cap_u8_ rsoc;
+  _cap_s16_ currStep;
+  _cap_u16_ minCurrStep;
+
+  curr = ptrMeasData->currAvg;
+  rsoc = FULL_CHARGE_RSOC;
+  currStep = ptrCellParameter->TPCurrent;
+  minCurrStep = obj->info->fcc;
+  minCurrStep = minCurrStep / CONST_PERCENTAGE;
+  UG31_LOGD("[%s]: curr = %d, rsoc = %d, currStep = %d, minCurrStep = %d, obj->info->fcc = %d\n", __func__,
+            curr,
+            rsoc,
+            currStep,
+            minCurrStep,
+            obj->info->fcc);
+
+  while(rsoc)
+  {
+    curr = curr - currStep;
+    if(curr < 0)
+    {
+      break;
+    }
+
+    rsoc = rsoc - 1;
+    currStep = currStep / 2;
+    if(currStep < minCurrStep)
+    {
+      currStep = minCurrStep;
+    }
+  }
+
+  UG31_LOGN("[%s]: RSOC = %d(%d), curr = %d, currSTep = %d, minCurrStep = %d\n", __func__,
+            rsoc,
+            obj->info->rsoc,
+            curr,
+            currStep,
+            minCurrStep);
+  return (rsoc);
+}
+
+#define CHG_CV_MODE_CHECK_COUNT     (2)
+
+/**
+ * @brief PredictChargeCapacity
+ *
+ *  Predict charging capacity according to current
+ *
+ * @para  obj address of CapacityInternalDataType
+ * @return  _UPI_NULL_
+ */
+void PredictChargeCapacity(CapacityInternalDataType *obj)
+{
+  _cap_s16_ curr;
+  _cap_s32_ tmp32;
+
+  /// [AT-PM] : Check current is decreasing ; 08/02/2013
+  curr = (_cap_s16_)ptrMeasData->currAvg;
+  curr = curr - ptrCellParameter->TPCurrent;
+  UG31_LOGD("[%s]: Delta Charging Current = %d (%d) -> %d\n", __func__, curr, obj->info->lastCVDeltaChgCurr, obj->info->cvCheckCnt);
+  if(obj->info->lastCVDeltaChgCurr <= 0)
+  {
+    obj->info->lastCVDeltaChgCurr = curr;
+    obj->info->cvCheckCnt = 0;
+    obj->info->status = obj->info->status & (~CAP_STS_CHG_CV_MODE);
+    return;
+  }
+  if(obj->info->lastCVDeltaChgCurr <= curr)
+  {
+    obj->info->status = obj->info->status & (~CAP_STS_CHG_CV_MODE);
+    return;
+  }
+  obj->info->lastCVDeltaChgCurr = curr;
+  obj->info->cvCheckCnt = obj->info->cvCheckCnt + 1;
+  if(obj->info->cvCheckCnt < CHG_CV_MODE_CHECK_COUNT)
+  {
+    return;
+  }
+  obj->info->cvCheckCnt = 0;
+  obj->info->status = obj->info->status | CAP_STS_CHG_CV_MODE;
+
+  if(obj->info->rsoc == CAP_FC_NEAR_RSOC)
+  {
+    UG31_LOGD("[%s]: Adjust RM at 99%% = %d\n", __func__, obj->rm);
+    return;
+  }
+
+  /// [AT-PM] : Calculate average charging RM ; 08/01/2013
+  tmp32 = (_cap_s32_)CalChgRsocWithCurrent(obj);
+  tmp32 = tmp32*obj->fcc/CONST_PERCENTAGE;
+  tmp32 = (tmp32 + obj->info->avgRM)/2;
+  obj->info->avgRM = (_cap_u16_)tmp32;
+  UG31_LOGD("[%s]: Average RM for CV mode = %d\n", __func__, obj->info->avgRM);
+}
+
+#define MINIMUM_TABLE_UPDATE_IDX  (1)
+
+/**
+ * @brief ResetSelfLearning
+ *
+ *  Reset self-learning status
+ *
+ * @para  obj address of CapacityInternalDataType
+ * @return  NULL
+ */
+void ResetSelfLearning(CapacityInternalDataType *obj)
+{
+  UG31_LOGD("[%s]: Reset self-learning status\n", __func__);
+  obj->info->dsgCharge = 0;
+  obj->info->dsgChargeStart = 0;
+  obj->info->dsgChargeTime = 0;
+  obj->info->tableUpdateIdx = MINIMUM_TABLE_UPDATE_IDX;
+}
+
+/**
+ * @brief FindNacIdxVoltage
+ *
+ *  Find the NAC table voltage index
+ *
+ * @para  obj address of CapacityInternalDataType
+ * @para  voltage battery voltage
+ * @return  _UPI_NULL_
+ */
+void FindNacIdxVoltage(CapacityInternalDataType *obj, _cap_u16_ voltage)
+{
+  /// [AT-PM] : Find the index ; 01/25/2013
+  obj->idxNacVoltage[INDEX_BOUNDARY_LOW] = 0;
+  obj->info->status = obj->info->status & (~(CAP_STS_V_OVER_MAX_TABLE | CAP_STS_V_UNDER_MIN_TABLE));
+  while(obj->idxNacVoltage[INDEX_BOUNDARY_LOW] < OCV_NUMS)
+  {
+    if(voltage >= obj->tableNacVoltage[obj->idxNacVoltage[INDEX_BOUNDARY_LOW]])
+    {
+      break;
+    }
+    obj->idxNacVoltage[INDEX_BOUNDARY_LOW] = obj->idxNacVoltage[INDEX_BOUNDARY_LOW] + 1;
+  }
+
+  /// [AT-PM] : Higher than upper bound ; 01/25/2013
+  if(obj->idxNacVoltage[INDEX_BOUNDARY_LOW] == 0)
+  {
+    obj->idxNacVoltage[INDEX_BOUNDARY_HIGH] = obj->idxNacVoltage[INDEX_BOUNDARY_LOW];
+    obj->info->status = obj->info->status | CAP_STS_V_OVER_MAX_TABLE;
+    return;
+  }
+
+  /// [AT-PM] : Lower than lower bound ; 01/25/2013
+  if(obj->idxNacVoltage[INDEX_BOUNDARY_LOW] >= SOV_NUMS)
+  {
+    obj->idxNacVoltage[INDEX_BOUNDARY_LOW] = SOV_NUMS - 1;
+    obj->idxNacVoltage[INDEX_BOUNDARY_HIGH] = obj->idxNacVoltage[INDEX_BOUNDARY_LOW];
+    obj->info->status = obj->info->status | CAP_STS_V_UNDER_MIN_TABLE;
+    return;
+  }
+
+  obj->idxNacVoltage[INDEX_BOUNDARY_HIGH] = obj->idxNacVoltage[INDEX_BOUNDARY_LOW] - 1;
+
+  if((ptrCellParameter->NacLmdAdjustCfg & NAC_LMD_ADJUST_CFG_ALWAYS_UPDATE_FCC_AT_LAST) &&
+     (obj->idxNacVoltage[INDEX_BOUNDARY_LOW] >= (SOV_NUMS - 1)) &&
+     (obj->info->tableUpdateIdx < SOV_NUMS))
+  {
+    obj->info->status = obj->info->status | (CAP_STS_UPDATE_FCC | CAP_STS_REFRESH_FCC);
+  }
+}
+
+/**
+ * @brief FindOcvIdxVoltage
+ *
+ *  Find the OCV tables voltage index
+ *
+ * @para  obj address of CapacityInternalDataType
+ * @para  tableIdx  index of INIT_OCV table
+ * @para  voltage battery voltage
+ * @return  _UPI_NULL_
+ */
+void FindOcvIdxVoltage(CapacityInternalDataType *obj, _cap_u8_ tableIdx, _cap_u16_ voltage)
+{
+  /// [AT-PM] : Find the index ; 01/25/2013
+  obj->idxOcvVoltage[INDEX_BOUNDARY_LOW] = 0;
+  while(obj->idxOcvVoltage[INDEX_BOUNDARY_LOW] < OCV_NUMS)
+  {
+    if(voltage >= ptrCellTable->INIT_OCV[obj->idxTemperature[INDEX_BOUNDARY_LOW]]
+                                               [tableIdx]
+                                               [obj->idxOcvVoltage[INDEX_BOUNDARY_LOW]])
+    {
+      break;
+    }
+    obj->idxOcvVoltage[INDEX_BOUNDARY_LOW] = obj->idxOcvVoltage[INDEX_BOUNDARY_LOW] + 1;
+  }
+
+  /// [AT-PM] : Higher than upper bound ; 01/25/2013
+  if(obj->idxOcvVoltage[INDEX_BOUNDARY_LOW] == 0)
+  {
+    obj->idxOcvVoltage[INDEX_BOUNDARY_HIGH] = obj->idxOcvVoltage[INDEX_BOUNDARY_LOW];
+    return;
+  }
+
+  /// [AT-PM] : Lower than lower bound ; 01/25/2013
+  if(obj->idxOcvVoltage[INDEX_BOUNDARY_LOW] >= OCV_NUMS)
+  {
+    obj->idxOcvVoltage[INDEX_BOUNDARY_LOW] = OCV_NUMS - 1;
+    obj->idxOcvVoltage[INDEX_BOUNDARY_HIGH] = obj->idxOcvVoltage[INDEX_BOUNDARY_LOW];
+    return;
+  }
+
+  obj->idxOcvVoltage[INDEX_BOUNDARY_HIGH] = obj->idxOcvVoltage[INDEX_BOUNDARY_LOW] - 1;
+}
+
+/**
+ * @brief FindOcvFcc
+ *
+ *  Find the FCC for OCV table, which is the average from NAC table
+ *
+ * @para  obj address of CapacityInternalDataType
+ * @return  _UPI_NULL_
+ */
+void FindOcvFcc(CapacityInternalDataType *obj)
+{
+  _cap_s32_ tmp32;
+  _cap_u8_ idx;
+
+  tmp32 = 0;
+  idx = 0;
+  while(idx < C_RATE_NUMS)
+  {
+    tmp32 = tmp32 + ptrCellTable->CELL_NAC_TABLE[obj->idxTemperature[INDEX_BOUNDARY_HIGH]][idx][0];
+    idx = idx + 1;
+  }
+  tmp32 = tmp32/C_RATE_NUMS;
+  obj->info->fcc = (_cap_u16_)tmp32;
+}
+
+static _cap_u8_ OcvSocTable[] = {
+  100,
+  95,
+  90,
+  85,
+  80,
+  75,
+  70,
+  65,
+  60,
+  55,
+  50,
+  45,
+  40,
+  35,
+  30,
+  25,
+  20,
+  15,
+  10,
+  5,
+  0,
+};
+
+static _cap_s16_ TemperatureTable[] = {
+  450,
+  250,
+  150,
+  50,
+};
+
+/**
+ * @brief FindOcvRM
+ *
+ *  Find the RM for OCV table
+ *  -> RM = FCC x RSOC
+ *
+ * @para  obj address of CapacityInternalDataType
+ * @para  tableIdx  OCV table index
+ * @para  voltage target voltage
+ * @return  _UPI_NULL_
+ */
+void FindOcvRM(CapacityInternalDataType *obj, _cap_u8_ tableIdx, _cap_u16_ voltage)
+{
+  _cap_s32_ tmp32;
+  _cap_s32_ voltHigh;
+  _cap_s32_ voltLow;
+
+  UG31_LOGN("[%s] INIT_OCV[%d][%d][%d] (%d) = %d\n", __func__,
+            obj->idxTemperature[INDEX_BOUNDARY_LOW],
+            tableIdx,
+            obj->idxOcvVoltage[INDEX_BOUNDARY_LOW],
+            OcvSocTable[obj->idxOcvVoltage[INDEX_BOUNDARY_LOW]],
+            ptrCellTable->INIT_OCV[obj->idxTemperature[INDEX_BOUNDARY_LOW]]
+                                         [tableIdx]
+                                         [obj->idxOcvVoltage[INDEX_BOUNDARY_LOW]]);
+  UG31_LOGN("[%s] INIT_OCV[%d][%d][%d] (%d) = %d\n", __func__,
+            obj->idxTemperature[INDEX_BOUNDARY_LOW],
+            tableIdx,
+            obj->idxOcvVoltage[INDEX_BOUNDARY_HIGH],
+            OcvSocTable[obj->idxOcvVoltage[INDEX_BOUNDARY_HIGH]],
+            ptrCellTable->INIT_OCV[obj->idxTemperature[INDEX_BOUNDARY_LOW]]
+                                         [tableIdx]
+                                         [obj->idxOcvVoltage[INDEX_BOUNDARY_HIGH]]);
+  UG31_LOGN("[%s] INIT_OCV[%d][%d][%d] (%d) = %d\n", __func__,
+            obj->idxTemperature[INDEX_BOUNDARY_HIGH],
+            tableIdx,
+            obj->idxOcvVoltage[INDEX_BOUNDARY_LOW],
+            OcvSocTable[obj->idxOcvVoltage[INDEX_BOUNDARY_LOW]],
+            ptrCellTable->INIT_OCV[obj->idxTemperature[INDEX_BOUNDARY_HIGH]]
+                                         [tableIdx]
+                                         [obj->idxOcvVoltage[INDEX_BOUNDARY_LOW]]);
+  UG31_LOGN("[%s] INIT_OCV[%d][%d][%d] (%d) = %d\n", __func__,
+            obj->idxTemperature[INDEX_BOUNDARY_HIGH],
+            tableIdx,
+            obj->idxOcvVoltage[INDEX_BOUNDARY_HIGH],
+            OcvSocTable[obj->idxOcvVoltage[INDEX_BOUNDARY_HIGH]],
+            ptrCellTable->INIT_OCV[obj->idxTemperature[INDEX_BOUNDARY_HIGH]]
+                                         [tableIdx]
+                                         [obj->idxOcvVoltage[INDEX_BOUNDARY_HIGH]]);
+
+  /// [AT-PM] : Interpolate voltage ; 02/16/2014
+  if(obj->idxTemperature[INDEX_BOUNDARY_HIGH] == obj->idxTemperature[INDEX_BOUNDARY_LOW])
+  {
+    voltHigh = ptrCellTable->INIT_OCV[obj->idxTemperature[INDEX_BOUNDARY_LOW]]
+                                            [tableIdx]
+                                            [obj->idxOcvVoltage[INDEX_BOUNDARY_HIGH]];
+    voltLow = ptrCellTable->INIT_OCV[obj->idxTemperature[INDEX_BOUNDARY_LOW]]
+                                           [tableIdx]
+                                           [obj->idxOcvVoltage[INDEX_BOUNDARY_LOW]];
+  }
+  else
+  {
+    tmp32 = (_cap_s32_)ptrCellTable->INIT_OCV[obj->idxTemperature[INDEX_BOUNDARY_HIGH]]
+                                                    [tableIdx]
+                                                    [obj->idxOcvVoltage[INDEX_BOUNDARY_HIGH]];
+    tmp32 = tmp32 - ptrCellTable->INIT_OCV[obj->idxTemperature[INDEX_BOUNDARY_LOW]]
+                                                 [tableIdx]
+                                                 [obj->idxOcvVoltage[INDEX_BOUNDARY_HIGH]];
+    tmp32 = tmp32*(GetBatteryTemperature(obj) -
+                   TemperatureTable[obj->idxTemperature[INDEX_BOUNDARY_LOW]]);
+    tmp32 = tmp32/(TemperatureTable[obj->idxTemperature[INDEX_BOUNDARY_HIGH]] -
+                   TemperatureTable[obj->idxTemperature[INDEX_BOUNDARY_LOW]]);
+    tmp32 = tmp32 + ptrCellTable->INIT_OCV[obj->idxTemperature[INDEX_BOUNDARY_LOW]]
+                                                 [tableIdx]
+                                                 [obj->idxOcvVoltage[INDEX_BOUNDARY_HIGH]];
+    voltHigh = tmp32;
+
+    tmp32 = (_cap_s32_)ptrCellTable->INIT_OCV[obj->idxTemperature[INDEX_BOUNDARY_HIGH]]
+                                                    [tableIdx]
+                                                    [obj->idxOcvVoltage[INDEX_BOUNDARY_LOW]];
+    tmp32 = tmp32 - ptrCellTable->INIT_OCV[obj->idxTemperature[INDEX_BOUNDARY_LOW]]
+                                                 [tableIdx]
+                                                 [obj->idxOcvVoltage[INDEX_BOUNDARY_LOW]];
+    tmp32 = tmp32*(GetBatteryTemperature(obj) -
+                   TemperatureTable[obj->idxTemperature[INDEX_BOUNDARY_LOW]]);
+    tmp32 = tmp32/(TemperatureTable[obj->idxTemperature[INDEX_BOUNDARY_HIGH]] -
+                   TemperatureTable[obj->idxTemperature[INDEX_BOUNDARY_LOW]]);
+    tmp32 = tmp32 + ptrCellTable->INIT_OCV[obj->idxTemperature[INDEX_BOUNDARY_LOW]]
+                                                 [tableIdx]
+                                                 [obj->idxOcvVoltage[INDEX_BOUNDARY_LOW]];
+    voltLow = tmp32;
+    UG31_LOGN("[%s]: Voltage High = %d and Low = %d\n", __func__,
+              (int)voltHigh,
+              (int)voltLow);
+  }
+
+  /// [AT-PM] : Calculate RSOC ; 01/25/2013
+  if(OcvSocTable[obj->idxOcvVoltage[INDEX_BOUNDARY_LOW]] == OcvSocTable[obj->idxOcvVoltage[INDEX_BOUNDARY_HIGH]])
+  {
+    tmp32 = OcvSocTable[obj->idxOcvVoltage[INDEX_BOUNDARY_LOW]];
+  }
+  else
+  {
+    tmp32 = (_cap_s32_)voltage;
+    tmp32 = tmp32 - voltLow;
+    tmp32 = tmp32*
+            (OcvSocTable[obj->idxOcvVoltage[INDEX_BOUNDARY_HIGH]] -
+             OcvSocTable[obj->idxOcvVoltage[INDEX_BOUNDARY_LOW]]);
+		if(voltHigh != voltLow)
+		{
+			tmp32 = tmp32/(voltHigh - voltLow);
+		}
+		else
+		{
+			tmp32 = 0;
+		}
+    tmp32 = tmp32 + OcvSocTable[obj->idxOcvVoltage[INDEX_BOUNDARY_LOW]];
+  }
+  UG31_LOGD("[%s] RSOC = %d (%d)\n", __func__,
+            obj->info->rsoc,
+            (int)tmp32);
+
+  /// [AT-PM] : Calculate RM ; 01/25/2013
+  tmp32 = tmp32*obj->info->fcc/CONST_PERCENTAGE;
+  obj->rm = (_cap_u16_)tmp32;
+}
+
+#define IS_SUSPEND_OPERATION_DELAT_TIME     (1*TIME_SEC_TO_MIN*TIME_MSEC_TO_SEC)
+
+/**
+ * @brief IsSuspendOperation
+ *
+ *  Suspend operation if delta time > 5 min and inSuspend = TRUE
+ *
+ * @para  obj addressof CapacityInternalDataType
+ * @return  CAP_TRUE if success
+ */
+_cap_bool_ IsSuspendOperation(CapacityInternalDataType *obj)
+{
+  if((obj->info->inSuspend == CAP_TRUE) &&
+     (ptrMeasData->deltaTime >= IS_SUSPEND_OPERATION_DELAT_TIME))
+  {
+    return (CAP_TRUE);
+  }
+  return (CAP_FALSE);
+}
+
+#define CHG_SPEED_DOWN_RSOC_THRD_1      (25)
+#define CHG_SPEED_DOWN_RSOC_THRD_2      (50)
+#define CHG_SPEED_DOWN_RSOC_THRD_3      (75)
+#define CHG_SPEED_DOWN_RSOC_THRD_4      (100)
+
+/**
+ * @brief ChargeSpeedDown
+ *
+ *  Limit RSOC incresing speed during charging mode
+ *
+ * @para  obj address of CapacityInternalDataType
+ * @return  _UPI_NULL_
+ */
+void ChargeSpeedDown(CapacityInternalDataType *obj)
+{
+  _cap_s32_ tmp32 = 0;
+  _cap_u8_ rsoc;
+  _cap_u8_ minRsoc;
+
+  if(obj->info->transferStateToChg > 0)
+  {
+    UG31_LOGD("[%s] Start voltage = %d, RSOC = %d\n", __func__, obj->info->startChgVolt, obj->info->startChgRsoc);
+    return;
+  }
+
+  if(IsSuspendOperation(obj) == CAP_TRUE)
+  {
+    UG31_LOGN("[%s]: In suspend operation. (%d)\n", __func__,
+              (int)ptrMeasData->deltaTime);
+    return;
+  }
+
+  /// [AT-PM] : Get minimum rsoc from current ; 03/26/2014
+  minRsoc = CalChgRsocWithCurrent(obj);
+  if(minRsoc < obj->info->startChgRsoc)
+  {
+    UG31_LOGN("[%s]: Minimum RSOC = %d < start charging RSOC = %d\n", __func__,
+              (int)minRsoc,
+              (int)obj->info->startChgRsoc);
+    return;
+  }
+
+  /// [AT-PM] : Calculate new RSOC ; 02/09/2014
+  rsoc = (_cap_u8_)CalculateRsoc((_cap_u32_)obj->rm, obj->info->fcc);
+
+  /// [FC] : Predict charge rsoc before VBAT greater than TP voltage; 07/05/2013
+  tmp32 = (_cap_s32_)obj->info->avgVoltage;
+  tmp32 = tmp32 - obj->info->startChgVolt;
+  tmp32 = tmp32 * (minRsoc - obj->info->startChgRsoc);
+  if(ptrCellParameter->TPVoltage > obj->info->startChgVolt)
+  {
+    tmp32 = tmp32 / (ptrCellParameter->TPVoltage - obj->info->startChgVolt);
+  }
+  tmp32 = tmp32 + obj->info->startChgRsoc;
+
+  /// [AT-PM] : Apply offset ; 07/06/2014
+  if(rsoc < CHG_SPEED_DOWN_RSOC_THRD_1)
+  {
+    tmp32 = tmp32 + obj->info->ccChgOffset25;
+    UG31_LOGD("[%s] Predict RSOC = %d, Offset = %d, Current RSOC = %d (%d)\n", __func__,
+              (int)tmp32,
+              obj->info->ccChgOffset25,
+              rsoc,
+              obj->info->rsoc);
+  }
+  else if(rsoc < CHG_SPEED_DOWN_RSOC_THRD_2)
+  {
+    tmp32 = tmp32 + obj->info->ccChgOffset50;
+    UG31_LOGD("[%s] Predict RSOC = %d, Offset = %d, Current RSOC = %d (%d)\n", __func__,
+              (int)tmp32,
+              obj->info->ccChgOffset50,
+              rsoc,
+              obj->info->rsoc);
+  }
+  else if(rsoc < CHG_SPEED_DOWN_RSOC_THRD_3)
+  {
+    tmp32 = tmp32 + obj->info->ccChgOffset75;
+    UG31_LOGD("[%s] Predict RSOC = %d, Offset = %d, Current RSOC = %d (%d)\n", __func__,
+              (int)tmp32,
+              obj->info->ccChgOffset75,
+              rsoc,
+              obj->info->rsoc);
+  }
+  else if(rsoc < CHG_SPEED_DOWN_RSOC_THRD_4)
+  {
+    tmp32 = tmp32 + obj->info->ccChgOffset100;
+    UG31_LOGD("[%s] Predict RSOC = %d, Offset = %d, Current RSOC = %d (%d)\n", __func__,
+              (int)tmp32,
+              obj->info->ccChgOffset100,
+              rsoc,
+              obj->info->rsoc);
+  }
+  else
+  {
+    UG31_LOGD("[%s] Predict RSOC = %d, Offset = %d, Current RSOC = %d (%d)\n", __func__,
+              (int)tmp32,
+              0,
+              rsoc,
+              obj->info->rsoc);
+  }
+
+  if(rsoc > tmp32)
+  {
+    tmp32 = tmp32 * obj->fcc / CONST_PERCENTAGE;
+    UG31_LOGN("[%s]: Limit RM = %d from %d (%d - %d).\n", __func__,
+              (int)tmp32,
+              obj->rm,
+              rsoc,
+              obj->info->fcc);
+    obj->rm = (_cap_u16_)tmp32;
+  }
+}
+
+/**
+ * @brief FullChargeSet
+ *
+ *  Set internal status after full charge
+ *
+ * @para  obj address of CapacityInternalDataType
+ * @return  NULL
+ */
+void FullChargeSet(CapacityInternalDataType *obj)
+{
+  obj->info->reverseCap = 0;
+
+  ResetSelfD(obj);
+  ResetSelfLearning(obj);
+
+  /// [AT-PM] : Set full charge state ; 01/25/2013
+  CapStatusFCSet(obj->info);
+  obj->info->status = obj->info->status | CAP_STS_DSG_AFTER_FC;
+  obj->info->status = obj->info->status & (~CAP_STS_DSGCHARGE_INITED);
+  obj->rm = obj->fcc;
+}
+
+/**
+ * @brief CapStatusFCStep100Set
+ *
+ * Set fcStep100 status
+ *
+ * @para data address of data strcture CapacityDataType
+ * @return NULL
+ */
+void CapStatusFCStep100Set(CapacityDataType *data)
+{
+  data->status = data->status | CAP_STS_FORCE_STEP_TO_100;
+  data->fcStep100 = CAP_TRUE;
+}
+
+/**
+ * @brief CapStatusAdjustCellTableSet
+ *
+ * Set CAP_STS_ADJUST_CELL_TABLE status
+ *
+ * @para data address of data strcture CapacityDataType
+ * @return NULL
+ */
+void CapStatusAdjustCellTableSet(CapacityDataType *data)
+{
+  data->status = data->status | CAP_STS_ADJUST_CELL_TABLE;
+}
+
+/**
+ * @brief CapStatusAdjustCellTableClear
+ *
+ * Clear CAP_STS_ADJUST_CELL_TABLE status
+ *
+ * @para data address of data strcture CapacityDataType
+ * @return NULL
+ */
+void CapStatusAdjustCellTableClear(CapacityDataType *data)
+{
+  data->status = data->status & (~CAP_STS_ADJUST_CELL_TABLE);
+}
+
+/**
+ * @brief CapStatusAdjustCellTableGet
+ *
+ * Get CAP_STS_ADJUST_CELL_TABLE status
+ *
+ * @para data address of data strcture CapacityDataType
+ * @return NULL
+ */
+_cap_bool_ CapStatusAdjustCellTableGet(CapacityDataType *info)
+{
+  return ((info->status & CAP_STS_ADJUST_CELL_TABLE) ? CAP_TRUE : CAP_FALSE);
+}
+
+
+/**
+ * @brief FindIdxTemperatureVer0
+ *
+ *  Find the temperature index
+ *
+ * @para  obj address of CapacityInternalDataType
+ * @para  argu  battery temperature
+ * @return  _UPI_NULL_
+ */
+void FindIdxTemperatureVer0(CapacityInternalDataType *obj, _cap_s16_ argu)
+{
+  /// [AT-PM] : Find the temperature index ; 01/25/2013
+  obj->idxTemperature[INDEX_BOUNDARY_LOW] = 0;
+  while(obj->idxTemperature[INDEX_BOUNDARY_LOW] < TEMPERATURE_NUMS)
+  {
+    if(argu >= TemperatureTable[obj->idxTemperature[INDEX_BOUNDARY_LOW]])
+    {
+      break;
+    }
+    obj->idxTemperature[INDEX_BOUNDARY_LOW] = obj->idxTemperature[INDEX_BOUNDARY_LOW] + 1;
+  }
+
+  /// [AT-PM] : Higher than upper bound ; 01/25/2013
+  if(obj->idxTemperature[INDEX_BOUNDARY_LOW] == 0)
+  {
+    obj->idxTemperature[INDEX_BOUNDARY_HIGH] = obj->idxTemperature[INDEX_BOUNDARY_LOW];
+    return;
+  }
+
+  /// [AT-PM] : Smaller than lower bound ; 01/25/2013
+  if(obj->idxTemperature[INDEX_BOUNDARY_LOW] >= TEMPERATURE_NUMS)
+  {
+    obj->idxTemperature[INDEX_BOUNDARY_LOW] = TEMPERATURE_NUMS - 1;
+    obj->idxTemperature[INDEX_BOUNDARY_HIGH] = obj->idxTemperature[INDEX_BOUNDARY_LOW];
+    return;
+  }
+
+  obj->idxTemperature[INDEX_BOUNDARY_HIGH] = obj->idxTemperature[INDEX_BOUNDARY_LOW] - 1;
+}
+
+/**
+ * @brief FindIdxTemperatureVer1
+ *
+ *  Find the temperature index
+ *
+ * @para  obj address of CapacityInternalDataType
+ * @para  argu  battery temperature
+ * @return  _UPI_NULL_
+ */
+void FindIdxTemperatureVer1(CapacityInternalDataType *obj, _cap_s16_ argu)
+{
+  _cap_s16_ tempThrd;
+
+  /// [AT-PM] : Get temperature index ; 10/25/2013
+  obj->idxTemperature[INDEX_BOUNDARY_LOW] = 0;
+  while(obj->idxTemperature[INDEX_BOUNDARY_LOW] < (TEMPERATURE_NUMS - 1))
+  {
+    tempThrd = TemperatureTable[obj->idxTemperature[INDEX_BOUNDARY_LOW]] + TemperatureTable[obj->idxTemperature[INDEX_BOUNDARY_LOW] + 1];
+    tempThrd = tempThrd/2;
+
+    if(argu > tempThrd)
+    {
+      break;
+    }
+    obj->idxTemperature[INDEX_BOUNDARY_LOW] = obj->idxTemperature[INDEX_BOUNDARY_LOW] + 1;
+  }
+  obj->idxTemperature[INDEX_BOUNDARY_HIGH] = obj->idxTemperature[INDEX_BOUNDARY_LOW];
+}
+
+#define FindIdxTemperatureVer2      (FindIdxTemperatureVer1)
+
+static VerFuncArguObjS16RtnNull FindIdxTemperature[] = {
+  FindIdxTemperatureVer0,
+  FindIdxTemperatureVer1,
+  FindIdxTemperatureVer2,
+  _UPI_NULL_,
+};
+
+#define C_RATE_CONVERT_BASE     (-100)
+
+static _cap_u8_ CRateTable[] = {
+  C_RATE_TABLE_VALUE_0,
+  C_RATE_TABLE_VALUE_1,
+  C_RATE_TABLE_VALUE_2,
+  C_RATE_TABLE_VALUE_3,
+};
+
+/**
+ * @brief FindNacIdxCRateVer0
+ *
+ *  Find the NAC table CRate index
+ *
+ * @para  obj address of CapacityInternalDataType
+ * @return  _UPI_NULL_
+ */
+void FindNacIdxCRateVer0(CapacityInternalDataType *obj)
+{
+  /// [AT-PM] : Find CRate index ; 01/25/2013
+  obj->idxNacCRate[INDEX_BOUNDARY_LOW] = 0;
+  while(obj->idxNacCRate[INDEX_BOUNDARY_LOW] < C_RATE_NUMS)
+  {
+    if(obj->cRate >= CRateTable[obj->idxNacCRate[INDEX_BOUNDARY_LOW]])
+    {
+      break;
+    }
+    obj->idxNacCRate[INDEX_BOUNDARY_LOW] = obj->idxNacCRate[INDEX_BOUNDARY_LOW] + 1;
+  }
+
+  /// [AT-PM] : Higher than upper bound ; 01/25/2013
+  if(obj->idxNacCRate[INDEX_BOUNDARY_LOW] == 0)
+  {
+    obj->idxNacCRate[INDEX_BOUNDARY_HIGH] = obj->idxNacCRate[INDEX_BOUNDARY_LOW];
+    return;
+  }
+
+  /// [AT-PM] : Smaller than lower bound ; 01/25/2013
+  if(obj->idxNacCRate[INDEX_BOUNDARY_LOW] >= C_RATE_NUMS)
+  {
+    obj->idxNacCRate[INDEX_BOUNDARY_LOW] = C_RATE_NUMS - 1;
+    obj->idxNacCRate[INDEX_BOUNDARY_HIGH] = obj->idxNacCRate[INDEX_BOUNDARY_LOW];
+    return;
+  }
+
+  obj->idxNacCRate[INDEX_BOUNDARY_HIGH] = obj->idxNacCRate[INDEX_BOUNDARY_LOW] - 1;
+}
+
+/**
+ * @brief FindNacIdxCRateVer1
+ *
+ *  Find the NAC table CRate index
+ *
+ * @para  obj address of CapacityInternalDataType
+ * @return  _UPI_NULL_
+ */
+void FindNacIdxCRateVer1(CapacityInternalDataType *obj)
+{
+  _cap_u8_ cRateThrd;
+
+  obj->idxNacCRate[INDEX_BOUNDARY_LOW] = 0;
+  while(obj->idxNacCRate[INDEX_BOUNDARY_LOW] < (C_RATE_NUMS - 1))
+  {
+    cRateThrd = CRateTable[obj->idxNacCRate[INDEX_BOUNDARY_LOW]] + CRateTable[obj->idxNacCRate[INDEX_BOUNDARY_LOW] + 1];
+    cRateThrd = cRateThrd/2;
+
+    if(obj->cRate > cRateThrd)
+    {
+      break;
+    }
+    obj->idxNacCRate[INDEX_BOUNDARY_LOW] = obj->idxNacCRate[INDEX_BOUNDARY_LOW] + 1;
+  }
+  obj->idxNacCRate[INDEX_BOUNDARY_HIGH] = obj->idxNacCRate[INDEX_BOUNDARY_LOW];
+}
+
+#define FindNacIdxCRateVer2     (FindNacIdxCRateVer1)
+
+static VerFuncArguObjRtnNull FindNacIdxCRate[] = {
+  FindNacIdxCRateVer0,
+  FindNacIdxCRateVer1,
+  FindNacIdxCRateVer2,
+  _UPI_NULL_,
+};
+
+/**
+ * @brief CreateNacVoltageTableVer0
+ *
+ *  Create NAC Voltage table
+ *
+ * @para  obj address of CapacityInternalDataType
+ * @return  _UPI_NULL_
+ */
+void CreateNacVoltageTableVer0(CapacityInternalDataType *obj)
+{
+  _cap_u8_ idx;
+  _cap_s32_ tmp32;
+  _cap_s32_ valueInterpolate1;
+  _cap_s32_ valueInterpolate2;
+  _cap_s16_ temperature;
+
+  idx = 0;
+  temperature = GetBatteryTemperature(obj);
+  while(idx < OCV_NUMS)
+  {
+    /// [AT-PM] : Temperature interpolation ; 01/25/2013
+    if(TemperatureTable[obj->idxTemperature[INDEX_BOUNDARY_HIGH]] ==
+       TemperatureTable[obj->idxTemperature[INDEX_BOUNDARY_LOW]])
+    {
+      valueInterpolate1 = ptrCellTable->CELL_VOLTAGE_TABLE[obj->idxTemperature[INDEX_BOUNDARY_LOW]]
+                                                                 [obj->idxNacCRate[INDEX_BOUNDARY_LOW]]
+                                                                 [idx];
+      valueInterpolate2 = ptrCellTable->CELL_VOLTAGE_TABLE[obj->idxTemperature[INDEX_BOUNDARY_LOW]]
+                                                                 [obj->idxNacCRate[INDEX_BOUNDARY_HIGH]]
+                                                                 [idx];
+    }
+    else
+    {
+      tmp32 = (_cap_s32_)ptrCellTable->CELL_VOLTAGE_TABLE[obj->idxTemperature[INDEX_BOUNDARY_HIGH]]
+                                                                [obj->idxNacCRate[INDEX_BOUNDARY_LOW]]
+                                                                [idx];
+      tmp32 = tmp32 - ptrCellTable->CELL_VOLTAGE_TABLE[obj->idxTemperature[INDEX_BOUNDARY_LOW]]
+                                                             [obj->idxNacCRate[INDEX_BOUNDARY_LOW]]
+                                                             [idx];
+      tmp32 = tmp32*(temperature - TemperatureTable[obj->idxTemperature[INDEX_BOUNDARY_LOW]]);
+      tmp32 = tmp32/
+              (TemperatureTable[obj->idxTemperature[INDEX_BOUNDARY_HIGH]] -
+               TemperatureTable[obj->idxTemperature[INDEX_BOUNDARY_LOW]]);
+      valueInterpolate1 = tmp32 + ptrCellTable->CELL_VOLTAGE_TABLE[obj->idxTemperature[INDEX_BOUNDARY_LOW]]
+                                                                         [obj->idxNacCRate[INDEX_BOUNDARY_LOW]]
+                                                                         [idx];
+
+      tmp32 = (_cap_s32_)ptrCellTable->CELL_VOLTAGE_TABLE[obj->idxTemperature[INDEX_BOUNDARY_HIGH]]
+                                                                [obj->idxNacCRate[INDEX_BOUNDARY_HIGH]]
+                                                                [idx];
+      tmp32 = tmp32 - ptrCellTable->CELL_VOLTAGE_TABLE[obj->idxTemperature[INDEX_BOUNDARY_LOW]]
+                                                             [obj->idxNacCRate[INDEX_BOUNDARY_HIGH]]
+                                                             [idx];
+      tmp32 = tmp32*(temperature - TemperatureTable[obj->idxTemperature[INDEX_BOUNDARY_LOW]]);
+      tmp32 = tmp32/
+              (TemperatureTable[obj->idxTemperature[INDEX_BOUNDARY_HIGH]] -
+               TemperatureTable[obj->idxTemperature[INDEX_BOUNDARY_LOW]]);
+      valueInterpolate2 = tmp32 + ptrCellTable->CELL_VOLTAGE_TABLE[obj->idxTemperature[INDEX_BOUNDARY_LOW]]
+                                                                         [obj->idxNacCRate[INDEX_BOUNDARY_HIGH]]
+                                                                         [idx];
+    }
+
+    /// [AT-PM] : CRate interpolation ; 01/25/2013
+    if(CRateTable[obj->idxNacCRate[INDEX_BOUNDARY_HIGH]] == CRateTable[obj->idxNacCRate[INDEX_BOUNDARY_LOW]])
+    {
+      tmp32 = valueInterpolate1;
+    }
+    else
+    {
+      tmp32 = valueInterpolate2 - valueInterpolate1;
+      tmp32 = tmp32*(obj->cRate - CRateTable[obj->idxNacCRate[INDEX_BOUNDARY_LOW]]);
+      tmp32 = tmp32/
+              (CRateTable[obj->idxNacCRate[INDEX_BOUNDARY_HIGH]] - CRateTable[obj->idxNacCRate[INDEX_BOUNDARY_LOW]]);
+      tmp32 = tmp32 + valueInterpolate1;
+    }
+    obj->tableNacVoltage[idx] = (_cap_s16_)tmp32;
+    UG31_LOGD("[%s]: NAC voltage Table[%d] = %dmV (%d,%d) (%d,%d)\n", __func__,
+              idx, obj->tableNacVoltage[idx],
+              ptrCellTable->CELL_VOLTAGE_TABLE[obj->idxTemperature[INDEX_BOUNDARY_HIGH]][obj->idxNacCRate[INDEX_BOUNDARY_LOW]][idx],
+              ptrCellTable->CELL_VOLTAGE_TABLE[obj->idxTemperature[INDEX_BOUNDARY_LOW]][obj->idxNacCRate[INDEX_BOUNDARY_LOW]][idx],
+              ptrCellTable->CELL_VOLTAGE_TABLE[obj->idxTemperature[INDEX_BOUNDARY_HIGH]][obj->idxNacCRate[INDEX_BOUNDARY_HIGH]][idx],
+              ptrCellTable->CELL_VOLTAGE_TABLE[obj->idxTemperature[INDEX_BOUNDARY_LOW]][obj->idxNacCRate[INDEX_BOUNDARY_HIGH]][idx]);
+    idx = idx + 1;
+  }
+}
+
+/**
+ * @brief CreateNacVoltageTableVer2
+ *
+ *  Create NAC Voltage table for fixed EDV
+ *
+ * @para  obj address of CapacityInternalDataType
+ * @return  _UPI_NULL_
+ */
+void CreateNacVoltageTableVer2(CapacityInternalDataType *obj)
+{
+  _cap_u8_ idx;
+  _cap_s16_ base;
+  _cap_s32_ deltaSoc;
+
+  obj->tableNacVoltage[0] = (_cap_s16_)ptrCellParameter->TPVoltage;
+  obj->tableNacVoltage[SOV_NUMS - 1] = (_cap_s16_)ptrCellParameter->edv1Voltage;
+  base = obj->tableNacVoltage[0] - obj->tableNacVoltage[SOV_NUMS - 1];
+  UG31_LOGD("[%s]: Head = %d, End = %d, Base = %d\n", __func__, obj->tableNacVoltage[0], obj->tableNacVoltage[SOV_NUMS - 1], base);
+
+  idx = 1;
+  while(idx < (SOV_NUMS - 1))
+  {
+    deltaSoc = (_cap_s32_)ptrCellParameter->SOV_TABLE[idx - 1];
+    deltaSoc = deltaSoc - ptrCellParameter->SOV_TABLE[idx];
+    deltaSoc = deltaSoc*base/CONST_PERCENTAGE/10;
+    obj->tableNacVoltage[idx] = (_cap_s16_)deltaSoc;
+    obj->tableNacVoltage[idx] = obj->tableNacVoltage[idx - 1] + obj->tableNacVoltage[idx];
+    UG31_LOGD("[%s]: V[%d] = %d + %d = %d\n", __func__, idx, obj->tableNacVoltage[idx - 1], (int)deltaSoc, obj->tableNacVoltage[idx]);
+
+    idx = idx + 1;
+  }
+
+}
+
+#define CreateNacVoltageTableVer1     (CreateNacVoltageTableVer0)
+
+static VerFuncArguObjRtnNull CreateNacVoltageTable[] = {
+  CreateNacVoltageTableVer0,
+  CreateNacVoltageTableVer1,
+  CreateNacVoltageTableVer2,
+  _UPI_NULL_,
+};
+
+/**
+ * @brief CreateNacTableVer0
+ *
+ *  Create NAC table
+ *
+ * @para  obj address of CapacityInternalDataType
+ * @return  _UPI_NULL_
+ */
+void CreateNacTableVer0(CapacityInternalDataType *obj)
+{
+  _cap_u8_ idx;
+  _cap_s32_ tmp32;
+  _cap_s32_ valueInterpolate1;
+  _cap_s32_ valueInterpolate2;
+  _cap_s16_ temperature;
+
+  idx = 0;
+  temperature = GetBatteryTemperature(obj);
+  while(idx < SOV_NUMS)
+  {
+    /// [AT-PM] : Temperature interpolation ; 01/25/2013
+    if(TemperatureTable[obj->idxTemperature[INDEX_BOUNDARY_HIGH]] ==
+       TemperatureTable[obj->idxTemperature[INDEX_BOUNDARY_LOW]])
+    {
+      valueInterpolate1 = ptrCellTable->CELL_NAC_TABLE[obj->idxTemperature[INDEX_BOUNDARY_LOW]]
+                                                             [obj->idxNacCRate[INDEX_BOUNDARY_LOW]]
+                                                             [idx];
+
+      valueInterpolate2 = ptrCellTable->CELL_NAC_TABLE[obj->idxTemperature[INDEX_BOUNDARY_LOW]]
+                                                             [obj->idxNacCRate[INDEX_BOUNDARY_HIGH]]
+                                                             [idx];
+    }
+    else
+    {
+      tmp32 = (_cap_s32_)ptrCellTable->CELL_NAC_TABLE[obj->idxTemperature[INDEX_BOUNDARY_HIGH]]
+                                                            [obj->idxNacCRate[INDEX_BOUNDARY_LOW]]
+                                                            [idx];
+      tmp32 = tmp32 - ptrCellTable->CELL_NAC_TABLE[obj->idxTemperature[INDEX_BOUNDARY_LOW]]
+                                                         [obj->idxNacCRate[INDEX_BOUNDARY_LOW]]
+                                                         [idx];
+      tmp32 = tmp32*(temperature - TemperatureTable[obj->idxTemperature[INDEX_BOUNDARY_LOW]]);
+      tmp32 = tmp32/
+              (TemperatureTable[obj->idxTemperature[INDEX_BOUNDARY_HIGH]] -
+               TemperatureTable[obj->idxTemperature[INDEX_BOUNDARY_LOW]]);
+      valueInterpolate1 = tmp32 + ptrCellTable->CELL_NAC_TABLE[obj->idxTemperature[INDEX_BOUNDARY_LOW]]
+                                                                     [obj->idxNacCRate[INDEX_BOUNDARY_LOW]]
+                                                                     [idx];
+
+      tmp32 = (_cap_s32_)ptrCellTable->CELL_NAC_TABLE[obj->idxTemperature[INDEX_BOUNDARY_HIGH]]
+                                                            [obj->idxNacCRate[INDEX_BOUNDARY_HIGH]]
+                                                            [idx];
+      tmp32 = tmp32 - ptrCellTable->CELL_NAC_TABLE[obj->idxTemperature[INDEX_BOUNDARY_LOW]]
+                                                         [obj->idxNacCRate[INDEX_BOUNDARY_HIGH]]
+                                                         [idx];
+      tmp32 = tmp32*(temperature - TemperatureTable[obj->idxTemperature[INDEX_BOUNDARY_LOW]]);
+      tmp32 = tmp32/
+              (TemperatureTable[obj->idxTemperature[INDEX_BOUNDARY_HIGH]] -
+               TemperatureTable[obj->idxTemperature[INDEX_BOUNDARY_LOW]]);
+      valueInterpolate2 = tmp32 + ptrCellTable->CELL_NAC_TABLE[obj->idxTemperature[INDEX_BOUNDARY_LOW]]
+                                                                     [obj->idxNacCRate[INDEX_BOUNDARY_HIGH]]
+                                                                     [idx];
+    }
+
+    /// [AT-PM] : CRate interpolation ; 01/25/2013
+    if(CRateTable[obj->idxNacCRate[INDEX_BOUNDARY_HIGH]] == CRateTable[obj->idxNacCRate[INDEX_BOUNDARY_LOW]])
+    {
+      tmp32 = valueInterpolate1;
+    }
+    else
+    {
+      tmp32 = valueInterpolate2 - valueInterpolate1;
+      tmp32 = tmp32*(obj->cRate - CRateTable[obj->idxNacCRate[INDEX_BOUNDARY_LOW]]);
+      tmp32 = tmp32/
+              (CRateTable[obj->idxNacCRate[INDEX_BOUNDARY_HIGH]] - CRateTable[obj->idxNacCRate[INDEX_BOUNDARY_LOW]]);
+      tmp32 = tmp32 + valueInterpolate1;
+    }
+    obj->tableNac[idx] = (_cap_s16_)tmp32;
+    UG31_LOGD("[%s]: NAC Table Index = (%d-%d, %d-%d)\n", __func__,
+              obj->idxTemperature[INDEX_BOUNDARY_HIGH], obj->idxTemperature[INDEX_BOUNDARY_LOW],
+              obj->idxNacCRate[INDEX_BOUNDARY_HIGH], obj->idxNacCRate[INDEX_BOUNDARY_LOW]);
+    UG31_LOGD("[%s]: NAC Table[%d] = %dmAh (%d,%d) (%d,%d)\n", __func__,
+              idx, obj->tableNac[idx],
+              ptrCellTable->CELL_NAC_TABLE[obj->idxTemperature[INDEX_BOUNDARY_HIGH]][obj->idxNacCRate[INDEX_BOUNDARY_LOW]][idx],
+              ptrCellTable->CELL_NAC_TABLE[obj->idxTemperature[INDEX_BOUNDARY_LOW]][obj->idxNacCRate[INDEX_BOUNDARY_LOW]][idx],
+              ptrCellTable->CELL_NAC_TABLE[obj->idxTemperature[INDEX_BOUNDARY_HIGH]][obj->idxNacCRate[INDEX_BOUNDARY_HIGH]][idx],
+              ptrCellTable->CELL_NAC_TABLE[obj->idxTemperature[INDEX_BOUNDARY_LOW]][obj->idxNacCRate[INDEX_BOUNDARY_HIGH]][idx]);
+    idx = idx + 1;
+  }
+}
+
+/**
+ * @brief CreateNacTableVer0
+ *
+ *  Create NAC table
+ *
+ * @para  obj address of CapacityInternalDataType
+ * @return  _UPI_NULL_
+ */
+void CreateNacTableVer1(CapacityInternalDataType *obj)
+{
+  _cap_u8_ idx;
+  _cap_s32_ tmp32;
+  _cap_u16_ base;
+
+  /// [AT-PM] : Copy nac table from global variable ; 10/25/2013
+  upi_memcpy((_cap_u8_ *)obj->tableNac, (_cap_u8_ *)obj->info->tableNac, sizeof(_cap_s16_)*SOV_NUMS);
+
+  /// [AT-PM] : Get ratio ; 10/25/2013
+  while(1)
+  {
+    idx = 1;
+    while(idx < SOV_NUMS)
+    {
+      if(obj->tableNac[idx] > 255)
+      {
+        break;
+      }
+      idx = idx + 1;
+    }
+
+    if(idx >= SOV_NUMS)
+    {
+      break;
+    }
+
+    idx = 1;
+    while(idx < SOV_NUMS)
+    {
+      obj->tableNac[idx] = obj->tableNac[idx]/2;
+      if(obj->tableNac[idx] <= 0)
+      {
+        obj->tableNac[idx] = 1;
+      }
+      idx = idx + 1;
+    }
+  }
+
+  /// [AT-PM] : Get base ; 10/25/2013
+  base = 0;
+  idx = 1;
+  while(idx < SOV_NUMS)
+  {
+    base = base + obj->tableNac[idx];
+    UG31_LOGD("[%s]: Ratio[%d] = %d - %d\n", __func__, idx, obj->tableNac[idx], base);
+    idx = idx + 1;
+  }
+
+  /// [AT-PM] : Get capacity at each region ; 10/25/2013
+  obj->tableNac[0] = 0;
+  idx = 1;
+  while(idx < SOV_NUMS)
+  {
+    tmp32 = (_cap_s32_)ptrCellTable->CELL_NAC_TABLE[obj->idxTemperature[INDEX_BOUNDARY_LOW]][obj->idxNacCRate[INDEX_BOUNDARY_LOW]][0];
+    tmp32 = tmp32*obj->tableNac[idx]/base;
+    if(tmp32 <= 0)
+    {
+      tmp32 = 1;
+    }
+    obj->tableNac[idx] = (_cap_s16_)tmp32;
+    obj->tableNac[0] = obj->tableNac[0] + obj->tableNac[idx];
+    UG31_LOGD("[%s]: Table[%d] = %d - %d\n", __func__, idx, obj->tableNac[idx], obj->tableNac[0]);
+    idx = idx + 1;
+  }
+}
+
+#define CreateNacTableVer2      (CreateNacTableVer1)
+
+static VerFuncArguObjRtnNull CreateNacTable[] = {
+  CreateNacTableVer0,
+  CreateNacTableVer1,
+  CreateNacTableVer2,
+  _UPI_NULL_,
+};
+
+#define MAX_DELTA_PREDICT_RSOC    (3)
+#define MIN_DELTA_PREDICT_RSOC    (-3)
+#define MAX_DISQUALIFY_DELTA_RSOC (20)
+
+/**
+ * @brief FindNacRM
+ *
+ *  Find the RM from NAC table
+ *
+ * @para  obj address of CapacityInternalDataType
+ * @return  _UPI_NULL_
+ */
+void FindNacRM(CapacityInternalDataType *obj, _cap_u16_ voltage)
+{
+  _cap_s32_ tmp32;
+  _cap_s32_ weightCC;
+  _cap_s32_ weightVolt;
+  _cap_s32_ min;
+
+  /// [AT-PM] : Calculate RM below current voltage region ; 03/13/2013
+  tmp32 = SOV_NUMS - 1;
+  min = 0;
+  while(tmp32 > obj->idxNacVoltage[INDEX_BOUNDARY_LOW])
+  {
+    min = min + obj->tableNac[tmp32];
+    tmp32 = tmp32 - 1;
+  }
+  UG31_LOGD("[%s]: RM below voltage region %d = %d\n", __func__, obj->idxNacVoltage[INDEX_BOUNDARY_LOW], (int)min);
+
+  /// [AT-PM] : Calculate RM for capacity parser ; 02/09/2013
+  if(obj->tableNacVoltage[obj->idxNacVoltage[INDEX_BOUNDARY_LOW]] ==
+     obj->tableNacVoltage[obj->idxNacVoltage[INDEX_BOUNDARY_HIGH]])
+  {
+    tmp32 = 0;
+  }
+  else
+  {
+    tmp32 = (_cap_s32_)voltage;
+    tmp32 = tmp32 - obj->tableNacVoltage[obj->idxNacVoltage[INDEX_BOUNDARY_LOW]];
+    tmp32 = tmp32*
+            obj->tableNac[obj->idxNacVoltage[INDEX_BOUNDARY_LOW]]/
+            (obj->tableNacVoltage[obj->idxNacVoltage[INDEX_BOUNDARY_HIGH]] -
+             obj->tableNacVoltage[obj->idxNacVoltage[INDEX_BOUNDARY_LOW]]);
+  }
+  tmp32 = tmp32 + min;
+  obj->rm = (_cap_u16_)tmp32;
+  obj->fcc = (_cap_u16_)obj->tableNac[0];
+  UG31_LOGD("[%s]: Predicted RM = %d (%d)\n", __func__,
+            obj->rm,
+            obj->fcc);
+
+  /// [AT-PM] : Calculate RM for FCC update ; 01/25/2013
+  if(obj->info->status & CAP_STS_DSGCHARGE_INITED)
+  {
+    obj->fccRM = obj->rm;
+    UG31_LOGD("[%s]: Predicted RM for FCC Update = %d\n", __func__, obj->fccRM);
+  }
+  else
+  {
+    tmp32 = (_cap_s32_)obj->fcc;
+    tmp32 = tmp32 - (obj->info->preDsgCharge + obj->info->dsgCharge);
+    if(tmp32 < 0)
+    {
+      tmp32 = 0;
+    }
+    obj->fccRM = (_cap_u16_)tmp32;
+    UG31_LOGD("[%s]: Predicted RM for FCC Update = %d - ( %d + %d ) = %d\n", __func__,
+              (int)obj->fcc,
+              (int)obj->info->preDsgCharge,
+              (int)obj->info->dsgCharge,
+              (int)obj->fccRM);
+  }
+
+  if(obj->info->status & CAP_STS_INIT_PROCEDURE)
+  {
+    UG31_LOGD("[%s]: Initial procedure no voltage weighting\n", __func__);
+    return;
+  }
+
+  /// [AT-PM] : If predicted RSOC is 20% higher than current RSOC, no coulomb counter wetighting ; 01/06/2014
+  weightCC = 0;
+  weightVolt = 0;
+  tmp32 = (_cap_s32_)CalculateRsoc(obj->rm, (_cap_u16_)obj->tableNac[0]);
+  tmp32 = tmp32 - obj->info->rsoc;
+  if(tmp32 >= MAX_DISQUALIFY_DELTA_RSOC)
+  {
+    UG31_LOGD("[%s]: Delta RSOC = %d(%d) out of range, no coulomb counter weighting\n", __func__, (int)tmp32, obj->info->rsoc);
+  }
+  else
+  {
+    /// [FC] : Add voltage weighting ; 06/27/2013
+    weightVolt = obj->idxNacVoltage[INDEX_BOUNDARY_LOW];
+    weightCC = (SOV_NUMS - 1) - obj->idxNacVoltage[INDEX_BOUNDARY_LOW];
+    tmp32 = SOV_NUMS - 1;
+    switch(ptrCellParameter->NacLmdAdjustCfg & NAC_LMD_ADJUST_CFG_VOLTAGE_CC_WEIGHT)
+    {
+      case  NAC_LMD_ADJUST_CFG_VOLTAGE_CC_WEIGHT_1:
+        tmp32 = tmp32*tmp32;
+        weightCC = weightCC*weightCC;
+        break;
+      case  NAC_LMD_ADJUST_CFG_VOLTAGE_CC_WEIGHT_2:
+        tmp32 = tmp32*tmp32*tmp32;
+        weightCC = weightCC*weightCC*weightCC;
+        break;
+      case  NAC_LMD_ADJUST_CFG_VOLTAGE_CC_WEIGHT_3:
+        tmp32 = tmp32*tmp32*tmp32*tmp32;
+        weightCC = weightCC*weightCC*weightCC*weightCC;
+        break;
+      case  NAC_LMD_ADJUST_CFG_VOLTAGE_CC_WEIGHT_4:
+        tmp32 = tmp32*tmp32*tmp32*tmp32*tmp32;
+        weightCC = weightCC*weightCC*weightCC*weightCC*weightCC;
+        break;
+      default:
+        tmp32 = tmp32*tmp32;
+        weightCC = weightCC*weightCC;
+        break;
+    }
+    weightVolt = tmp32 - weightCC;
+    UG31_LOGD("[%s]: CC Weight = %d, Voltage Weight = %d, Base = %d\n", __func__, (int)weightCC, (int)weightVolt, (int)tmp32);
+    weightCC = weightCC*obj->fccRM;
+    weightVolt = weightVolt*obj->rm;
+    tmp32 = (weightCC + weightVolt)/tmp32;
+    obj->rm = (_cap_u16_)tmp32;
+  }
+  UG31_LOGN("[%s]: Target Predicted RM = %d (%d,%d)\n", __func__, obj->rm, (int)weightCC, (int)weightVolt);
+
+  /// [AT-PM] : Check predicted RSOC and current RSOC ; 04/02/2013
+  tmp32 = (_cap_s32_)CalculateRsoc(obj->rm, (_cap_u16_)obj->tableNac[0]);
+  tmp32 = tmp32 - obj->info->rsoc;
+  if((tmp32 <= MAX_DELTA_PREDICT_RSOC) && (tmp32 >= MIN_DELTA_PREDICT_RSOC))
+  {
+    tmp32 = (_cap_s32_)CalculateRsoc(obj->rm, (_cap_u16_)obj->tableNac[0]);
+    tmp32 = tmp32*obj->info->fcc/CONST_PERCENTAGE;
+    obj->rm = (_cap_u16_)tmp32;
+    obj->fcc = obj->info->fcc;
+    UG31_LOGN("[%s]: Target Predicted RM with RSOC = %d (%d)\n", __func__,
+              (int)obj->rm,
+              (int)obj->fcc);
+  }
+}
+
+#define AVG_CRATE_MINIMUM_VALUE     (1)
+
+/**
+ * @brief CalculateCRate
+ *
+ *  Calculate C-Rate
+ *
+ * @para  obj address of CapacityInternalDataType
+ * @return  _UPI_NULL_
+ */
+void CalculateCRate(CapacityInternalDataType *obj)
+{
+  _cap_s32_ cRate;
+
+  /// [AT-PM] : Calculate CRate ; 01/25/2013
+  cRate = (_cap_s32_)ptrMeasData->currAvg;
+  cRate = cRate*C_RATE_CONVERT_BASE/ptrCellParameter->ILMD;
+  obj->cRate = (_cap_u8_)cRate;
+  cRate = (cRate + obj->info->avgCRate)/2;
+  if(cRate < AVG_CRATE_MINIMUM_VALUE)
+  {
+    cRate = AVG_CRATE_MINIMUM_VALUE;
+  }
+  obj->info->avgCRate = (_cap_u8_)cRate;
+  UG31_LOGD("[%s]: C-Rate = %d (%d)\n", __func__, obj->cRate, obj->info->avgCRate);
+}
+
+#define INIT_CAP_PARSER_FULL_SOC      (100)
+
+static _cap_s8_ const InitCapMap[] =
+{
+  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,      ///< 0% ~ 9%
+  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,      ///< 10% ~ 19%
+  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,      ///< 20% ~ 29%
+  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,      ///< 30% ~ 39%
+  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,      ///< 40% ~ 49%
+  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,      ///< 50% ~ 59%
+  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,      ///< 60% ~ 69%
+  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,      ///< 70% ~ 79%
+  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,      ///< 80% ~ 89%
+  2,  2,  2,  2,  2,  1,  1,  1,  1,  1,      ///< 90% ~ 99%
+  0,                                          ///< 100%
+};
+
+#define INIT_PARSER_FORCE_100_THRD      (90)
+
+/**
+ * @brief InitCapacityParser
+ *
+ *  Reduce the initial capacity value
+ *
+ * @para  obj address of CapacityInternalDataType
+ * @return  _UPI_NULL_
+ */
+void InitCapacityParser(CapacityInternalDataType *obj)
+{
+  _cap_s8_ newRsoc;
+  _cap_u32_ tmp32;
+
+  if(ptrCellParameter->NacLmdAdjustCfg & NAC_LMD_ADJUST_CFG_REMOVE_INIT_PARSER)
+  {
+    UG31_LOGN("[%s]: NAC_LMD_ADJUST_CFG_REMOVE_INIT_PARSER is set\n", __func__);
+    return;
+  }
+
+  newRsoc = (_cap_s8_)obj->info->rsoc;
+  newRsoc = newRsoc + InitCapMap[obj->info->rsoc];
+  UG31_LOGN("[%s]: Parsed initial capacity = %d <- %d\n", __func__,
+            newRsoc,
+            obj->info->rsoc);
+
+  if((ptrCellParameter->NacLmdAdjustCfg & NAC_LMD_ADJUST_CFG_INIT_PARSER_FORCE_100_EN) &&
+     (!(obj->info->status & CAP_STS_NO_INIT_FORCE_100)) &&
+     (newRsoc > INIT_PARSER_FORCE_100_THRD))
+  {
+    UG31_LOGN("[%s]: Force initial capacity to 100 from %d\n", __func__,
+              newRsoc);
+    newRsoc = CONST_PERCENTAGE;
+  }
+
+  if(newRsoc == obj->info->rsoc)
+  {
+    UG31_LOGN("[%s]: No changed.\n", __func__);
+    return;
+  }
+
+  tmp32 = (_cap_u32_)newRsoc;
+  tmp32 = tmp32*obj->info->fcc/CONST_PERCENTAGE;
+  obj->info->rm = (_cap_u16_)tmp32;
+  obj->info->rsoc = (_cap_u8_)CalculateRsoc(obj->info->rm, obj->info->fcc);
+}
+
+#define CHARGE_TABLE_REF_THRESHOLD      (20)
+
+/**
+ * @brief InitCharge
+ *
+ *  Initialize charge status according to temperature, voltage, and current
+ *
+ * @para  obj address of CapacityInternalDataType
+ * @return  _UPI_NULL_
+ */
+void InitCharge(CapacityInternalDataType *obj)
+{
+  _cap_u16_ tmp16;
+  _cap_u32_ tmp32;
+
+  /// [AT-PM] : Find temperature index ; 01/25/2013
+  if(FindIdxTemperature[GET_CAP_ALGORITHM_VER(ptrCellParameter->NacLmdAdjustCfg)] != _UPI_NULL_)
+  {
+    (*FindIdxTemperature[GET_CAP_ALGORITHM_VER(ptrCellParameter->NacLmdAdjustCfg)])(obj, GetBatteryTemperature(obj));
+  }
+
+  switch(obj->info->status & CAP_STS_CURR_STATE)
+  {
+    case CAP_STS_CURR_STANDBY:
+      UG31_LOGN("[%s]: (0x%08x) CAP_STS_CURR_STANDBY\n", __func__, (unsigned int)obj->info->status);
+      /// [AT-PM] : Loop up OCV table ; 01/25/2013
+      FindOcvIdxVoltage(obj, OCV_TABLE_IDX_STAND_ALONE, ptrMeasData->bat1VoltageAvg);
+      FindOcvFcc(obj);
+      FindOcvRM(obj, OCV_TABLE_IDX_STAND_ALONE, ptrMeasData->bat1VoltageAvg);
+      obj->info->rm = obj->rm;
+      break;
+    case CAP_STS_CURR_CHG:
+      UG31_LOGN("[%s]: (0x%08x) CAP_STS_CURR_CHG\n", __func__, (unsigned int)obj->info->status);
+      /// [AT-PM] : Look up stand alone table ; 03/18/2014
+      tmp16 = ptrMeasData->bat1VoltageAvg;
+      tmp16 = tmp16 - ptrMeasData->currAvg/CHARGE_VOLTAGE_CONST;
+      FindOcvIdxVoltage(obj, OCV_TABLE_IDX_STAND_ALONE, tmp16);
+      FindOcvFcc(obj);
+      FindOcvRM(obj, OCV_TABLE_IDX_STAND_ALONE, tmp16);
+      /// [AT-PM] : Check minimum rsoc threshold for stand alone table ; 03/18/2014
+      tmp32 = (_cap_u32_)obj->info->fcc;
+      tmp32 = tmp32*CHARGE_TABLE_REF_THRESHOLD/CONST_PERCENTAGE;
+      if((obj->rm < tmp32) &&
+				 (ptrMeasData->currAvg > ptrCellParameter->ILMD / 4))
+      {
+        tmp16 = ptrMeasData->bat1VoltageAvg;
+        FindOcvIdxVoltage(obj, OCV_TABLE_IDX_CHARGE, tmp16);
+        FindOcvFcc(obj);
+        FindOcvRM(obj, OCV_TABLE_IDX_CHARGE, tmp16);
+      }
+      obj->info->rm = obj->rm;
+      break;
+    case CAP_STS_CURR_DSG:
+      UG31_LOGN("[%s]: (0x%08x) CAP_STS_CURR_DSG\n", __func__, (unsigned int)obj->info->status);
+      /// [AT-PM] : Loop up NAC table ; 01/25/2013
+      CalculateCRate(obj);
+      if(FindNacIdxCRate[GET_CAP_ALGORITHM_VER(ptrCellParameter->NacLmdAdjustCfg)] != _UPI_NULL_)
+      {
+        (*FindNacIdxCRate[GET_CAP_ALGORITHM_VER(ptrCellParameter->NacLmdAdjustCfg)])(obj);
+      }
+      if(CreateNacVoltageTable[GET_CAP_ALGORITHM_VER(ptrCellParameter->NacLmdAdjustCfg)] != _UPI_NULL_)
+      {
+        (*CreateNacVoltageTable[GET_CAP_ALGORITHM_VER(ptrCellParameter->NacLmdAdjustCfg)])(obj);
+      }
+      FindNacIdxVoltage(obj, (_cap_u16_)ptrMeasData->bat1VoltageAvg);
+      if(CreateNacTable[GET_CAP_ALGORITHM_VER(ptrCellParameter->NacLmdAdjustCfg)] != _UPI_NULL_)
+      {
+        (*CreateNacTable[GET_CAP_ALGORITHM_VER(ptrCellParameter->NacLmdAdjustCfg)])(obj);
+      }
+      obj->fcc = (_cap_u16_)LimitValue((_cap_s32_)obj->tableNac[0], (_cap_s32_)ptrCellParameter->ILMD, LIMIT_FCC_WITH_ILMD_RANGE);
+      obj->info->fcc = obj->tableNac[0];
+      FindNacRM(obj, (_cap_u16_)ptrMeasData->bat1VoltageAvg);
+      obj->info->rm = obj->rm;
+      break;
+    default:
+      UG31_LOGE("[%s]: (0x%08x) CAP_STS_UNKNOWN\n", __func__, (unsigned int)obj->info->status);
+      /// [AT-PM] : Loop up OCV table ; 01/25/2013
+      FindOcvIdxVoltage(obj, OCV_TABLE_IDX_STAND_ALONE, ptrMeasData->bat1VoltageAvg);
+      FindOcvFcc(obj);
+      FindOcvRM(obj, OCV_TABLE_IDX_STAND_ALONE, ptrMeasData->bat1VoltageAvg);
+      obj->info->rm = obj->rm;
+      break;
+  }
+
+  if(obj->info->rm > obj->info->fcc)
+  {
+    obj->info->rm = obj->info->fcc;
+  }
+  obj->info->rsoc = (_cap_u8_)CalculateRsoc(obj->info->rm, obj->info->fcc);
+  InitCapacityParser(obj);
+  obj->info->rsoc = (_cap_u8_)CalculateRsoc(obj->info->rm, obj->info->fcc);
+  obj->info->fccBackup = obj->info->fcc;
+  obj->info->predictRsoc = obj->info->rsoc;
+  obj->info->tableRsoc = obj->info->rsoc;
+  UG31_LOGN("[%s]: Initial capacity %d / %d = %d\n", __func__,
+            obj->info->rm, obj->info->fcc, obj->info->rsoc);
+}
+
+/**
+ * @brief CheckTableAvailable
+ *
+ *  Check table is available or not
+ *
+ * @para  data  address of CapacityInternalDataType
+ * @return  _UPI_TRUE_ if data is available
+ */
+_cap_bool_ CheckTableAvailable(CapacityInternalDataType *data)
+{
+  _cap_u8_ idx;
+
+  idx = 0;
+  while(idx < (SOV_NUMS - 1))
+  {
+    if(data->info->encriptTable[idx] == 0)
+    {
+      return (_UPI_FALSE_);
+    }
+    idx = idx + 1;
+  }
+  return (_UPI_TRUE_);
+}
+
+#define CELL_TABLE_ENCRIPTION_RATIO     (1000)
+
+/**
+ * @brief EncriptTable
+ *
+ *  Encript table from ptrCellTable->CELL_NAC_TABLE to data->info->encriptTable
+ *
+ * @para  data  address of CapacityInternalDataType
+ * @return  _UPI_NULL_
+ */
+void EncriptTable(CapacityInternalDataType *data)
+{
+  _cap_u8_ idxTemp;
+  _cap_u8_ idxCRate;
+  _cap_u8_ idxSov;
+  _cap_u8_ idx;
+  _cap_u16_ tmp;
+  _cap_u16_ percentage[TEMPERATURE_NUMS][C_RATE_NUMS][SOV_NUMS-1];
+  _cap_u32_ tmp32;
+
+  idxTemp = 0;
+  idxCRate = 0;
+  idxSov = 0;
+  while(idxTemp < TEMPERATURE_NUMS)
+  {
+    while(idxCRate < C_RATE_NUMS)
+    {
+      while(idxSov < (SOV_NUMS - 1))
+      {
+        percentage[idxTemp][idxCRate][idxSov] = 0;
+        idxSov = idxSov + 1;
+      }
+      idxCRate = idxCRate + 1;
+    }
+    idxTemp = idxTemp + 1;
+  }
+
+  /// [FC] : Encript table by percentage ; 06/14/2013
+  if(data->tableNac[0] != 0)
+  {
+    idx = 0;
+    idxSov = 1;
+    while(idxSov < SOV_NUMS)
+    {
+      tmp32 = (_cap_u32_)data->tableNac[idxSov];
+      tmp32 = tmp32*CELL_TABLE_ENCRIPTION_RATIO*CONST_ROUNDING/data->tableNac[0];
+      tmp32 = (tmp32 + CONST_ROUNDING_5)/CONST_ROUNDING;
+      if(tmp32 < 1)
+      {
+        tmp32 = 1;
+      }
+      data->info->encriptTable[idx] = (_cap_u8_)tmp32;
+      UG31_LOGD("[%s]: Encripted Value [%d] = %d\n", __func__,
+                idx, data->info->encriptTable[idx]);
+      idxSov = idxSov + 1;
+      idx = idx + 1;
+    }
+    idxTemp = 0;
+    while(idxTemp < TEMPERATURE_NUMS)
+    {
+      idxCRate = 0;
+      while(idxCRate < C_RATE_NUMS)
+      {
+        if(ptrCellTable->CELL_NAC_TABLE[idxTemp][idxCRate][0] < SOV_NUMS)
+        {
+          ptrCellTable->CELL_NAC_TABLE[idxTemp][idxCRate][0] = SOV_NUMS - 1;
+        }
+        data->info->encriptTable[idx] = ptrCellTable->CELL_NAC_TABLE[idxTemp][idxCRate][0] / 256;
+        UG31_LOGD("[%s]: Encripted Value [%d] = %d\n", __func__,
+                  idx, data->info->encriptTable[idx]);
+        data->info->encriptTable[idx+1] = ptrCellTable->CELL_NAC_TABLE[idxTemp][idxCRate][0] % 256;
+        UG31_LOGD("[%s]: Encripted Value [%d] = %d\n", __func__,
+                  idx+1, data->info->encriptTable[idx+1]);
+        idx = idx + 2;
+        idxCRate = idxCRate + 1;
+      }
+      idxTemp = idxTemp + 1;
+    }
+  }
+  else
+  {
+    idx = SOV_NUMS - 1;
+    idxTemp = 0;
+    while(idxTemp < TEMPERATURE_NUMS)
+    {
+      idxCRate = 0;
+      while(idxCRate < C_RATE_NUMS)
+      {
+        idxSov = 1;
+        while(idxSov < SOV_NUMS)
+        {
+          tmp32 = (_cap_u32_)ptrCellTable->CELL_NAC_TABLE[idxTemp][idxCRate][idxSov];
+          tmp32 = tmp32*1000*CONST_ROUNDING/ptrCellTable->CELL_NAC_TABLE[idxTemp][idxCRate][0];
+          tmp32 = (tmp32 + CONST_ROUNDING_5)/CONST_ROUNDING;
+          percentage[idxTemp][idxCRate][idxSov - 1] = (_cap_u16_)tmp32;
+          UG31_LOGD("[%s]: Percentage =  Table[%d][%d][%d] * %d / %d = %d  * %d / %d = %d\n", __func__,
+                    idxTemp, idxCRate, idxSov,
+                    CELL_TABLE_ENCRIPTION_RATIO,
+                    ptrCellTable->CELL_NAC_TABLE[idxTemp][idxCRate][0],
+                    ptrCellTable->CELL_NAC_TABLE[idxTemp][idxCRate][idxSov],
+                    CELL_TABLE_ENCRIPTION_RATIO,
+                    ptrCellTable->CELL_NAC_TABLE[idxTemp][idxCRate][0],
+                    percentage[idxTemp][idxCRate][idxSov - 1]);
+          idxSov = idxSov + 1;
+        }
+        if(ptrCellTable->CELL_NAC_TABLE[idxTemp][idxCRate][0] < SOV_NUMS)
+        {
+          ptrCellTable->CELL_NAC_TABLE[idxTemp][idxCRate][0] = SOV_NUMS - 1;
+        }
+        data->info->encriptTable[idx] = ptrCellTable->CELL_NAC_TABLE[idxTemp][idxCRate][0] / 256;
+        UG31_LOGD("[%s]: Encripted Value [%d] = %d\n", __func__,
+                  idx, data->info->encriptTable[idx]);
+        data->info->encriptTable[idx+1] = ptrCellTable->CELL_NAC_TABLE[idxTemp][idxCRate][0] % 256;
+        UG31_LOGD("[%s]: Encripted Value [%d] = %d\n", __func__,
+                  idx+1, data->info->encriptTable[idx+1]);
+        idx = idx + 2;
+        idxCRate = idxCRate + 1;
+      }
+      idxTemp = idxTemp + 1;
+    }
+    idxSov = 1;
+    while(idxSov < SOV_NUMS)
+    {
+      idxTemp = 0;
+      tmp = 0;
+      while(idxTemp < TEMPERATURE_NUMS)
+      {
+        idxCRate = 0;
+        while(idxCRate < C_RATE_NUMS)
+        {
+          tmp = tmp + percentage[idxTemp][idxCRate][idxSov-1];
+          idxCRate = idxCRate + 1;
+        }
+        idxTemp = idxTemp + 1;
+      }
+      data->info->encriptTable[idxSov-1] = tmp / (TEMPERATURE_NUMS * C_RATE_NUMS);
+      if(data->info->encriptTable[idxSov-1] < 1)
+      {
+        data->info->encriptTable[idxSov-1] = 1;
+      }
+      UG31_LOGD("[%s]: Encripted Value [%d] = %d\n", __func__,
+                idxSov-1, data->info->encriptTable[idxSov-1]);
+      idxSov = idxSov + 1;
+    }
+  }
+}
+
+/**
+ * @brief DecriptTable
+ *
+ *  Decript table from data->info->encriptTable to ptrCellTable->CELL_NAC_TABLE
+ *
+ * @para  data  address of CapacityInternalDataType
+ * @return  _UPI_NULL_
+ */
+void DecriptTable(CapacityInternalDataType *data)
+{
+  _cap_u8_ idxTemp;
+  _cap_u8_ idxCRate;
+  _cap_u8_ idxSov;
+  _cap_u8_ idx;
+  _cap_s16_ tmp;
+  _cap_u32_ tmp32;
+
+  /// [AT-PM] : Decript table ; 12/17/2012
+  idx = SOV_NUMS - 1;
+  idxTemp = 0;
+  while(idxTemp < TEMPERATURE_NUMS)
+  {
+    idxCRate = 0;
+    while(idxCRate < C_RATE_NUMS)
+    {
+      idxSov = 0;
+      ptrCellTable->CELL_NAC_TABLE[idxTemp][idxCRate][idxSov] = 0;
+      ptrCellTable->CELL_NAC_TABLE[idxTemp][idxCRate][0] =
+        data->info->encriptTable[idx] * 256 +  data->info->encriptTable[idx+1];
+      if(ptrCellTable->CELL_NAC_TABLE[idxTemp][idxCRate][0] < SOV_NUMS)
+      {
+        ptrCellTable->CELL_NAC_TABLE[idxTemp][idxCRate][0] = SOV_NUMS - 1;
+      }
+      UG31_LOGD("[%s]: Table[%d][%d][%d] = %d\n", __func__,
+                idxTemp, idxCRate, 0,
+                ptrCellTable->CELL_NAC_TABLE[idxTemp][idxCRate][0]);
+      idxSov = 1;
+      tmp = 0;
+      while(idxSov < SOV_NUMS)
+      {
+        tmp32 = (_cap_u32_)data->info->encriptTable[idxSov - 1];
+        tmp32 = tmp32*ptrCellTable->CELL_NAC_TABLE[idxTemp][idxCRate][0]*CONST_ROUNDING/CELL_TABLE_ENCRIPTION_RATIO;
+        tmp32 = (tmp32 + CONST_ROUNDING_5)/CONST_ROUNDING;
+        ptrCellTable->CELL_NAC_TABLE[idxTemp][idxCRate][idxSov] = (_upi_s16_)tmp32;
+        /// [FC] : Limit the minimum capacity to 1 ; 06/14/2013
+        if(ptrCellTable->CELL_NAC_TABLE[idxTemp][idxCRate][idxSov] < 1)
+        {
+          ptrCellTable->CELL_NAC_TABLE[idxTemp][idxCRate][idxSov] = 1;
+        }
+        tmp = tmp + ptrCellTable->CELL_NAC_TABLE[idxTemp][idxCRate][idxSov];
+        idxSov = idxSov + 1;
+      }
+      /// [FC] : Distribute insufficient or superfluous capacity ; 06/14/2013
+      tmp = ptrCellTable->CELL_NAC_TABLE[idxTemp][idxCRate][0] - tmp;
+      while(tmp)
+      {
+        idxSov = 1;
+        while(idxSov < SOV_NUMS)
+        {
+          if(tmp > 0)
+          {
+            ptrCellTable->CELL_NAC_TABLE[idxTemp][idxCRate][idxSov] =
+              ptrCellTable->CELL_NAC_TABLE[idxTemp][idxCRate][idxSov] + 1;
+            tmp = tmp - 1;
+          }
+          else
+          {
+            if(ptrCellTable->CELL_NAC_TABLE[idxTemp][idxCRate][idxSov] > 1)
+            {
+              ptrCellTable->CELL_NAC_TABLE[idxTemp][idxCRate][idxSov] =
+                ptrCellTable->CELL_NAC_TABLE[idxTemp][idxCRate][idxSov] - 1;
+              tmp = tmp + 1;
+            }
+          }
+          if(tmp == 0)
+          {
+            break;
+          }
+          idxSov = idxSov + 1;
+        }
+      }
+      idxSov = 1;
+      while(idxSov < SOV_NUMS)
+      {
+        UG31_LOGD("[%s]: Table[%d][%d][%d] = ( Encript Value [%d] = %d ) x %d / %d = %d\n", __func__,
+                  idxTemp, idxCRate, idxSov, idxSov-1,
+                  data->info->encriptTable[idxSov-1],
+                  ptrCellTable->CELL_NAC_TABLE[idxTemp][idxCRate][0],
+                  CELL_TABLE_ENCRIPTION_RATIO,
+                  ptrCellTable->CELL_NAC_TABLE[idxTemp][idxCRate][idxSov]);
+        idxSov = idxSov + 1;
+      }
+      idx = idx + 2;
+      idxCRate = idxCRate + 1;
+    }
+    idxTemp = idxTemp + 1;
+  }
+}
+
+#define PREPARE_NAC_TABLE_VER1_CONST      (10000)
+
+/**
+ * @brief PrepareNacTableVer1
+ *
+ *  Prepare NAC table for no learning feature
+ *
+ * @para  obj address of CapacityInternalDataType
+ * @return  NULL
+ */
+void PrepareNacTableVer1(CapacityInternalDataType *obj)
+{
+  _cap_s32_ tmp32;
+  _cap_u8_ idxSov;
+  _cap_u8_ idxTemp;
+  _cap_u8_ idxCRate;
+  _cap_u8_ dataCnt;
+  _cap_s32_ ratio;
+
+  /// [AT-PM] : Find a suitable FCC for each curve ; 10/28/2013
+  tmp32 = 0;
+  dataCnt = 0;
+  idxTemp = 0;
+  while(idxTemp < TEMPERATURE_NUMS)
+  {
+    idxCRate = 0;
+    while(idxCRate < C_RATE_NUMS)
+    {
+      tmp32 = tmp32 + ptrCellTable->CELL_NAC_TABLE[idxTemp][idxCRate][0];
+      dataCnt = dataCnt + 1;
+      idxCRate = idxCRate + 1;
+    }
+    idxTemp = idxTemp + 1;
+  }
+  tmp32 = tmp32/dataCnt;
+
+  ratio = (_cap_s32_)ptrCellParameter->ILMD;
+  ratio = ratio*PREPARE_NAC_TABLE_VER1_CONST;
+  ratio = ratio/tmp32;
+
+  /// [AT-PM] : Prepare NAC table ; 10/28/2013
+  obj->info->tableNac[0] = 0;
+
+  idxSov = 1;
+  while(idxSov < SOV_NUMS)
+  {
+    dataCnt = 0;
+    tmp32 = 0;
+
+    idxTemp = 0;
+    while(idxTemp < TEMPERATURE_NUMS)
+    {
+      idxCRate = 0;
+      while(idxCRate < C_RATE_NUMS)
+      {
+        tmp32 = tmp32 + ptrCellTable->CELL_NAC_TABLE[idxTemp][idxCRate][idxSov];
+        dataCnt = dataCnt + 1;
+        idxCRate = idxCRate + 1;
+      }
+
+      idxTemp = idxTemp + 1;
+    }
+
+    tmp32 = tmp32*ratio/PREPARE_NAC_TABLE_VER1_CONST/dataCnt;
+    obj->info->tableNac[idxSov] = (_cap_s16_)tmp32;
+    obj->info->tableNac[0] = obj->info->tableNac[0] + obj->info->tableNac[idxSov];
+    UG31_LOGD("[%s]: tableNac[%d] = %d (%d)\n", __func__, idxSov, obj->info->tableNac[idxSov], obj->info->tableNac[0]);
+
+    idxSov = idxSov + 1;
+  }
+}
+
+#define PrepareNacTableVer0     (_UPI_NULL_)
+#define PrepareNacTableVer2     (PrepareNacTableVer1)
+
+static VerFuncArguObjRtnNull PrepareNacTable[] = {
+  PrepareNacTableVer0,
+  PrepareNacTableVer1,
+  PrepareNacTableVer2,
+  _UPI_NULL_,
+};
+
+/**
+ * @brief SaveUpdateNacTable
+ *
+ *  Save updated NAC table to IC
+ *
+ * @para  data  address of CapacityInternalDataType
+ * @return  _UPI_NULL_
+ */
+void SaveUpdateNacTable(CapacityInternalDataType *data)
+{
+  _cap_u8_ tmpTable[MAX_ENCRIPT_TABLE_SIZE];
+  _sys_u8_ *ptr;
+
+  ptr = (_sys_u8_ *)&tmpTable[0];
+  UpiAllocateTableBuf((_sys_u8_ **)&ptr, (_sys_u8_ *)&data->info->tableSize);
+  upi_memcpy(tmpTable, data->info->encriptTable, data->info->tableSize);
+
+  /// [AT-PM] : Refresh NAC table ; 02/26/2013
+  if(CreateNacTable[GET_CAP_ALGORITHM_VER(ptrCellParameter->NacLmdAdjustCfg)] != _UPI_NULL_)
+  {
+    (*CreateNacTable[GET_CAP_ALGORITHM_VER(ptrCellParameter->NacLmdAdjustCfg)])(data);
+  }
+
+  /// [AT-PM] : Encript table ; 01/31/2013
+  EncriptTable(data);
+
+  /// [AT-PM] : Decript table ; 01/31/2013
+  DecriptTable(data);
+  UpiFreeTableBuf((_sys_u8_ **)&tmpTable);
+
+  /// [AT-PM] : Prepare NAC table ; 10/25/2013
+  if(PrepareNacTable[GET_CAP_ALGORITHM_VER(ptrCellParameter->NacLmdAdjustCfg)] != _UPI_NULL_)
+  {
+    (*PrepareNacTable[GET_CAP_ALGORITHM_VER(ptrCellParameter->NacLmdAdjustCfg)])(data);
+  }
+
+  /// [AT-PM] : Refresh NAC table ; 02/26/2013
+  if(CreateNacTable[GET_CAP_ALGORITHM_VER(ptrCellParameter->NacLmdAdjustCfg)] != _UPI_NULL_)
+  {
+    (*CreateNacTable[GET_CAP_ALGORITHM_VER(ptrCellParameter->NacLmdAdjustCfg)])(data);
+  }
+}
+
+#define MAX_RATIO_OF_CC_RECORD_WITH_TABLE     (11/10)
+#define MIN_RATIO_OF_CC_RECORD_WITH_TABLE     (9/10)
+
+/**
+ * @brief UpdateCCRecord
+ *
+ *  Update CC record array from coulomb counter
+ *
+ * @para  obj address of CapacityInternalDataType
+ * @return  _UPI_NULL_
+ */
+void UpdateCCRecord(CapacityInternalDataType *obj)
+{
+  _cap_s32_ tmp32;
+  _cap_u8_ idx;
+
+  /// [AT-PM] : Check delta capacity ; 01/31/2013
+  tmp32 = obj->info->dsgCharge - obj->info->dsgChargeStart;
+  if(tmp32 < 0)
+  {
+    UG31_LOGE("[%s]: Check delta capacity fail (%d - %d < 0)\n",
+              __func__, (int)obj->info->dsgCharge, (int)obj->info->dsgChargeStart);
+    return;
+  }
+
+  /// [AT-PM] : Check discharge time ; 07/18/2013
+  if(obj->info->dsgChargeTime == 0)
+  {
+    UG31_LOGE("[%s]: Discharge time = 0\n", __func__);
+    return;
+  }
+
+  /// [AT-PM] : Check update index ; 03/05/2014
+  if(obj->info->tableUpdateIdx >= SOV_NUMS)
+  {
+    UG31_LOGE("[%s]: Check update index fail (%d >= %d)\n",
+              __func__, (int)obj->info->tableUpdateIdx, SOV_NUMS);
+    return;
+  }
+
+  obj->info->ccRecord[obj->info->tableUpdateIdx] = (_cap_s16_)tmp32;
+
+  obj->info->ccRecord[0] = 0;
+  idx = 1;
+  while(idx < SOV_NUMS)
+  {
+    obj->info->ccRecord[0] = obj->info->ccRecord[0] + obj->info->ccRecord[idx];
+    UG31_LOGD("[%s]: New CC Record[%d] = %d (%d)\n", __func__,
+              idx, obj->info->ccRecord[idx], obj->info->ccRecord[0]);
+
+    idx = idx + 1;
+  }
+}
+
+#ifdef  CAP_LOG_UPDATE_TABLE
+
+/**
+ * @brief DumpUpdateTable
+ *
+ *  Dump updated NAC table to file
+ *
+ * @para  obj address of Capacity InternalDataType
+ * @return  NULL
+ */
+void DumpUpdateTable(CapacityInternalDataType *obj)
+{
+  struct file *fp;
+  mm_segment_t oldFS;
+  loff_t pos;
+  size_t size;
+
+  fp = _UPI_NULL_;
+  fp = filp_open(CAP_LOG_UPDATE_TABLE_PATH, O_CREAT | O_APPEND | O_WRONLY, 0);
+  if(IS_ERR(fp))
+  {
+    UG31_LOGE("[%s]: Create table dump file fail\n", __func__);
+    return;
+  }
+
+  /// [AT-PM] : Write data to file ; 03/25/2013
+  oldFS = get_fs();
+  set_fs(get_ds());
+  pos = 0;
+  size = vfs_write(fp, (char *)&obj->info->tableUpdateIdx, sizeof(obj->info->tableUpdateIdx), &pos);
+  size = vfs_write(fp, (char *)obj->info->encriptTable, sizeof(obj->info->encriptTable), &pos);
+  set_fs(oldFS);
+
+  filp_close(fp, _UPI_NULL_);
+}
+
+#endif  ///< end of CAP_LOG_UPDATE_TABLE
+
+/**
+ * @brief UpdateProcedureVer0
+ *
+ *  Procedure for updating NAC table
+ *
+ * @para  obj address of CapacityInternalDataType
+ * @return  NULL
+ */
+void UpdateProcedureVer0(CapacityInternalDataType *obj)
+{
+  _cap_s32_ offset;
+  _cap_s32_ tmp32;
+  _cap_u8_ idxTemperature;
+  _cap_u8_ idxCRate;
+
+  /// [AT-PM] : Update table using offset ; 02/26/2013
+  offset = obj->info->dsgCharge - obj->info->dsgChargeStart - obj->tableNac[obj->info->tableUpdateIdx];
+  UG31_LOGD("[%s]: Update Offset = (%d - %d) - %d = %d\n", __func__,
+            (int)obj->info->dsgCharge, (int)obj->info->dsgChargeStart, obj->tableNac[obj->info->tableUpdateIdx], (int)offset);
+
+  /// [AT-PM] : Update table ; 02/26/2013
+  idxTemperature = obj->idxTemperature[INDEX_BOUNDARY_HIGH];
+  while(idxTemperature <= obj->idxTemperature[INDEX_BOUNDARY_LOW])
+  {
+    idxCRate = obj->idxNacCRate[INDEX_BOUNDARY_HIGH];
+    while(idxCRate <= obj->idxNacCRate[INDEX_BOUNDARY_LOW])
+    {
+      tmp32 = (_cap_s32_)ptrCellTable->CELL_NAC_TABLE[idxTemperature][idxCRate][obj->info->tableUpdateIdx];
+      tmp32 = tmp32 + offset;
+      if(tmp32 < 1)
+      {
+        tmp32 = 1;
+      }
+      UG31_LOGD("[%s]: Update NAC Table[%d][%d][%d] = %d -> %d\n", __func__,
+                idxTemperature, idxCRate, obj->info->tableUpdateIdx,
+                ptrCellTable->CELL_NAC_TABLE[idxTemperature][idxCRate][obj->info->tableUpdateIdx], (int)tmp32);
+      ptrCellTable->CELL_NAC_TABLE[idxTemperature][idxCRate][obj->info->tableUpdateIdx] = (_upi_s16_)tmp32;
+
+      tmp32 = offset + (_cap_s32_)ptrCellTable->CELL_NAC_TABLE[idxTemperature][idxCRate][0];
+      if(tmp32 <= SOV_NUMS - 1)
+      {
+        tmp32 = SOV_NUMS - 1;
+      }
+      ptrCellTable->CELL_NAC_TABLE[idxTemperature][idxCRate][0] = (_upi_s16_)tmp32;
+
+      idxCRate = idxCRate + 1;
+    }
+    idxTemperature = idxTemperature + 1;
+  }
+}
+
+/**
+ * @brief UpdateProcedureVer1
+ *
+ *  Procedure for updating NAC table
+ *
+ * @para  obj address of CapacityInternalDataType
+ * @return  NULL
+ */
+void UpdateProcedureVer1(CapacityInternalDataType *obj)
+{
+  _cap_s32_ offset;
+  _cap_s32_ tmp32;
+
+  /// [AT-PM] : Get offset to be updated ; 10/25/2013
+  offset = obj->info->dsgCharge - obj->info->dsgChargeStart - obj->tableNac[obj->info->tableUpdateIdx];
+  UG31_LOGD("[%s]: Update Offset = (%d - %d) - %d = %d\n", __func__,
+            (int)obj->info->dsgCharge, (int)obj->info->dsgChargeStart, obj->tableNac[obj->info->tableUpdateIdx], (int)offset);
+
+  /// [AT-PM] : Update FCC table ; 10/25/2013
+  tmp32 = (_cap_s32_)ptrCellTable->CELL_NAC_TABLE[obj->idxTemperature[INDEX_BOUNDARY_LOW]][obj->idxNacCRate[INDEX_BOUNDARY_LOW]][0];
+  tmp32 = tmp32 + offset;
+  if(tmp32 < SOV_NUMS)
+  {
+    tmp32 = SOV_NUMS;
+  }
+  UG31_LOGD("[%s]: Update table FCC[%d][%d][%d] = %d (%d)\n", __func__, obj->idxTemperature[INDEX_BOUNDARY_LOW],
+            obj->idxNacCRate[INDEX_BOUNDARY_LOW], 0, (int)tmp32,
+            ptrCellTable->CELL_NAC_TABLE[obj->idxTemperature[INDEX_BOUNDARY_LOW]][obj->idxNacCRate[INDEX_BOUNDARY_LOW]][0]);
+  ptrCellTable->CELL_NAC_TABLE[obj->idxTemperature[INDEX_BOUNDARY_LOW]][obj->idxNacCRate[INDEX_BOUNDARY_LOW]][0] = (_upi_s16_)tmp32;
+
+  /// [AT-PM] : Update capacity in the region ; 10/25/2013
+  tmp32 = (_cap_s32_)obj->info->tableNac[obj->info->tableUpdateIdx];
+  tmp32 = tmp32 + offset;
+  if(tmp32 < 1)
+  {
+    tmp32 = 1;
+  }
+  UG31_LOGD("[%s]: Update table NAC[%d] = %d (%d)\n", __func__, obj->info->tableUpdateIdx, (int)tmp32,
+            obj->info->tableNac[obj->info->tableUpdateIdx]);
+  obj->info->tableNac[obj->info->tableUpdateIdx] = (_cap_s16_)tmp32;
+
+  /// [AT-PM] : Update FCC of the region ; 10/25/2013
+  tmp32 = (_cap_s32_)obj->info->tableNac[0];
+  tmp32 = tmp32 + offset;
+  if(tmp32 < SOV_NUMS)
+  {
+    tmp32 = SOV_NUMS;
+  }
+  UG31_LOGD("[%s]: Update table FCC = %d (%d)\n", __func__, (int)tmp32, obj->info->tableNac[0]);
+  obj->info->tableNac[0] = (_cap_s16_)tmp32;
+}
+
+#define UpdateProcedureVer2     (_UPI_NULL_)
+
+static VerFuncArguObjRtnNull UpdateProcedure[] = {
+  UpdateProcedureVer0,
+  UpdateProcedureVer1,
+  UpdateProcedureVer2,
+  _UPI_NULL_,
+};
+
+/**
+ * @brief UpdateTable
+ *
+ *  Update table procedure
+ *
+ * @para  obj address of CapacityInternalDataType
+ * @return  NULL
+ */
+void UpdateTable(CapacityInternalDataType *obj)
+{
+  _cap_s32_ tmp32;
+
+  /// [AT-PM] : Check delta capacity ; 01/31/2013
+  tmp32 = obj->info->dsgCharge - obj->info->dsgChargeStart;
+  if(tmp32 < 0)
+  {
+    UG31_LOGE("[%s]: Check delta capacity fail (%d - %d < 0)\n",
+              __func__, (int)obj->info->dsgCharge, (int)obj->info->dsgChargeStart);
+    return;
+  }
+
+  /// [AT-PM] : Check discharge time ; 07/18/2013
+  if(obj->info->dsgChargeTime == 0)
+  {
+    UG31_LOGE("[%s]: Discharge time = 0\n", __func__);
+    return;
+  }
+
+  /// [AT-PM] : Calculate average c-rate ; 01/31/2013
+  tmp32 = tmp32*TIME_SEC_TO_HOUR/obj->info->dsgChargeTime;
+  UG31_LOGD("[%s]: Average C-Rate tmp = %d x %d / %d\n", __func__, (int)tmp32, TIME_SEC_TO_HOUR, (int)obj->info->dsgChargeTime);
+  tmp32 = tmp32*C_RATE_CONVERT_BASE*(-1)/ptrCellParameter->ILMD;
+  UG31_LOGD("[%s]: Average C-Rate = %d x %d x (-1) / %d\n", __func__, (int)tmp32, C_RATE_CONVERT_BASE, ptrCellParameter->ILMD);
+  obj->cRate = (_cap_u8_)tmp32;
+  UG31_LOGD("[%s]: Average C-Rate = %d\n", __func__, obj->cRate);
+
+  /// [AT-PM] : Refresh NAC and voltage table ; 01/31/2013
+  if(FindNacIdxCRate[GET_CAP_ALGORITHM_VER(ptrCellParameter->NacLmdAdjustCfg)] != _UPI_NULL_)
+  {
+    (*FindNacIdxCRate[GET_CAP_ALGORITHM_VER(ptrCellParameter->NacLmdAdjustCfg)])(obj);
+  }
+  if(CreateNacVoltageTable[GET_CAP_ALGORITHM_VER(ptrCellParameter->NacLmdAdjustCfg)] != _UPI_NULL_)
+  {
+    (*CreateNacVoltageTable[GET_CAP_ALGORITHM_VER(ptrCellParameter->NacLmdAdjustCfg)])(obj);
+  }
+  FindNacIdxVoltage(obj, obj->info->avgVoltage);
+  if(CreateNacTable[GET_CAP_ALGORITHM_VER(ptrCellParameter->NacLmdAdjustCfg)] != _UPI_NULL_)
+  {
+    (*CreateNacTable[GET_CAP_ALGORITHM_VER(ptrCellParameter->NacLmdAdjustCfg)])(obj);
+  }
+
+  /// [AT-PM] : Update NAC table ; 10/25/2013
+  if(UpdateProcedure[GET_CAP_ALGORITHM_VER(ptrCellParameter->NacLmdAdjustCfg)] != _UPI_NULL_)
+  {
+    (*UpdateProcedure[GET_CAP_ALGORITHM_VER(ptrCellParameter->NacLmdAdjustCfg)])(obj);
+  }
+
+  /// [AT-PM] : Save updated NAC table ; 01/31/2013
+  SaveUpdateNacTable(obj);
+  return;
+}
+
+enum RSOC_FILTER_FLAG {
+  RSOC_FILTER_FLAG_RESET_ALL = 0,
+  RSOC_FILTER_FLAG_RESET_STEP,
+  RSOC_FILTER_FLAG_RESET_FULL,
+  RSOC_FILTER_FLAG_RESET_LOCK,
+  RSOC_FILTER_FLAG_SET_1_STEP,
+  RSOC_FILTER_FLAG_SET_1_FULL,
+};
+
+/**
+ * @brief RsocFilterReset
+ *
+ *  Reset timer
+ *
+ * @para  obj address of CapacityInternalDataType
+ * @para  flag  RSOC_FILTER_FLAG
+ * @return  NULL
+ */
+void RsocFilterReset(CapacityInternalDataType *obj, _cap_u8_ flag)
+{
+  switch(flag)
+  {
+    case RSOC_FILTER_FLAG_RESET_ALL:
+      obj->info->status = obj->info->status & (~CAP_STS_FILTER_LOCK_OVER);
+      obj->info->socTimeStep = 0;
+      obj->info->socTimeStepOverCnt = 0;
+      obj->info->socTimeFull = 0;
+      obj->info->socTimeFullOverCnt = 0;
+      obj->info->socTimeLock = 0;
+      obj->info->socCCStep = 0;
+      break;
+    case RSOC_FILTER_FLAG_RESET_STEP:
+      obj->info->socTimeStep = 0;
+      obj->info->socTimeStepOverCnt = 0;
+      obj->info->socCCStep = 0;
+      break;
+    case RSOC_FILTER_FLAG_RESET_FULL:
+      obj->info->socTimeFull = 0;
+      obj->info->socTimeFullOverCnt = 0;
+      break;
+    case RSOC_FILTER_FLAG_RESET_LOCK:
+      obj->info->status = obj->info->status & (~CAP_STS_FILTER_LOCK_OVER);
+      obj->info->socTimeLock = 0;
+      break;
+    case RSOC_FILTER_FLAG_SET_1_STEP:
+      if(obj->info->socTimeStepOverCnt > 0)
+      {
+        obj->info->socTimeStepOverCnt = 1;
+      }
+      break;
+    case RSOC_FILTER_FLAG_SET_1_FULL:
+      if(obj->info->socTimeFullOverCnt > 0)
+      {
+        obj->info->socTimeFullOverCnt = 1;
+      }
+      break;
+  }
+}
+
+
+/**
+ * @brief GetCCRecordFromTable
+ *
+ *  Get CC record array element from NAC table
+ *
+ * @para  obj address of CapacityInternalDataType
+ * @para  idxSov  SOV index
+ * @para  idxCRate C-Rate index
+ * @return  CC Record value
+ */
+_cap_s32_ GetCCRecordFromTable(CapacityInternalDataType *obj, _cap_u8_ idxSov, _cap_u8_ idxCRate)
+{
+  _cap_s32_ valueInterpolate;
+  _cap_s16_ temperature;
+
+  temperature = GetBatteryTemperature(obj);
+
+  if(TemperatureTable[obj->idxTemperature[INDEX_BOUNDARY_HIGH]] ==
+     TemperatureTable[obj->idxTemperature[INDEX_BOUNDARY_LOW]])
+  {
+    valueInterpolate = (_cap_s32_)ptrCellTable->CELL_NAC_TABLE[obj->idxTemperature[INDEX_BOUNDARY_LOW]]
+                                                                     [idxCRate]
+                                                                     [idxSov];
+  }
+  else
+  {
+    valueInterpolate = (_cap_s32_)ptrCellTable->CELL_NAC_TABLE[obj->idxTemperature[INDEX_BOUNDARY_HIGH]]
+                                                                     [idxCRate]
+                                                                     [idxSov];
+    valueInterpolate = valueInterpolate - ptrCellTable->CELL_NAC_TABLE[obj->idxTemperature[INDEX_BOUNDARY_LOW]]
+                                                                     [idxCRate]
+                                                                     [idxSov];
+    valueInterpolate = valueInterpolate*(temperature - TemperatureTable[obj->idxTemperature[INDEX_BOUNDARY_LOW]]);
+    valueInterpolate = valueInterpolate/
+                       (TemperatureTable[obj->idxTemperature[INDEX_BOUNDARY_HIGH]] -
+                        TemperatureTable[obj->idxTemperature[INDEX_BOUNDARY_LOW]]);
+    valueInterpolate = valueInterpolate +
+                       ptrCellTable->CELL_NAC_TABLE[obj->idxTemperature[INDEX_BOUNDARY_LOW]]
+                                                          [idxCRate]
+                                                          [idxSov];
+  }
+  return (valueInterpolate);
+}
+
+/**
+ * @brief InitCCRecord
+ *
+ *  Initialize coulomb counter record from NAC table
+ *
+ * @para  obj address of CapacityInternalDataType
+ * @return  _UPI_NULL_
+ */
+void InitCCRecord(CapacityInternalDataType *obj)
+{
+  _cap_u8_ idxSov;
+  _cap_u8_ idxCRate;
+  _cap_s32_ tmp32;
+  _cap_s32_ valueInterpolate;
+
+  obj->info->ccRecord[0] = 0;
+
+  idxSov = 1;
+  while(idxSov < SOV_NUMS)
+  {
+    tmp32 = 0;
+
+    idxCRate = 0;
+    while(idxCRate < C_RATE_NUMS)
+    {
+      valueInterpolate = GetCCRecordFromTable(obj, idxSov, idxCRate);
+      tmp32 = tmp32 + valueInterpolate;
+
+      idxCRate = idxCRate + 1;
+    }
+
+    tmp32 = tmp32/idxCRate;
+    obj->info->ccRecord[idxSov] = (_cap_s16_)tmp32;
+    obj->info->ccRecord[0] = obj->info->ccRecord[0] + obj->info->ccRecord[idxSov];
+    UG31_LOGD("[%s]: CC Record[%d] = %d (%d)\n", __func__,
+              idxSov, obj->info->ccRecord[idxSov], obj->info->ccRecord[0]);
+
+    idxSov = idxSov + 1;
+  }
+}
+
+
+/**
+ * @brief ResetUpdateNacTableVer2
+ *
+ *  Reset UpdateNacTable buffer for fixed EDV version
+ *
+ * @para  obj address of CapacityInternalDataType
+ * @return  NULL
+ */
+void ResetUpdateNacTableVer2(CapacityInternalDataType *obj)
+{
+  upi_memset((_cap_u8_ *)&obj->info->tableNacUpdate[0], 0, (sizeof(_cap_s16_)*SOV_NUMS));
+}
+
+#define ResetUpdateNacTableVer0     (_UPI_NULL_)
+#define ResetUpdateNacTableVer1     (_UPI_NULL_)
+
+static VerFuncArguObjRtnNull ResetUpdateNacTable[] = {
+  ResetUpdateNacTableVer0,
+  ResetUpdateNacTableVer1,
+  ResetUpdateNacTableVer2,
+  _UPI_NULL_,
+};
+
+
+/// =============================================
+/// Extern region
+/// =============================================
+
+/**
+ * @brief UpiInitCapacity
+ *
+ *  Initial capacity algorithm
+ *
+ * @para  data  address of CapacityDataType
+ * @return  _UPI_NULL_
+ */
+void UpiInitCapacity(CapacityDataType *data)
+{
+  CapacityInternalDataType *obj;
+  _cap_u16_ idx;
+  _cap_u8_ *ptr;
+
+  UG31_LOGI("[%s]: %s\n", __func__, CAPACITY_VERSION);
+
+  /// [AT-PM] : Initialize variables ; 01/25/2013
+  data->status = CAP_STS_LAST_STANDBY | CAP_STS_CURR_STANDBY | CAP_STS_INIT_PROCEDURE | CAP_STS_RELEASE_100;
+  data->status = data->status & (~(CAP_STS_INIT_TIMER_PASS));
+  data->tableUpdateIdx = SOV_NUMS;
+  data->dsgChargeStart = (_cap_s32_)ptrCellParameter->ILMD*2;
+  data->tableUpdateDisqTime = 0;
+  data->standbyDsgRatio = 0;
+  data->standbyMilliSec = 0;
+  data->standbyHour = 0;
+  data->inSuspendMilliSec = 0;
+  data->ccChgOffset25 = 0;
+  data->ccChgOffset50 = 0;
+  data->ccChgOffset75 = 0;
+  data->ccChgOffset100 = 0;
+
+  #ifdef  UG31XX_SHELL_ALGORITHM
+    obj = (CapacityInternalDataType *)upi_malloc(sizeof(CapacityInternalDataType));
+  #else   ///< else of UG31XX_SHELL_ALGORITHM
+    obj = &capData;
+  #endif  ///< end of UG31XX_SHELL_ALGORITHM
+
+  idx = 0;
+  ptr = (_cap_u8_ *)obj;
+  while(idx < sizeof(CapacityInternalDataType))
+  {
+    *(ptr + idx) = 0;
+    idx = idx + 1;
+  }
+
+  obj->info = data;
+  obj->rm = obj->info->rm;
+  obj->fcc = (_cap_u16_)LimitValue((_cap_s32_)obj->info->fcc, (_cap_s32_)ptrCellParameter->ILMD, LIMIT_FCC_WITH_ILMD_RANGE);
+
+  UG31_LOGN("[%s]: Temperature Table: %d / %d / %d / %d\n", __func__,
+            TemperatureTable[0], TemperatureTable[1], TemperatureTable[2], TemperatureTable[3]);
+  UG31_LOGN("[%s]: CRate Table: %d / %d / %d / %d\n", __func__,
+            CRateTable[0], CRateTable[1], CRateTable[2], CRateTable[3]);
+  UG31_LOGN("[%s]: Current status: %d mV / %d mA / %d 0.1oC / %d 0.1oC\n", __func__,
+            ptrMeasData->bat1VoltageAvg, ptrMeasData->currAvg, ptrMeasData->intTemperature, ptrMeasData->extTemperature);
+
+  /// [AT-PM] : Get battery state ; 01/25/2013
+  data->avgVoltage = (_cap_u16_)ptrMeasData->bat1VoltageAvg;
+  data->avgTemperature = GetBatteryTemperature(obj);
+  GetBatteryState(obj);
+  /// [AT-PM] : Release full charge condition ; 01/25/2013
+  FullChargeRelease(obj);
+  /// [AT-PM] : Find out initial capacity ; 01/28/2013
+  InitCharge(obj);
+  data->lastRsoc = data->rsoc;
+  /// [AT-PM] : Initialize record CC array ; 02/19/2013
+  InitCCRecord(obj);
+  /// [AT-PM] : Reset RSOC filter ; 02/07/2014
+  RsocFilterReset(obj, RSOC_FILTER_FLAG_RESET_ALL);
+
+  data->status = data->status & (~CAP_STS_INIT_PROCEDURE);
+  #ifdef  UG31XX_SHELL_ALGORITHM
+    upi_free(obj);
+  #endif  ///< end of UG31XX_SHELL_ALGORITHM
+}
+
+
+/**
+ * @brief UpiTableCapacity
+ *
+ *  Look up capacity from table
+ *
+ * @para  data  address of CapacityDataType
+ * @return  _UPI_NULL_
+ */
+void UpiTableCapacity(CapacityDataType *data)
+{
+  CapacityInternalDataType *obj;
+  _cap_u16_ idx;
+  _cap_u8_ *ptr;
+
+  #ifdef  UG31XX_SHELL_ALGORITHM
+    obj = (CapacityInternalDataType *)upi_malloc(sizeof(CapacityInternalDataType));
+  #else   ///< else of UG31XX_SHELL_ALGORITHM
+    obj = &capData;
+  #endif  ///< end of UG31XX_SHELL_ALGORITHM
+
+  idx = 0;
+  ptr = (_cap_u8_ *)obj;
+  while(idx < sizeof(CapacityInternalDataType))
+  {
+    *(ptr + idx) = 0;
+    idx = idx + 1;
+  }
+
+  obj->info = data;
+  obj->rm = obj->info->rm;
+  obj->fcc = (_cap_u16_)LimitValue((_cap_s32_)obj->info->fcc, (_cap_s32_)ptrCellParameter->ILMD, LIMIT_FCC_WITH_ILMD_RANGE);
+
+  /// [AT-PM] : Find out initial capacity ; 01/28/2013
+  obj->info->status = obj->info->status | (CAP_STS_INIT_PROCEDURE |
+                                           CAP_STS_NO_INIT_FORCE_100);
+  InitCharge(obj);
+  obj->info->status = obj->info->status & (~(CAP_STS_INIT_PROCEDURE |
+                                             CAP_STS_NO_INIT_FORCE_100));
+  #ifdef  UG31XX_SHELL_ALGORITHM
+    upi_free(obj);
+  #endif  ///< end of UG31XX_SHELL_ALGORITHM
+}
+
+/**
+ * @brief UpiInitNacTable
+ *
+ *  Initialize NAC table
+ *
+ * @para  data  address of CapacityDataType
+ * @return  _UPI_NULL_
+ */
+void UpiInitNacTable(CapacityDataType *data)
+{
+  CapacityInternalDataType *obj;
+  _cap_bool_ rtn;
+  _cap_u16_ idx;
+  _cap_u8_ *ptr;
+
+  #ifdef  UG31XX_SHELL_ALGORITHM
+    obj = (CapacityInternalDataType *)upi_malloc(sizeof(CapacityInternalDataType));
+  #else   ///< else of UG31XX_SHELL_ALGORITHM
+    obj = &capData;
+  #endif  ///< end of UG31XX_SHELL_ALGORITHM
+
+  idx = 0;
+  ptr = (_cap_u8_ *)obj;
+  while(idx < sizeof(CapacityInternalDataType))
+  {
+    *(ptr + idx) = 0;
+    idx = idx + 1;
+  }
+
+  obj->info = data;
+
+  idx = 0;
+  while(idx < ENCRIPT_TABLE_SIZE)
+  {
+    data->encriptBuf[idx] = data->encriptTable[idx];
+    idx = idx + 1;
+  }
+
+  /// [AT-PM] : Check data from IC ; 01/31/2013
+  #ifdef  UG31XX_RESET_DATABASE
+    rtn = _UPI_FALSE_;
+  #else   ///< else of UG31XX_RESET_DATABASE
+    rtn = CheckTableAvailable(obj);
+  #endif  ///< end of UG31XX_RESET_DATABASE
+  if(rtn == _UPI_FALSE_)
+  {
+		#ifdef UG31XX_ADJUST_CELL_TABLE
+	    /// [AT-PM] : Encript table from GGB file ; 01/31/2013
+	    if(CapStatusAdjustCellTableGet(data) == _UPI_TRUE_)
+	    {
+	    	upiGG_AdjustCellTable(data);
+				CapStatusAdjustCellTableClear(data);
+	    }
+		#endif  ///< end of UG31XX_ADJUST_CELL_TABLE
+    EncriptTable(obj);
+  }
+  else
+  {
+    /// [AT-PM] : Decript table ; 01/31/2013
+    DecriptTable(obj);
+		#ifdef UG31XX_ADJUST_CELL_TABLE
+	    if(CapStatusAdjustCellTableGet(data) == _UPI_TRUE_)
+	    {
+	    	upiGG_AdjustCellTable(data);
+				CapStatusAdjustCellTableClear(data);
+	    }
+		#endif	///< end of UG31XX_ADJUST_CELL_TABLE
+  }
+  obj->rm = obj->info->rm;
+  obj->fcc = (_cap_u16_)LimitValue((_cap_s32_)obj->info->fcc, (_cap_s32_)ptrCellParameter->ILMD, LIMIT_FCC_WITH_ILMD_RANGE);
+
+  /// [AT-PM] : Prepare NAC table ; 10/25/2013
+  if(PrepareNacTable[GET_CAP_ALGORITHM_VER(ptrCellParameter->NacLmdAdjustCfg)] != _UPI_NULL_)
+  {
+    (*PrepareNacTable[GET_CAP_ALGORITHM_VER(ptrCellParameter->NacLmdAdjustCfg)])(obj);
+  }
+  /// [AT-PM] : Reset update NAC table buffer ; 11/05/2013
+  if(ResetUpdateNacTable[GET_CAP_ALGORITHM_VER(ptrCellParameter->NacLmdAdjustCfg)] != _UPI_NULL_)
+  {
+    (*ResetUpdateNacTable[GET_CAP_ALGORITHM_VER(ptrCellParameter->NacLmdAdjustCfg)])(obj);
+  }
+
+  #ifdef  UG31XX_SHELL_ALGORITHM
+    upi_free(obj);
+  #endif  ///< end of UG31XX_SHELL_ALGORITHM
+}
+
+/**
+ * @brief UpiSetChargerFull
+ *
+ *  Set charger full condition for capacity algorithm
+ *
+ * @para  data  address of CapacityDataType
+ * @para  isFull  set _UPI_TRUE_ for full charge condition
+ * @return  NULL
+ */
+void UpiSetChargerFull(CapacityDataType *data, _cap_bool_ isFull)
+{
+  CapacityInternalDataType *obj;
+
+  #ifdef  UG31XX_SHELL_ALGORITHM
+    obj = (CapacityInternalDataType *)upi_malloc(sizeof(CapacityInternalDataType));
+  #else   ///< else of UG31XX_SHELL_ALGORITHM
+    obj = &capData;
+  #endif  ///< end of UG31XX_SHELL_ALGORITHM
+  obj->info = data;
+  obj->rm = obj->info->rm;
+  obj->fcc = (_cap_u16_)LimitValue((_cap_s32_)obj->info->fcc, (_cap_s32_)ptrCellParameter->ILMD, LIMIT_FCC_WITH_ILMD_RANGE);
+
+  if(isFull == _UPI_FALSE_)
+  {
+    obj->info->status = obj->info->status & (~CAP_STS_CHARGER_FULL);
+  }
+  else
+  {
+    /// [AT-PM] : Set full charge state ; 01/25/2013
+    FullChargeSet(obj);
+
+    obj->info->status = obj->info->status | CAP_STS_CHARGER_FULL;
+    obj->info->rm = obj->rm;
+    obj->info->fcc = obj->fcc;
+    obj->info->rsoc = FULL_CHARGE_RSOC;
+    UG31_LOGD("[%s]: (0x%08x) %d mAh / %d mAh = %d %%\n", __func__,
+              (unsigned int)obj->info->status, obj->info->rm, obj->info->fcc, obj->info->rsoc);
+  }
+
+  #ifdef  UG31XX_SHELL_ALGORITHM
+    upi_free(obj);
+  #endif  ///< end of UG31XX_SHELL_ALGORITHM
+}
+
+/**
+ * @brief UpiSetChargerFullStep
+ *
+ *  Set charger full with stepping RSOC
+ *
+ * @para  data  address of CapacityDataType
+ * @para  orgData original capacity data
+ * @return  NULL
+ */
+void UpiSetChargerFullStep(CapacityDataType *data, GG_BATTERY_INFO *orgData)
+{
+  data->rm = (_cap_u16_)orgData->NAC;
+  data->fcc = (_cap_u16_)orgData->LMD;
+  data->rsoc = (_cap_u8_)orgData->RSOC;
+  CapStatusFCStep100Set(data);
+}
+
+/**
+ * @brief UpiInitDsgCharge
+ *
+ *  Initialize data->dsgCharge value
+ *
+ * @para  data  address of CapacityDataType
+ * @return  _UPI_NULL_
+ */
+void UpiInitDsgCharge(CapacityDataType *data)
+{
+  data->dsgCharge = 0;
+  data->qFromCurr = (_cap_s32_)ptrCellParameter->ILMD;
+  data->qFromCC = 0;
+  data->qFromCurrBuf = 0;
+  data->status = data->status | CAP_STS_DSGCHARGE_INITED;
+  UG31_LOGD("[%s]: Initial discharge charge counter = %d\n", __func__, (int)data->dsgCharge);
+}
+
+
+/**
+ * @brief UpiAdjustCCRecord
+ *
+ *  Adjust CCRecord according to FCC
+ *
+ * @para  data  address of CapacityDataType
+ * @return  NULL
+ */
+void UpiAdjustCCRecord(CapacityDataType *data)
+{
+  _cap_u8_ idxSov;
+  _cap_s16_ residual;
+  _cap_s32_ tmpNewData;
+  _cap_s32_ tmpBuf;
+
+  idxSov = 1;
+  residual = 0;
+  while(idxSov < SOV_NUMS)
+  {
+    tmpBuf = (_cap_s32_)data->ccRecord[idxSov];
+    tmpBuf = tmpBuf*data->fcc*CONST_ROUNDING/data->ccRecord[0] + residual;
+    tmpNewData = tmpBuf/CONST_ROUNDING;
+    UG31_LOGD("[%s]: CCRecord[%d] = %d (%d)\n", __func__, idxSov, (int)tmpNewData, data->ccRecord[idxSov]);
+    data->ccRecord[idxSov] = (_cap_s16_)tmpNewData;
+    residual = (_cap_s16_)(tmpBuf - tmpNewData*CONST_ROUNDING);
+    idxSov = idxSov + 1;
+  }
+  data->ccRecord[0] = data->fcc;
+  UG31_LOGD("[%s]: CCRecord[0] = %d\n", __func__, data->ccRecord[0]);
+}
+
+/**
+ * @brief CalculateRsoc
+ *
+ *  RSOC = RM x 100 / FCC
+ *
+ * @para  rm  remaining capacity
+ * @para  fcc full charged capacity
+ * @return  relative state of charge
+ */
+_cap_u16_ CalculateRsoc(_cap_u32_ rm, _cap_u16_ fcc)
+{
+  _sys_u32_ tmp32;
+
+  if(fcc == 0)
+  {
+    tmp32 = rm*CONST_PERCENTAGE*CONST_ROUNDING;
+    UG31_LOGE("[%s]: FCC = 0. (%d <-> %d)\n", __func__,
+              (int)tmp32,
+              (int)rm);
+  }
+  else
+  {
+    tmp32 = rm*CONST_PERCENTAGE*CONST_ROUNDING/fcc;
+  }
+  tmp32 = tmp32 + CONST_ROUNDING_5;
+  tmp32 = tmp32/CONST_ROUNDING;
+  return ((_cap_u16_)tmp32);
+}
+
+/**
+ * @brief UpiSetBoardOffsetKed
+ *
+ *  Set board offset has been calibrated
+ *
+ * @para  data  address of CapacityDataType
+ * @return  NULL
+ */
+void UpiSetBoardOffsetKed(CapacityDataType *data)
+{
+  data->status = data->status | CAP_STS_BOARD_OFFSET_KED;
+}
+
+/**
+ * @brief UpiSetFactoryBoardOffset
+ *
+ *  Set board offset is loaded from factory
+ *
+ * @para  data  address of CapacityDataType
+ * @return  NULL
+ */
+void UpiSetFactoryBoardOffset(CapacityDataType *data)
+{
+  data->status = data->status | (CAP_STS_NO_STANDBY_CAP_EST |
+                                 CAP_STS_BOARD_OFFSET_KED);
+}
+
+/**
+ * @brief UpiGetOcvSoc
+ *
+ *  Get OCV soc according to current temperature and voltage
+ *
+ * @para  data  address of CapacityDataType
+ * @para  volt  target voltage
+ * @return  SOC from OCV table
+ */
+_cap_u8_ UpiGetOcvSoc(CapacityDataType *data, _cap_u16_ volt)
+{
+  CapacityInternalDataType *obj;
+  _cap_u8_ soc;
+
+  #ifdef  UG31XX_SHELL_ALGORITHM
+    obj = (CapacityInternalDataType *)upi_malloc(sizeof(CapacityInternalDataType));
+  #else   ///< else of UG31XX_SHELL_ALGORITHM
+    obj = &capData;
+  #endif  ///< end of UG31XX_SHELL_ALGORITHM
+
+  upi_memset((_cap_u8_ *)obj, 0, sizeof(CapacityInternalDataType));
+  obj->info = data;
+
+  if(FindIdxTemperature[GET_CAP_ALGORITHM_VER(ptrCellParameter->NacLmdAdjustCfg)] != _UPI_NULL_)
+  {
+    (*FindIdxTemperature[GET_CAP_ALGORITHM_VER(ptrCellParameter->NacLmdAdjustCfg)])(obj, GetBatteryTemperature(obj));
+  }
+
+  FindOcvIdxVoltage(obj, OCV_TABLE_IDX_STAND_ALONE, volt);
+  FindOcvRM(obj, OCV_TABLE_IDX_STAND_ALONE, volt);
+  soc = (_cap_u8_)CalculateRsoc((_cap_u32_)obj->rm, obj->info->fcc);
+  #ifdef  UG31XX_SHELL_ALGORITHM
+    upi_free(obj);
+  #endif  ///< end of UG31XX_SHELL_ALGORITHM
+  return (soc);
+}
+
+
+/**
+ * Copyright @ 2013 uPI Semiconductor Corp. All right reserved.
+ * The information, images, and/or data contained in this material is copyrighted by uPI
+ * Semiconductor Corp., and may not be distributed, modified, reproduced in whole or in part
+ * without the prior, written consent of uPI Semiconductor Corp.
+ */
diff --git a/drivers/power/supply/ASUS_BATTERY/ME176C/ug31xx/uG31xx_API_Capacity.h b/drivers/power/supply/ASUS_BATTERY/ME176C/ug31xx/uG31xx_API_Capacity.h
new file mode 100644
index 000000000000..5a5dfaccf40f
--- /dev/null
+++ b/drivers/power/supply/ASUS_BATTERY/ME176C/ug31xx/uG31xx_API_Capacity.h
@@ -0,0 +1,288 @@
+/**
+ * @filename  uG31xx_API_Capacity.h
+ *
+ *  Header of uG31xx capacity algorithm
+ *
+ * @author  AllenTeng <allen_teng@upi-semi.com>
+ * @revision  $Revision: 648 $
+ */
+
+typedef char            _cap_bool_;
+typedef unsigned char   _cap_u8_;
+typedef signed char     _cap_s8_;
+typedef unsigned short  _cap_u16_;
+typedef signed short    _cap_s16_;
+typedef unsigned int   _cap_u32_;
+typedef signed int     _cap_s32_;
+
+#define CAP_TRUE                (1)
+#define CAP_FALSE               (0)
+
+#define CAP_FC_RELEASE_RSOC     (90)
+#define CAP_FC_NEAR_RSOC        (99)
+#define SOC_LOCK_TIME_STEP      (10000) /// 15 sec
+#define SOC_CHG_LOCK_TIME       (120000) /// 180 sec
+#define SOC_DSG_LOCK_TIME       (120000) /// 120 sec
+
+#define CHARGE_VOLTAGE_CONST      (4)
+
+#define MAX_ENCRIPT_TABLE_SIZE    (128)
+
+typedef struct CapacityDataST {
+
+  _cap_u8_ encriptTable[MAX_ENCRIPT_TABLE_SIZE];
+  /// [FC] : encript backup in order to compare the difference ; 05/30/2013
+  _cap_u8_ encriptBuf[MAX_ENCRIPT_TABLE_SIZE];
+  _cap_u8_ tableSize;
+
+  /// [AT-PM] : Capacity information ; 01/25/2013
+  _cap_u16_ rm;
+  _cap_u16_ fcc;
+  _cap_u16_ fccBackup;
+  _cap_u8_ rsoc;
+  _cap_u8_ predictRsoc;
+  _cap_u8_ tableRsoc;
+  _cap_bool_ fcSts;
+  _cap_bool_ fcStep100;
+  _cap_bool_ inSuspend;
+
+  /// [AT-PM] : Capacity operation variables ; 01/25/2013
+  _cap_u32_ status;
+
+  _cap_u32_ selfDsgMilliSec;
+  _cap_u8_ selfDsgSec;
+  _cap_u8_ selfDsgMin;
+  _cap_u8_ selfDsgHour;
+  _cap_u8_ selfDsgResidual;
+
+  _cap_u32_ standbyDsgResidual;
+  _cap_u8_ standbyDsgRatio;
+  _cap_u32_ standbyMilliSec;
+  _cap_u8_ standbyHour;
+
+  _cap_u8_ lastRsoc;
+
+  _cap_u32_ tpTime;
+
+  _cap_s32_ dsgCharge;
+  _cap_s32_ dsgChargeStart;
+  _cap_u32_ dsgChargeTime;
+  _cap_s32_ preDsgCharge;
+
+  _cap_u8_ tableUpdateIdx;
+  _cap_u32_ tableUpdateDisqTime;
+
+  _cap_s8_ parseRMResidual;
+
+  _cap_s16_ reverseCap;
+  _cap_u8_ avgCRate;
+  _cap_u16_ avgVoltage;
+  _cap_s16_ avgTemperature;
+
+  _cap_s16_ ccRecord[SOV_NUMS];
+  _cap_u8_ chgPredictSOCStep;
+  _cap_u8_ transferStateToChg;
+  _cap_u16_ startChgVolt;
+  _cap_u8_ startChgRsoc;
+  _cap_u8_ ccChgOffset25;
+  _cap_u8_ ccChgOffset50;
+  _cap_u8_ ccChgOffset75;
+  _cap_u8_ ccChgOffset100;
+  _cap_u16_ avgRM;
+  _cap_s16_ lastCVDeltaChgCurr;
+  _cap_u8_ cvCheckCnt;
+
+  _cap_u32_ socTimeStep;
+  _cap_u8_ socTimeStepOverCnt;
+  _cap_u32_ socTimeFull;
+  _cap_u8_ socTimeFullOverCnt;
+  _cap_u32_ socTimeLock;
+  _cap_s32_ socCCStep;
+  _cap_s32_ socCCStepBuf;
+
+  _cap_u8_ rsocFilterActiveCnt;
+
+  _cap_u32_ inSuspendMilliSec;
+
+  _cap_s32_ qFromCurr;
+  _cap_s32_ qFromCC;
+  _cap_s32_ qFromCurrBuf;
+
+  _cap_s16_ tableNac[SOV_NUMS];
+  _cap_s16_ tableNacUpdate[SOV_NUMS];
+} ALIGNED_ATTRIBUTE CapacityDataType;
+
+extern CapacityDataType *ptrCapData;
+
+/**
+ * @brief UpiInitCapacity
+ *
+ *  Initial capacity algorithm
+ *
+ * @para  data  address of CapacityDataType
+ * @return  _UPI_NULL_
+ */
+extern void UpiInitCapacity(CapacityDataType *data);
+
+/**
+ * @brief UpiReadCapacity
+ *
+ *  Read capacity information
+ *
+ * @para  data  address of CapacityDataType
+ * @return  _UPI_NULL_
+ */
+extern void UpiReadCapacity(CapacityDataType *data);
+
+/**
+ * @brief UpiTableCapacity
+ *
+ *  Look up capacity from table
+ *
+ * @para  data  address of CapacityDataType
+ * @return  _UPI_NULL_
+ */
+extern void UpiTableCapacity(CapacityDataType *data);
+
+/**
+ * @brief UpiInitNacTable
+ *
+ *  Initialize NAC table
+ *
+ * @para  data  address of CapacityDataType
+ * @return  _UPI_NULL_
+ */
+extern void UpiInitNacTable(CapacityDataType *data);
+
+/**
+ * @brief UpiSetChargerFull
+ *
+ *  Set charger full condition for capacity algorithm
+ *
+ * @para  data  address of CapacityDataType
+ * @para  isFull  set _UPI_TRUE_ for full charge condition
+ * @return  NULL
+ */
+extern void UpiSetChargerFull(CapacityDataType *data, _cap_bool_ isFull);
+
+/**
+ * @brief UpiSetChargerFullStep
+ *
+ *  Set charger full with stepping RSOC
+ *
+ * @para  data  address of CapacityDataType
+ * @para  orgData address of GG_BATTERY_INFO
+ * @return  NULL
+ */
+extern void UpiSetChargerFullStep(CapacityDataType *data, GG_BATTERY_INFO *orgData);
+
+/**
+ * @brief UpiInitDsgCharge
+ *
+ *  Initialize data->dsgCharge value
+ *
+ * @para  data  address of CapacityDataType
+ * @return  _UPI_NULL_
+ */
+extern void UpiInitDsgCharge(CapacityDataType *data);
+
+/**
+ * @brief UpiAdjustCCRecord
+ *
+ *  Adjust CCRecord according to FCC
+ *
+ * @para  data  address of CapacityDataType
+ * @return  NULL
+ */
+extern void UpiAdjustCCRecord(CapacityDataType *data);
+
+/**
+ * @brief CalculateRsoc
+ *
+ *  RSOC = RM x 100 / FCC
+ *
+ * @para  rm  remaining capacity
+ * @para  fcc full charged capacity
+ * @return  relative state of charge
+ */
+extern _cap_u16_ CalculateRsoc(_cap_u32_ rm, _cap_u16_ fcc);
+
+/**
+ * @brief UpiSetBoardOffsetKed
+ *
+ *  Set board offset has been calibrated
+ *
+ * @para  data  address of CapacityDataType
+ * @return  NULL
+ */
+extern void UpiSetBoardOffsetKed(CapacityDataType *data);
+
+/**
+ * @brief UpiGetCapacityMemorySize
+ *
+ *  Get memory size for capacity module
+ *
+ * @return  memory size
+ */
+extern _cap_u32_ UpiGetCapacityMemorySize(void);
+
+/**
+ * @brief UpiSetFactoryBoardOffset
+ *
+ *  Set board offset is loaded from factory
+ *
+ * @para  data  address of CapacityDataType
+ * @return  NULL
+ */
+extern void UpiSetFactoryBoardOffset(CapacityDataType *data);
+
+/**
+ * @brief UpiPrintCapacityVersion
+ *
+ *  Print capacity module version
+ *
+ * @return  NULL
+ */
+extern void UpiPrintCapacityVersion(void);
+
+/**
+ * @brief UpiGetOcvSoc
+ *
+ *  Get OCV soc according to current temperature and voltage
+ *
+ * @para  data  address of CapacityDataType
+ * @para  volt  target voltage
+ * @return  SOC from OCV table
+ */
+extern _cap_u8_ UpiGetOcvSoc(CapacityDataType *data, _cap_u16_ volt);
+
+/**
+ * @brief CapStatusAdjustCellTableSet
+ *
+ * Set CAP_STS_ADJUST_CELL_TABLE status
+ *
+ * @para data address of data strcture CapacityDataType
+ * @return NULL
+ */
+extern void CapStatusAdjustCellTableSet(CapacityDataType *data);
+
+/**
+ * @brief CapStatusAdjustCellTableClear
+ *
+ * Clear CAP_STS_ADJUST_CELL_TABLE status
+ *
+ * @para data address of data strcture CapacityDataType
+ * @return NULL
+ */
+extern void CapStatusAdjustCellTableClear(CapacityDataType *data);
+
+/**
+ * @brief CapStatusAdjustCellTableGet
+ *
+ * Get CAP_STS_ADJUST_CELL_TABLE status
+ *
+ * @para data address of data strcture CapacityDataType
+ * @return NULL
+ */
+extern _cap_bool_ CapStatusAdjustCellTableGet(CapacityDataType *info);
+
diff --git a/drivers/power/supply/ASUS_BATTERY/ME176C/ug31xx/uG31xx_API_Measurement.c b/drivers/power/supply/ASUS_BATTERY/ME176C/ug31xx/uG31xx_API_Measurement.c
new file mode 100644
index 000000000000..a9bf5fcae8ec
--- /dev/null
+++ b/drivers/power/supply/ASUS_BATTERY/ME176C/ug31xx/uG31xx_API_Measurement.c
@@ -0,0 +1,2567 @@
+/**
+ * Copyright @ 2013 uPI Semiconductor Corp. All right reserved.
+ * The information, images, and/or data contained in this material is copyrighted by uPI
+ * Semiconductor Corp., and may not be distributed, modified, reproduced in whole or in part
+ * without the prior, written consent of uPI Semiconductor Corp.
+ */
+
+/**
+ * @filename  uG31xx_API_Measurement.cpp
+ *
+ *  guG31xx measurement API
+ *
+ * @author  AllenTeng <allen_teng@upi-semi.com>
+ * @revision  $Revision: 107 $
+ */
+
+#include "stdafx.h"     //windows need this??
+#include "uG31xx_API.h"
+
+#ifdef  uG31xx_OS_WINDOWS
+
+  #define MEASUREMENT_VERSION      (_T("Measurement $Rev: 107 $"))
+
+#else   ///< else of uG31xx_OS_WINDOWS
+
+  #define MEASUREMENT_VERSION      ("Measurement $Rev: 107 $")
+
+#endif  ///< end of uG31xx_OS_WINDOWS
+
+//#define MEAS_FAKE_INT_TEMP
+
+#ifdef  MEAS_FAKE_INT_TEMP
+
+  #define MEAS_FAKE_INT_TEMP_OFFSET     (200)
+
+#endif  ///< end of MEAS_FAKE_INT_TEMP
+
+MeasDataType *ptrMeasData = _UPI_NULL_;
+
+typedef struct MeasDataInternalST {
+
+  MeasDataType *info;
+
+  _meas_s16_ adc1CodeT25V100;
+  _meas_s16_ adc1CodeT25V200;
+  _meas_s16_ adc1CodeT80V100;
+  _meas_s16_ adc1CodeT80V200;
+
+  _meas_s16_ adc2CodeT25V100;
+  _meas_s16_ adc2CodeT25V200;
+  _meas_s16_ adc2CodeT80V100;
+  _meas_s16_ adc2CodeT80V200;
+
+  _meas_u32_ currTime;
+
+  _meas_u16_ codeBat1;
+  _meas_s16_ codeCurrent;
+  _meas_u16_ codeIntTemperature;
+  _meas_u16_ codeExtTemperature;
+  _meas_s16_ codeCharge;
+  _meas_u16_ codeCounter;
+  _meas_s16_ ccOffset;
+  _meas_s16_ codeExtTemperatureComp;
+
+  _meas_u16_ codeBat2;
+  _meas_u16_ codeBat3;
+
+  _meas_u8_ reg14;
+  _meas_u8_ reg9C;
+  _meas_u8_ regC5;
+  _meas_u8_ regC6;
+  _meas_u8_ regC7;
+  _meas_u8_ regC8;
+  _meas_u8_ regC9;
+  _meas_u8_ regCA;
+  _meas_u8_ regCB;
+  _meas_u8_ reg0A;
+  _meas_u8_ reg0B;
+  _meas_u8_ reg50;
+  _meas_u8_ reg51;
+  _meas_u8_ reg9B;
+  _meas_u8_ reg9E;
+} ALIGNED_ATTRIBUTE MeasDataInternalType;
+
+#ifndef UG31XX_SHELL_ALGORITHM
+
+static MeasDataInternalType measData;
+
+#endif  ///< end of UG31XX_SHELL_ALGORITHM
+
+typedef struct BoardFactorST {
+  _meas_u16_ voltage_gain;
+  _meas_s16_ voltage_offset;
+  _meas_u16_ current_gain;
+  _meas_s16_ current_offset;
+  _meas_s16_ int_temp_offset;
+  _meas_s16_ ext_temp_offset;
+} ALIGNED_ATTRIBUTE BoardFactorType;
+
+#define BOARD_FACTOR_CONST                  (1000)
+
+static BoardFactorType BoardFactor[] =
+{
+  { 998,  1,  1075, -4, -23,  13  },      ///< uG3105
+  { 998,  3,  1066, 10, -23,  13  },      ///< uG310x
+  { 1000, 0,  1000, 0,  0,    0   },      ///< default
+  { 1000, 0,  1000, 0,  0,    0   },      ///< default
+};
+
+typedef struct AdcDeltaCodeMappingST {
+  _meas_s32_ Adc1V100;
+  _meas_s32_ Adc1V200;
+  _meas_s32_ Adc2V100;
+  _meas_s32_ Adc2V200;
+} ALIGNED_ATTRIBUTE AdcDeltaCodeMappingType;
+
+static AdcDeltaCodeMappingType AdcDeltaCodeMapping[] =
+{
+  { -12800, -25600, 1536,  0    },     ///< Index = 0
+  { -12544, -25088, 1600,  128  },     ///< Index = 1
+  { -13056, -26112, 1472, -128  },     ///< Index = 2
+  { -12288, -24576, 1664,  256  },     ///< Index = 3
+  { -13312, -26624, 1408, -256  },     ///< Index = 4
+  { -12032, -24064, 1728,  384  },     ///< Index = 5
+  { -13568, -27136, 1344, -384  },     ///< Index = 6
+  { -11776, -23552, 1792,  512  },     ///< Index = 7
+  { -13824, -27648, 1280, -512  },     ///< Index = 8
+  { -11520, -23040, 1856,  640  },     ///< Index = 9
+  { -14080, -28160, 1216, -640  },     ///< Index = 10
+  { -11264, -22528, 1920,  768  },     ///< Index = 11
+  { -14336, -28672, 1152, -768  },     ///< Index = 12
+  { -11008, -22016, 1984,  896  },     ///< Index = 13
+  { -14592, -29184, 1088, -896  },     ///< Index = 14
+  { -10752, -21504, 2048,  1024 },     ///< Index = 15
+  { -14848, -29696, 1024, -1024 },     ///< Index = 16
+  { -10496, -20992, 2112,  1152 },     ///< Index = 17
+  { -15104, -30208, 960,  -1152 },     ///< Index = 18
+  { -10240, -20480, 2176,  1280 },     ///< Index = 19
+  { -15360, -30720, 896,  -1280 },     ///< Index = 20
+  { -9984,  -19968, 2240,  1408 },     ///< Index = 21
+  { -15616, -31232, 832,  -1408 },     ///< Index = 22
+  { -9728,  -19456, 2304,  1536 },     ///< Index = 23
+  { -15872, -31744, 768,  -1536 },     ///< Index = 24
+  { -9472,  -18944, 2368,  1664 },     ///< Index = 25
+  { -16128, -32256, 704,  -1664 },     ///< Index = 26
+  { -9216,  -18432, 2432,  1792 },     ///< Index = 27
+  { -16384, -32768, 640,  -1792 },     ///< Index = 28
+  { -8960,  -17920, 2496,  1920 },     ///< Index = 29
+  { -16640, -33280, 576,  -1920 },     ///< Index = 30
+  { 0,      0,      0,     0    },     ///< Index = 31
+};
+
+#ifdef  UG31XX_ADC_NO_TEMP_COMPENSATION
+  #define ADC_TEMPERATURE_GAIN_CONST          (0)
+#else   ///< else of UG31XX_ADC_NO_TEMP_COMPENSATION
+  #define ADC_TEMPERATURE_GAIN_CONST          (1000)
+#endif  ///< end of UG31XX_ADC_NO_TEMP_COMPENSATION
+
+#define ADC1_CODE_100MV_NEGATIVE              (0xFF00)
+#define ADC1_CODE_200MV_NEGATIVE              (0xFE00)
+#define ADC1_CP_CODE_25_100MV                 (12288)
+#define ADC1_CP_CODE_25_200MV                 (24576)
+#define ADC1_DELTA_CODE_25_100MV_SIGN_BIT     (1<<8)
+#define ADC1_DELTA_CODE_25_200MV_SIGN_BIT     (1<<9)
+#define ADC1_TEMPERATURE_GAIN_100MV           (869600)
+#define ADC1_TEMPERATURE_GAIN_200MV           (-695680)
+
+/**
+ * @brief ConvertAdc1Data
+ *
+ *  Convert ADC1 data from OTP
+ *
+ * @para  obj address of MeasDataInternalType
+ * @return  _UPI_NULL_
+ */
+void ConvertAdc1Data(MeasDataInternalType *obj)
+{
+  _meas_u16_ tmp16;
+  _meas_s32_ tmp32;
+
+  /// [AT-PM] : Get code T25 100mV ; 01/23/2013
+  tmp16 = ptrOtpData->adc1DeltaCodeT25V100;
+  if(tmp16 & ADC1_DELTA_CODE_25_100MV_SIGN_BIT)
+  {
+    tmp16 = tmp16 & (~ADC1_DELTA_CODE_25_100MV_SIGN_BIT);
+    if(tmp16 != 0)
+    {
+      tmp16 = tmp16 + ADC1_CODE_100MV_NEGATIVE;
+    }
+  }
+  tmp16 = tmp16 + ADC1_CP_CODE_25_100MV;
+  tmp32 = (_meas_s32_)(_meas_s16_)tmp16;
+  tmp32 = tmp32 + AdcDeltaCodeMapping[ptrOtpData->indexAdc1V100T25].Adc1V100;
+  obj->adc1CodeT25V100 = (_meas_s16_)tmp32;
+	#ifdef	UPI_UBOOT_DEBUG_MSG
+		printf("[ConvertAdc1Data] adc1CodeT25V100 = %d\n", tmp32);
+	#endif	///< end of UPI_UBOOT_DEBUG_MSG
+
+  /// [AT-PM] : Get code T25 200mV ; 01/23/2013
+  tmp16 = ptrOtpData->adc1DeltaCodeT25V200;
+  if(tmp16 & ADC1_DELTA_CODE_25_200MV_SIGN_BIT)
+  {
+    tmp16 = tmp16 & (~ADC1_DELTA_CODE_25_200MV_SIGN_BIT);
+    if(tmp16 != 0)
+    {
+      tmp16 = tmp16 + ADC1_CODE_200MV_NEGATIVE;
+    }
+  }
+  tmp16 = tmp16 + ADC1_CP_CODE_25_200MV;
+  tmp32 = (_meas_s32_)(_meas_s16_)tmp16;
+  tmp32 = tmp32 + AdcDeltaCodeMapping[ptrOtpData->indexAdc1V200T25].Adc1V200;
+  obj->adc1CodeT25V200 = (_meas_s16_)tmp32;
+        #ifdef  UPI_UBOOT_DEBUG_MSG
+                printf("[ConvertAdc1Data] adc1CodeT25V200 = %d\n", tmp32);
+        #endif  ///< end of UPI_UBOOT_DEBUG_MSG
+
+  tmp32 = (_meas_s32_)ptrOtpData->aveIT80;
+  tmp32 = (tmp32 - ptrOtpData->aveIT25)*ADC_TEMPERATURE_GAIN_CONST;
+
+  /// [AT-PM] : Get code T80 100mV ; 01/23/2013
+  obj->adc1CodeT80V100 = (_meas_s16_)(tmp32/ADC1_TEMPERATURE_GAIN_100MV + obj->adc1CodeT25V100);
+        #ifdef  UPI_UBOOT_DEBUG_MSG
+                printf("[ConvertAdc1Data] adc1CodeT80V100 = %d\n", obj->adc1CodeT80V100);
+        #endif  ///< end of UPI_UBOOT_DEBUG_MSG
+
+  /// [AT-PM] : Get code T80 200mV ; 01/23/2013
+  obj->adc1CodeT80V200 = (_meas_s16_)(tmp32/ADC1_TEMPERATURE_GAIN_200MV + obj->adc1CodeT25V200);
+        #ifdef  UPI_UBOOT_DEBUG_MSG
+                printf("[ConvertAdc1Data] adc1CodeT80V200 = %d\n", obj->adc1CodeT80V200);
+        #endif  ///< end of UPI_UBOOT_DEBUG_MSG
+}
+
+#define ADC2_CODE_100MV_NEGATIVE              (0xFFC0)
+#define ADC2_CODE_200MV_NEGATIVE              (0xFF80)
+#define ADC2_CP_CODE_25_100MV                 (3072)
+#define ADC2_CP_CODE_25_200MV                 (6144)
+#define ADC2_DELTA_CODE_25_100MV_SIGN_BIT     (1<<6)
+#define ADC2_DELTA_CODE_25_200MV_SIGN_BIT     (1<<7)
+#define ADC2_TEMPERATURE_GAIN_100MV           (-149130)
+#define ADC2_TEMPERATURE_GAIN_200MV           (-136937)
+
+/**
+ * @brief ConvertAdc2Data
+ *
+ *  Convert ADC2 data from OTP
+ *
+ * @para  obj address of MeasDataInternalType
+ * @return  _UPI_NULL_
+ */
+void ConvertAdc2Data(MeasDataInternalType *obj)
+{
+  _meas_u16_ tmp16;
+  _meas_s32_ tmp32;
+
+  /// [AT-PM] : Get code T25 100mV ; 01/23/2013
+  tmp16 = ptrOtpData->adc2DeltaCodeT25V100;
+  if(tmp16 & ADC2_DELTA_CODE_25_100MV_SIGN_BIT)
+  {
+    tmp16 = tmp16 & (~ADC2_DELTA_CODE_25_100MV_SIGN_BIT);
+    tmp16 = tmp16 + ADC2_CODE_100MV_NEGATIVE;
+  }
+  tmp16 = tmp16 + ADC2_CP_CODE_25_100MV;
+  tmp32 = (_meas_s32_)(_meas_s16_)tmp16;
+  tmp32 = tmp32 + AdcDeltaCodeMapping[ptrOtpData->indexAdc2V100T25].Adc2V100;
+  obj->adc2CodeT25V100 = (_meas_s16_)tmp32;
+        #ifdef  UPI_UBOOT_DEBUG_MSG
+                printf("[ConvertAdc2Data] adc2CodeT25V100 = %d\n", tmp32);
+        #endif  ///< end of UPI_UBOOT_DEBUG_MSG
+
+  /// [AT-PM] : Get code T25 200mV ; 01/23/2013
+  tmp16 = ptrOtpData->adc2DeltaCodeT25V200;
+  if(tmp16 & ADC2_DELTA_CODE_25_200MV_SIGN_BIT)
+  {
+    tmp16 = tmp16 & (~ADC2_DELTA_CODE_25_200MV_SIGN_BIT);
+    tmp16 = tmp16 + ADC2_CODE_200MV_NEGATIVE;
+  }
+  tmp16 = tmp16 + ADC2_CP_CODE_25_200MV;
+  tmp32 = (_meas_s32_)(_meas_s16_)tmp16;
+  tmp32 = tmp32 + AdcDeltaCodeMapping[ptrOtpData->indexAdc2V200T25].Adc2V200;
+  obj->adc2CodeT25V200 = (_meas_s16_)tmp32;
+        #ifdef  UPI_UBOOT_DEBUG_MSG
+                printf("[ConvertAdc2Data] adc2CodeT25V200 = %d\n", tmp32);
+        #endif  ///< end of UPI_UBOOT_DEBUG_MSG
+
+  tmp32 = (_meas_s32_)ptrOtpData->aveIT80;
+  tmp32 = (tmp32 - ptrOtpData->aveIT25)*ADC_TEMPERATURE_GAIN_CONST;
+
+  /// [AT-PM] : Get code T80 100mV ; 01/23/2013
+  obj->adc2CodeT80V100 = (_meas_s16_)(tmp32/ADC2_TEMPERATURE_GAIN_100MV + obj->adc2CodeT25V100);
+        #ifdef  UPI_UBOOT_DEBUG_MSG
+                printf("[ConvertAdc2Data] adc2CodeT80V100 = %d\n", obj->adc2CodeT80V100);
+        #endif  ///< end of UPI_UBOOT_DEBUG_MSG
+
+  /// [AT-PM] : Get code T80 200mV ; 01/23/2013
+  obj->adc2CodeT80V200 = (_meas_s16_)(tmp32/ADC2_TEMPERATURE_GAIN_200MV + obj->adc2CodeT25V200);
+        #ifdef  UPI_UBOOT_DEBUG_MSG
+                printf("[ConvertAdc2Data] adc2CodeT80V200 = %d\n", obj->adc2CodeT80V200);
+        #endif  ///< end of UPI_UBOOT_DEBUG_MSG
+}
+
+/**
+ * @brief CalAdc1Factors
+ *
+ *  Calculate ADC1 gain slope and factor B
+ *  Calculate ADC1 offset slope and factor O
+ *
+ * @para  obj address of MeasDataInternalType
+ * @return  _UPI_NULL_
+ */
+void CalAdc1Factors(MeasDataInternalType *obj)
+{
+  _meas_s32_ delta25;
+  _meas_s32_ delta80;
+  _meas_s64_ tmp64;
+
+  /// [AT-PM] : Calculate gain slope and factor B ; 01/23/2013
+  delta25 = (_meas_s32_)obj->adc1CodeT25V200;
+  delta25 = delta25 - obj->adc1CodeT25V100;
+  delta80 = (_meas_s32_)obj->adc1CodeT80V200;
+  delta80 = delta80 - obj->adc1CodeT80V100;
+
+  obj->info->adc1GainSlope = delta80 - delta25;
+  obj->info->adc1GainFactorB = delta25*(ptrOtpData->aveIT80) - delta80*(ptrOtpData->aveIT25);
+        #ifdef  UPI_UBOOT_DEBUG_MSG
+                printf("[CalAdc1Factors] adc1GainSlope / adc1GainFactorB  = %d / %d\n", obj->info->adc1GainSlope, obj->info->adc1GainFactorB);
+        #endif  ///< end of UPI_UBOOT_DEBUG_MSG
+
+  /// [AT-PM] : Calculate offset slope and factor O ; 01/23/2013
+  delta25 = (_meas_s32_)obj->adc1CodeT25V100;
+  delta25 = delta25*2 - obj->adc1CodeT25V200;
+  delta80 = (_meas_s32_)obj->adc1CodeT80V100;
+  delta80 = delta80*2 - obj->adc1CodeT80V200;
+
+  obj->info->adc1OffsetSlope = delta80 - delta25;
+  obj->info->adc1OffsetFactorO = delta25*(ptrOtpData->aveIT80) - delta80*(ptrOtpData->aveIT25);
+        #ifdef  UPI_UBOOT_DEBUG_MSG
+		printf("[CalAdc1Factors] adc1OffsetSlope / adc1OffsetFactorO = %d / %d\n", obj->info->adc1OffsetSlope, obj->info->adc1OffsetFactorO);
+        #endif  ///< end of UPI_UBOOT_DEBUG_MSG
+
+  /// [AT-PM] : Calculate current ADC1 gain ; 01/23/2013
+  tmp64 = (_meas_s64_)obj->info->adc1GainSlope;
+  tmp64 = tmp64*(obj->info->filterIntTemperature) + obj->info->adc1GainFactorB;
+  obj->info->adc1Gain = (_meas_s32_)tmp64;
+
+  /// [AT-PM] : Calculate current ADC1 offset ; 01/23/2013
+  tmp64 = (_meas_s64_)obj->info->adc1OffsetSlope;
+  tmp64 = tmp64*(obj->info->filterIntTemperature) + obj->info->adc1OffsetFactorO;
+  obj->info->adc1Offset = (_meas_s32_)tmp64;
+	#ifdef	UPI_UBOOT_DEBUG_MSG
+		printf("[CalAdc1Factors] adc1Gain / adc1Offset = %d / %d\n", obj->info->adc1Gain, obj->info->adc1Offset);
+	#endif	///< end of UPI_UBOOT_DEBUG_MSG
+}
+
+/**
+ * @brief CalAdc2Factors
+ *
+ *  Calculate ADC2 gain slope and factor B
+ *  Calculate ADC2 offset slope and factor O
+ *
+ * @para  obj address of MeasDataInternalType
+ * @return  _UPI_NULL_
+ */
+void CalAdc2Factors(MeasDataInternalType *obj)
+{
+  _meas_s32_ delta25;
+  _meas_s32_ delta80;
+  _meas_s64_ tmp64;
+
+  /// [AT-PM] : Calculate gain slope and factor B ; 01/23/2013
+  delta25 = (_meas_s32_)obj->adc2CodeT25V200;
+  delta25 = delta25 - obj->adc2CodeT25V100;
+  delta80 = (_meas_s32_)obj->adc2CodeT80V200;
+  delta80 = delta80 - obj->adc2CodeT80V100;
+
+  obj->info->adc2GainSlope = delta80 - delta25;
+  obj->info->adc2GainFactorB = delta25*(ptrOtpData->aveIT80) - delta80*(ptrOtpData->aveIT25);
+	#ifdef	UPI_UBOOT_DEBUG_MSG
+		printf("[CalAdc2Factors] adc2GainSlope / adc2GainFactorB = %d / %d\n", obj->info->adc2GainSlope, obj->info->adc2GainFactorB);
+	#endif	///< end of UPI_UBOOT_DEBUG_MSG
+
+  /// [AT-PM] : Calculate offset slope and factor O ; 01/23/2013
+  delta25 = (_meas_s32_)obj->adc2CodeT25V100;
+  delta25 = delta25*2 - obj->adc2CodeT25V200;
+  delta80 = (_meas_s32_)obj->adc2CodeT80V100;
+  delta80 = delta80*2 - obj->adc2CodeT80V200;
+
+  obj->info->adc2OffsetSlope = delta80 - delta25;
+  obj->info->adc2OffsetFactorO = delta25*(ptrOtpData->aveIT80) - delta80*(ptrOtpData->aveIT25);
+        #ifdef  UPI_UBOOT_DEBUG_MSG
+                printf("[CalAdc2Factors] adc2OffsetSlope / adc2OffsetFactorO = %d / %d\n", obj->info->adc2OffsetSlope, obj->info->adc2OffsetFactorO);
+        #endif  ///< end of UPI_UBOOT_DEBUG_MSG
+
+  /// [AT-PM] : Calculate current ADC1 gain ; 01/23/2013
+  tmp64 = (_meas_s64_)obj->info->adc2GainSlope;
+  tmp64 = tmp64*(obj->info->filterIntTemperature) + obj->info->adc2GainFactorB;
+  obj->info->adc2Gain = (_meas_s32_)tmp64;
+
+  /// [AT-PM] : Calculate current ADC1 offset ; 01/23/2013
+  tmp64 = (_meas_s64_)obj->info->adc2OffsetSlope;
+  tmp64 = tmp64*(obj->info->filterIntTemperature) + obj->info->adc2OffsetFactorO;
+  obj->info->adc2Offset = (_meas_s32_)tmp64;
+        #ifdef  UPI_UBOOT_DEBUG_MSG
+                printf("[CalAdc2Factors] adc2Gain / adc2Offset = %d / %d\n", obj->info->adc2Gain, obj->info->adc2Offset);
+        #endif  ///< end of UPI_UBOOT_DEBUG_MSG
+}
+
+#define ADC1_IDEAL_CODE_100MV     (614)
+#define ADC1_IDEAL_CODE_200MV     (1229)
+#define ADC1_IDEAL_CODE_DELTA     (ADC1_IDEAL_CODE_200MV - ADC1_IDEAL_CODE_100MV)
+
+/**
+ * @brief CalibrateAdc1Code
+ *
+ *  Calibrate ADC1 code
+ *
+ * @para  obj address of MeasDataInternalType
+ * @para  code  ADC1 code to be calibrated
+ * @return  calibrated code
+ */
+_meas_s32_ CalibrateAdc1Code(MeasDataInternalType *obj, _meas_s32_ code)
+{
+  _meas_s64_ tmp64;
+  _meas_s32_ tmp32;
+  _meas_s32_ deltaIT;
+  _meas_s32_ gain;
+  _meas_s32_ offset;
+
+  deltaIT = (_meas_s32_)ptrOtpData->aveIT80;
+  deltaIT = deltaIT - ptrOtpData->aveIT25;
+
+  /// [AT-PM] : Pre-operation to avoid 64-bit division ; 01/23/2013
+  gain = obj->info->adc1Gain;
+  offset = obj->info->adc1Offset;
+  while(1)
+  {
+    tmp64 = (_meas_s64_)code;
+    tmp64 = tmp64*deltaIT - offset;
+    tmp64 = tmp64*ADC1_IDEAL_CODE_DELTA;
+    if((tmp64 < 2147483647) && (tmp64 > -2147483647))
+    {
+      break;
+    }
+    code = code/2;
+    deltaIT = deltaIT/2;
+    gain = gain/4;
+    offset = offset/4;
+  }
+
+  tmp32 = (_meas_s32_)tmp64;
+  tmp32 = tmp32/gain;
+	#ifdef	UPI_UBOOT_DEBUG_MSG
+		printf("[CalibrateAdc1Code] %d -> %d\n", code, tmp32);
+	#endif	///< end of UPI_UBOOT_DEBUG_MSG
+  return (tmp32);
+}
+
+#define ADC2_IDEAL_CODE_100MV     (ADC2_CP_CODE_25_100MV)
+#define ADC2_IDEAL_CODE_200MV     (ADC2_CP_CODE_25_200MV)
+#define ADC2_IDEAL_CODE_DELTA     (ADC2_IDEAL_CODE_200MV - ADC2_IDEAL_CODE_100MV)
+
+/**
+ * @brief CalibrateAdc2Code
+ *
+ *  Calibrate ADC2 code
+ *
+ * @para  obj address of MeasDataInternalType
+ * @para  code  ADC2 code to be calibrated
+ * @return  calibrated code
+ */
+_meas_s32_ CalibrateAdc2Code(MeasDataInternalType *obj, _meas_s32_ code, _meas_s32_ gain, _meas_s32_ offset)
+{
+  _meas_s64_ tmp64;
+  _meas_s32_ tmp32;
+  _meas_s32_ deltaIT;
+  deltaIT = (_meas_s32_)ptrOtpData->aveIT80;
+  deltaIT = deltaIT - ptrOtpData->aveIT25;
+
+  /// [AT-PM] : Pre-operation to avoid 64-bit division ; 01/23/2013
+  while(1)
+  {
+    tmp64 = (_meas_s64_)code;
+    tmp64 = tmp64*deltaIT - offset;
+    tmp64 = tmp64*ADC2_IDEAL_CODE_DELTA;
+    if((tmp64 < 2147483647) && (tmp64 > -2147483647))
+    {
+      break;
+    }
+    code = code/2;
+    deltaIT = deltaIT/2;
+    gain = gain/4;
+    offset = offset/4;
+  }
+
+  tmp32 = (_meas_s32_)tmp64;
+  tmp32 = tmp32/gain;
+        #ifdef  UPI_UBOOT_DEBUG_MSG
+                printf("[CalibrateAdc2Code] %d -> %d\n", code, tmp32);
+        #endif  ///< end of UPI_UBOOT_DEBUG_MSG
+  return (tmp32);
+}
+
+#define IT_IDEAL_CODE_DELTA   (IT_IDEAL_CODE_80 - IT_IDEAL_CODE_25)
+
+/**
+ * @brief CalibrateITCode
+ *
+ *  Calibrate internal temperature code
+ *
+ * @para  obj address of MeasDataInternalType
+ * @para  itCode  raw IT code
+ * @return  calibrated IT code
+ */
+_meas_u16_ CalibrateITCode(MeasDataInternalType *obj, _meas_u16_ itCode)
+{
+  _meas_s32_ tmp32;
+
+  tmp32 = (_meas_s32_)itCode;
+  tmp32 = tmp32 - ptrOtpData->aveIT25;
+  tmp32 = tmp32*IT_IDEAL_CODE_DELTA;
+  tmp32 = tmp32/(ptrOtpData->aveIT80 - ptrOtpData->aveIT25);
+  tmp32 = tmp32 + IT_IDEAL_CODE_25;
+  return ((_meas_u16_)tmp32);
+}
+
+#define NORMAL_REGISTER     (NORMAL)
+#define SEURITY_REGISTER    (SECURITY)
+
+/**
+ * @brief CalibrateChargeCode
+ *
+ *  Calibrate charge code
+ *
+ * @para  obj address of MeasDataInternalType
+ * @return  _UPI_NULL_
+ */
+void CalibrateChargeCode(MeasDataInternalType *obj)
+{
+  _meas_s32_ tmp32;
+  _meas_s64_ tmp64;
+  _meas_s32_ gain;
+  _meas_s32_ offset;
+
+  UG31_LOGN("[%s]: Raw Code = %d\n", __func__, obj->codeCharge);
+  #ifdef	UPI_UBOOT_DEBUG_MSG
+    printf("[CalibrateChargeCode]: Raw Code = %d\n", obj->codeCharge);
+  #endif	///< end of UPI_UBOOT_DEBUG_MSG
+
+  /// [AT-PM] : Calibrate charge code ; 01/23/2013
+  obj->info->codeCharge = CalibrateAdc1Code(obj, ((_meas_s32_)obj->codeCharge)*2);
+
+  /// [AT-PM] : Remove the offset in calibrated charge code ; 01/23/2013
+  gain = obj->info->adc1Gain;
+  offset = obj->info->adc1Offset;
+  while(1)
+  {
+    tmp64 = (_meas_s64_)offset;
+    tmp64 = tmp64*ADC1_IDEAL_CODE_DELTA;
+    if((tmp64 < 2147483647) && (tmp64 > -2147483647))
+    {
+      break;
+    }
+    gain = gain/2;
+    offset = offset/2;
+  }
+  tmp32 = (_meas_s32_)tmp64;
+  tmp32 = tmp32/gain;
+  UG31_LOGN("[%s]: Compensation = %d x %d / %d\n", __func__,
+            (int)obj->info->adc1Offset, ADC1_IDEAL_CODE_DELTA, (int)obj->info->adc1Gain);
+  #ifdef	UPI_UBOOT_DEBUG_MSG
+    printf("[CalibrateChargeCode]: Compensation = %d x %d / %d\n", obj->info->adc1Offset, ADC1_IDEAL_CODE_DELTA, obj->info->adc1Gain);
+  #endif	///< end of UPI_UBOOT_DEBUG_MSG
+  obj->info->codeCharge = obj->info->codeCharge + tmp32;
+  UG31_LOGI("[%s]: Charge = %d\n", __func__, (int)obj->info->codeCharge);
+  #ifdef	UPI_UBOOT_DEBUG_MSG
+    printf("[CalibrateChargeCode]: Charge = %d\n", obj->info->codeCharge);
+  #endif	///< end of UPI_UBOOT_DEBUG_MSG
+}
+
+#define ADC2_VOLTAGE_100MV    (3000)                                    ///< [AT-PM] : Unit in mV ; 01/25/2013
+#define ADC2_VOLTAGE_200MV    (4000)                                    ///< [AT-PM] : Unit in mV ; 01/25/2013
+#define ADC2_VOLTAGE_DELTA    (ADC2_VOLTAGE_200MV - ADC2_VOLTAGE_100MV)
+
+/**
+ * @brief ConvertBat1
+ *
+ *  Convert code of BAT1
+ *
+ * @para  obj address of MeasDataInternalType
+ * @return  _UPI_NULL_
+ */
+void ConvertBat1(MeasDataInternalType *obj)
+{
+  _meas_s32_ tmp32;
+
+  /// [AT-PM] : Convert from calibrated ADC code ; 01/25/2013
+  tmp32 = (_meas_s32_)obj->info->codeBat1;
+  tmp32 = tmp32 - ADC2_IDEAL_CODE_100MV;
+  tmp32 = tmp32*ADC2_VOLTAGE_DELTA/ADC2_IDEAL_CODE_DELTA;
+  tmp32 = tmp32 + ADC2_VOLTAGE_100MV;
+
+  /// [AT-PM] : Apply board factor ; 01/25/2013
+  tmp32 = tmp32 - BoardFactor[GET_PRODUCT_TYPE(ptrCellParameter->NacLmdAdjustCfg)].voltage_offset;
+  tmp32 = tmp32*BOARD_FACTOR_CONST/BoardFactor[GET_PRODUCT_TYPE(ptrCellParameter->NacLmdAdjustCfg)].voltage_gain;
+
+  /// [AT-PM] : Apply calibration parameter ; 01/25/2013
+  tmp32 = tmp32 - ptrCellParameter->adc2_offset;
+  tmp32 = tmp32*CALIBRATION_FACTOR_CONST/ptrCellParameter->adc2_gain;
+  obj->info->bat1Voltage = (_meas_u16_)tmp32;
+}
+
+/**
+ * @brief ConvertBat2
+ *
+ *  Convert code of BAT2
+ *
+ * @para  obj address of MeasDataInternalType
+ * @return  _UPI_NULL_
+ */
+void ConvertBat2(MeasDataInternalType *obj)
+{
+  _meas_s32_ tmp32;
+
+  /// [AT-PM] : Convert from calibrated ADC code ; 01/25/2013
+  tmp32 = (_meas_s32_)obj->info->codeBat2;
+  tmp32 = tmp32 - ADC2_IDEAL_CODE_100MV;
+  tmp32 = tmp32*ADC2_VOLTAGE_DELTA/ADC2_IDEAL_CODE_DELTA;
+  tmp32 = tmp32 + ADC2_VOLTAGE_100MV;
+
+  /// [AT-PM] : Apply board factor ; 01/25/2013
+  tmp32 = tmp32 - BoardFactor[GET_PRODUCT_TYPE(ptrCellParameter->NacLmdAdjustCfg)].voltage_offset;
+  tmp32 = tmp32*BOARD_FACTOR_CONST/BoardFactor[GET_PRODUCT_TYPE(ptrCellParameter->NacLmdAdjustCfg)].voltage_gain;
+
+/// [RY] : add check the vbat2 gain
+  if(ptrCellParameter->vbat2_gain <= 0)
+  {
+    obj->info->bat2Voltage = 0;
+  }
+  else
+  {
+    /// [AT-PM] : Apply calibration parameter ; 01/25/2013
+    tmp32 = tmp32 - ptrCellParameter->vbat2_offset;
+    tmp32 = (tmp32*CALIBRATION_FACTOR_CONST)/ptrCellParameter->vbat2_gain;
+    obj->info->bat2Voltage = (_meas_u16_)tmp32*2;
+  }
+}
+
+/**
+ * @brief ConvertBat2
+ *
+ *  Convert code of BAT2
+ *
+ * @para  obj address of MeasDataInternalType
+ * @return  _UPI_NULL_
+ */
+void ConvertBat3(MeasDataInternalType *obj)
+{
+  _meas_s32_ tmp32;
+
+  /// [AT-PM] : Convert from calibrated ADC code ; 01/25/2013
+  tmp32 = (_meas_s32_)obj->info->codeBat3;
+  tmp32 = tmp32 - ADC2_IDEAL_CODE_100MV;
+  tmp32 = tmp32*ADC2_VOLTAGE_DELTA/ADC2_IDEAL_CODE_DELTA;
+  tmp32 = tmp32 + ADC2_VOLTAGE_100MV;
+
+  /// [AT-PM] : Apply board factor ; 01/25/2013
+  tmp32 = tmp32 - BoardFactor[GET_PRODUCT_TYPE(ptrCellParameter->NacLmdAdjustCfg)].voltage_offset;
+  tmp32 = tmp32*BOARD_FACTOR_CONST/BoardFactor[GET_PRODUCT_TYPE(ptrCellParameter->NacLmdAdjustCfg)].voltage_gain;
+
+  /// [RY] : add check the vbat2 gain
+  if(ptrCellParameter->vbat3_gain <= 0)
+  {
+    obj->info->bat3Voltage = 0;
+  }
+  else
+  {
+    /// [AT-PM] : Apply calibration parameter ; 01/25/2013
+    tmp32 = tmp32 - ptrCellParameter->vbat3_offset;
+    tmp32 = (tmp32*CALIBRATION_FACTOR_CONST)/ptrCellParameter->vbat3_gain;
+    obj->info->bat3Voltage = (_meas_u16_)tmp32*3;
+  }
+}
+
+#define ADC1_VOLTAGE_100MV    (-5000)                                   ///< [AT-PM] : Unit in uV ; 01/25/2013
+#define ADC1_VOLTAGE_200MV    (-10000)                                  ///< [AT-PM] : Unit in uV ; 01/25/2013
+#define ADC1_VOLTAGE_DELTA    (ADC1_VOLTAGE_200MV - ADC1_VOLTAGE_100MV)
+/**
+ * @brief ConvertCurrent
+ *
+ *  Convert code of Current
+ *
+ * @para  obj address of MeasDataInternalType
+ * @return  _UPI_NULL_
+ */
+void ConvertCurrent(MeasDataInternalType *obj)
+{
+  _meas_s32_ tmp32;
+
+  /// [AT-PM] : Convert from calibrated ADC code ; 01/25/2013
+  tmp32 = (_meas_s32_)obj->info->codeCurrent;
+  tmp32 = tmp32 - ADC1_IDEAL_CODE_100MV;
+  tmp32 = tmp32*ADC1_VOLTAGE_DELTA/ADC1_IDEAL_CODE_DELTA;
+  tmp32 = tmp32 + ADC1_VOLTAGE_100MV;
+  tmp32 = tmp32/ptrCellParameter->rSense;
+
+  /// [AT-PM] : Apply board factor ; 01/25/2013
+  tmp32 = tmp32 - BoardFactor[GET_PRODUCT_TYPE(ptrCellParameter->NacLmdAdjustCfg)].current_offset;
+  tmp32 = tmp32*BOARD_FACTOR_CONST/BoardFactor[GET_PRODUCT_TYPE(ptrCellParameter->NacLmdAdjustCfg)].current_gain;
+
+  /// [AT-PM] : Apply calibration factor ; 01/25/2013
+  tmp32 = tmp32 - ptrCellParameter->adc1_pos_offset - obj->info->ccOffsetAdj;
+  if(tmp32 > 0)
+  {
+    tmp32 = tmp32*CALIBRATION_FACTOR_CONST/ptrCellParameter->adc1_pgain;
+  }
+  else
+  {
+    tmp32 = tmp32*CALIBRATION_FACTOR_CONST/ptrCellParameter->adc1_ngain;
+  }
+  obj->info->curr = (_meas_s16_)tmp32;
+  if(MEAS_REVERSE_CURRENT_DIRECTION(obj->info->status) == _UPI_TRUE_)
+  {
+    obj->info->curr = obj->info->curr*(-1);
+  }
+
+  if((MEAS_CABLE_OUT(obj->info->status) == _UPI_TRUE_) && (obj->info->curr > 0))
+  {
+    obj->info->curr = 0;
+  }
+}
+
+#define AMBIENT_TEMPERATURE_IN_FT (220)
+#define IT_CONST                  (100)
+#define IT_GAIN                   (392)
+#define IT_OFFSET                 (11172)
+
+static _meas_s16_ FTAmbientMappingTable[] =
+{
+  AMBIENT_TEMPERATURE_IN_FT,            ///< Index = 0
+  AMBIENT_TEMPERATURE_IN_FT + 10,       ///< Index = 1
+  AMBIENT_TEMPERATURE_IN_FT - 10,       ///< Index = 2
+  AMBIENT_TEMPERATURE_IN_FT + 20,       ///< Index = 3
+  AMBIENT_TEMPERATURE_IN_FT - 20,       ///< Index = 4
+  AMBIENT_TEMPERATURE_IN_FT + 30,       ///< Index = 5
+  AMBIENT_TEMPERATURE_IN_FT - 30,       ///< Index = 6
+  AMBIENT_TEMPERATURE_IN_FT + 40,       ///< Index = 7
+  AMBIENT_TEMPERATURE_IN_FT - 40,       ///< Index = 8
+  AMBIENT_TEMPERATURE_IN_FT + 50,       ///< Index = 9
+  AMBIENT_TEMPERATURE_IN_FT - 50,       ///< Index = 10
+  AMBIENT_TEMPERATURE_IN_FT + 60,       ///< Index = 11
+  AMBIENT_TEMPERATURE_IN_FT - 60,       ///< Index = 12
+  AMBIENT_TEMPERATURE_IN_FT + 70,       ///< Index = 13
+  AMBIENT_TEMPERATURE_IN_FT - 70,       ///< Index = 14
+  AMBIENT_TEMPERATURE_IN_FT,            ///< Index = 15
+};
+
+/**
+ * @brief ConvertIntTemperature
+ *
+ *  Convert code of internal temperature
+ *
+ * @para  obj address of MeasDataInternalType
+ * @return  _UPI_NULL_
+ */
+void ConvertIntTemperature(MeasDataInternalType *obj)
+{
+  _meas_s32_ tmp32;
+  _meas_s32_ ftIT;
+
+  /// [AT-PM] : Convert from calibrated ADC code ; 01/25/2013
+  tmp32 = (_meas_s32_)obj->info->codeIntTemperature;
+  tmp32 = tmp32/2;
+  tmp32 = tmp32 - IT_OFFSET;
+  tmp32 = tmp32*IT_CONST/IT_GAIN;
+
+  /// [AT-PM] : Apply FT information ; 01/25/2013
+  ftIT = (_meas_s32_)CalibrateITCode(obj, ptrOtpData->ftIT);
+  ftIT = ftIT/2;
+  ftIT = ftIT - IT_OFFSET;
+  ftIT = ftIT*IT_CONST/IT_GAIN;
+  tmp32 = tmp32 - (ftIT - FTAmbientMappingTable[ptrOtpData->deltaET]);
+
+  /// [AT-PM] : Apply board factor ; 01/25/2013
+  tmp32 = tmp32 - BoardFactor[GET_PRODUCT_TYPE(ptrCellParameter->NacLmdAdjustCfg)].int_temp_offset;
+
+  /// [AT-PM] : Apply calibration factor ; 01/25/2013
+  tmp32 = tmp32 - ptrCellParameter->adc_d5;
+  obj->info->intTemperature = (_meas_s16_)tmp32;
+}
+
+static _meas_s16_ ExtTemperatureTable[] = {
+  -100,       ///< Index = 0
+  -50,        ///< Index = 1
+  0,          ///< Index = 2
+  50,         ///< Index = 3
+  100,        ///< Index = 4
+  150,        ///< Index = 5
+  200,        ///< Index = 6
+  250,        ///< Index = 7
+  300,        ///< Index = 8
+  350,        ///< Index = 9
+  400,        ///< Index = 10
+  450,        ///< Index = 11
+  500,        ///< Index = 12
+  550,        ///< Index = 13
+  600,        ///< Index = 14
+  650,        ///< Index = 15
+  700,        ///< Index = 16
+  750,        ///< Index = 17
+  800,        ///< Index = 18
+};
+
+/**
+ * @brief ConvertExtTemperature
+ *
+ *  Convert code of external temperature
+ *
+ * @para  obj address of MeasDataInternalType
+ * @return  _UPI_NULL_
+ */
+void ConvertExtTemperature(MeasDataInternalType *obj)
+{
+  _meas_u8_ idx;
+  _meas_s32_ tmp32;
+  _meas_s16_ tmp16;
+
+  /// [AT-PM] : Get adc code of voltage divider ; 11/01/2013
+  tmp16 = (_meas_s16_)ptrCellParameter->adc_d3;
+  tmp16 = tmp16 - obj->codeExtTemperatureComp - obj->info->codeExtTemperature;
+  UG31_LOGN("[%s]: Voltage divider = %d\n", __func__, tmp16);
+  if(tmp16 <= 0)
+  {
+    UG31_LOGE("[%s]: Limit the minimum of voltage divider to 1 from %d\n", __func__,
+              tmp16);
+    tmp16 = 1;
+  }
+
+  /// [AT-PM] : Calculate NTC resistance ; 11/01/2013
+  tmp32 = (_meas_s32_)obj->info->codeExtTemperature;
+  tmp32 = tmp32*(ptrCellParameter->R)/tmp16;
+  UG31_LOGI("[%s]: NTC resistance = %d x %d / %d = %d\n", __func__,
+            obj->info->codeExtTemperature, ptrCellParameter->R, tmp16, (int)tmp32);
+
+  idx = 0;
+  while(idx < ET_NUMS)
+  {
+    if(tmp32 >= ptrCellParameter->rtTable[idx])
+    {
+      break;
+    }
+    idx = idx + 1;
+  }
+
+  if(idx == 0)
+  {
+    /// [AT-PM] : Minimum measurable temperature ; 01/25/2013
+    tmp32 = (_meas_s32_)ExtTemperatureTable[0];
+  }
+  else if(idx == ET_NUMS)
+  {
+    /// [AT-PM] : Maximum measurable temperature ; 01/25/2013
+    tmp32 = (_meas_s32_)ExtTemperatureTable[ET_NUMS - 1];
+  }
+  else
+  {
+    /// [AT-PM] : Calculate external temperature ; 01/25/2013
+    tmp32 = tmp32 - ptrCellParameter->rtTable[idx];
+    tmp32 = tmp32*(ExtTemperatureTable[idx - 1] - ExtTemperatureTable[idx]);
+    tmp32 = tmp32/(ptrCellParameter->rtTable[idx - 1] - ptrCellParameter->rtTable[idx]);
+    tmp32 = tmp32 + ExtTemperatureTable[idx];
+  }
+
+  /// [AT-PM] : Apply board factor ; 01/25/2013
+  tmp32 = tmp32 - BoardFactor[GET_PRODUCT_TYPE(ptrCellParameter->NacLmdAdjustCfg)].ext_temp_offset;
+
+  /// [AT-PM] : Apply calibration factor ; 01/25/2013
+  tmp32 = tmp32 - ptrCellParameter->adc_d4;
+
+  /// [AT-PM] : Average to avoid unexpected jumping ; 07/04/2013
+  tmp32 = tmp32*ET_AVERAGE_NEW + obj->info->extTemperature*ET_AVERAGE_OLD;
+  tmp32 = tmp32/ET_AVERAGE_BASE;
+  obj->info->extTemperature = (_meas_s16_)tmp32;
+}
+
+#define MINIMUM_ADC1_COUNTER_FOR_CONVERT_TIME (10)
+#define MAXIMUM_ADC1_CONVERSION_TIME          (0xf8)
+#define MINIMUM_ADC1_CONVERSION_TIME          (0x08)
+
+/**
+ * @brief CalculateAdc1ConvertTime
+ *
+ *  Calculate ADC1 conversion time
+ *
+ * @para  obj address of MeasDataInternalType
+ * @return  _UPI_NULL_
+ */
+void CalculateAdc1ConvertTime(MeasDataInternalType *obj)
+{
+  _meas_u32_ tmp32;
+
+  UG31_LOGN("[%s]: Initial conversion time = %d\n", __func__, obj->info->adc1ConvertTime);
+
+  /// [AT-PM] : Check internal suspend mode ; 08/01/2013
+  if(MEAS_IN_SUSPEND_MODE(obj->info->status) == _UPI_TRUE_)
+  {
+    obj->info->lastCounter = obj->codeCounter;
+    return;
+  }
+
+  /// [AT-PM] : First time to calculate ADC1 conversion time ; 01/25/2013
+  if(obj->info->adc1ConvertTime == 0)
+  {
+    obj->info->adc1ConvertTime = TIME_DEFAULT_ADC1_CONVERT_TIME;
+    obj->info->lastCounter = obj->codeCounter;
+    return;
+  }
+
+  #ifdef  uG31xx_BOOT_LOADER
+
+    /// [AT-PM] : In bootloader, ADC1 converstion time is not calculated ; 02/12/2013
+    obj->info->lastCounter = obj->codeCounter;
+    return;
+
+  #endif  ///< end of uG31xx_BOOT_LOADER
+
+  /// [AT-PM] : Check counter overflow or time overflow; 01/25/2013
+  if((obj->codeCounter <= obj->info->lastCounter) || (obj->info->deltaTime == 0))
+  {
+    obj->info->lastCounter = obj->codeCounter;
+    return;
+  }
+
+  /// [AT-PM] : Limit the minimum counter ; 02/11/2013
+  tmp32 = (_meas_u32_)obj->codeCounter;
+  tmp32 = tmp32 - obj->info->lastCounter;
+  if(tmp32 < MINIMUM_ADC1_COUNTER_FOR_CONVERT_TIME)
+  {
+    obj->info->lastCounter = obj->codeCounter;
+    return;
+  }
+
+  /// [AT-PM] : Calculate new ADC1 conversion time ; 09/25/2013
+  tmp32 = obj->info->deltaTime;
+  tmp32 = tmp32*TIME_CONVERT_TIME_TO_MSEC/(obj->codeCounter - obj->info->lastCounter);
+
+  /// [AT-PM] : Check conversion time is valid or not ; 02/13/2013
+  if((tmp32 > (MAXIMUM_ADC1_CONVERSION_TIME*TIME_CONVERT_TIME_TO_MSEC)) ||
+     (tmp32 < (MINIMUM_ADC1_CONVERSION_TIME*TIME_CONVERT_TIME_TO_MSEC)))
+  {
+    UG31_LOGI("[%s]: ***************************************************************************************\n", __func__);
+    UG31_LOGE("[%s]: ***************************************************************************************\n", __func__);
+    UG31_LOGI("[%s]:  ####  #####  ##  ##  ####  #####  ##   ##  ####  ##       ###### ###### ##   ## ######\n", __func__);
+    UG31_LOGI("[%s]: ##  ## ##  ## ### ## ##  ## ##  ## ### ### ##  ## ##       ######   ##   ### ### ##\n", __func__);
+    UG31_LOGI("[%s]: ###### #####  ###### ##  ## #####  ####### ###### ##         ##     ##   ####### ###\n", __func__);
+    UG31_LOGI("[%s]: ##  ## ##  ## ## ### ##  ## ##  ## ##   ## ##  ## ##         ##     ##   ##   ## ##\n", __func__);
+    UG31_LOGI("[%s]: ##  ## #####  ##  ##  ####  ##  ## ##   ## ##  ## ######     ##   ###### ##   ## ######\n", __func__);
+    UG31_LOGI("[%s]:\n", __func__);
+    UG31_LOGI("[%s]: Previous Time Tag    = %d\n", __func__, (int)(obj->info->lastTimeTick - obj->info->deltaTime));
+    UG31_LOGI("[%s]: Current Time Tag     = %d\n", __func__, (int)obj->info->lastTimeTick);
+    UG31_LOGE("[%s]: Delta Time           = %d\n", __func__, (int)obj->info->deltaTime);
+    UG31_LOGE("[%s]: Previous ADC Count   = %d\n", __func__, obj->info->lastCounter);
+    UG31_LOGE("[%s]: Current ADC Count    = %d\n", __func__, obj->codeCounter);
+    UG31_LOGI("[%s]: Delta ADC Count      = %d\n", __func__, obj->codeCounter - obj->info->lastCounter);
+    UG31_LOGI("[%s]: Old ADC Convert Time = %d\n", __func__, obj->info->adc1ConvertTime);
+    UG31_LOGI("[%s]: New ADC Convert Time = %d\n", __func__, (int)tmp32);
+    UG31_LOGE("[%s]: ***************************************************************************************\n", __func__);
+    UG31_LOGI("[%s]: ***************************************************************************************\n", __func__);
+    tmp32 = (_meas_u32_)TIME_DEFAULT_ADC1_CONVERT_TIME;
+  }
+
+  /// [AT-PM] : ADC1 converstion time filter ; 09/25/2013
+  if(tmp32 > obj->info->adc1ConvertTime)
+  {
+    if(tmp32 > ((_meas_u32_)(obj->info->adc1ConvertTime + TIME_DEFAULT_ADC1_CONVERT_TIME)))
+    {
+      tmp32 = tmp32 + obj->info->adc1ConvertTime;
+      tmp32 = tmp32/2;
+      obj->info->adc1ConvertTime = (_meas_u16_)tmp32;
+    }
+    else
+    {
+      obj->info->adc1ConvertTime = obj->info->adc1ConvertTime + 1;
+    }
+  }
+  else if(tmp32 < obj->info->adc1ConvertTime)
+  {
+    if((tmp32 + TIME_DEFAULT_ADC1_CONVERT_TIME) < ((_meas_u32_)obj->info->adc1ConvertTime))
+    {
+      tmp32 = tmp32 + obj->info->adc1ConvertTime;
+      tmp32 = tmp32/2;
+      obj->info->adc1ConvertTime = (_meas_u16_)tmp32;
+    }
+    else
+    {
+      obj->info->adc1ConvertTime = obj->info->adc1ConvertTime - 1;
+    }
+  }
+  else
+  {
+    obj->info->adc1ConvertTime = (_meas_u16_)tmp32;
+  }
+  UG31_LOGI("[%s]: Conversion Time = %d ((%d - %d)/%d)\n", __func__,
+            obj->info->adc1ConvertTime, obj->codeCounter, obj->info->lastCounter, (int)obj->info->deltaTime);
+  obj->info->lastCounter = obj->codeCounter;
+}
+
+#define COULOMB_COUNTER_LSB       (4096)
+
+/**
+ * @brief ConvertCharge
+ *
+ *  Convert code of charge
+ *
+ * @para  obj address of MeasDataInternalType
+ * @return  _UPI_NULL_
+ */
+void ConvertCharge(MeasDataInternalType *obj)
+{
+  _meas_s16_ tmp16;
+  _meas_s32_ tmp32;
+  _meas_s64_ tmp64;
+
+  /// [AT-PM] : Convert from calibrated ADC code ; 01/25/2013
+  tmp16 = ADC1_IDEAL_CODE_DELTA;
+  tmp32 = (_meas_s32_)obj->info->codeCharge;
+  tmp32 = tmp32 - ADC1_IDEAL_CODE_100MV;
+  while(1)
+  {
+    tmp64 = (_meas_s64_)tmp32;
+    tmp64 = tmp64*ADC1_VOLTAGE_DELTA;
+    if((tmp64 < 2147483647) && (tmp64 > -2147483647))
+    {
+      break;
+    }
+    tmp16 = tmp16/2;
+    tmp32 = tmp32/2;
+  }
+  tmp32 = (_meas_s32_)tmp64;
+  tmp32 = tmp32/tmp16;
+  tmp32 = tmp32 + ADC1_VOLTAGE_100MV;
+  tmp32 = tmp32/ptrCellParameter->rSense;
+  UG31_LOGN("[%s]: ((%d - %d) x %d / %d + %d) / %d = %d\n", __func__,
+            (int)obj->info->codeCharge, ADC1_IDEAL_CODE_100MV, ADC1_VOLTAGE_DELTA,
+            ADC1_IDEAL_CODE_DELTA, ADC1_VOLTAGE_100MV, ptrCellParameter->rSense, (int)tmp32);
+  #ifdef	UPI_UBOOT_DEBUG_MSG
+    printf("[ConvertCharge]: ((%d - %d) x %d / %d + %d) / %d = %d\n",
+           obj->info->codeCharge, ADC1_IDEAL_CODE_100MV, ADC1_VOLTAGE_DELTA,
+           ADC1_IDEAL_CODE_DELTA, ADC1_VOLTAGE_100MV, ptrCellParameter->rSense, tmp32);
+  #endif	///< end of UPI_UBOOT_DEBUG_MSG
+  /// [AT-PM] : Apply board factor ; 01/25/2013
+  tmp32 = tmp32*BOARD_FACTOR_CONST/BoardFactor[GET_PRODUCT_TYPE(ptrCellParameter->NacLmdAdjustCfg)].current_gain;
+  UG31_LOGN("[%s]: Board Factor (%d/%d) -> %d\n", __func__,
+            BoardFactor[GET_PRODUCT_TYPE(ptrCellParameter->NacLmdAdjustCfg)].current_gain,
+            BoardFactor[GET_PRODUCT_TYPE(ptrCellParameter->NacLmdAdjustCfg)].current_offset, (int)tmp32);
+
+  /// [AT-PM] : Apply calibration factor ; 01/25/2013
+  if(tmp32 > 0)
+  {
+    tmp32 = tmp32*CALIBRATION_FACTOR_CONST/ptrCellParameter->adc1_pgain;
+  }
+  else
+  {
+    tmp32 = tmp32*CALIBRATION_FACTOR_CONST/ptrCellParameter->adc1_ngain;
+  }
+  UG31_LOGN("[%s]: Calibration Factor (%d|%d/%d) -> %d\n", __func__,
+            ptrCellParameter->adc1_pgain, ptrCellParameter->adc1_ngain,
+            ptrCellParameter->adc1_pos_offset, (int)tmp32);
+  #ifdef	UPI_UBOOT_DEBUG_MSG
+    printf("[ConvertCharge]: Calibration Factor (%d|%d/%d) -> %d\n",
+           ptrCellParameter->adc1_pgain, ptrCellParameter->adc1_ngain,
+           ptrCellParameter->adc1_pos_offset, tmp32);
+  #endif	///< end of UPI_UBOOT_DEBUG_MSG
+
+  /// [AT-PM] : Apply time information ; 01/25/2013
+  CalculateAdc1ConvertTime(obj);
+  tmp32 = tmp32*(obj->info->adc1ConvertTime)/TIME_MSEC_TO_SEC*COULOMB_COUNTER_LSB/TIME_SEC_TO_HOUR;
+  tmp32 = tmp32/TIME_CONVERT_TIME_TO_MSEC;
+  if(MEAS_REVERSE_CURRENT_DIRECTION(obj->info->status) == _UPI_TRUE_)
+  {
+    tmp32 = tmp32*(-1);
+  }
+
+  /// [AT-PM] : Update capacity information ; 01/25/2013
+  obj->info->deltaCap = (_meas_s16_)tmp32;
+  obj->info->stepCap = obj->info->deltaCap - obj->info->lastDeltaCap;
+  if((MEAS_CABLE_OUT(obj->info->status) == _UPI_TRUE_) &&
+     (obj->info->stepCap > 0))
+  {
+    obj->info->stepCap = 0;
+    UG31_LOGI("[%s]: Force stepCap to 0\n", __func__);
+  }
+  obj->info->lastDeltaCap = obj->info->deltaCap;
+  UG31_LOGI("[%s]: Capacity = %d (%d)\n", __func__, obj->info->deltaCap, obj->info->stepCap);
+  #ifdef	UPI_UBOOT_DEBUG_MSG
+    printf("[ConvertCharge]: Capacity = %d (%d)\n", obj->info->deltaCap, obj->info->stepCap);
+  #endif	///< end of UPI_UBOOT_DEBUG_MSG
+}
+
+/**
+ * @brief TimeTick
+ *
+ *  Get the time tick and calculate delta time
+ *
+ * @para  obj address of MeasDataInternalType
+ * @return  _UPI_NULL_
+ */
+void TimeTick(MeasDataInternalType *obj)
+{
+  if((MEAS_IN_SUSPEND_MODE(obj->info->status) == _UPI_TRUE_) ||
+     (MEAS_LEAVE_SUSPEND_MODE(obj->info->status) == _UPI_TRUE_))
+  {
+    /// [AT-PM] : Prevent adc conversion count overflow ; 06/11/2013
+    if(obj->codeCounter < obj->info->lastCounter)
+    {
+      obj->info->deltaTime = 0x10000;
+      obj->info->deltaTime = obj->info->deltaTime - obj->info->lastCounter;
+      obj->info->deltaTime = obj->info->deltaTime + obj->codeCounter;
+      UG31_LOGE("[%s]: Counter overflow in internal suspend mode, counter = %d (%d, %d)\n", __func__,
+                (int)obj->info->deltaTime,
+                (int)obj->info->lastCounter,
+                (int)obj->codeCounter);
+    }
+    else
+    {
+      obj->info->deltaTime = (_meas_u32_)obj->codeCounter;
+      obj->info->deltaTime = obj->info->deltaTime - obj->info->lastCounter;
+    }
+    /// [AT-PM] : Use conversion count to estimate delta time ; 06/11/2013
+    obj->info->deltaTime = obj->info->deltaTime*obj->info->adc1ConvertTime/TIME_CONVERT_TIME_TO_MSEC;
+    UG31_LOGE("[%s]: In internal suspend mode, deltaTime = %d\n", __func__,
+              (int)obj->info->deltaTime);
+    if(MEAS_LEAVE_SUSPEND_MODE(obj->info->status) == _UPI_TRUE_)
+    {
+      obj->info->status = obj->info->status & (~MEAS_STATUS_LAST_IN_SUSPEND_MODE);
+      obj->info->lastTimeTick = GetTickCount();
+      UG31_LOGE("[%s]: Leave internal suspend mode, lastTimeTick = %d\n", __func__,
+                (int)obj->info->lastTimeTick);
+    }
+    return;
+  }
+
+  obj->currTime = GetTickCount();
+
+  /// [AT-PM] : Prevent time tick overflow ; 01/25/2013
+  if(obj->currTime <= obj->info->lastTimeTick)
+  {
+    UG31_LOGE("[%s]: OVERFLOW -> %d < %d\n", __func__,
+              (int)obj->currTime, (int)obj->info->lastTimeTick);
+    obj->info->lastTimeTick = obj->currTime;
+
+    /// [AT-PM] : Use adc conversion count to count delta time ; 03/04/2014
+    if(obj->codeCounter < obj->info->lastCounter)
+    {
+      /// [AT-PM] : Prevent adc conversion count overflow ; 06/11/2013
+      obj->info->deltaTime = (_meas_u32_)obj->codeCounter;
+      UG31_LOGE("[%s]: Counter and jiffies overflow, counter = %d\n", __func__,
+                (int)obj->codeCounter);
+    }
+    else
+    {
+      obj->info->deltaTime = (_meas_u32_)obj->codeCounter;
+      obj->info->deltaTime = obj->info->deltaTime - obj->info->lastCounter;
+    }
+    /// [AT-PM] : Use conversion count to estimate delta time ; 06/11/2013
+    obj->info->deltaTime = obj->info->deltaTime*obj->info->adc1ConvertTime/TIME_CONVERT_TIME_TO_MSEC;
+    UG31_LOGE("[%s]: Jiffies overflow, deltaTime = %d\n", __func__, (int)obj->info->deltaTime);
+    return;
+  }
+
+  /// [AT-PM] : Calculate delta time ; 01/25/2013
+  obj->info->deltaTime = obj->currTime - obj->info->lastTimeTick;
+  UG31_LOGN("[%s]: Delta Time = %d - %d = %d\n", __func__,
+            (int)obj->currTime, (int)obj->info->lastTimeTick, (int)obj->info->deltaTime);
+  obj->info->lastTimeTick = obj->currTime;
+}
+
+#define MAX_READ_REGISTER_RETRY     (5)
+
+/**
+ * @brief ReadVoltBat3Code
+ *
+ *  Read register with debug for LA
+ *
+ * @return  NULL
+ */
+void ReadVoltBat3Code(void)
+{
+  _meas_u8_ buf[2];
+  buf[0] = 0;
+  buf[1] = 0;
+  API_I2C_Read(NORMAL_REGISTER,
+                           UG31XX_I2C_HIGH_SPEED_MODE,
+                           UG31XX_I2C_TEM_BITS_MODE,
+                           REG_VBAT3_LOW,
+                           2,
+                           (unsigned char *)&buf[0]);
+  UG31_LOGE("[UPI] %s vbat3(%x%x)\n", __func__,
+          buf[1], buf[0]);
+}
+
+/**
+ * @brief _ReadRegister
+ *
+ *  Read register with double buffer
+ *
+ * @para  addr  register address
+ * @para  size  data size in byte
+ * @para  rdata address of data to be stored
+ * @return  NULL
+ */
+void _ReadRegister(_meas_u8_ addr, _meas_u8_ size, _meas_u8_ *rdata)
+{
+  _meas_u8_ buf[2];
+  _meas_u8_ cnt;
+
+  API_I2C_Read(NORMAL_REGISTER,
+               UG31XX_I2C_HIGH_SPEED_MODE,
+               UG31XX_I2C_TEM_BITS_MODE,
+               addr,
+               size,
+               (unsigned char *)rdata);
+
+  cnt = 0;
+  while(1)
+  {
+    buf[0] = 0;
+    buf[1] = 0;
+    API_I2C_Read(NORMAL_REGISTER,
+                 UG31XX_I2C_HIGH_SPEED_MODE,
+                 UG31XX_I2C_TEM_BITS_MODE,
+                 addr,
+                 size,
+                 (unsigned char *)&buf[0]);
+
+    if((buf[0] == *rdata) &&
+       (buf[1] == *(rdata + 1)))
+    {
+      break;
+    }
+    UG31_LOGE("[%s]: re-read i2c %x%x -> %x != %x%x (%d)\n", __func__,
+              addr,
+              *(rdata+1),
+              *rdata,
+              buf[1],
+              buf[0],
+              cnt);
+
+    upi_memcpy(rdata, &buf[0], size);
+
+    cnt = cnt + 1;
+    if(cnt > MAX_READ_REGISTER_RETRY)
+    {
+      UG31_LOGE("[%s]: read i2c %x fail (%d)\n", __func__,
+                addr,
+                cnt);
+      break;
+    }
+  }
+}
+
+/**
+ * @brief ReadRegister
+ *
+ *  Read measurement registers
+ *
+ * @para  obj address of MeasDataInternalType
+ * @return  _UPI_NULL_
+ */
+void ReadRegister(MeasDataInternalType *obj)
+{
+  /// [AT-PM] : Read VBat1Ave ; 01/27/2013
+  _ReadRegister(REG_AVE_VBAT1_LOW,
+                REG_AVE_VBAT1_HIGH - REG_AVE_VBAT1_LOW + 1,
+                (unsigned char *)&obj->codeBat1);
+
+  /// [AT-PM] : Read CurrentAve ; 01/27/2013
+  _ReadRegister(REG_AVE_CURRENT_LOW,
+                REG_AVE_CURRENT_HIGH - REG_AVE_CURRENT_LOW + 1,
+                (unsigned char *)&obj->codeCurrent);
+
+  /// [AT-PM] : Read ITAve ; 01/27/2013
+  _ReadRegister(REG_AVE_IT_LOW,
+                REG_AVE_IT_HIGH - REG_AVE_IT_LOW + 1,
+                (unsigned char *)&obj->codeIntTemperature);
+
+  /// [AT-PM] : Read ETAve ; 01/27/2013
+  _ReadRegister(REG_AVE_ET_LOW,
+                REG_AVE_ET_HIGH - REG_AVE_ET_LOW + 1,
+                (unsigned char *)&obj->codeExtTemperature);
+
+  /// [AT-PM] : Read Charge ; 01/27/2013
+  _ReadRegister(REG_CHARGE_LOW,
+                REG_CHARGE_HIGH - REG_CHARGE_LOW + 1,
+                (unsigned char *)&obj->codeCharge);
+
+  /// [AT-PM] : Read Counter ; 01/27/2013
+  _ReadRegister(REG_COUNTER_LOW,
+                REG_COUNTER_HIGH - REG_COUNTER_LOW + 1,
+                (unsigned char *)&obj->codeCounter);
+
+  /// [AT-PM] : Read Offset ; 01/27/2013
+  _ReadRegister(REG_ADC1_OFFSET_LOW,
+                REG_ADC1_OFFSET_HIGH - REG_ADC1_OFFSET_LOW + 1,
+                (unsigned char *)&obj->ccOffset);
+
+  /// [AT-PM] : Read register for debugging ; 02/27/2014
+  API_I2C_Read(NORMAL_REGISTER,
+               UG31XX_I2C_HIGH_SPEED_MODE,
+               UG31XX_I2C_TEM_BITS_MODE,
+               REG_INTR_STATUS,
+               1,
+               (unsigned char *)&obj->reg14);
+  API_I2C_Read(SEURITY_REGISTER,
+               UG31XX_I2C_HIGH_SPEED_MODE,
+               UG31XX_I2C_TEM_BITS_MODE,
+               REG_INTR_CTRL_B,
+               1,
+               (unsigned char *)&obj->reg9C);
+  API_I2C_Read(SEURITY_REGISTER,
+               UG31XX_I2C_HIGH_SPEED_MODE,
+               UG31XX_I2C_TEM_BITS_MODE,
+               REG_ADC_CTR_A,
+               REG_ADC_V3 - REG_ADC_CTR_A + 1,
+               (unsigned char *)&obj->regC5);
+  API_I2C_Read(NORMAL_REGISTER,
+               UG31XX_I2C_HIGH_SPEED_MODE,
+               UG31XX_I2C_TEM_BITS_MODE,
+               REG_AVE_IT_LOW,
+               REG_AVE_IT_HIGH - REG_AVE_IT_LOW + 1,
+               (unsigned char *)&obj->reg0A);
+  API_I2C_Read(NORMAL_REGISTER,
+               UG31XX_I2C_HIGH_SPEED_MODE,
+               UG31XX_I2C_TEM_BITS_MODE,
+               REG_INTR_TEMPER_LOW,
+               REG_INTR_TEMPER_HIGH - REG_INTR_TEMPER_LOW + 1,
+               (unsigned char *)&obj->reg50);
+  API_I2C_Read(SEURITY_REGISTER,
+               UG31XX_I2C_HIGH_SPEED_MODE,
+               UG31XX_I2C_TEM_BITS_MODE,
+               REG_INTR_CTRL_A,
+               1,
+               (unsigned char *)&obj->reg9B);
+  API_I2C_Read(SEURITY_REGISTER,
+               UG31XX_I2C_HIGH_SPEED_MODE,
+               UG31XX_I2C_TEM_BITS_MODE,
+               REG_CELL_EN,
+               1,
+               (unsigned char *)&obj->reg9E);
+
+  if(obj->reg9E >= APPLICATION_UG3102)
+  {
+    _ReadRegister(REG_VBAT2_LOW,
+                  REG_VBAT2_HIGH - REG_VBAT2_LOW + 1,
+                  (unsigned char *)&obj->codeBat2);
+  }
+  else
+  {
+    obj->codeBat2 = 0;
+  }
+  if((obj->reg9E & APPLICATION_UG3103_3) == APPLICATION_UG3103_3)
+  {
+    _ReadRegister(REG_VBAT3_LOW,
+                  REG_VBAT3_HIGH - REG_VBAT3_LOW + 1,
+                  (unsigned char *)&obj->codeBat3);
+  }
+  else
+  {
+    obj->codeBat3 = 0;
+  }
+}
+
+/**
+ * @brief ResetCoulombCounter
+ *
+ *  Reset coulomb counter
+ *
+ * @para  obj address of MeasDataInternalType
+ * @return  _UPI_NULL_
+ */
+void ResetCoulombCounter(MeasDataInternalType *obj)
+{
+  _meas_u8_ tmp8;
+
+  tmp8 = 0;
+  API_I2C_Read(NORMAL_REGISTER,
+               UG31XX_I2C_HIGH_SPEED_MODE,
+               UG31XX_I2C_TEM_BITS_MODE,
+               REG_CTRL1,
+               1,
+               &tmp8);
+  tmp8 = tmp8 | CTRL1_GG_RST;
+  API_I2C_Write(NORMAL_REGISTER,
+                UG31XX_I2C_HIGH_SPEED_MODE,
+                UG31XX_I2C_TEM_BITS_MODE,
+                REG_CTRL1,
+                1,
+                &tmp8);
+}
+
+/**
+ * @brief RevertCalibrateAdc2Code
+ *
+ *  Revert calibrated ADC2 code
+ *
+ * @para  data  address of MeasDataType
+ * @para  caliCode  calibrated ADC2 code
+ * @return  raw ADC2 code
+ */
+_meas_s32_ RevertCalibrateAdc2Code(MeasDataType *data, _meas_s32_ caliCode)
+{
+  _meas_s64_ tmp64;
+  _meas_s32_ tmp32;
+  _meas_s32_ deltaIT;
+  _meas_s32_ gain;
+  _meas_s32_ offset;
+  _meas_s32_ constant;
+
+  /// [AT-PM] : tmp32 = ( caliCode x gain / constant + offset ) / deltaIT ; 04/08/2013
+  gain = data->adc2Gain;
+  offset = data->adc2Offset;
+  deltaIT = (_meas_s32_)ptrOtpData->aveIT80;
+  deltaIT = deltaIT - ptrOtpData->aveIT25;
+  constant = ADC2_IDEAL_CODE_DELTA;
+  while(1)
+  {
+    tmp64 = (_meas_s64_)caliCode;
+    tmp64 = tmp64*gain;
+    if((tmp64 < 2147483647) && (tmp64 > -2147483647))
+    {
+      break;
+    }
+    caliCode = caliCode/2;
+    gain = gain/2;
+    constant = constant/4;
+  }
+  tmp32 = (_meas_s32_)tmp64;
+  tmp32 = tmp32/constant;
+  tmp32 = tmp32 + offset;
+  tmp32 = tmp32/deltaIT;
+  return (tmp32);
+}
+
+/**
+ * @brief RevertBat1Code
+ *
+ *  Revert VBat1 code
+ *
+ * @para  data  address of MeasDataType
+ * @para  volt  voltage in mV to be reverted
+ * @return  adc2 vbat1 code
+ */
+_meas_u16_ RevertBat1Code(MeasDataType *data, _upi_s16_ volt)
+{
+  _meas_s32_ tmp32;
+
+  tmp32 = (_meas_s32_)volt;
+
+  /// [AT-PM] : Revert calibration parameter ; 04/08/2013
+  tmp32 = tmp32*ptrCellParameter->adc2_gain/CALIBRATION_FACTOR_CONST;
+  tmp32 = tmp32 + ptrCellParameter->adc2_offset;
+
+  /// [AT-PM] : Revert board factor ; 04/08/2013
+  tmp32 = tmp32*BoardFactor[GET_PRODUCT_TYPE(ptrCellParameter->NacLmdAdjustCfg)].voltage_gain/BOARD_FACTOR_CONST;
+  tmp32 = tmp32 + BoardFactor[GET_PRODUCT_TYPE(ptrCellParameter->NacLmdAdjustCfg)].voltage_offset;
+
+  /// [AT-PM] : Revert to calibrated ADC code ; 04/08/2013
+  tmp32 = tmp32 - ADC2_VOLTAGE_100MV;
+  tmp32 = tmp32*ADC2_IDEAL_CODE_DELTA/ADC2_VOLTAGE_DELTA;
+  tmp32 = tmp32 + ADC2_IDEAL_CODE_100MV;
+
+  /// [AT-PM] : Revert to raw code ; 04/08/2013
+  tmp32 = RevertCalibrateAdc2Code(data, tmp32);
+  return ((_meas_u16_)tmp32);
+}
+
+/**
+ * @brief RevertETCode
+ *
+ *  Revert ET code
+ *
+ * @para  data  address of MeasDataType
+ * @para  et  external temperature in 0.1oC to be reverted
+ * @return  adc1 et code
+ */
+_meas_u16_ RevertETCode(MeasDataType *data, _upi_s16_ et)
+{
+  _meas_s32_ tmp32;
+  _meas_u8_ idx;
+
+  tmp32 = (_meas_s32_)et;
+
+  /// [AT-PM] : Revert calibration factor ; 04/08/2013
+  tmp32 = tmp32 + ptrCellParameter->adc_d4;
+
+  /// [AT-PM] : Revert board factor ; 04/08/2013
+  tmp32 = tmp32 + BoardFactor[GET_PRODUCT_TYPE(ptrCellParameter->NacLmdAdjustCfg)].ext_temp_offset;
+
+  /// [AT-PM] : Revert external temperature calculation ; 04/08/2013
+  idx = 0;
+  while(idx < ET_NUMS)
+  {
+    if(tmp32 < ExtTemperatureTable[idx])
+    {
+      break;
+    }
+    idx = idx + 1;
+  }
+  if(idx == 0)
+  {
+    tmp32 = (_meas_s32_)ptrCellParameter->rtTable[0];
+  }
+  else if(idx >= ET_NUMS)
+  {
+    tmp32 = (_meas_s32_)ptrCellParameter->rtTable[ET_NUMS - 1];
+  }
+  else
+  {
+    tmp32 = tmp32 - ExtTemperatureTable[idx - 1];
+    tmp32 = tmp32*(ptrCellParameter->rtTable[idx] - ptrCellParameter->rtTable[idx - 1]);
+    tmp32 = tmp32/(ExtTemperatureTable[idx] - ExtTemperatureTable[idx - 1]);
+    tmp32 = tmp32 + ptrCellParameter->rtTable[idx - 1];
+  }
+  return ((_meas_u16_)tmp32);
+}
+
+#define MINIMUM_VBAT1_CODE            (ADC2_IDEAL_CODE_100MV/2)
+#define MAXIMUM_CURRENT_CODE          (ADC1_IDEAL_CODE_200MV*6)
+#define MINIMUM_CURRENT_CODE          (ADC1_IDEAL_CODE_200MV*(-6))
+#define MINIMUM_IT_CODE               (IT_IDEAL_CODE_25/2)
+#define MAXIMUM_IT_CODE               (IT_IDEAL_CODE_80*11/10)
+#define MINIMUM_ET_CODE               (1000)
+#define MAXIMUM_ET_CODE               (28000)
+
+typedef MEAS_RTN_CODE (*CheckAdcCode)(MeasDataInternalType *obj);
+
+/**
+ * @brief CheckCurrentMin
+ *
+ *  Check minimum current ADC code
+ *
+ * @para  obj address of MeasDataInternalType
+ * @return  MEAS_RTN_CODE
+ */
+MEAS_RTN_CODE CheckCurrentMin(MeasDataInternalType *obj)
+{
+  /// [FC] : Add variable MPK_active for MPK intial ; 12/10/2013
+  if(MPK_active == _UPI_FALSE_)
+  {
+    if(obj->codeCurrent < MINIMUM_CURRENT_CODE)
+    {
+      UG31_LOGE("[%s]: Current code %d < %d\n", __func__,
+                obj->codeCurrent, MINIMUM_CURRENT_CODE);
+      obj->codeCurrent = MINIMUM_CURRENT_CODE;
+    }
+  }
+  return (MEAS_RTN_PASS);
+}
+
+/**
+ * @brief CheckCurrentMax
+ *
+ *  Check maximum current ADC code
+ *
+ * @para  obj address of MeasDataInternalType
+ * @return  MEAS_RTN_CODE
+ */
+MEAS_RTN_CODE CheckCurrentMax(MeasDataInternalType *obj)
+{
+  /// [FC] : Add variable MPK_active for MPK intial ; 12/10/2013
+  if(MPK_active == _UPI_FALSE_)
+  {
+    if(obj->codeCurrent > MAXIMUM_CURRENT_CODE)
+    {
+      UG31_LOGE("[%s]: Current code %d > %d\n", __func__,
+                obj->codeCurrent, MAXIMUM_CURRENT_CODE);
+      obj->codeCurrent = MAXIMUM_CURRENT_CODE;
+    }
+  }
+  return (MEAS_RTN_PASS);
+}
+
+/**
+ * @brief CheckITMin
+ *
+ *  Check minimum internal temperature ADC code
+ *
+ * @para  obj address of MeasDataInternalType
+ * @return  MEAS_RTN_CODE
+ */
+MEAS_RTN_CODE CheckITMin(MeasDataInternalType *obj)
+{
+  /// [FC] : Add variable MPK_active for MPK intial ; 12/10/2013
+  if(MPK_active == _UPI_FALSE_)
+  {
+    if(obj->codeIntTemperature < MINIMUM_IT_CODE)
+    {
+      UG31_LOGE("[%s]: Internal Temperature code %d < %d\n", __func__,
+                obj->codeIntTemperature, MINIMUM_IT_CODE);
+      return (MEAS_RTN_ADC_ABNORMAL);
+    }
+  }
+  return (MEAS_RTN_PASS);
+}
+
+/**
+ * @brief CheckITMax
+ *
+ *  Check maximum internal temperature ADC code
+ *
+ * @para  obj address of MeasDataInternalType
+ * @return  MEAS_RTN_CODE
+ */
+MEAS_RTN_CODE CheckITMax(MeasDataInternalType *obj)
+{
+  /// [FC] : Add variable MPK_active for MPK intial ; 12/10/2013
+  if(MPK_active == _UPI_FALSE_)
+  {
+    if(obj->codeIntTemperature > MAXIMUM_IT_CODE)
+    {
+      UG31_LOGE("[%s]: Internal Temperature code %d > %d\n", __func__,
+                obj->codeIntTemperature, MAXIMUM_IT_CODE);
+      return (MEAS_RTN_ADC_ABNORMAL);
+    }
+  }
+  return (MEAS_RTN_PASS);
+}
+
+/**
+ * @brief CheckETMin
+ *
+ *  Check minimum external temperature ADC code
+ *
+ * @para  obj address of MeasDataInternalType
+ * @return  MEAS_RTN_CODE
+ */
+MEAS_RTN_CODE CheckETMin(MeasDataInternalType *obj)
+{
+  /// [FC] : Add variable MPK_active for MPK intial ; 12/10/2013
+  if(MPK_active == _UPI_FALSE_)
+  {
+    if(obj->codeExtTemperature < MINIMUM_ET_CODE)
+    {
+      UG31_LOGE("[%s]: External Temperature code %d < %d\n", __func__,
+                obj->codeExtTemperature, MINIMUM_ET_CODE);
+      obj->info->status = obj->info->status | MEAS_STATUS_NTC_SHORT;
+    }
+    else
+    {
+      obj->info->status = obj->info->status & (~MEAS_STATUS_NTC_SHORT);
+    }
+  }
+  return (MEAS_RTN_PASS);
+}
+
+/**
+ * @brief CheckETMax
+ *
+ *  Check maximum external temperature ADC code
+ *
+ * @para  obj address of MeasDataInternalType
+ * @return  MEAS_RTN_CODE
+ */
+MEAS_RTN_CODE CheckETMax(MeasDataInternalType *obj)
+{
+  /// [FC] : Add variable MPK_active for MPK intial ; 12/10/2013
+  if(MPK_active == _UPI_FALSE_)
+  {
+    if(obj->codeExtTemperature > MAXIMUM_ET_CODE)
+    {
+      UG31_LOGE("[%s]: External Temperature code %d > %d\n", __func__,
+                obj->codeExtTemperature, MAXIMUM_ET_CODE);
+      obj->info->status = obj->info->status | MEAS_STATUS_NTC_OPEN;
+    }
+    else
+    {
+      obj->info->status = obj->info->status & (~MEAS_STATUS_NTC_OPEN);
+    }
+  }
+  return (MEAS_RTN_PASS);
+}
+
+/**
+ * @brief CheckVBat1Min
+ *
+ *  Check minimum VBat1 ADC code
+ *
+ * @para  obj address of MeasDataInternalType
+ * @return  MEAS_RTN_CODE
+ */
+MEAS_RTN_CODE CheckVBat1Min(MeasDataInternalType *obj)
+{
+  /// [FC] : Add variable MPK_active for MPK intial ; 12/10/2013
+  if(MPK_active == _UPI_FALSE_)
+  {
+    if(obj->codeBat1 < MINIMUM_VBAT1_CODE)
+    {
+      UG31_LOGE("[%s]: Voltage code %d < %d\n", __func__,
+                obj->codeBat1, MINIMUM_VBAT1_CODE);
+      return (MEAS_RTN_BATTERY_REMOVED);
+    }
+  }
+  return (MEAS_RTN_PASS);
+}
+
+static CheckAdcCode CheckAdcCodeRoutine[] = {
+  CheckCurrentMin,
+  CheckCurrentMax,
+  CheckITMin,
+  CheckITMax,
+  #ifdef  ENABLE_NTC_CHECK
+    CheckETMin,
+    CheckETMax,
+  #endif  ///< end of ENABLE_NTC_CHECK
+  CheckVBat1Min,
+  _UPI_NULL_,
+};
+
+/**
+ * @brief FetchAdcCode
+ *
+ *  Fetch ADC converted code
+ *
+ * @para  obj address of MeasDataInternalType
+ * @return  MEAS_RTN_CODE
+ */
+MEAS_RTN_CODE FetchAdcCode(MeasDataInternalType *obj)
+{
+  _meas_u8_ retry;
+  MEAS_RTN_CODE rtn = MEAS_RTN_ADC_ABNORMAL;
+  _meas_u8_ idx;
+
+  /// [AT-PM] : Read ADC code ; 01/27/2013
+  retry = 0;
+  while(retry <= obj->info->fetchRetryCnt)
+  {
+    ReadRegister(obj);
+    UG31_LOGI("[%s]: Retry = %d (%d)\n", __func__, retry, obj->info->fetchRetryCnt);
+    UG31_LOGI("[%s]: Voltage code = %d\n", __func__, obj->codeBat1);
+    UG31_LOGI("[%s]: Current code = %d\n", __func__, obj->codeCurrent);
+    UG31_LOGI("[%s]: Internal Temperature code = %d\n", __func__, obj->codeIntTemperature);
+    UG31_LOGI("[%s]: External Temperature code = %d\n", __func__, obj->codeExtTemperature);
+    UG31_LOGI("[%s]: Charge code = %d\n", __func__, obj->codeCharge);
+    UG31_LOGI("[%s]: Counter = %d\n", __func__, obj->codeCounter);
+
+    idx = 0;
+    while(CheckAdcCodeRoutine[idx] != _UPI_NULL_)
+    {
+      rtn = CheckAdcCodeRoutine[idx](obj);
+      if(rtn != MEAS_RTN_PASS)
+      {
+        SleepMiniSecond(125);
+        break;
+      }
+      idx = idx + 1;
+    }
+
+    if(rtn == MEAS_RTN_PASS)
+    {
+      if((MEAS_NTC_OPEN(obj->info->status) == _UPI_TRUE_) ||
+         (MEAS_NTC_SHORT(obj->info->status) == _UPI_TRUE_))
+      {
+        #ifdef  STOP_IF_NTC_CHECK_FAIL
+
+          SleepMiniSecond(250);
+          UG31_LOGE("[%s]: NTC status abnormal. (%x)\n", __func__,
+                    obj->info->status);
+
+        #else   ///< else of STOP_IF_NTC_CHECK_FAIL
+
+          break;
+
+        #endif  ///< end of STOP_IF_NTC_CHECK_FAIL
+      }
+      else
+      {
+        if(retry != 0)
+        {
+          SleepMiniSecond(250);
+
+          ReadRegister(obj);
+          UG31_LOGI("[%s]: Retry = %d (%d)\n", __func__, retry, obj->info->fetchRetryCnt);
+          UG31_LOGI("[%s]: Voltage code = %d\n", __func__, obj->codeBat1);
+          UG31_LOGI("[%s]: Current code = %d\n", __func__, obj->codeCurrent);
+          UG31_LOGI("[%s]: Internal Temperature code = %d\n", __func__, obj->codeIntTemperature);
+          UG31_LOGI("[%s]: External Temperature code = %d\n", __func__, obj->codeExtTemperature);
+          UG31_LOGI("[%s]: Charge code = %d\n", __func__, obj->codeCharge);
+          UG31_LOGI("[%s]: Counter = %d\n", __func__, obj->codeCounter);
+        }
+        break;
+      }
+    }
+
+    rtn = MEAS_RTN_ADC_ABNORMAL;
+    retry = retry + 1;
+  }
+
+  if(rtn == MEAS_RTN_ADC_ABNORMAL)
+  {
+    ReadVoltBat3Code();
+  }
+
+  obj->info->codeBat1BeforeCal = obj->codeBat1;
+  obj->info->codeBat2BeforeCal = obj->codeBat2;
+  obj->info->codeBat3BeforeCal = obj->codeBat3;
+  obj->info->codeCurrentBeforeCal = obj->codeCurrent;
+  obj->info->codeIntTemperatureBeforeCal = obj->codeIntTemperature;
+  obj->info->codeExtTemperatureBeforeCal = obj->codeExtTemperature;
+  obj->info->codeChargeBeforeCal = obj->codeCharge;
+  obj->info->codeCCOffset = obj->ccOffset;
+  return (rtn);
+}
+
+#define MAX_ET_CODE_DIFF  (200)
+#define MIN_ET_CODE_DIFF  (-200)
+
+/**
+ * @brief CalibrateETCode
+ *
+ *  Calibrate external temperature code
+ *
+ * @para  obj address of MeasDataInternalType
+ * @return  MEAS_RTN_CODE
+ */
+_meas_u16_ CalibrateETCode(MeasDataInternalType *obj)
+{
+  _meas_s16_ tmp16;
+  _meas_s32_ tmp32;
+
+  /// [AT-PM] : Get compensation of board and r-sense ; 11/01/2013
+  tmp32 = (_meas_s32_)obj->codeCurrent;
+  tmp32 = tmp32 + obj->ccOffset;
+  tmp32 = tmp32*(ptrCellParameter->rSense + ptrCellParameter->offsetR)/ptrCellParameter->rSense;
+  obj->codeExtTemperatureComp = (_meas_s16_)tmp32;
+  UG31_LOGN("[%s]: Compensation = %d\n", __func__, (int)tmp32);
+
+  /// [AT-PM] : Compensate temperature code ; 11/01/2013
+  tmp16 = (_meas_s16_)obj->codeExtTemperature;
+  if(MEAS_REVERSE_CURRENT_DIRECTION(obj->info->status) == _UPI_FALSE_)
+  {
+    tmp16 = tmp16 - obj->codeExtTemperatureComp;
+  }
+  obj->info->codeInstExtTemperature = (_meas_u16_)tmp16;
+  UG31_LOGN("[%s]: Calibrated ET Code = %d - %d = %d\n", __func__, obj->codeExtTemperature, obj->codeExtTemperatureComp, tmp16);
+  if(obj->info->codeExtTemperature != 0)
+  {
+	#ifdef	UPI_UBOOT_DEBUG_MSG
+		printf("[CalibrateETCode]: Last = %d, Current = %d\n", obj->info->codeExtTemperature, tmp16);
+	#endif	///< end of UPI_UBOOT_DEBUG_MSG
+    tmp16 = tmp16 - obj->info->codeExtTemperature;
+    UG31_LOGN("[%s]: Previous ET Code = %d\n", __func__, obj->info->codeExtTemperature);
+    if(tmp16 > MAX_ET_CODE_DIFF)
+    {
+      UG31_LOGE("[%s]: Exceed maximum ET code difference (%d > %d)\n", __func__, tmp16, MAX_ET_CODE_DIFF);
+      tmp16 = MAX_ET_CODE_DIFF;
+    }
+    if(tmp16 < MIN_ET_CODE_DIFF)
+    {
+      UG31_LOGE("[%s]: Exceed minimum ET code difference (%d < %d)\n", __func__, tmp16, MIN_ET_CODE_DIFF);
+      tmp16 = MIN_ET_CODE_DIFF;
+    }
+    tmp16 = tmp16 + obj->info->codeExtTemperature;
+  }
+	#ifdef	UPI_UBOOT_DEBUG_MSG
+		printf("[CalibrateETCode]: ET code = %d\n", tmp16);
+	#endif	///< end of UPI_UBOOT_DEBUG_MSG
+  return ((_meas_u16_)tmp16);
+}
+
+/**
+ * @brief RevertCurrent
+ *
+ *  Revert current to adc code
+ *
+ * @para  obj address of MeasDataInternalType
+ * @para  curr  current to be reverted
+ * @return  adc code
+ */
+_meas_s16_ RevertCurrent(MeasDataInternalType *obj, _meas_s32_ curr)
+{
+  _meas_s32_ tmp32;
+
+  tmp32 = curr*(ptrCellParameter->rSense) - ADC1_VOLTAGE_100MV;
+  tmp32 = tmp32*ADC1_IDEAL_CODE_DELTA/ADC1_VOLTAGE_DELTA;
+  tmp32 = tmp32 + ADC1_IDEAL_CODE_100MV;
+  return ((_meas_s16_)tmp32);
+}
+
+/**
+ * @brief CalculateCCOffset
+ *
+ *  Calculate coulomb counter offset
+ *
+ * @para  obj address of MeasDataInternalType
+ * @return  NULL
+ */
+void CalculateCCOffset(MeasDataInternalType *obj)
+{
+  _meas_s32_ offset;
+  _meas_s32_ tmp32;
+
+  /// [AT-PM] : Offset from FT ; 09/24/2013
+  offset = obj->info->adc1Offset/(ptrOtpData->aveIT80 - ptrOtpData->aveIT25);
+  UG31_LOGN("[%s]: Offset from FT = %d\n", __func__, (int)offset);
+
+  /// [AT-PM] : Offset from board factor and calibration factor ; 09/24/2013
+  tmp32 = (_meas_s32_)ptrCellParameter->adc1_pos_offset;
+  tmp32 = tmp32 + obj->info->ccOffsetAdj;
+  tmp32 = tmp32*BoardFactor[GET_PRODUCT_TYPE(ptrCellParameter->NacLmdAdjustCfg)].current_gain/BOARD_FACTOR_CONST;
+  tmp32 = tmp32 + BoardFactor[GET_PRODUCT_TYPE(ptrCellParameter->NacLmdAdjustCfg)].current_offset;
+  UG31_LOGN("[%s]: Offset from board and calibration factor = (%d + %d) x %d / %d + %d = %d\n", __func__,
+            ptrCellParameter->adc1_pos_offset,
+            obj->info->ccOffsetAdj,
+            BoardFactor[GET_PRODUCT_TYPE(ptrCellParameter->NacLmdAdjustCfg)].current_gain,
+            BOARD_FACTOR_CONST,
+            BoardFactor[GET_PRODUCT_TYPE(ptrCellParameter->NacLmdAdjustCfg)].current_offset,
+            (int)tmp32);
+
+  /// [AT-PM] : Revert board factor and calibration factor  09/24/2013
+  tmp32 = RevertCurrent(obj, tmp32);
+  UG31_LOGI("[%s]: Revert offset to adc code from current = %d\n", __func__, (int)tmp32);
+
+  /// [AT-PM] : Update offset ; 09/24/2013
+  offset = (offset - tmp32)*(-1);
+  obj->info->ccOffset = (_meas_s16_)offset;
+
+  /// [AT-PM] : Set coulomb counter offset ; 01/27/2013
+  API_I2C_Write(NORMAL_REGISTER,
+                UG31XX_I2C_HIGH_SPEED_MODE,
+                UG31XX_I2C_TEM_BITS_MODE,
+                REG_ADC1_OFFSET_LOW,
+                REG_ADC1_OFFSET_HIGH - REG_ADC1_OFFSET_LOW + 1,
+                (unsigned char *)&obj->info->ccOffset);
+}
+
+/**
+ * @brief CountCycleCount
+ *
+ *  Count cycle count of battery discharged capacity
+ *
+ * @para  obj address of MeasDataInternalType
+ * @return  NULL
+ */
+void CountCycleCount(MeasDataInternalType *obj)
+{
+  if(obj->info->curr >= ((ptrCellParameter->standbyCurrent)*(-1)))
+  {
+    UG31_LOGI("[%s]: No cycle count calculation because no discharging capacity measured.\n", __func__);
+    return;
+  }
+
+  obj->info->cycleCountBuf = obj->info->cycleCountBuf - obj->info->stepCap;
+
+  if(ptrCellParameter->CycleCountThrd == 0)
+  {
+    ptrCellParameter->CycleCountThrd = ptrCellParameter->ILMD;
+  }
+  if(obj->info->cycleCountBuf >= ptrCellParameter->CycleCountThrd)
+  {
+    obj->info->cycleCount = obj->info->cycleCount + 1;
+    obj->info->cycleCountBuf = obj->info->cycleCountBuf - ptrCellParameter->CycleCountThrd;
+    UG31_LOGI("[%s]: Update cycle count = %d (%d >= %d)\n", __func__,
+              obj->info->cycleCount, (int)obj->info->cycleCountBuf, ptrCellParameter->CycleCountThrd);
+  }
+}
+
+/**
+ * @brief CountCumuCap
+ *
+ *  Count cumulative capacity
+ *
+ * @para  obj address of MeasDataInternalType
+ * @return  NULL
+ */
+void CountCumuCap(MeasDataInternalType *obj)
+{
+  obj->info->cumuCap = obj->info->cumuCap + obj->info->stepCap;
+  UG31_LOGI("[%s]: Cumulative capacity = %d\n", __func__,
+            (int)obj->info->cumuCap);
+}
+
+#define FILTER_BAT_CODE_CNT         (5)
+#define FILTER_BAT_CODE_WEIGHT_OLD  (90)
+#define FILTER_BAT_CODE_WEIGHT_NEW  (10)
+
+/**
+ * @brief FilterBat1Code
+ *
+ *  IIR for BAT1
+ *
+ * @para  obj address of MeasDataInternalType
+ * @return  NULL
+ */
+void FilterBat1Code(MeasDataInternalType *obj)
+{
+  _meas_u32_ result;
+
+  if(MEAS_IN_SUSPEND_MODE(obj->info->status) == _UPI_TRUE_)
+  {
+    obj->info->filterBat1 = obj->codeBat1;
+    return;
+  }
+
+  if(obj->info->filterCntBat1 < FILTER_BAT_CODE_CNT)
+  {
+    obj->info->filterCntBat1 = obj->info->filterCntBat1 + 1;
+    obj->info->filterSumBat1 = obj->info->filterSumBat1 + obj->codeBat1;
+    result = (obj->info->filterSumBat1)/(obj->info->filterCntBat1);
+    obj->info->filterBat1 = (_meas_u16_)result;
+    return;
+  }
+
+  result = (_meas_u32_)obj->codeBat1;
+  result = result*FILTER_BAT_CODE_WEIGHT_NEW + (obj->info->filterBat1)*FILTER_BAT_CODE_WEIGHT_OLD;
+  result = result/(FILTER_BAT_CODE_WEIGHT_NEW + FILTER_BAT_CODE_WEIGHT_OLD);
+  obj->info->filterBat1 = (_meas_u16_)result;
+}
+
+/**
+ * @brief FilterBat1Code
+ *
+ *  IIR for BAT1
+ *
+ * @para  obj address of MeasDataInternalType
+ * @return  NULL
+ */
+void FilterBat2Code(MeasDataInternalType *obj)
+{
+  _meas_u32_ result;
+
+  if(MEAS_IN_SUSPEND_MODE(obj->info->status) == _UPI_TRUE_)
+  {
+    obj->info->filterBat2 = obj->codeBat2;
+    return;
+  }
+
+  if(obj->info->filterCntBat2 < FILTER_BAT_CODE_CNT)
+  {
+    obj->info->filterCntBat2 = obj->info->filterCntBat2 + 1;
+    obj->info->filterSumBat2 = obj->info->filterSumBat2 + obj->codeBat2;
+    result = (obj->info->filterSumBat2)/(obj->info->filterCntBat2);
+    obj->info->filterBat2 = (_meas_u16_)result;
+    return;
+  }
+
+  result = (_meas_u32_)obj->codeBat2;
+  result = result*FILTER_BAT_CODE_WEIGHT_NEW + (obj->info->filterBat2)*FILTER_BAT_CODE_WEIGHT_OLD;
+  result = result/(FILTER_BAT_CODE_WEIGHT_NEW + FILTER_BAT_CODE_WEIGHT_OLD);
+  obj->info->filterBat2 = (_meas_u16_)result;
+}
+
+/**
+ * @brief FilterBat1Code
+ *
+ *  IIR for BAT1
+ *
+ * @para  obj address of MeasDataInternalType
+ * @return  NULL
+ */
+void FilterBat3Code(MeasDataInternalType *obj)
+{
+  _meas_u32_ result;
+
+  if(MEAS_IN_SUSPEND_MODE(obj->info->status) == _UPI_TRUE_)
+  {
+    obj->info->filterBat3 = obj->codeBat3;
+    return;
+  }
+
+  if(obj->info->filterCntBat3 < FILTER_BAT_CODE_CNT)
+  {
+    obj->info->filterCntBat3 = obj->info->filterCntBat3 + 1;
+    obj->info->filterSumBat3 = obj->info->filterSumBat3 + obj->codeBat3;
+    result = (obj->info->filterSumBat3)/(obj->info->filterCntBat3);
+    obj->info->filterBat3 = (_meas_u16_)result;
+    return;
+  }
+
+  result = (_meas_u32_)obj->codeBat3;
+  result = result*FILTER_BAT_CODE_WEIGHT_NEW + (obj->info->filterBat3)*FILTER_BAT_CODE_WEIGHT_OLD;
+  result = result/(FILTER_BAT_CODE_WEIGHT_NEW + FILTER_BAT_CODE_WEIGHT_OLD);
+  obj->info->filterBat3 = (_meas_u16_)result;
+}
+
+#define FILTER_IT_CODE_CNT        (5)
+#define FILTER_IT_CODE_WEIGHT_OLD (60)
+#define FILTER_IT_CODE_WEIGHT_NEW (40)
+
+/**
+ * @brief FilterITCode
+ *
+ *  IIR for IT
+ *
+ * @para  obj address of MeasDataInternalType
+ * @return  NULL
+ */
+void FilterITCode(MeasDataInternalType *obj)
+{
+  _meas_u32_ result;
+
+  if(obj->info->filterCntIntTemperature < FILTER_IT_CODE_CNT)
+  {
+    obj->info->filterCntIntTemperature = obj->info->filterCntIntTemperature + 1;
+    obj->info->filterSumIntTemperature = obj->info->filterSumIntTemperature + obj->codeIntTemperature;
+    result = (obj->info->filterSumIntTemperature)/(obj->info->filterCntIntTemperature);
+    obj->info->filterIntTemperature = (_meas_u16_)result;
+    return;
+  }
+
+  result = (_meas_u32_)obj->codeIntTemperature;
+  result = result*FILTER_IT_CODE_WEIGHT_NEW + (obj->info->filterIntTemperature)*FILTER_IT_CODE_WEIGHT_OLD;
+  result = result/(FILTER_IT_CODE_WEIGHT_NEW + FILTER_IT_CODE_WEIGHT_OLD);
+  obj->info->filterIntTemperature = (_meas_u16_)result;
+}
+
+/// =============================================
+/// [AT-PM] : Extern function region
+/// =============================================
+
+/**
+ * @brief UpiResetCoulombCounter
+ *
+ *  Reset coulomb counter
+ *
+ * @para  data  address of MeasDataType
+ * @return  _UPI_NULL_
+ */
+void UpiResetCoulombCounter(MeasDataType *data)
+{
+  MeasDataInternalType *obj;
+
+  #ifdef  UG31XX_SHELL_ALGORITHM
+    obj = (MeasDataInternalType *)upi_malloc(sizeof(MeasDataInternalType));
+  #else   ///< else of UG31XX_SHELL_ALGORITHM
+    obj = &measData;
+  #endif  ///< end of UG31XX_SHELL_ALGORITHM
+  upi_memset(obj, 0x00, sizeof(MeasDataInternalType));
+
+  obj->info = data;
+  obj->info->fetchRetryCnt = MEAS_MAXIMUM_ROUTINE_RETRY_CNT;
+
+  /// [AT-PM] : Read ADC code ; 01/27/2013
+  FetchAdcCode(obj);
+
+  /// [AT-PM] : Get delta time ; 01/25/2013
+  TimeTick(obj);
+  obj->info->deltaTimeDaemon = obj->info->deltaTimeDaemon + obj->info->deltaTime;
+
+  /// [AT-PM] : Reset coulomb counter ; 01/30/2013
+  ResetCoulombCounter(obj);
+
+  /// [AT-PM] : Convert ADC characteristic from OTP ; 01/23/2013
+  ConvertAdc1Data(obj);
+
+  /// [AT-PM] : Calculate ADC gain and offset ; 01/23/2013
+  CalAdc1Factors(obj);
+
+  /// [AT-PM] : Calibrate ADC code ; 01/23/2013
+  CalibrateChargeCode(obj);
+
+  /// [AT-PM] : Convert into physical value ; 01/23/2013
+  ConvertCharge(obj);
+
+  /// [AT-PM] : Count cycle count ; 10/08/2013
+  CountCycleCount(obj);
+
+  /// [AT-PM] : Count cumulative capacity ; 02/18/2014
+  CountCumuCap(obj);
+
+  /// [AT-PM] : Calculate coulomb counter offset ; 09/24/2013
+  CalculateCCOffset(obj);
+
+  data->lastDeltaCap = 0;
+
+  /// [AT-PM] : Read ADC code ; 01/27/2013
+  FetchAdcCode(obj);
+  obj->info->lastCounter = obj->codeCounter;
+
+  #ifdef  UG31XX_SHELL_ALGORITHM
+    upi_free(obj);
+  #endif  ///< end of UG31XX_SHELL_ALGORITHM
+}
+
+#define RESET_CC_CURRENT_MAGIC_NUMBER               (2)
+#define RESET_CC_DELTA_TIME                         (TIME_SEC_TO_HOUR*TIME_MSEC_TO_SEC)
+#define COULOMB_COUNTER_RESET_THRESHOLD_CHARGE_CHG  (30000)
+#define COULOMB_COUNTER_RESET_THREDHOLD_CHARGE_DSG  (-30000)
+
+_meas_s32_ AvgVoltage(_meas_u16_ currVoltage, _meas_u16_ avgVoltage)
+{
+  _meas_s32_ tmp32;
+
+  tmp32 = (_meas_s32_)currVoltage;
+  tmp32 = tmp32 + avgVoltage;
+  tmp32 = tmp32/2;
+  //obj->info->bat1VoltageAvg = (_meas_u16_)tmp32;
+  return tmp32;
+  }
+
+/**
+ * @brief UpiMeasurement
+ *
+ *  Measurement routine
+ *
+ * @para  data  address of MeasDataType
+ * @para  select  MEAS_SEL_CODE
+ * @return  MEAS_RTN_CODE
+ */
+MEAS_RTN_CODE UpiMeasurement(MeasDataType *data, MEAS_SEL_CODE select)
+{
+  MeasDataInternalType *obj;
+  MEAS_RTN_CODE rtn;
+  _meas_s16_ standbyUpper;
+  _meas_s16_ standbyLower;
+  _meas_u16_ tmp16;
+  _meas_s32_ tmp32;
+
+  UG31_LOGI("[%s]: %s\n", __func__, MEASUREMENT_VERSION);
+
+  #ifdef  UG31XX_SHELL_ALGORITHM
+    obj = (MeasDataInternalType *)upi_malloc(sizeof(MeasDataInternalType));
+  #else   ///< else of UG31XX_SHELL_ALGORITHM
+    obj = &measData;
+  #endif  ///< end of UG31XX_SHELL_ALGORITHM
+  upi_memset(obj, 0x00, sizeof(MeasDataInternalType));
+
+  obj->info = data;
+  obj->info->fetchRetryCnt = MEAS_MAXIMUM_ROUTINE_RETRY_CNT;
+
+  rtn = MEAS_RTN_PASS;
+
+  /// [AT-PM] : Get ADC code ; 06/04/2013
+  rtn = FetchAdcCode(obj);
+  if((select == MEAS_SEL_ALL) || (select == MEAS_SEL_INITIAL))
+  {
+  UG31_LOGE("[%s]: (%d-%d) V=%d, I=%d, IT=%d, ET=%d, CH=%d, CT=%d, %02x%02x %02x%02x%02x%02x %02x%02x%02x %02x%02x %02x%02x %02x%02x\n", __func__,
+              select, obj->info->fetchRetryCnt, obj->codeBat1, obj->codeCurrent,
+              obj->codeIntTemperature, obj->codeExtTemperature, obj->codeCharge, obj->codeCounter,
+              obj->reg14, obj->reg9C,
+              obj->regC5, obj->regC6, obj->regC7, obj->regC8,
+              obj->regC9, obj->regCA, obj->regCB,
+              obj->reg0A, obj->reg0B,
+              obj->reg50, obj->reg51,
+              obj->reg9B, obj->reg9E);
+  }
+  else
+  {
+  UG31_LOGI("[%s]: (%d-%d) V=%d, I=%d, IT=%d, ET=%d, CH=%d, CT=%d, %02x%02x %02x%02x%02x%02x %02x%02x%02x %02x%02x %02x%02x %02x%02x\n", __func__,
+              select, obj->info->fetchRetryCnt, obj->codeBat1, obj->codeCurrent,
+              obj->codeIntTemperature, obj->codeExtTemperature, obj->codeCharge, obj->codeCounter,
+              obj->reg14, obj->reg9C,
+              obj->regC5, obj->regC6, obj->regC7, obj->regC8,
+              obj->regC9, obj->regCA, obj->regCB,
+              obj->reg0A, obj->reg0B,
+              obj->reg50, obj->reg51,
+              obj->reg9B, obj->reg9E);
+  }
+  if(rtn != MEAS_RTN_PASS)
+  {
+    #ifdef  UG31XX_SHELL_ALGORITHM
+      upi_free(obj);
+    #endif  ///< end of UG31XX_SHELL_ALGORITHM
+    return (rtn);
+  }
+
+  /// [AT-PM] : IIR filter ; 04/15/2014
+  FilterBat1Code(obj);
+  FilterBat2Code(obj);
+  FilterBat3Code(obj);
+  FilterITCode(obj);
+
+  /// [AT-PM] : Get delta time ; 01/25/2013
+  if((select == MEAS_SEL_ALL) || (select == MEAS_SEL_INITIAL))
+  {
+    TimeTick(obj);
+    obj->info->deltaTimeDaemon = obj->info->deltaTimeDaemon + obj->info->deltaTime;
+  }
+
+  if((select == MEAS_SEL_ALL) || (select == MEAS_SEL_CURRENT) || (select == MEAS_SEL_INITIAL))
+  {
+    /// [AT-PM] : Convert ADC characteristic from OTP ; 01/23/2013
+    ConvertAdc1Data(obj);
+
+    /// [FC] : Record ADC code ; 05/15/2013
+    data->adc1CodeT25V100 = obj->adc1CodeT25V100;
+    data->adc1CodeT25V200 = obj->adc1CodeT25V200;
+
+    /// [AT-PM] : Calculate ADC gain and offset ; 01/23/2013
+    CalAdc1Factors(obj);
+  }
+  if((select == MEAS_SEL_ALL) || (select == MEAS_SEL_VOLTAGE) || (select == MEAS_SEL_INITIAL))
+  {
+    /// [AT-PM] : Convert ADC characteristic from OTP ; 01/23/2013
+    ConvertAdc2Data(obj);
+
+    /// [FC] : Record ADC code ; 05/15/2013
+    data->adc2CodeT25V100 = obj->adc2CodeT25V100;
+    data->adc2CodeT25V200 = obj->adc2CodeT25V200;
+
+    /// [AT-PM] : Calculate ADC gain and offset ; 01/23/2013
+    CalAdc2Factors(obj);
+  }
+
+  /// [AT-PM] : Calibrate ADC code ; 01/23/2013
+  if((select == MEAS_SEL_ALL) || (select == MEAS_SEL_VOLTAGE) || (select == MEAS_SEL_INITIAL))
+  {
+    data->codeBat1 = (_meas_u16_)CalibrateAdc2Code(obj, (_meas_s32_)obj->info->filterBat1, obj->info->adc2Gain, obj->info->adc2Offset);
+    if(obj->codeBat2 > 0x00)
+    {
+      data->codeBat2 = (_meas_u16_)CalibrateAdc2Code(obj, (_meas_s32_)obj->info->filterBat2, obj->info->adc2Gain, obj->info->adc2Offset);
+    }
+    else
+    {
+      data->codeBat2 = obj->codeBat2;
+    }
+
+    if(obj->codeBat3 > 0x00)
+    {
+    data->codeBat3 = (_meas_u16_)CalibrateAdc2Code(obj, (_meas_s32_)obj->info->filterBat3, obj->info->adc2Gain, obj->info->adc2Offset);
+    }
+    else
+    {
+      data->codeBat3 = obj->codeBat3;
+    }
+    UG31_LOGN("[%s]: VBat1 Code = %d -> %d\n", __func__, obj->info->filterBat1, data->codeBat1);
+  }
+  if((select == MEAS_SEL_ALL) || (select == MEAS_SEL_CURRENT) || (select == MEAS_SEL_INITIAL))
+  {
+    data->codeCurrent = (_meas_s16_)CalibrateAdc1Code(obj, (_meas_s32_)obj->codeCurrent);
+    UG31_LOGN("[%s]: Current Code = %d -> %d\n", __func__, obj->codeCurrent, data->codeCurrent);
+  }
+  if((select == MEAS_SEL_ALL) || (select == MEAS_SEL_INITIAL))
+  {
+    CalibrateChargeCode(obj);
+  }
+  if((select == MEAS_SEL_ALL) || (select == MEAS_SEL_INT_TEMP) || (select == MEAS_SEL_INITIAL))
+  {
+    data->codeIntTemperature = CalibrateITCode(obj, obj->info->filterIntTemperature);
+    UG31_LOGN("[%s]: Internal Temperature Code = %d -> %d\n", __func__,
+              obj->info->filterIntTemperature, data->codeIntTemperature);
+  }
+  if((select == MEAS_SEL_ALL) || (select == MEAS_SEL_EXT_TEMP) || (select == MEAS_SEL_INITIAL))
+  {
+    data->codeExtTemperature = CalibrateETCode(obj);
+    UG31_LOGN("[%s]: External Temperature Code = %d -> %d\n", __func__, obj->codeExtTemperature, data->codeExtTemperature);
+  }
+
+  /// [AT-PM] : Convert into physical value ; 01/23/2013
+  if((select == MEAS_SEL_ALL) || (select == MEAS_SEL_VOLTAGE) || (select == MEAS_SEL_INITIAL))
+  {
+    ConvertBat1(obj);
+    ConvertBat2(obj);
+    ConvertBat3(obj);
+
+    if((select == MEAS_SEL_INITIAL) || (MEAS_IN_SUSPEND_MODE(obj->info->status) == _UPI_TRUE_))
+    {
+      obj->info->bat1VoltageAvg = obj->info->bat1Voltage;
+      obj->info->bat2VoltageAvg = obj->info->bat2Voltage;
+      obj->info->bat3VoltageAvg = obj->info->bat3Voltage;
+    }
+    else
+    {
+      obj->info->bat1VoltageAvg = (_meas_u16_)AvgVoltage(obj->info->bat1Voltage, obj->info->bat1VoltageAvg);
+      obj->info->bat2VoltageAvg = (_meas_u16_)AvgVoltage(obj->info->bat2Voltage, obj->info->bat2VoltageAvg);
+      obj->info->bat3VoltageAvg = (_meas_u16_)AvgVoltage(obj->info->bat3Voltage, obj->info->bat3VoltageAvg);
+
+      UG31_LOGN("[%s]: Average voltage = %d (%d)\n", __func__,
+                obj->info->bat1VoltageAvg,
+                obj->info->bat1Voltage);
+    }
+  }
+  if((select == MEAS_SEL_ALL) || (select == MEAS_SEL_CURRENT) || (select == MEAS_SEL_INITIAL))
+  {
+    ConvertCurrent(obj);
+
+    if((select == MEAS_SEL_INITIAL) || (MEAS_IN_SUSPEND_MODE(obj->info->status) == _UPI_TRUE_))
+    {
+      obj->info->currAvg = obj->info->curr;
+    }
+    else
+    {
+      tmp32 = (_meas_s32_)obj->info->curr;
+      tmp32 = tmp32 + obj->info->currAvg;
+      tmp32 = tmp32/2;
+      obj->info->currAvg = (_meas_u16_)tmp32;
+      UG31_LOGN("[%s]: Average current = %d (%d)\n", __func__,
+                obj->info->currAvg,
+                obj->info->curr);
+    }
+  }
+  if((select == MEAS_SEL_ALL) || (select == MEAS_SEL_INT_TEMP) || (select == MEAS_SEL_INITIAL))
+  {
+    ConvertIntTemperature(obj);
+
+    #ifdef  MEAS_FAKE_INT_TEMP
+      data->extTemperature = data->intTemperature;
+      data->intTemperature = MEAS_FAKE_INT_TEMP_OFFSET + data->intTemperature%100;
+    #endif  ///< end of MEAS_FAKE_INT_TEMP
+  }
+  if((select == MEAS_SEL_ALL) || (select == MEAS_SEL_EXT_TEMP) || (select == MEAS_SEL_INITIAL))
+  {
+    /// [AT-PM] : Convert instant external temperature ; 11/27/2013
+    tmp16 = obj->info->codeExtTemperature;
+    obj->info->codeExtTemperature = obj->info->codeInstExtTemperature;
+    ConvertExtTemperature(obj);
+    obj->info->instExtTemperature = obj->info->extTemperature;
+    /// [AT-PM] : Convert average external temperature ; 11/27/2013
+    obj->info->codeExtTemperature = tmp16;
+    ConvertExtTemperature(obj);
+  }
+  if((select == MEAS_SEL_ALL) || (select == MEAS_SEL_INITIAL))
+  {
+    ConvertCharge(obj);
+
+    /// [AT-PM] : Count cycle count ; 10/08/2013
+    CountCycleCount(obj);
+
+    /// [AT-PM] : Count cumulative capacity ; 02/18/2014
+    CountCumuCap(obj);
+
+    /// [AT-PM] : Calculate coulomb counter offset ; 09/24/2013
+    CalculateCCOffset(obj);
+
+    /// [AT-PM] : Reset coulomb counter if necessary ; 01/27/2013
+    standbyUpper = (_meas_s16_)ptrCellParameter->standbyCurrent;
+    standbyUpper = standbyUpper/RESET_CC_CURRENT_MAGIC_NUMBER;
+    standbyLower = standbyUpper*(-1);
+    if((obj->codeCharge > COULOMB_COUNTER_RESET_THRESHOLD_CHARGE_CHG) ||
+       (obj->codeCharge < COULOMB_COUNTER_RESET_THREDHOLD_CHARGE_DSG) ||
+#ifdef  UG31XX_RESET_CC_IN_STANDBY
+       ((obj->info->curr < standbyUpper) &&
+        (obj->info->curr > standbyLower) &&
+        (obj->info->deltaCap != 0)) ||
+#endif  ///< end of UG31XX_RESET_CC_IN_STANDBY
+       (obj->info->deltaTime > RESET_CC_DELTA_TIME))
+    {
+      UG31_LOGN("[%s]: Reset coulomb counter (%d - %d - %d - %d)\n", __func__,
+                obj->codeCharge,
+                obj->info->curr,
+                obj->info->deltaCap,
+                obj->info->deltaTime);
+      ResetCoulombCounter(obj);
+      data->lastDeltaCap = 0;
+
+      /// [AT-PM] : Read ADC code ; 01/27/2013
+      FetchAdcCode(obj);
+      obj->info->lastCounter = obj->codeCounter;
+    }
+  }
+
+  UG31_LOGI("[%s]: %d mV / %d mA / %d 0.1oC / %d 0.1oC / %d mAh\n", __func__,
+            data->bat1Voltage, data->curr, data->intTemperature, data->extTemperature, data->deltaCap);
+  #ifdef  UG31XX_SHELL_ALGORITHM
+    upi_free(obj);
+  #endif  ///< end of UG31XX_SHELL_ALGORITHM
+  return (rtn);
+}
+
+/**
+ * @brief UpiMeasAlarmThreshold
+ *
+ *  Get alarm threshold
+ *
+ * @para  data  address of MeasDataType
+ * @return  MEAS_RTN_CODE
+ */
+MEAS_RTN_CODE UpiMeasAlarmThreshold(MeasDataType *data)
+{
+  MEAS_RTN_CODE rtn;
+
+  rtn = MEAS_RTN_PASS;
+
+  /// [AT-PM] : Calculate UV alarm and release threshold ; 04/08/2013
+  ptrSysData->uvAlarm.alarmThrd = RevertBat1Code(data, ptrCellParameter->uvAlarm);
+  ptrSysData->uvAlarm.releaseThrd = RevertBat1Code(data, ptrCellParameter->uvRelease);
+  UG31_LOGN("[%s]: UV Alarm -> %d / %d\n", __func__,
+            ptrSysData->uvAlarm.alarmThrd, ptrSysData->uvAlarm.releaseThrd);
+
+  /// [AT-PM] : Calculate UET alarm and release threshold ; 04/08/2013
+  ptrSysData->uetAlarm.alarmThrd = RevertETCode(data, ptrCellParameter->uetAlarm);
+  ptrSysData->uetAlarm.releaseThrd = RevertETCode(data, ptrCellParameter->uetRelease);
+  UG31_LOGN("[%s]: UET Alarm -> %d / %d\n", __func__,
+            ptrSysData->uetAlarm.alarmThrd, ptrSysData->uetAlarm.releaseThrd);
+
+  /// [AT-PM] : Calculate OET alarm and release threshold ; 04/08/2013
+  ptrSysData->oetAlarm.alarmThrd = RevertETCode(data, ptrCellParameter->oetAlarm);
+  ptrSysData->oetAlarm.releaseThrd = RevertETCode(data, ptrCellParameter->oetRelease);
+  UG31_LOGN("[%s]: OET Alarm -> %d / %d\n", __func__,
+            ptrSysData->oetAlarm.alarmThrd, ptrSysData->oetAlarm.releaseThrd);
+
+  return (rtn);
+}
+
+/**
+ * @brief UpiMeasReadCode
+ *
+ *  Read ADC code
+ *
+ * @para  data  address of MeasDataType
+ * @return  MEAS_RTN_CODE
+ */
+MEAS_RTN_CODE UpiMeasReadCode(MeasDataType *data)
+{
+  MEAS_RTN_CODE rtn;
+  MeasDataInternalType *obj;
+
+  #ifdef  UG31XX_SHELL_ALGORITHM
+    obj = (MeasDataInternalType *)upi_malloc(sizeof(MeasDataInternalType));
+  #else   ///< else of UG31XX_SHELL_ALGORITHM
+    obj = &measData;
+  #endif  ///< end of UG31XX_SHELL_ALGORITHM
+  upi_memset(obj, 0x00, sizeof(MeasDataInternalType));
+
+  obj->info = data;
+  obj->info->fetchRetryCnt = MEAS_MAXIMUM_INITIAL_RETRY_CNT;
+
+  rtn = FetchAdcCode(obj);
+
+  #ifdef  UG31XX_SHELL_ALGORITHM
+    upi_free(obj);
+  #endif  ///< end of UG31XX_SHELL_ALGORITHM
+  return (rtn);
+}
+
+/**
+ * @brief UpiGetMeasurementMemorySize
+ *
+ *  Get memory size used by measurement
+ *
+ * @return  memory size
+ */
+_meas_u32_ UpiGetMeasurementMemorySize(void)
+{
+  _meas_u32_ totalSize;
+
+  #ifndef UG31XX_SHELL_ALGORITHM
+
+  totalSize = (_meas_u32_)sizeof(measData);
+  UG31_LOGD("[%s]: memory size for measData = %d\n", __func__, (int)totalSize);
+
+  #else   ///< else of UG31XX_SHELL_ALGORITHM
+
+  totalSize = 0;
+
+  #endif  ///< end of UG31XX_SHELL_ALGORITHM
+
+  return (totalSize);
+}
+
+/**
+ * @brief UpiPrintMeasurementVersion
+ *
+ *  Print measurement module version
+ *
+ * @return  NULL
+ */
+void UpiPrintMeasurementVersion(void)
+{
+  UG31_LOGE("[%s]: %s\n", __func__,
+            MEASUREMENT_VERSION);
+}
+
+
+/**
+ * Copyright @ 2013 uPI Semiconductor Corp. All right reserved.
+ * The information, images, and/or data contained in this material is copyrighted by uPI
+ * Semiconductor Corp., and may not be distributed, modified, reproduced in whole or in part
+ * without the prior, written consent of uPI Semiconductor Corp.
+ */
diff --git a/drivers/power/supply/ASUS_BATTERY/ME176C/ug31xx/uG31xx_API_Measurement.h b/drivers/power/supply/ASUS_BATTERY/ME176C/ug31xx/uG31xx_API_Measurement.h
new file mode 100644
index 000000000000..5c6ddaf4a026
--- /dev/null
+++ b/drivers/power/supply/ASUS_BATTERY/ME176C/ug31xx/uG31xx_API_Measurement.h
@@ -0,0 +1,217 @@
+/**
+ * @filename  uG31xx_API_Measurement.h
+ *
+ *  Header for uG31xx measurement API
+ *
+ * @author  AllenTeng <allen_teng@upi-semi.com>
+ * @revision  $Revision: 107 $
+ */
+
+typedef signed char       _meas_s8_;
+typedef unsigned char     _meas_u8_;
+typedef signed short      _meas_s16_;
+typedef unsigned short    _meas_u16_;
+typedef signed int       _meas_s32_;
+typedef unsigned int     _meas_u32_;
+typedef signed long long  _meas_s64_;
+typedef char              _meas_bool_;
+
+#define CALIBRATION_FACTOR_CONST    (1000)
+
+#define TIME_DEFAULT_ADC1_CONVERT_TIME        (1253)
+
+#define MEAS_STATUS_IN_SUSPEND_MODE           (1<<0)
+#define MEAS_STATUS_REVERSE_CURRENT_DIRECTION (1<<1)
+#define MEAS_STATUS_NTC_OPEN                  (1<<2)
+#define MEAS_STATUS_NTC_SHORT                 (1<<3)
+#define MEAS_STATUS_REFER_ET                  (1<<4)
+#define MEAS_STATUS_CABLE_OUT                 (1<<5)
+#define MEAS_STATUS_LAST_IN_SUSPEND_MODE      (1<<6)
+
+#define MEAS_IN_SUSPEND_MODE(x)           ((x & MEAS_STATUS_IN_SUSPEND_MODE) ? _UPI_TRUE_ : _UPI_FALSE_)
+#define MEAS_REVERSE_CURRENT_DIRECTION(x) ((x & MEAS_STATUS_REVERSE_CURRENT_DIRECTION) ? _UPI_TRUE_ : _UPI_FALSE_)
+#define MEAS_NTC_OPEN(x)                  ((x & MEAS_STATUS_NTC_OPEN) ? _UPI_TRUE_ : _UPI_FALSE_)
+#define MEAS_NTC_SHORT(x)                 ((x & MEAS_STATUS_NTC_SHORT) ? _UPI_TRUE_ : _UPI_FALSE_)
+#define MEAS_CABLE_OUT(x)                 ((x & MEAS_STATUS_CABLE_OUT) ? _UPI_TRUE_ : _UPI_FALSE_)
+#define MEAS_LEAVE_SUSPEND_MODE(x)        (((x & MEAS_STATUS_LAST_IN_SUSPEND_MODE) && (!(x & MEAS_STATUS_IN_SUSPEND_MODE))) ? _UPI_TRUE_ : _UPI_FALSE_)
+
+#define MEAS_MAXIMUM_INITIAL_RETRY_CNT      (40)
+#define MEAS_MAXIMUM_ROUTINE_RETRY_CNT      (3)
+/// [FC] : Add variable MPK_active for MPK intial ; 12/10/2013
+extern _upi_bool_ MPK_active;
+
+typedef enum _MEAS_RTN_CODE {
+  MEAS_RTN_PASS = 0,
+  MEAS_RTN_BATTERY_REMOVED,
+  MEAS_RTN_ADC_ABNORMAL,
+  MEAS_RTN_NTC_SHORT,
+} MEAS_RTN_CODE;
+
+typedef enum _MEAS_SEL_CODE {
+  MEAS_SEL_ALL = 0,
+  MEAS_SEL_VOLTAGE,
+  MEAS_SEL_CURRENT,
+  MEAS_SEL_EXT_TEMP,
+  MEAS_SEL_INT_TEMP,
+  MEAS_SEL_INITIAL,
+} MEAS_SEL_CODE;
+
+typedef struct MeasDataST {
+
+  /// [AT-PM] : Physical value ; 01/23/2013
+  _meas_u16_ bat1Voltage;
+  _meas_u16_ bat2Voltage;
+  _meas_u16_ bat3Voltage;
+  _meas_u16_ bat1VoltageAvg;
+  _meas_u16_ bat2VoltageAvg;
+  _meas_u16_ bat3VoltageAvg;
+  _meas_s16_ curr;
+  _meas_s16_ currAvg;
+  _meas_s16_ intTemperature;
+  _meas_s16_ extTemperature;
+  _meas_s16_ instExtTemperature;
+  _meas_s16_ deltaCap;
+  _meas_s16_ stepCap;
+  _meas_s32_ cumuCap;
+  _meas_u32_ deltaTime;
+  _meas_u32_ deltaTimeDaemon;
+
+  /// [AT-PM] : ADC code ; 01/23/2013
+  _meas_u16_ codeBat1;
+  _meas_u16_ codeBat2;
+  _meas_u16_ codeBat3;
+  _meas_s16_ codeCurrent;
+  _meas_u16_ codeIntTemperature;
+  _meas_u16_ codeExtTemperature;
+  _meas_u16_ codeInstExtTemperature;
+  _meas_s32_ codeCharge;
+
+  /// [AT-PM] : ADC code filter ; 04/15/2014
+  _meas_u32_ filterSumBat1;
+  _meas_u32_ filterSumBat2;
+  _meas_u32_ filterSumBat3;
+  _meas_u32_ filterSumIntTemperature;
+  _meas_u8_ filterCntBat1;
+  _meas_u8_ filterCntBat2;
+  _meas_u8_ filterCntBat3;
+  _meas_u8_ filterCntIntTemperature;
+  _meas_u16_ filterBat1;
+  _meas_u16_ filterBat2;
+  _meas_u16_ filterBat3;
+  _meas_u16_ filterIntTemperature;
+
+  /// [AT-PM] : Coulomb counter offset ; 01/23/2013
+  _meas_s16_ ccOffset;
+  _meas_s8_ ccOffsetAdj;
+
+  /// [AT-PM] : ADC1 characteristic ; 01/23/2013
+  _meas_u16_ adc1ConvertTime;
+  _meas_s32_ adc1Gain;
+  _meas_s32_ adc1GainSlope;
+  _meas_s32_ adc1GainFactorB;
+  _meas_s32_ adc1Offset;
+  _meas_s32_ adc1OffsetSlope;
+  _meas_s32_ adc1OffsetFactorO;
+
+  /// [AT-PM] : ADC2 characteristic ; 01/23/2013
+  _meas_s32_ adc2Gain;
+  _meas_s32_ adc2GainSlope;
+  _meas_s32_ adc2GainFactorB;
+  _meas_s32_ adc2Offset;
+  _meas_s32_ adc2OffsetSlope;
+  _meas_s32_ adc2OffsetFactorO;
+
+  _meas_s32_ adc2Vbat2Gain;
+  _meas_s32_ adc2Vbat2Offset;
+  _meas_s32_ adc2Vbat3Gain;
+  _meas_s32_ adc2Vbat3Offset;
+
+  /// [AT-PM] : Previous information ; 01/25/2013
+  _meas_u16_ lastCounter;
+  _meas_u32_ lastTimeTick;
+  _meas_s16_ lastDeltaCap;
+
+  /// [FC] : Record ADC code ; 05/15/2013
+  _meas_s16_ adc1CodeT25V100;
+  _meas_s16_ adc1CodeT25V200;
+  _meas_s16_ adc2CodeT25V100;
+  _meas_s16_ adc2CodeT25V200;
+  _meas_u16_ codeBat1BeforeCal;
+  _meas_u16_ codeBat2BeforeCal;
+  _meas_u16_ codeBat3BeforeCal;
+  _meas_s16_ codeCurrentBeforeCal;
+  _meas_u16_ codeIntTemperatureBeforeCal;
+  _meas_u16_ codeExtTemperatureBeforeCal;
+  _meas_s16_ codeChargeBeforeCal;
+  _meas_s16_ codeCCOffset;
+
+  /// [AT-PM] : Operation control ; 11/12/2013
+  _meas_u32_ status;
+  _meas_u8_ fetchRetryCnt;
+
+  /// [AT-PM] : Cycle count operation ; 10/08/2013
+  _meas_s32_ cycleCountBuf;
+  _meas_u16_ cycleCount;
+} ALIGNED_ATTRIBUTE MeasDataType;
+
+extern MeasDataType *ptrMeasData;
+
+/**
+ * @brief UpiResetCoulombCounter
+ *
+ *  Reset coulomb counter
+ *
+ * @para  data  address of MeasDataType
+ * @return  _UPI_NULL_
+ */
+extern void UpiResetCoulombCounter(MeasDataType *data);
+
+/**
+ * @brief UpiMeasurement
+ *
+ *  Measurement routine
+ *
+ * @para  data  address of MeasDataType
+ * @para  select  MEAS_SEL_CODE
+ * @return  MEAS_RTN_CODE
+ */
+extern MEAS_RTN_CODE UpiMeasurement(MeasDataType *data, MEAS_SEL_CODE select);
+
+/**
+ * @brief UpiMeasAlarmThreshold
+ *
+ *  Get alarm threshold
+ *
+ * @para  data  address of MeasDataType
+ * @return  MEAS_RTN_CODE
+ */
+extern MEAS_RTN_CODE UpiMeasAlarmThreshold(MeasDataType *data);
+
+/**
+ * @brief UpiMeasReadCode
+ *
+ *  Read ADC code
+ *
+ * @para  data  address of MeasDataType
+ * @return  MEAS_RTN_CODE
+ */
+extern MEAS_RTN_CODE UpiMeasReadCode(MeasDataType *data);
+
+/**
+ * @brief UpiGetMeasurementMemorySize
+ *
+ *  Get memory size used by measurement
+ *
+ * @return  memory size
+ */
+extern _meas_u32_ UpiGetMeasurementMemorySize(void);
+
+/**
+ * @brief UpiPrintMeasurementVersion
+ *
+ *  Print measurement module version
+ *
+ * @return  NULL
+ */
+extern void UpiPrintMeasurementVersion(void);
+
diff --git a/drivers/power/supply/ASUS_BATTERY/ME176C/ug31xx/uG31xx_API_Otp.c b/drivers/power/supply/ASUS_BATTERY/ME176C/ug31xx/uG31xx_API_Otp.c
new file mode 100644
index 000000000000..5ae410220d91
--- /dev/null
+++ b/drivers/power/supply/ASUS_BATTERY/ME176C/ug31xx/uG31xx_API_Otp.c
@@ -0,0 +1,952 @@
+/**
+ * Copyright @ 2013 uPI Semiconductor Corp. All right reserved.
+ * The information, images, and/or data contained in this material is copyrighted by uPI
+ * Semiconductor Corp., and may not be distributed, modified, reproduced in whole or in part
+ * without the prior, written consent of uPI Semiconductor Corp.
+ */
+
+/**
+ * @filename  uG31xx_API_Otp.cpp
+ *
+ *  Convert OTP registers into readable value
+ *
+ * @author  AllenTeng <allen_teng@upi-semi.com>
+ * @revision  $Revision: 107 $
+ */
+
+#include "stdafx.h"     //windows need this??
+#include "uG31xx_API.h"
+
+#ifdef  uG31xx_OS_WINDOWS
+
+  #define OTP_VERSION      (_T("OTP $Rev: 107 $ "))
+
+#else   ///< else of uG31xx_OS_WINDOWS
+
+  #define OTP_VERSION      ("OTP $Rev: 107 $ ")
+
+#endif  ///< end of uG31xx_OS_WINDOWS
+
+/// =============================================
+/// [AT-PM] : OTP register definition
+/// =============================================
+
+#define OTP1_OFFSET_E0                (0)
+  #define INDEX_ADC1_200_25_0         (1<<0)
+  #define INDEX_ADC1_200_25_1         (1<<1)
+  #define INDEX_ADC1_200_25_2         (1<<2)
+  #define INDEX_ADC1_200_25_3         (1<<3)
+  #define DELTA_VREF_0                (1<<4)
+  #define DELTA_VREF_1                (1<<5)
+  #define DELTA_VREF_2                (1<<6)
+  #define DELTA_VREF_3                (1<<7)
+
+#define OTP1_OFFSET_E1                (OTP1_OFFSET_E0 + 1)
+  #define INDEX_ADC1_100_25_0         (1<<0)
+  #define INDEX_ADC1_100_25_1         (1<<1)
+  #define INDEX_ADC1_100_25_2         (1<<2)
+  #define INDEX_ADC1_100_25_3         (1<<3)
+  #define FT_IT_3                     (1<<4)
+  #define FT_IT_4                     (1<<5)
+  #define FT_IT_5                     (1<<6)
+  #define FT_IT_6                     (1<<7)
+
+#define OTP1_OFFSET_E2                (OTP1_OFFSET_E1 + 1)
+  #define INDEX_ADC2_200_25_0         (1<<0)
+  #define INDEX_ADC2_200_25_1         (1<<1)
+  #define INDEX_ADC2_200_25_2         (1<<2)
+  #define INDEX_ADC2_200_25_3         (1<<3)
+  #define FT_IT_7                     (1<<4)
+  #define FT_IT_8                     (1<<5)
+  #define FT_IT_9                     (1<<6)
+  #define FT_IT_10                    (1<<7)
+
+#define OTP1_OFFSET_E3                (OTP1_OFFSET_E2 + 1)
+  #define INDEX_ADC2_100_25_0         (1<<0)
+  #define INDEX_ADC2_100_25_1         (1<<1)
+  #define INDEX_ADC2_100_25_2         (1<<2)
+  #define INDEX_ADC2_100_25_3         (1<<3)
+  #define FT_IT_11                    (1<<4)
+  #define FT_IT_12                    (1<<5)
+  #define FT_IT_13                    (1<<6)
+  #define FT_IT_14                    (1<<7)
+
+#define OTP2_OFFSET_F0                (0)
+  #define OTP2_OFFSET_F0_RSVD_0       (1<<0)
+  #define OTP2_OFFSET_F0_RSVD_1       (1<<1)
+  #define OTP2_OFFSET_F0_RSVD_2       (1<<2)
+  #define PRODUCT_TYPE_0              (1<<3)
+  #define PRODUCT_TYPE_1              (1<<4)
+  #define DELTA_ET_0                  (1<<5)
+  #define INDEX_ADC2_100_25_4         (1<<6)
+  #define DELTA_ET_1                  (1<<7)
+
+#define OTP2_OFFSET_F1                (OTP2_OFFSET_F0 + 1)
+  #define OTP2_OFFSET_F1_RSVD_0       (1<<0)
+  #define OTP2_OFFSET_F1_RSVD_1       (1<<1)
+  #define OTP2_OFFSET_F1_RSVD_2       (1<<2)
+  #define OTP2_OFFSET_F1_RSVD_3       (1<<3)
+  #define OTP2_OFFSET_F1_RSVD_4       (1<<4)
+  #define OTP2_OFFSET_F1_RSVD_5       (1<<5)
+  #define OTP2_OFFSET_F1_RSVD_6       (1<<6)
+  #define OTP2_OFFSET_F1_RSVD_7       (1<<7)
+
+#define OTP2_OFFSET_F2                (OTP2_OFFSET_F1 + 1)
+  #define OTP2_OFFSET_F2_RSVD_0       (1<<0)
+  #define OTP2_OFFSET_F2_RSVD_1       (1<<1)
+  #define OTP2_OFFSET_F2_RSVD_2       (1<<2)
+  #define OTP_CELL_EN_0               (1<<3)
+  #define OTP_CELL_EN_1               (1<<4)
+  #define OTP_CELL_EN_2               (1<<5)
+  #define OTP_CELL_EN_3               (1<<6)
+  #define OTP_CELL_EN_4               (1<<7)
+
+#define OTP2_OFFSET_F3                (OTP2_OFFSET_F2 + 1)
+  #define OTP2_OFFSET_F3_RSVD_0       (1<<0)
+  #define OTP2_OFFSET_F3_RSVD_1       (1<<1)
+  #define OTP2_OFFSET_F3_RSVD_2       (1<<2)
+  #define OTP2_OFFSET_F3_RSVD_3       (1<<3)
+  #define OTP2_OFFSET_F3_RSVD_4       (1<<4)
+  #define OTP2_OFFSET_F3_RSVD_5       (1<<5)
+  #define OTP2_OFFSET_F3_RSVD_6       (1<<6)
+  #define OTP2_OFFSET_F3_RSVD_7       (1<<7)
+
+#define OTP2_OFFSET_F4                (OTP2_OFFSET_F3 + 1)
+  #define ADC1_DELTA_CODE_25_200MV_8  (1<<0)
+  #define ADC1_DELTA_CODE_25_200MV_9  (1<<1)
+  #define DEV_ADDR_0                  (1<<2)
+  #define DEV_ADDR_1                  (1<<3)
+  #define DEV_ADDR_2                  (1<<4)
+  #define DEV_ADDR_7                  (1<<5)
+  #define DEV_ADDR_8                  (1<<6)
+  #define DEV_ADDR_9                  (1<<7)
+
+#define OTP2_OFFSET_F5                (OTP2_OFFSET_F4 + 1)
+  #define OTP2_OFFSET_F5_RSVD_0       (1<<0)
+  #define OTP2_OFFSET_F5_RSVD_1       (1<<1)
+  #define BGR_TUNE_0                  (1<<2)
+  #define BGR_TUNE_1                  (1<<3)
+  #define BGR_TUNE_2                  (1<<4)
+  #define BGR_TUNE_3                  (1<<5)
+  #define BGR_TUNE_4                  (1<<6)
+  #define BGR_TUNE_5                  (1<<7)
+
+#define OTP2_OFFSET_F6                (OTP2_OFFSET_F5 + 1)
+  #define OSC_DELTA_CODE_25_0         (1<<0)
+  #define OSC_DELTA_CODE_25_1         (1<<1)
+  #define OSC_DELTA_CODE_25_2         (1<<2)
+  #define OSC_DELTA_CODE_25_3         (1<<3)
+  #define OSC_DELTA_CODE_25_4         (1<<4)
+  #define OSC_DELTA_CODE_25_5         (1<<5)
+  #define OSC_DELTA_CODE_25_6         (1<<6)
+  #define OSC_DELTA_CODE_25_7         (1<<7)
+
+#define OTP2_OFFSET_F7                (OTP2_OFFSET_F6 + 1)
+  #define OSC_DELTA_CODE_80_0         (1<<0)
+  #define OSC_DELTA_CODE_80_1         (1<<1)
+  #define OSC_DELTA_CODE_80_2         (1<<2)
+  #define OSC_DELTA_CODE_80_3         (1<<3)
+  #define OSC_DELTA_CODE_80_4         (1<<4)
+  #define OSC_DELTA_CODE_80_5         (1<<5)
+  #define OSC_DELTA_CODE_80_6         (1<<6)
+  #define OSC_DELTA_CODE_80_7         (1<<7)
+
+#define OTP2_OFFSET_F8                (OTP2_OFFSET_F7 + 1)
+  #define ADC1_DELTA_CODE_25_200MV_0  (1<<0)
+  #define ADC1_DELTA_CODE_25_200MV_1  (1<<1)
+  #define ADC1_DELTA_CODE_25_200MV_2  (1<<2)
+  #define ADC1_DELTA_CODE_25_200MV_3  (1<<3)
+  #define ADC1_DELTA_CODE_25_200MV_4  (1<<4)
+  #define ADC1_DELTA_CODE_25_200MV_5  (1<<5)
+  #define ADC1_DELTA_CODE_25_200MV_6  (1<<6)
+  #define ADC1_DELTA_CODE_25_200MV_7  (1<<7)
+
+#define OTP2_OFFSET_F9                (OTP2_OFFSET_F8 + 1)
+  #define OTP2_OFFSET_F9_RSVD_0       (1<<0)
+  #define OTP2_OFFSET_F9_RSVD_1       (1<<1)
+  #define OTP2_OFFSET_F9_RSVD_2       (1<<2)
+  #define OTP2_OFFSET_F9_RSVD_3       (1<<3)
+  #define OTP2_OFFSET_F9_RSVD_4       (1<<4)
+  #define OTP2_OFFSET_F9_RSVD_5       (1<<5)
+  #define OTP2_OFFSET_F9_RSVD_6       (1<<6)
+  #define OTP2_OFFSET_F9_RSVD_7       (1<<7)
+
+#define OTP2_OFFSET_FA                (OTP2_OFFSET_F9 + 1)
+  #define ADC1_DELTA_CODE_25_100MV_0  (1<<0)
+  #define ADC1_DELTA_CODE_25_100MV_1  (1<<1)
+  #define ADC1_DELTA_CODE_25_100MV_2  (1<<2)
+  #define ADC1_DELTA_CODE_25_100MV_3  (1<<3)
+  #define ADC1_DELTA_CODE_25_100MV_4  (1<<4)
+  #define ADC1_DELTA_CODE_25_100MV_5  (1<<5)
+  #define ADC1_DELTA_CODE_25_100MV_6  (1<<6)
+  #define ADC1_DELTA_CODE_25_100MV_7  (1<<7)
+
+#define OTP2_OFFSET_FB                (OTP2_OFFSET_FA + 1)
+  #define OTP2_OFFSET_FB_RSVD_0       (1<<0)
+  #define OTP2_OFFSET_FB_RSVD_1       (1<<1)
+  #define OTP2_OFFSET_FB_RSVD_2       (1<<2)
+  #define OTP2_OFFSET_FB_RSVD_3       (1<<3)
+  #define OTP2_OFFSET_FB_RSVD_4       (1<<4)
+  #define OTP2_OFFSET_FB_RSVD_5       (1<<5)
+  #define OTP2_OFFSET_FB_RSVD_6       (1<<6)
+  #define OTP2_OFFSET_FB_RSVD_7       (1<<7)
+
+#define OTP2_OFFSET_FC                (OTP2_OFFSET_FB + 1)
+  #define ADC1_DELTA_CODE_25_100MV_8  (1<<0)
+  #define ADC2_DELTA_CODE_25_100MV_0  (1<<1)
+  #define ADC2_DELTA_CODE_25_100MV_1  (1<<2)
+  #define ADC2_DELTA_CODE_25_100MV_2  (1<<3)
+  #define ADC2_DELTA_CODE_25_100MV_3  (1<<4)
+  #define ADC2_DELTA_CODE_25_100MV_4  (1<<5)
+  #define ADC2_DELTA_CODE_25_100MV_5  (1<<6)
+  #define ADC2_DELTA_CODE_25_100MV_6  (1<<7)
+
+#define OTP2_OFFSET_FD                (OTP2_OFFSET_FC + 1)
+  #define OTP2_OFFSET_FD_RSVD_0       (1<<0)
+  #define OTP2_OFFSET_FD_RSVD_1       (1<<1)
+  #define OTP2_OFFSET_FD_RSVD_2       (1<<2)
+  #define OTP2_OFFSET_FD_RSVD_3       (1<<3)
+  #define OTP2_OFFSET_FD_RSVD_4       (1<<4)
+  #define OTP2_OFFSET_FD_RSVD_5       (1<<5)
+  #define OTP2_OFFSET_FD_RSVD_6       (1<<6)
+  #define OTP2_OFFSET_FD_RSVD_7       (1<<7)
+
+#define OTP2_OFFSET_FE                (OTP2_OFFSET_FD + 1)
+  #define ADC2_DELTA_CODE_25_200MV_0  (1<<0)
+  #define ADC2_DELTA_CODE_25_200MV_1  (1<<1)
+  #define ADC2_DELTA_CODE_25_200MV_2  (1<<2)
+  #define ADC2_DELTA_CODE_25_200MV_3  (1<<3)
+  #define ADC2_DELTA_CODE_25_200MV_4  (1<<4)
+  #define ADC2_DELTA_CODE_25_200MV_5  (1<<5)
+  #define ADC2_DELTA_CODE_25_200MV_6  (1<<6)
+  #define ADC2_DELTA_CODE_25_200MV_7  (1<<7)
+
+#define OTP2_OFFSET_FF                (OTP2_OFFSET_FE + 1)
+  #define OTP2_OFFSET_FF_RSVD_0       (1<<0)
+  #define OTP2_OFFSET_FF_RSVD_1       (1<<1)
+  #define OTP2_OFFSET_FF_RSVD_2       (1<<2)
+  #define OTP2_OFFSET_FF_RSVD_3       (1<<3)
+  #define OTP2_OFFSET_FF_RSVD_4       (1<<4)
+  #define OTP2_OFFSET_FF_RSVD_5       (1<<5)
+  #define OTP2_OFFSET_FF_RSVD_6       (1<<6)
+  #define OTP2_OFFSET_FF_RSVD_7       (1<<7)
+
+
+#define OTP3_OFFSET_70                (0)
+  #define DELTA_VREF_4                (1<<0)
+  #define DELTA_ET_2                  (1<<1)
+  #define DELTA_ET_3                  (1<<2)
+  #define AVE_IT_25_3                 (1<<3)
+  #define AVE_IT_25_4                 (1<<4)
+  #define AVE_IT_25_5                 (1<<5)
+  #define AVE_IT_25_6                 (1<<6)
+  #define AVE_IT_25_7                 (1<<7)
+
+#define OTP3_OFFSET_71                (OTP3_OFFSET_70 + 1)
+  #define AVE_IT_25_8                 (1<<0)
+  #define AVE_IT_25_9                 (1<<1)
+  #define AVE_IT_25_10                (1<<2)
+  #define AVE_IT_25_11                (1<<3)
+  #define AVE_IT_25_12                (1<<4)
+  #define AVE_IT_25_13                (1<<5)
+  #define AVE_IT_25_14                (1<<6)
+  #define AVE_IT_25_15                (1<<7)
+
+#define OTP3_OFFSET_72                (OTP3_OFFSET_71 + 1)
+  #define INDEX_ADC2_200_25_4         (1<<0)
+  #define INDEX_ADC1_100_25_4         (1<<1)
+  #define INDEX_ADC1_200_25_4         (1<<2)
+  #define AVE_IT_80_3                 (1<<3)
+  #define AVE_IT_80_4                 (1<<4)
+  #define AVE_IT_80_5                 (1<<5)
+  #define AVE_IT_80_6                 (1<<6)
+  #define AVE_IT_80_7                 (1<<7)
+
+#define OTP3_OFFSET_73                (OTP3_OFFSET_72 + 1)
+  #define AVE_IT_80_8                 (1<<0)
+  #define AVE_IT_80_9                 (1<<1)
+  #define AVE_IT_80_10                (1<<2)
+  #define AVE_IT_80_11                (1<<3)
+  #define AVE_IT_80_12                (1<<4)
+  #define AVE_IT_80_13                (1<<5)
+  #define AVE_IT_80_14                (1<<6)
+  #define AVE_IT_80_15                (1<<7)
+
+OtpDataType *ptrOtpData = _UPI_NULL_;
+
+/// =============================================
+/// [AT-PM] : OTP register conversion routine
+/// =============================================
+
+/**
+ * @brief ConvOtp1E0
+ *
+ *  Convert OTP1 0xE0
+ *
+ * @para  obj address of OtpDataType
+ * @return  _UPI_NULL_
+ */
+void ConvOtp1E0(OtpDataType *obj)
+{
+  _otp_u8_ value;
+
+  value = obj->otp1[OTP1_OFFSET_E0];
+	#ifdef	UPI_UBOOT_DEBUG_MSG
+		printf("[ConvOtp1E0] Initial value of indexAdc1V200T25 = %d\n");
+	#endif	///< end of UPI_UBOOT_DEBUG_MSG
+  obj->indexAdc1V200T25 = obj->indexAdc1V200T25 + (value & (INDEX_ADC1_200_25_0 |
+                                                            INDEX_ADC1_200_25_1 |
+                                                            INDEX_ADC1_200_25_2 |
+                                                            INDEX_ADC1_200_25_3));
+
+  obj->deltaVref = obj->deltaVref + ((value & (DELTA_VREF_0| DELTA_VREF_1 | DELTA_VREF_2 | DELTA_VREF_3)) >> 4);
+}
+
+/**
+ * @brief ConvOtp1E1
+ *
+ *  Convert OTP1 0xE1
+ *
+ * @para  obj address of OtpDataType
+ * @return  _UPI_NULL_
+ */
+void ConvOtp1E1(OtpDataType *obj)
+{
+  _otp_u8_ value;
+
+  value = obj->otp1[OTP1_OFFSET_E1];
+
+	#ifdef	UPI_UBOOT_DEBUG_MSG
+		printf("[ConvOtp1E1] Initial value of indexAdc1V100T25 = %d\n", obj->indexAdc1V100T25);
+	#endif	///< end of UPI_UBOOT_DEBUG_MSG
+  obj->indexAdc1V100T25 = obj->indexAdc1V100T25 + (value & (INDEX_ADC1_100_25_0 |
+                                                            INDEX_ADC1_100_25_1 |
+                                                            INDEX_ADC1_100_25_2 |
+                                                            INDEX_ADC1_100_25_3));
+
+  obj->ftIT = obj->ftIT + ((value & (FT_IT_3 | FT_IT_4 | FT_IT_5 | FT_IT_6)) >> 1);
+}
+
+/**
+ * @brief ConvOtp1E2
+ *
+ *  Convert OTP1 0xE2
+ *
+ * @para  obj address of OtpDataType
+ * @return  _UPI_NULL_
+ */
+void ConvOtp1E2(OtpDataType *obj)
+{
+  _otp_u8_ value;
+  _otp_u16_ tmp;
+
+  value = obj->otp1[OTP1_OFFSET_E2];
+
+	#ifdef	UiPI_UBOOT_DEBUG_MSG
+		printf("[ConvOtp1E2] Initial value of indexAdc2V200T25 = %d\n", obj->indexAdc2V200T25);
+	#endif	///< end of UiPI_UBOOT_DEBUG_MSG
+  obj->indexAdc2V200T25 = obj->indexAdc2V200T25 + (value & (INDEX_ADC2_200_25_0 |
+                                                            INDEX_ADC2_200_25_1 |
+                                                            INDEX_ADC2_200_25_2 |
+                                                            INDEX_ADC2_200_25_3));
+
+  tmp = (value & (FT_IT_7 | FT_IT_8 | FT_IT_9 | FT_IT_10));
+  obj->ftIT = obj->ftIT + (tmp << 3);
+}
+
+/**
+ * @brief ConvOtp1E3
+ *
+ *  Convert OTP1 0xE3
+ *
+ * @para  obj address of OtpDataType
+ * @return  _UPI_NULL_
+ */
+void ConvOtp1E3(OtpDataType *obj)
+{
+  _otp_u8_ value;
+  _otp_u16_ tmp;
+
+  value = obj->otp1[OTP1_OFFSET_E3];
+
+	#ifdef	UPI_UBOOT_DEBUG_MSG
+		printf("[ConvOtp1E3] Initial value of indexAdc2V100T25 = %d\n", obj->indexAdc2V100T25);
+	#endif	///< end of UPI_UBOOT_DEBUG_MSG
+  obj->indexAdc2V100T25 = obj->indexAdc2V100T25 + (value & (INDEX_ADC2_100_25_0 |
+                                                            INDEX_ADC2_100_25_1 |
+                                                            INDEX_ADC2_100_25_2 |
+                                                            INDEX_ADC2_100_25_3));
+
+  tmp = (value & (FT_IT_11 | FT_IT_12 | FT_IT_13 | FT_IT_14));
+  obj->ftIT = obj->ftIT + (tmp << 7);
+}
+
+/**
+ * @brief ConvOtp2F0
+ *
+ *  Convert OTP2 0xF0
+ *
+ * @para  obj address of OtpDataType
+ * @return  _UPI_NULL_
+ */
+void ConvOtp2F0(OtpDataType *obj)
+{
+  _otp_u8_ value;
+
+  value = obj->otp2[OTP2_OFFSET_F0];
+
+  obj->productType = (value & (PRODUCT_TYPE_0 | PRODUCT_TYPE_1)) >> 3;
+
+  obj->deltaET = obj->deltaET + ((value & DELTA_ET_0) >> 5) + ((value & DELTA_ET_1) >> 6);
+
+        #ifdef  UPI_UBOOT_DEBUG_MSG
+                printf("[ConvOtp2F0] Initial value of indexAdc2V100T25 = %d\n", obj->indexAdc2V100T25);
+        #endif  ///< end of UPI_UBOOT_DEBUG_MSG
+  obj->indexAdc2V100T25 = obj->indexAdc2V100T25 + ((value & INDEX_ADC2_100_25_4) >> 2);
+}
+
+/**
+ * @brief ConvOtp2F1
+ *
+ *  Convert OTP2 0xF1
+ *
+ * @para  obj address of OtpDataType
+ * @return  _UPI_NULL_
+ */
+void ConvOtp2F1(OtpDataType *obj)
+{
+}
+
+/**
+ * @brief ConvOtp2F2
+ *
+ *  Convert OTP2 0xF2
+ *
+ * @para  obj address of OtpDataType
+ * @return  _UPI_NULL_
+ */
+void ConvOtp2F2(OtpDataType *obj)
+{
+  _otp_u8_ value;
+
+  value = obj->otp2[OTP2_OFFSET_F2];
+
+  obj->otpCellEN = obj->otpCellEN + ((value & (OTP_CELL_EN_0 |
+                                               OTP_CELL_EN_1 |
+                                               OTP_CELL_EN_2 |
+                                               OTP_CELL_EN_3 |
+                                               OTP_CELL_EN_4)) >> 3);
+}
+
+/**
+ * @brief ConvOtp2F3
+ *
+ *  Convert OTP2 0xF3
+ *
+ * @para  obj address of OtpDataType
+ * @return  _UPI_NULL_
+ */
+void ConvOtp2F3(OtpDataType *obj)
+{
+}
+
+/**
+ * @brief ConvOtp2F4
+ *
+ *  Convert OTP2 0xF4
+ *
+ * @para  obj address of OtpDataType
+ * @return  _UPI_NULL_
+ */
+void ConvOtp2F4(OtpDataType *obj)
+{
+  _otp_u8_ value;
+  _otp_u16_ tmp;
+
+  value = obj->otp2[OTP2_OFFSET_F4];
+
+  tmp = value & (ADC1_DELTA_CODE_25_200MV_8| ADC1_DELTA_CODE_25_200MV_9);
+	#ifdef	UPI_UBOOT_DEBUG_MSG
+		printf("[ConvOtp2F4] Initial value of adc1DeltaCodeT25V200 = %d\n", obj->adc1DeltaCodeT25V200);
+	#endif	///< end of UPI_UBOOT_DEBUG_MSG
+  obj->adc1DeltaCodeT25V200 = obj->adc1DeltaCodeT25V200 + (tmp << 8);
+
+  tmp = value & (DEV_ADDR_7 | DEV_ADDR_8 | DEV_ADDR_9);
+  obj->devAddr = (tmp << 2) + ((value & (DEV_ADDR_0 | DEV_ADDR_1 | DEV_ADDR_2)) >> 2);
+}
+
+/**
+ * @brief ConvOtp2F5
+ *
+ *  Convert OTP2 0xF5
+ *
+ * @para  obj address of OtpDataType
+ * @return  _UPI_NULL_
+ */
+void ConvOtp2F5(OtpDataType *obj)
+{
+  _otp_u8_ value;
+
+  value = obj->otp2[OTP2_OFFSET_F5];
+
+  obj->bgrTune = obj->bgrTune + ((value & (BGR_TUNE_0 |
+                                           BGR_TUNE_1 |
+                                           BGR_TUNE_2 |
+                                           BGR_TUNE_3 |
+                                           BGR_TUNE_4 |
+                                           BGR_TUNE_5)) >> 2);
+}
+
+/**
+ * @brief ConvOtp2F6
+ *
+ *  Convert OTP2 0xF6
+ *
+ * @para  obj address of OtpDataType
+ * @return  _UPI_NULL_
+ */
+void ConvOtp2F6(OtpDataType *obj)
+{
+  _otp_s16_ value;
+
+  value = (_otp_s16_)obj->otp2[OTP2_OFFSET_F6];
+  if(obj->otp2[OTP2_OFFSET_F6] & OSC_DELTA_CODE_25_7)
+  {
+    value = value - 256;
+  }
+  obj->oscDeltaCode25 = (_otp_s8_)value;
+}
+
+/**
+ * @brief ConvOtp2F7
+ *
+ *  Convert OTP2 0xF7
+ *
+ * @para  obj address of OtpDataType
+ * @return  _UPI_NULL_
+ */
+void ConvOtp2F7(OtpDataType *obj)
+{
+  _otp_s16_ value;
+
+  value = (_otp_s16_)obj->otp2[OTP2_OFFSET_F7];
+  if(obj->otp2[OTP2_OFFSET_F7] & OSC_DELTA_CODE_80_7)
+  {
+    value = value - 256;
+  }
+  obj->oscDeltaCode80 = (_otp_s8_)value;
+}
+
+/**
+ * @brief ConvOtp2F8
+ *
+ *  Convert OTP2 0xF8
+ *
+ * @para  obj address of OtpDataType
+ * @return  _UPI_NULL_
+ */
+void ConvOtp2F8(OtpDataType *obj)
+{
+  _otp_u8_ value;
+
+  value = obj->otp2[OTP2_OFFSET_F8];
+
+        #ifdef  UPI_UBOOT_DEBUG_MSG
+                printf("[ConvOtp2F8] Initial value of adc1DeltaCodeT25V200 = %d\n", obj->adc1DeltaCodeT25V200);
+        #endif  ///< end of UPI_UBOOT_DEBUG_MSG
+  obj->adc1DeltaCodeT25V200 = obj->adc1DeltaCodeT25V200 + (value & (ADC1_DELTA_CODE_25_200MV_0 |
+                                                                    ADC1_DELTA_CODE_25_200MV_1 |
+                                                                    ADC1_DELTA_CODE_25_200MV_2 |
+                                                                    ADC1_DELTA_CODE_25_200MV_3 |
+                                                                    ADC1_DELTA_CODE_25_200MV_4 |
+                                                                    ADC1_DELTA_CODE_25_200MV_5 |
+                                                                    ADC1_DELTA_CODE_25_200MV_6 |
+                                                                    ADC1_DELTA_CODE_25_200MV_7));
+}
+
+/**
+ * @brief ConvOtp2F9
+ *
+ *  Convert OTP2 0xF9
+ *
+ * @para  obj address of OtpDataType
+ * @return  _UPI_NULL_
+ */
+void ConvOtp2F9(OtpDataType *obj)
+{
+}
+
+/**
+ * @brief ConvOtp2FA
+ *
+ *  Convert OTP2 0xFA
+ *
+ * @para  obj address of OtpDataType
+ * @return  _UPI_NULL_
+ */
+void ConvOtp2FA(OtpDataType *obj)
+{
+  _otp_u8_ value;
+
+  value = obj->otp2[OTP2_OFFSET_FA];
+
+	#ifdef	UPI_UBOOT_DEBUG_MSG
+		printf("[ConvOtp2FA] Initial value of adc1DeltaCodeT25V100 = %d\n", obj->adc1DeltaCodeT25V100);
+	#endif	///< end of UPI_UBOOT_DEBUG_MSG
+  obj->adc1DeltaCodeT25V100 = obj->adc1DeltaCodeT25V100 + (value & (ADC1_DELTA_CODE_25_100MV_0 |
+                                                                    ADC1_DELTA_CODE_25_100MV_1 |
+                                                                    ADC1_DELTA_CODE_25_100MV_2 |
+                                                                    ADC1_DELTA_CODE_25_100MV_3 |
+                                                                    ADC1_DELTA_CODE_25_100MV_4 |
+                                                                    ADC1_DELTA_CODE_25_100MV_5 |
+                                                                    ADC1_DELTA_CODE_25_100MV_6 |
+                                                                    ADC1_DELTA_CODE_25_100MV_7));
+}
+
+/**
+ * @brief ConvOtp2FB
+ *
+ *  Convert OTP2 0xFB
+ *
+ * @para  obj address of OtpDataType
+ * @return  _UPI_NULL_
+ */
+void ConvOtp2FB(OtpDataType *obj)
+{
+}
+
+/**
+ * @brief ConvOtp2FC
+ *
+ *  Convert OTP2 0xFC
+ *
+ * @para  obj address of OtpDataType
+ * @return  _UPI_NULL_
+ */
+void ConvOtp2FC(OtpDataType *obj)
+{
+  _otp_u8_ value;
+  _otp_u16_ tmp;
+
+  value = obj->otp2[OTP2_OFFSET_FC];
+
+  tmp = value & ADC1_DELTA_CODE_25_100MV_8;
+	#ifdef	UPI_UBOOT_DEBUG_MSG
+		printf("[ConvOtp2FC] Initial value of = %d\n", obj->adc1DeltaCodeT25V100);
+	#endif	///< end of UPI_UBOOT_DEBUG_MSG
+  obj->adc1DeltaCodeT25V100 = obj->adc1DeltaCodeT25V100 + (tmp << 8);
+
+        #ifdef  UPI_UBOOT_DEBUG_MSG
+                printf("[ConvOtp2FC] Initial value of = %d\n", obj->adc2DeltaCodeT25V100);
+        #endif  ///< end of UPI_UBOOT_DEBUG_MSG
+  obj->adc2DeltaCodeT25V100 = obj->adc2DeltaCodeT25V100 + ((value & (ADC2_DELTA_CODE_25_100MV_0 |
+                                                                     ADC2_DELTA_CODE_25_100MV_1 |
+                                                                     ADC2_DELTA_CODE_25_100MV_2 |
+                                                                     ADC2_DELTA_CODE_25_100MV_3 |
+                                                                     ADC2_DELTA_CODE_25_100MV_4 |
+                                                                     ADC2_DELTA_CODE_25_100MV_5 |
+                                                                     ADC2_DELTA_CODE_25_100MV_6)) >> 1);
+}
+
+/**
+ * @brief ConvOtp2FD
+ *
+ *  Convert OTP2 0xFD
+ *
+ * @para  obj address of OtpDataType
+ * @return  _UPI_NULL_
+ */
+void ConvOtp2FD(OtpDataType *obj)
+{
+}
+
+/**
+ * @brief ConvOtp2FE
+ *
+ *  Convert OTP2 0xFE
+ *
+ * @para  obj address of OtpDataType
+ * @return  _UPI_NULL_
+ */
+void ConvOtp2FE(OtpDataType *obj)
+{
+  _otp_u8_ value;
+
+  value = obj->otp2[OTP2_OFFSET_FE];
+
+	#ifdef	UPI_UBOOT_DEBUG_MSG
+		printf("[ConvOtp2FE] Initial value of adc2DeltaCodeT25V200 = %d\n", obj->adc2DeltaCodeT25V200);
+	#endif	///< end of UPI_UBOOT_DEBUG_MSG
+  obj->adc2DeltaCodeT25V200 = obj->adc2DeltaCodeT25V200 + (value & (ADC2_DELTA_CODE_25_200MV_0 |
+                                                                    ADC2_DELTA_CODE_25_200MV_1 |
+                                                                    ADC2_DELTA_CODE_25_200MV_2 |
+                                                                    ADC2_DELTA_CODE_25_200MV_3 |
+                                                                    ADC2_DELTA_CODE_25_200MV_4 |
+                                                                    ADC2_DELTA_CODE_25_200MV_5 |
+                                                                    ADC2_DELTA_CODE_25_200MV_6 |
+                                                                    ADC2_DELTA_CODE_25_200MV_7));
+}
+
+/**
+ * @brief ConvOtp2FF
+ *
+ *  Convert OTP2 0xFF
+ *
+ * @para  obj address of OtpDataType
+ * @return  _UPI_NULL_
+ */
+void ConvOtp2FF(OtpDataType *obj)
+{
+}
+
+/**
+ * @brief ConvOtp370
+ *
+ *  Convert OTP3 0x70
+ *
+ * @para  obj address of OtpDataType
+ * @return  _UPI_NULL_
+ */
+void ConvOtp370(OtpDataType *obj)
+{
+  _otp_u8_ value;
+
+  value = obj->otp3[OTP3_OFFSET_70];
+
+  obj->deltaVref = obj->deltaVref + ((value & DELTA_VREF_4) << 4);
+
+  obj->deltaET = obj->deltaET + ((value & (DELTA_ET_2 | DELTA_ET_3)) << 1);
+
+  obj->aveIT25 = obj->aveIT25 + (value & (AVE_IT_25_3 | AVE_IT_25_4 | AVE_IT_25_5 | AVE_IT_25_6 | AVE_IT_25_7));
+}
+
+/**
+ * @brief ConvOtp371
+ *
+ *  Convert OTP3 0x71
+ *
+ * @para  obj address of OtpDataType
+ * @return  _UPI_NULL_
+ */
+void ConvOtp371(OtpDataType *obj)
+{
+  _otp_u8_ value;
+  _otp_u16_ tmp;
+
+  value = obj->otp3[OTP3_OFFSET_71];
+
+  tmp = value & (AVE_IT_25_8 |
+                 AVE_IT_25_9 |
+                 AVE_IT_25_10 |
+                 AVE_IT_25_11 |
+                 AVE_IT_25_12 |
+                 AVE_IT_25_13 |
+                 AVE_IT_25_14 |
+                 AVE_IT_25_15);
+  obj->aveIT25 = obj->aveIT25 + (tmp << 8);
+}
+
+/**
+ * @brief ConvOtp372
+ *
+ *  Convert OTP3 0x72
+ *
+ * @para  obj address of OtpDataType
+ * @return  _UPI_NULL_
+ */
+void ConvOtp372(OtpDataType *obj)
+{
+  _otp_u8_ value;
+
+  value = obj->otp3[OTP3_OFFSET_72];
+
+        #ifdef  UPI_UBOOT_DEBUG_MSG
+                printf("[ConvOtp372] Initial value of indexAdc2V200T25 = %d\n", obj->indexAdc2V200T25);
+        #endif  ///< end of UPI_UBOOT_DEBUG_MSG
+  obj->indexAdc2V200T25 = obj->indexAdc2V200T25 + ((value & INDEX_ADC2_200_25_4) << 4);
+
+        #ifdef  UPI_UBOOT_DEBUG_MSG
+                printf("[ConvOtp372] Initial value of indexAdc1V100T25 = %d\n", obj->indexAdc1V100T25);
+        #endif  ///< end of UPI_UBOOT_DEBUG_MSG
+  obj->indexAdc1V100T25 = obj->indexAdc1V100T25 + ((value & INDEX_ADC1_100_25_4) << 3);
+
+        #ifdef  UPI_UBOOT_DEBUG_MSG
+                printf("[ConvOtp372] Initial value of indexAdc1V200T25 = %d\n", obj->indexAdc1V200T25);
+        #endif  ///< end of UPI_UBOOT_DEBUG_MSG
+  obj->indexAdc1V200T25 = obj->indexAdc1V200T25 + ((value & INDEX_ADC1_200_25_4) << 2);
+
+  obj->aveIT80 = obj->aveIT80 + (value & (AVE_IT_80_3 | AVE_IT_80_4 | AVE_IT_80_5 | AVE_IT_80_6 | AVE_IT_80_7));
+}
+
+/**
+ * @brief ConvOtp373
+ *
+ *  Convert OTP3 0x73
+ *
+ * @para  obj address of OtpDataType
+ * @return  _UPI_NULL_
+ */
+void ConvOtp373(OtpDataType *obj)
+{
+  _otp_u8_ value;
+  _otp_u16_ tmp;
+
+  value = obj->otp3[OTP3_OFFSET_73];
+
+  tmp = value & (AVE_IT_80_8 |
+                 AVE_IT_80_9 |
+                 AVE_IT_80_10 |
+                 AVE_IT_80_11 |
+                 AVE_IT_80_12 |
+                 AVE_IT_80_13 |
+                 AVE_IT_80_14 |
+                 AVE_IT_80_15);
+  obj->aveIT80 = obj->aveIT80 + (tmp << 8);
+}
+
+#define CONV_FUNC_PTR_NULL  (0)
+
+typedef void (*ConvFuncPtr)(OtpDataType *obj);
+
+static ConvFuncPtr ConvFuncTable[] = {
+  ConvOtp1E0,
+  ConvOtp1E1,
+  ConvOtp1E2,
+  ConvOtp1E3,
+
+  ConvOtp2F0,
+  ConvOtp2F1,
+  ConvOtp2F2,
+  ConvOtp2F3,
+  ConvOtp2F4,
+  ConvOtp2F5,
+  ConvOtp2F6,
+  ConvOtp2F7,
+  ConvOtp2F8,
+  ConvOtp2F9,
+  ConvOtp2FA,
+  ConvOtp2FB,
+  ConvOtp2FC,
+  ConvOtp2FD,
+  ConvOtp2FE,
+  ConvOtp2FF,
+
+  ConvOtp370,
+  ConvOtp371,
+  ConvOtp372,
+  ConvOtp373,
+
+  CONV_FUNC_PTR_NULL,
+};
+
+/**
+ * @brief CheckOtpISEmpty
+ *
+ *  Check OTP is empty or not
+ *
+ * @para  data  address of OtpDataType
+ * @return  _UPI_NULL_
+ */
+void CheckOtpISEmpty(OtpDataType *data)
+{
+  _otp_u8_ idx;
+
+  /// [AT-PM] : Check OTP1 ; 01/25/2013
+  idx = 0;
+  while(idx < OTP1_SIZE)
+  {
+    if(data->otp1[idx] != 0)
+    {
+      data->empty = OTP_IS_NOT_EMPTY;
+      return;
+    }
+    idx = idx + 1;
+  }
+
+  /// [AT-PM] : Check OTP2 ; 01/25/2013
+  idx = 0;
+  while(idx < OTP2_SIZE)
+  {
+    if(data->otp2[idx] != 0)
+    {
+      data->empty = OTP_IS_NOT_EMPTY;
+      return;
+    }
+    idx = idx + 1;
+  }
+
+  /// [AT-PM] : Check OTP3 ; 01/25/2013
+  idx = 0;
+  while(idx < OTP3_SIZE)
+  {
+    if(data->otp3[idx] != 0)
+    {
+      data->empty = OTP_IS_NOT_EMPTY;
+      return;
+    }
+    idx = idx + 1;
+  }
+
+  /// [AT-PM] : Set OTP is empty ; 01/25/2013
+  data->empty = OTP_IS_EMPTY;
+}
+
+/// =============================================
+/// [AT-PM] : Extern function region
+/// =============================================
+
+/**
+ * @brief UpiConvertOtp
+ *
+ *  Convert OTP register value to readable value
+ *
+ * @para  data  address of OtpDataType
+ * @return  _UPI_NULL_
+ */
+void UpiConvertOtp(OtpDataType *data)
+{
+  _otp_u8_ idx;
+
+  UG31_LOGI("[%s]: %s : %04x%04x\n", __func__, OTP_VERSION, UG31XX_OTP_VERSION_MAIN, UG31XX_OTP_VERSION_SUB);
+
+  /// [AT-PM] : Set version ; 01/25/2013
+  data->versionMain = UG31XX_OTP_VERSION_MAIN;
+  data->versionSub = UG31XX_OTP_VERSION_SUB;
+
+  /// [AT-PM] : Conversion ; 01/23/2013
+  idx = 0;
+  while(1)
+  {
+    (*ConvFuncTable[idx])(data);
+
+    idx = idx + 1;
+    if(ConvFuncTable[idx] == CONV_FUNC_PTR_NULL)
+    {
+      break;
+    }
+  }
+
+  /// [AT-PM] : Check OTP is empty ; 01/25/2013
+  CheckOtpISEmpty(data);
+}
+
+/**
+ * @brief UpiPrintOtpVersion
+ *
+ *  Print OTP module version
+ *
+ * @return  NULL
+ */
+void UpiPrintOtpVersion(void)
+{
+  UG31_LOGE("[%s]: %s\n", __func__,
+            OTP_VERSION);
+}
+
+
+/**
+ * Copyright @ 2013 uPI Semiconductor Corp. All right reserved.
+ * The information, images, and/or data contained in this material is copyrighted by uPI
+ * Semiconductor Corp., and may not be distributed, modified, reproduced in whole or in part
+ * without the prior, written consent of uPI Semiconductor Corp.
+ */
diff --git a/drivers/power/supply/ASUS_BATTERY/ME176C/ug31xx/uG31xx_API_Otp.h b/drivers/power/supply/ASUS_BATTERY/ME176C/ug31xx/uG31xx_API_Otp.h
new file mode 100644
index 000000000000..3c06466293c8
--- /dev/null
+++ b/drivers/power/supply/ASUS_BATTERY/ME176C/ug31xx/uG31xx_API_Otp.h
@@ -0,0 +1,94 @@
+/**
+ * @filename  uG31xx_API_Otp.h
+ *
+ *  Header of OTP conversion module
+ *
+ * @author  AllenTeng <allen_teng@upi-semi.com>
+ * @revision  $Revision: 107 $
+ */
+
+/// [AT-PM] : Product Type definition in OTP ; 01/23/2013
+enum UG31XX_PRODUCT_TYPE {
+  UG31XX_PRODUCT_TYPE_0 = 0,
+  UG31XX_PRODUCT_TYPE_1 = 1,
+  UG31XX_PRODUCT_TYPE_2 = 2,
+  UG31XX_PRODUCT_TYPE_3 = 3,
+};
+
+#define UG31XX_OTP_VERSION_MAIN (0x2013)
+#define UG31XX_OTP_VERSION_SUB  (0x0110)
+
+#define OTP_IS_EMPTY      (1)
+#define OTP_IS_NOT_EMPTY  (0)
+
+#define OTP1_SIZE         (4)
+#define OTP2_SIZE         (16)
+#define OTP3_SIZE         (4)
+
+typedef unsigned char   _otp_u8_;
+typedef signed char     _otp_s8_;
+typedef unsigned short  _otp_u16_;
+typedef signed short    _otp_s16_;
+
+typedef struct OtpDataST {
+
+  /// [AT-PM] : Version ; 01/23/2013
+  _otp_u16_ versionMain;
+  _otp_u16_ versionSub;
+  _otp_u8_ empty;
+
+  /// [AT-PM] : Raw data ; 01/23/2013
+  _otp_u8_ otp1[OTP1_SIZE];
+  _otp_u8_ otp2[OTP2_SIZE];
+  _otp_u8_ otp3[OTP3_SIZE];
+
+  /// [AT-PM] : Converted value ; 01/23/2013
+  _otp_u16_ adc1DeltaCodeT25V100;
+  _otp_u16_ adc1DeltaCodeT25V200;
+  _otp_u16_ adc2DeltaCodeT25V100;
+  _otp_u16_ adc2DeltaCodeT25V200;
+  _otp_u16_ aveIT25;
+  _otp_u16_ aveIT80;
+
+  _otp_u8_ bgrTune;
+
+  _otp_u8_ deltaET;
+  _otp_u8_ deltaVref;
+  _otp_u16_ devAddr;
+
+  _otp_u16_ ftIT;
+
+  _otp_u8_ indexAdc1V100T25;
+  _otp_u8_ indexAdc1V200T25;
+  _otp_u8_ indexAdc2V100T25;
+  _otp_u8_ indexAdc2V200T25;
+
+  _otp_s8_ oscDeltaCode25;
+  _otp_s8_ oscDeltaCode80;
+  _otp_u8_ otpCellEN;
+
+  _otp_u8_ productType;
+
+} ALIGNED_ATTRIBUTE OtpDataType;
+
+extern OtpDataType *ptrOtpData;
+
+/**
+ * @brief UpiConvertOtp
+ *
+ *  Convert OTP register value to readable value
+ *
+ * @para  data  address of OtpDataType
+ * @return  _UPI_NULL_
+ */
+extern void UpiConvertOtp(OtpDataType *data);
+
+/**
+ * @brief UpiPrintOtpVersion
+ *
+ *  Print OTP module version
+ *
+ * @return  NULL
+ */
+extern void UpiPrintOtpVersion(void);
+
diff --git a/drivers/power/supply/ASUS_BATTERY/ME176C/ug31xx/uG31xx_API_Platform.c b/drivers/power/supply/ASUS_BATTERY/ME176C/ug31xx/uG31xx_API_Platform.c
new file mode 100644
index 000000000000..8f983510af3a
--- /dev/null
+++ b/drivers/power/supply/ASUS_BATTERY/ME176C/ug31xx/uG31xx_API_Platform.c
@@ -0,0 +1,1509 @@
+/**
+ * @filename  uG31xx_API_Platform.c
+ *
+ *  Source of function required by uG31xx driver
+ *
+ * @author  AllenTeng <allen_teng@upi-semi.com>
+ * @note
+ */
+
+#include "stdafx.h"     //windows need this??
+#include "uG31xx_Platform.h"
+#include "uG31xx_API_Platform.h"
+#include <asm/intel_scu_ipc.h>
+
+#define BATT_DATA_DEBUG
+#define BACKUP_BATTERY_KEY      0xBB
+#define UMIP_REF_FG_TBL         0x806   /* 2 bytes */
+#define BATT_FG_TBL_BODY        14      /* 144 bytes */
+#define BATT_UG31_FG_TBL_BODY   0x820
+#define BATT_UG31_RESERVED      2   /* 1st byte: which battery cell.
+                                    2nd byte: had backup before */
+#define I2C_RETRY_CNT           (20)
+
+/**
+ * ug31xx_restore_config_data - restore config data
+ * @name : Power Supply name
+ * @data : config data output pointer
+ * @len : length of config data
+ *
+ */
+int ug31xx_restore_config_data(const char *name, u8 *data, int len)
+{
+    int mip_offset, ret;
+    int i;
+
+    pr_info("%s:\n", __func__);
+
+    /* Read the fuel gauge config data from umip */
+    mip_offset = BATT_UG31_FG_TBL_BODY + BATT_UG31_RESERVED;
+    //mip_offset = UMIP_REF_FG_TBL + BATT_FG_TBL_BODY;
+    ret = intel_scu_ipc_read_mip(data, len, mip_offset, 0);
+
+    if (ret) {
+        UG31_LOGE("%s: * umip read failed *\n", name);
+    }
+#ifdef BATT_DATA_DEBUG
+    else
+    {
+        for (i=0; i<len; i++)
+            printk("0x%02X ", *(data + i));
+        printk("\n");
+    }
+#endif
+
+    return ret;
+}
+
+/**
+ * ug31xx_save_config_data - save config data
+ * @name : Power Supply name
+ * @data : config data input pointer
+ * @len : length of config data
+ *
+ */
+int ug31xx_save_config_data(const char *name, u8 *data, int len)
+{
+    int mip_offset, ret;
+    int i;
+
+    pr_info("%s:\n", __func__);
+
+    /* write the fuel gauge config data to umip */
+    mip_offset = BATT_UG31_FG_TBL_BODY + BATT_UG31_RESERVED;
+    //mip_offset = UMIP_REF_FG_TBL + BATT_FG_TBL_BODY;
+    ret = intel_scu_ipc_write_umip(data, len, mip_offset);
+
+    if (ret) {
+        UG31_LOGE("%s: * umip write failed *\n", name);
+    }
+#ifdef BATT_DATA_DEBUG
+    else
+    {
+        for (i=0; i<len; i++)
+            printk("0x%02X ", *(data + i));
+        printk("\n");
+    }
+#endif
+
+    return ret;
+}
+
+int ug31xx_read_backup_tag(const char *name, u8 *data)
+{
+    int mip_offset, ret;
+
+    pr_debug("%s:\n", __func__);
+
+    mip_offset = BATT_UG31_FG_TBL_BODY;
+    ret = intel_scu_ipc_read_mip(data, 1, mip_offset, 0);
+
+    if (ret)
+        UG31_LOGE("%s: * umip read failed *\n", name);
+
+    return ret;
+}
+
+int ug31xx_write_backup_tag(const char *name, u8 *data)
+{
+    int mip_offset, ret;
+
+    pr_warn("%s:\n", __func__);
+
+    mip_offset = BATT_UG31_FG_TBL_BODY;
+    ret = intel_scu_ipc_write_umip(data, 1, mip_offset);
+
+    if (ret)
+        UG31_LOGE("%s: * umip write failed *\n", name);
+
+    return ret;
+}
+
+#ifdef  uG31xx_OS_WINDOWS
+
+  typedef char mm_segment_t;
+  typedef char loff_t;
+
+  typedef struct file
+  {
+    FILE *fp;
+  } fileType;
+
+  #define O_RDONLY  (1<<0)
+  #define O_WRONLY  (1<<1)
+  #define O_RDWR    (3<<0)
+  #define O_CREAT   (1<<2)
+  #define O_APPEND  (1<<3)
+
+  static struct file BackupFile;
+
+  /**
+     * @brief filp_open
+     *
+     *  Open file
+     *
+     * @para  path  address of file
+     * @para  cntl  FILE_CNTL parameter
+     * @para  misc  dummy parameter
+     * @return  address of BackupFile
+     */
+  struct file * filp_open(const wchar_t *path, int cntl, int misc)
+  {
+    if(BackupFile.fp != _UPI_NULL_)
+    {
+      fclose(BackupFile.fp);
+    }
+    BackupFile.fp = _UPI_NULL_;
+
+    switch(cntl)
+    {
+      case  (O_RDONLY):
+        _wfopen_s(&BackupFile.fp, path, _T("rb, ccs=UTF-8"));
+        break;
+      case  (O_CREAT | O_RDWR):
+        _wfopen_s(&BackupFile.fp, path, _T("w+b, ccs=UTF-8"));
+        break;
+      case  (O_RDWR):
+        _wfopen_s(&BackupFile.fp, path, _T("r+b, ccs=UTF-8"));
+        break;
+      case  (O_CREAT | O_APPEND | O_WRONLY):
+        _wfopen_s(&BackupFile.fp, path, _T("a+b, ccs=UTF-8"));
+        break;
+      default:
+        _wfopen_s(&BackupFile.fp, path, _T("rb, ccs=UTF-8"));
+        break;
+    }
+    return (&BackupFile);
+  }
+
+  /**
+     * @brief filp_close
+     *
+     *  Close file
+     *
+     * @para  fp  address of struct file
+     * @para  misc  dummy value
+     * @return  _UPI_NULL_
+     */
+  void filp_close(struct file *fp, int misc)
+  {
+    if(fp->fp != _UPI_NULL_)
+    {
+      fclose(fp->fp);
+    }
+  }
+
+  /**
+     * @brief vfs_write
+     *
+     *  Write data to binary file
+     *
+     * @para  fp  address of struct file
+     * @para  data  address of data to be written
+     * @para  size  size to be written
+     * @para  pos start position in the file
+     * @return  size be written
+     */
+  size_t vfs_write(struct file *fp, char *data, int size, loff_t *pos)
+  {
+    return (fwrite(data, sizeof(char), size, fp->fp));
+  }
+
+  /**
+     * @brief vfs_read
+     *
+     *  Read data from binary file
+     *
+     * @para  fp  address of struct file
+     * @para  data  address of data to be read
+     * @para  size  size to be read
+     * @para  pos start position in the file
+     * @return  size be read
+     */
+  size_t vfs_read(struct file *fp, char *data, int size, loff_t *pos)
+  {
+    return (fread(data, sizeof(char), size, fp->fp));
+  }
+
+  /**
+     * @brief get_fs
+     *
+     *  Dummy function
+     *
+     * @return  0
+     */
+  mm_segment_t get_fs(void)
+  {
+    return (0);
+  }
+
+  /**
+     * @brief set_fs
+     *
+     *  Dummy function
+     *
+     * @para  value mm_segment_t value
+     * @return  _UPI_NULL_
+     */
+  void set_fs(mm_segment_t value)
+  {
+  }
+
+  /**
+     * @brief get_ds
+     *
+     *  Dummy function
+     *
+     * @return  0
+     */
+  mm_segment_t get_ds(void)
+  {
+    return (0);
+  }
+
+#endif  ///< end of uG31xx_OS_WINDOWS
+
+/**
+   * @brief IS_ERR
+   *
+   *  Check file is opened or not
+   *
+   * @para  fp  address of struct file
+   * @return  _UPI_TRUE_ if file is opened
+   */
+#ifdef  uG31xx_BOOT_LOADER
+
+#define is_err
+
+#else   ///< else of uG31xx_BOOT_LOADER
+
+_upi_bool_ is_err(struct file *fp)
+{
+  #ifdef  uG31xx_OS_WINDOWS
+
+    return ((fp->fp == _UPI_NULL_) ? _UPI_TRUE_ : _UPI_FALSE_);
+
+  #else   ///< else of uG31xx_OS_WINDOWS
+
+    return (IS_ERR(fp) ? _UPI_TRUE_ : _UPI_FALSE_);
+
+  #endif  ///< end of uG31xx_OS_WINDOWS
+}
+
+#endif  ///< end of uG31xx_BOOT_LOADER
+
+#ifndef uG31xx_OS_WINDOWS
+
+char *shell_ap_name = NULL;
+
+/**
+ * @brief set_shell_ap_name
+ *
+ *  Set shell AP name
+ *
+ * @para  apname  address of AP name
+ * @return  NULL
+ */
+void set_shell_ap_name(char *apname)
+{
+  shell_ap_name = apname;
+}
+
+static _upi_u8_ file_op_status = 0;
+
+/**
+ * @brief get_file_op_status
+ *
+ *  Get file_op_status
+ *
+ * @return  file_op_status
+ */
+_upi_u8_ get_file_op_status(void)
+{
+  return (file_op_status);
+}
+
+/**
+ * @brief set_file_op_status_bit
+ *
+ *  Set bit of file_op_status
+ *
+ * @para  bit_sts bit of file_op_sts to be set
+ * @return  file_op_status
+ */
+_upi_u8_ set_file_op_status_bit(_upi_u8_ bit_sts)
+{
+  file_op_status = file_op_status | bit_sts;
+  return (file_op_status);
+}
+
+/**
+ * @brief clear_file_op_status_bit
+ *
+ *  Clear bit of file_op_status
+ *
+ * @para  bit_sts bit of file_op_sts to be set
+ * @return  file_op_status
+ */
+_upi_u8_ clear_file_op_status_bit(_upi_u8_ bit_sts)
+{
+  file_op_status = file_op_status & (~bit_sts);
+  return (file_op_status);
+}
+
+#endif  ///< end of uG31xx_OS_WINDOWS
+
+/**
+ * @brief is_file_exist
+ *
+ *  Check file is existed or not
+ *
+ * @para  filename  address of filename string
+ * @return  _UPI_TRUE_ if file is existed
+ */
+#ifdef  uG31xx_OS_WINDOWS
+  _upi_bool_ is_file_exist(const wchar_t *filename)
+#else   ///< else of uG31xx_OS_WINDOWS
+  _upi_bool_ is_file_exist(char *filename)
+#endif  ///< end of uG31xx_OS_WINDOWS
+{
+  #ifndef uG31xx_BOOT_LOADER
+
+    #ifndef CONFIG_ASUS_ENGINEER_MODE
+
+    #ifdef  UG31XX_USE_SHELL_AP_FOR_FILE_OP
+
+    struct subprocess_info *sub_info;
+    char *argv[] = {shell_ap_name, "BACKUP_FILE", "EXIST", filename, NULL};
+    char *env[] = {NULL};
+    int rtn;
+
+    sub_info = NULL;
+    sub_info = call_usermodehelper_setup(argv[0], argv, env, GFP_ATOMIC);
+    if(sub_info == NULL)
+    {
+      return (_UPI_FALSE_);
+    }
+    UG31_LOGN("[%s]: call_usermodehelper_setup() done (%d)\n", __func__, (int)sub_info);
+
+    rtn = call_usermodehelper_exec(sub_info, UMH_WAIT_PROC);
+    UG31_LOGN("[%s]: call_usermodehelper_exec() = %d\n", __func__, rtn);
+    return ((rtn == 0) ? _UPI_TRUE_ : _UPI_FALSE_);
+
+  #else   ///< else of UG31XX_USE_SHELL_AP_FOR_FILE_OP
+
+  #ifdef  UG31XX_USE_DAEMON_AP_FOR_FILE_OP
+
+    if(get_file_op_status() & UG31XX_KERNEL_FILE_FINISH)
+    {
+      set_file_op_status_bit(UG31XX_KERNEL_FILE_EXIST);
+      return (_UPI_FALSE_);
+    }
+
+    if(get_file_op_status() & UG31XX_USER_FILE_EXIST)
+    {
+      clear_file_op_status_bit(UG31XX_KERNEL_FILE_EXIST);
+      set_file_op_status_bit(UG31XX_KERNEL_FILE_READ);
+      set_file_op_status_bit(UG31XX_KERNEL_FILE_FINISH);
+      return (_UPI_TRUE_);
+    }
+
+    set_file_op_status_bit(UG31XX_KERNEL_FILE_EXIST);
+    set_file_op_status_bit(UG31XX_KERNEL_FILE_FINISH);
+    return (_UPI_FALSE_);
+
+  #else   ///< else of UG31XX_USE_DAEMON_AP_FOR_FILE_OP
+
+    struct file *fp;
+    _upi_u8_ retry;
+
+    retry = 3;
+    while(retry)
+    {
+      fp = filp_open(filename, O_RDONLY, 0644);
+      if(!is_err(fp))
+      {
+        break;
+      }
+
+      retry = retry - 1;
+    }
+    if(retry == 0)
+    {
+      return (_UPI_FALSE_);
+    }
+
+    filp_close(fp, _UPI_NULL_);
+
+  #endif  ///< end of UG31XX_USE_DAEMON_AP_FOR_FILE_OP
+
+    #endif  ///< end of UG31XX_USE_SHELL_AP_FOR_FILE_OP
+
+    #else
+    _upi_u8_ backup_tag = 0;
+    if (ug31xx_read_backup_tag("ug31xx", &backup_tag))
+        return (_UPI_FALSE_);
+    if (backup_tag != BACKUP_BATTERY_KEY)
+        return (_UPI_FALSE_);
+    return (_UPI_TRUE_);
+    #endif
+
+  #endif  ///< end of uG31xx_BOOT_LOADER
+
+  return (_UPI_TRUE_);
+}
+
+/**
+ * @brief write_file
+ *
+ *  Write data to file
+ *
+ * @para  fp  address of struct fp
+ * @para  data  address of data buffer to be written
+ * @para  size  size of data buffer
+ */
+#ifdef  uG31xx_BOOT_LOADER
+
+#define write_file
+
+#else   ///< else of uG31xx_BOOT_LOADER
+
+void write_file(struct file *fp, _upi_u8_ *data, _upi_u8_ size)
+{
+  mm_segment_t oldFS;
+  loff_t pos;
+  _upi_s32_ rtn;
+  _upi_u8_ idx;
+
+  oldFS = get_fs();
+  set_fs(get_ds());
+
+  pos = 0;
+  idx = 0;
+  rtn = 1;
+  UG31_LOGN("[%s] Write file ->", __func__);
+  while(idx < size)
+  {
+    rtn = (_upi_s32_)vfs_write(fp, (char *)(&data[idx]), 1, &pos);
+    ug31_printk(LOG_LEVEL_NOTICE, " %02x", data[idx]);
+
+    idx = idx + 1;
+    if(rtn != 1)
+    {
+      break;
+    }
+  }
+  ug31_printk(LOG_LEVEL_NOTICE, "\n");
+
+  if(rtn != 1)
+  {
+    UG31_LOGE("[%s]: Write file fail\n", __func__);
+  }
+  else
+  {
+    UG31_LOGN("[%s]: Write %d (%d) bytes to file\n", __func__, idx, size);
+  }
+
+  set_fs(oldFS);
+}
+
+#endif  ///< end of uG31xx_BOOT_LOADER
+
+/**
+ * @brief create_backup_file
+ *
+ *  Create backup file on system
+ *
+ * @para  filename  address of filename string
+ * @return  _UPI_TRUE_ if success
+ */
+#ifdef  uG31xx_OS_WINDOWS
+  _upi_bool_ create_backup_file(const wchar_t *filename, _upi_u8_ *data, _upi_u8_ size)
+#else   ///< else of uG31xx_OS_WINDOWS
+  _upi_bool_ create_backup_file(char *filename, _upi_u8_ *data, _upi_u8_ size)
+#endif  ///< end of uG31xx_OS_WINDOWS
+{
+  #ifndef uG31xx_BOOT_LOADER
+
+    #ifndef CONFIG_ASUS_ENGINEER_MODE
+
+    #ifdef  UG31XX_USE_SHELL_AP_FOR_FILE_OP
+
+    struct subprocess_info *sub_info;
+    char *argv[] = {shell_ap_name, "BACKUP_FILE", "CREATE", filename, NULL};
+    char *env[] = {NULL};
+    int rtn;
+
+    sub_info = NULL;
+    sub_info = call_usermodehelper_setup(argv[0], argv, env, GFP_ATOMIC);
+    if(sub_info == NULL)
+    {
+      return (_UPI_FALSE_);
+    }
+    UG31_LOGN("[%s]: call_usermodehelper_setup() done (%d - %d - %d)\n", __func__, (int)sub_info, (int)data, (int)size);
+
+    rtn = call_usermodehelper_exec(sub_info, UMH_WAIT_PROC);
+    UG31_LOGN("[%s]: call_usermodehelper_exec() = %d\n", __func__, rtn);
+    return ((rtn == 0) ? _UPI_TRUE_ : _UPI_FALSE_);
+
+  #else   ///< else of UG31XX_USE_SHELL_AP_FOR_FILE_OP
+
+  #ifdef  UG31XX_USE_DAEMON_AP_FOR_FILE_OP
+
+    if(get_file_op_status() & UG31XX_KERNEL_FILE_FINISH)
+    {
+      clear_file_op_status_bit(UG31XX_KERNEL_FILE_EXIST);
+      clear_file_op_status_bit(UG31XX_KERNEL_FILE_READ);
+      set_file_op_status_bit(UG31XX_KERNEL_FILE_WRITE);
+      return (_UPI_FALSE_);
+    }
+
+    if(get_file_op_status() & UG31XX_USER_FILE_WRITE)
+    {
+      clear_file_op_status_bit(UG31XX_KERNEL_FILE_WRITE);
+      set_file_op_status_bit(UG31XX_KERNEL_FILE_READ);
+      set_file_op_status_bit(UG31XX_KERNEL_FILE_FINISH);
+      return (_UPI_TRUE_);
+    }
+
+    clear_file_op_status_bit(UG31XX_KERNEL_FILE_EXIST);
+    clear_file_op_status_bit(UG31XX_KERNEL_FILE_READ);
+    set_file_op_status_bit(UG31XX_KERNEL_FILE_WRITE);
+    set_file_op_status_bit(UG31XX_KERNEL_FILE_FINISH);
+    return (_UPI_FALSE_);
+
+  #else   ///< else of UG31XX_USE_DAEMON_AP_FOR_FILE_OP
+
+    struct file *fp;
+    _upi_u8_ retry;
+
+    retry = 3;
+    while(retry)
+    {
+      fp = filp_open(filename, O_CREAT | O_RDWR, 0644);
+      if(!is_err(fp))
+      {
+        break;
+      }
+
+      retry = retry - 1;
+    }
+    if(retry == 0)
+    {
+      return (_UPI_FALSE_);
+    }
+
+    /// [AT-PM] : Write data to file ; 02/21/2013
+    write_file(fp, data, size);
+
+    filp_close(fp, _UPI_NULL_);
+
+      #endif  ///< end of UG31XX_USE_DAEMON_AP_FOR_FILE_OP
+
+    #endif  ///< end of UG31XX_USE_SHELL_AP_FOR_FILE_OP
+
+    #else
+    int backup_tag = BACKUP_BATTERY_KEY;
+    if (ug31xx_save_config_data("ug31xx", data, size)) {
+        UG31_LOGE("[%s]: fail to write Intel UMIP data\n", __func__);
+        return (_UPI_FALSE_);
+    }
+    else {
+        if (ug31xx_write_backup_tag("ug31xx", &backup_tag)) {
+            UG31_LOGE("[%s]: fail to write Intel UMIP backup tag\n", __func__);
+            return (_UPI_FALSE_);
+        }
+    }
+    return (_UPI_TRUE_);
+    #endif
+
+  #endif  ///< end of uG31xx_BOOT_LOADER
+
+  return (_UPI_TRUE_);
+}
+
+#ifdef  uG31xx_NO_MEM_UNIT
+
+#define MEMORY_BUFFER_COUNT     (0x10)
+#define MEMORY_BUFFER_SIZE      (0x400)
+
+static _upi_bool_ memory_idx[] = {  _UPI_FALSE_,  _UPI_FALSE_,  _UPI_FALSE_,  _UPI_FALSE_,
+                                    _UPI_FALSE_,  _UPI_FALSE_,  _UPI_FALSE_,  _UPI_FALSE_,
+                                    _UPI_FALSE_,  _UPI_FALSE_,  _UPI_FALSE_,  _UPI_FALSE_,
+                                    _UPI_FALSE_,  _UPI_FALSE_,  _UPI_FALSE_,  _UPI_FALSE_,  };
+static _upi_u8_ memory_buffer[MEMORY_BUFFER_COUNT][MEMORY_BUFFER_SIZE];
+
+#endif  ///< end of uG31xx_NO_MEM_UNIT
+
+/**
+ * @brief upi_free
+ *
+ *  Free memory for uG31xx driver
+ *
+ * @para  obj address of memory
+ * @return  NULL
+ */
+void upi_free(void *obj)
+{
+  #if defined(uG31xx_OS_ANDROID)
+    #ifdef  uG31xx_BOOT_LOADER
+      #ifdef  uG31xx_NO_MEM_UNIT
+        _upi_u8_ idx;
+
+        idx = 0;
+        while(idx < MEMORY_BUFFER_COUNT)
+        {
+          if(obj == &memory_buffer[idx][0])
+          {
+            memory_idx[idx] = _UPI_FALSE_;
+            break;
+          }
+          idx = idx + 1;
+        }
+      #else   ///< else of uG31xx_NO_MEM_UNIT
+        free(obj);
+      #endif  ///< end of uG31xx_NO_MEM_UNIT
+    #else   ///< else of uG31xx_BOOT_LOADER
+      kfree(obj);
+    #endif  ///< end of uG31xx_BOOT_LOADER
+  #else   ///< else of defined(uG31xx_OS_ANDROID)
+    free(obj);
+  #endif  ///< end of defined(uG31xx_OS_ANDROID)
+
+  obj = _UPI_NULL_;
+}
+
+/**
+ * @brief upi_malloc
+ *
+ *  Allocate memory for uG31xx driver
+ *
+ * @para  size  size of memory
+ * @return  address of memory
+ */
+void *upi_malloc(_upi_u32_ size)
+{
+  #if defined(uG31xx_OS_ANDROID)
+    #ifdef  uG31xx_BOOT_LOADER
+      #ifdef  uG31xx_NO_MEM_UNIT
+        _upi_u8_ idx;
+
+        idx = 0;
+        while(idx < MEMORY_BUFFER_COUNT)
+        {
+          if(memory_idx[idx] == _UPI_FALSE_)
+          {
+            memory_idx[idx] = _UPI_TRUE_;
+            return ((void *)&memory_buffer[idx][0]);
+          }
+          idx = idx + 1;
+        }
+        return (_UPI_NULL_);
+      #else   ///< else of uG31xx_NO_MEM_UNIT
+        return (malloc(size));
+      #endif  ///< end of uG31xx_NO_MEM_UNIT
+    #else   ///< else of uG31xx_BOOT_LOADER
+      return (kzalloc(size, GFP_KERNEL));
+    #endif  ///< end of uG31xx_BOOT_LOADER
+  #else   ///< else of defined(uG31xx_OS_ANDROID)
+	  return (malloc(size));
+  #endif  ///< end of defined(uG31xx_OS_ANDROID)
+}
+
+/**
+ * @brief upi_memcpy
+ *
+ *  Copy memory for uG31xx driver
+ *
+ * @para  dest  address of destination
+ * @para  src address of source
+ * @para  size  size of data to be copied
+ * @return  NULL
+ */
+void upi_memcpy(void *dest, void *src, _upi_u32_ size)
+{
+  #ifdef  uG31xx_NO_MEM_UNIT
+    _upi_u64_ idx;
+    _upi_u8_ *ptr_dest;
+    _upi_u8_ *ptr_src;
+
+    idx = 0;
+    ptr_dest = (_upi_u8_ *)dest;
+    ptr_src = (_upi_u8_ *)src;
+    while(idx < size)
+    {
+      *(ptr_dest + idx) = *(ptr_src + idx);
+      idx = idx + 1;
+    }
+  #else   ///< else of uG31xx_NO_MEM_UNIT
+    memcpy(dest, src, size);
+  #endif  ///< end of uG31xx_NO_MEM_UNIT
+}
+
+/**
+ * @brief read_file
+ *
+ *  Read data from file
+ *
+ * @para  data  address of BackupDataType
+ * @para  fp  address of struct fp
+ */
+#ifdef  uG31xx_BOOT_LOADER
+
+#define read_file
+
+#else   ///< else of uG31xx_BOOT_LOADER
+
+void read_file(struct file *fp, _upi_u8_ *data, _upi_u8_ size)
+{
+  mm_segment_t oldFS;
+  loff_t pos;
+  _upi_s32_ rtn;
+  _upi_u8_ idx;
+
+  oldFS = get_fs();
+  set_fs(get_ds());
+
+  pos = 0;
+  idx = 0;
+  rtn = 1;
+  UG31_LOGN("[%s]: Read file ->", __func__);
+  while(idx < size)
+  {
+    rtn = (_upi_s32_)vfs_read(fp, (char *)(&data[idx]), 1, &pos);
+    ug31_printk(LOG_LEVEL_NOTICE, " %02x", data[idx]);
+
+    idx = idx + 1;
+    if(rtn != 1)
+    {
+      break;
+    }
+  }
+  ug31_printk(LOG_LEVEL_NOTICE, "\n");
+
+  if(rtn != 1)
+  {
+    UG31_LOGE("[%s]: Read file fail.\n", __func__);
+  }
+  else
+  {
+    UG31_LOGN("[%s]: Read %d (%d) bytes from file\n", __func__, idx, size);
+  }
+
+  set_fs(oldFS);
+}
+
+#endif  ///< end of uG31xx_BOOT_LOADER
+
+/**
+ * @brief read_backup_file
+ *
+ *  Read data from backup file
+ *
+ * @para  filename  address of backup filename string
+ * @para  data  address of data buffer
+ * @para  size  size of data to be read
+ * @return  _UPI_TRUE_ if success
+ */
+#ifdef  uG31xx_OS_WINDOWS
+  extern _upi_bool_ read_backup_file(const wchar_t *filename, _upi_u8_ *data, _upi_u32_ size)
+#else   ///< else of uG31xx_OS_WINDOWS
+  extern _upi_bool_ read_backup_file(char *filename, _upi_u8_ *data, _upi_u32_ size)
+#endif  ///< end of uG31xx_OS_WINDOWS
+{
+  #ifndef uG31xx_BOOT_LOADER
+
+    #ifndef CONFIG_ASUS_ENGINEER_MODE
+
+  #ifdef  UG31XX_USE_SHELL_AP_FOR_FILE_OP
+
+    struct subprocess_info *sub_info;
+    char *argv[] = {shell_ap_name, "BACKUP_FILE", "READ", filename, NULL};
+    char *env[] = {NULL};
+    int rtn;
+
+    sub_info = NULL;
+    sub_info = call_usermodehelper_setup(argv[0], argv, env, GFP_ATOMIC);
+    if(sub_info == NULL)
+    {
+      return (_UPI_FALSE_);
+    }
+    UG31_LOGN("[%s]: call_usermodehelper_setup() done (%d - %d - %d)\n", __func__, (int)sub_info, (int)data, (int)size);
+
+    rtn = call_usermodehelper_exec(sub_info, UMH_WAIT_PROC);
+    UG31_LOGN("[%s]: call_usermodehelper_exec() = %d\n", __func__, rtn);
+    return ((rtn == 0) ? _UPI_TRUE_ : _UPI_FALSE_);
+
+  #else   ///< else of UG31XX_USE_SHELL_AP_FOR_FILE_OP
+
+  #ifdef  UG31XX_USE_DAEMON_AP_FOR_FILE_OP
+
+    if(get_file_op_status() & UG31XX_KERNEL_FILE_FINISH)
+    {
+      clear_file_op_status_bit(UG31XX_KERNEL_FILE_EXIST);
+      clear_file_op_status_bit(UG31XX_KERNEL_FILE_WRITE);
+      set_file_op_status_bit(UG31XX_KERNEL_FILE_READ);
+      return (_UPI_FALSE_);
+    }
+
+    if(get_file_op_status() & UG31XX_USER_FILE_READ)
+    {
+      clear_file_op_status_bit(UG31XX_KERNEL_FILE_EXIST);
+      clear_file_op_status_bit(UG31XX_KERNEL_FILE_WRITE);
+      set_file_op_status_bit(UG31XX_KERNEL_FILE_READ);
+      set_file_op_status_bit(UG31XX_KERNEL_FILE_FINISH);
+      return (_UPI_TRUE_);
+    }
+
+    clear_file_op_status_bit(UG31XX_KERNEL_FILE_EXIST);
+    clear_file_op_status_bit(UG31XX_KERNEL_FILE_WRITE);
+    set_file_op_status_bit(UG31XX_KERNEL_FILE_READ);
+    set_file_op_status_bit(UG31XX_KERNEL_FILE_FINISH);
+    return (_UPI_FALSE_);
+
+  #else   ///< else of UG31XX_USE_DAEMON_AP_FOR_FILE_OP
+
+    struct file *fp;
+    _upi_u8_ retry;
+
+    retry = 3;
+    while(retry)
+    {
+      fp = filp_open(filename, O_RDWR, 0644);
+      if(!is_err(fp))
+      {
+        break;
+      }
+
+      retry = retry - 1;
+    }
+    if(retry == 0)
+    {
+      return (_UPI_FALSE_);
+    }
+
+    /// [AT-PM] : Write data to file ; 02/21/2013
+    read_file(fp, data, size);
+
+    filp_close(fp, _UPI_NULL_);
+
+  #endif  ///< end of UG31XX_USE_DAEMON_AP_FOR_FILE_OP
+
+  #endif  ///< end of UG31XX_USE_SHELL_AP_FOR_FILE_OP
+
+    #else
+    if (ug31xx_restore_config_data("ug31xx", data, size)) {
+        UG31_LOGE("[%s]: fail to read Intel UMIP data\n", __func__);
+        return (_UPI_FALSE_);
+    }
+    return (_UPI_TRUE_);
+    #endif
+
+  #endif  ///< end of uG31xx_BOOT_LOADER
+
+  return (_UPI_TRUE_);
+}
+
+/**
+ * @brief write_backup_file
+ *
+ *  Write data to backup file
+ *
+ * @para  filename  address of backup filename string
+ * @para  data  address of data buffer
+ * @para  size  size of data to be written
+ * @return  _UPI_TRUE_ if success
+ */
+#ifdef  uG31xx_OS_WINDOWS
+  extern _upi_bool_ write_backup_file(const wchar_t *filename, _upi_u8_ *data, _upi_u32_ size)
+#else   ///< else of uG31xx_OS_WINDOWS
+  extern _upi_bool_ write_backup_file(char *filename, _upi_u8_ *data, _upi_u32_ size)
+#endif  ///< end of uG31xx_OS_WINDOWS
+{
+  #ifndef uG31xx_BOOT_LOADER
+
+    #ifndef CONFIG_ASUS_ENGINEER_MODE
+
+  #ifdef  UG31XX_USE_SHELL_AP_FOR_FILE_OP
+
+    struct subprocess_info *sub_info;
+    char *argv[] = {shell_ap_name, "BACKUP_FILE", "WRITE", filename, NULL};
+    char *env[] = {NULL};
+    int rtn;
+
+    sub_info = NULL;
+    sub_info = call_usermodehelper_setup(argv[0], argv, env, GFP_ATOMIC);
+    if(sub_info == NULL)
+    {
+      return (_UPI_FALSE_);
+    }
+    UG31_LOGN("[%s]: call_usermodehelper_setup() done (%d - %d - %d)\n", __func__, (int)sub_info, (int)data, (int)size);
+
+    rtn = call_usermodehelper_exec(sub_info, UMH_WAIT_PROC);
+    UG31_LOGN("[%s]: call_usermodehelper_exec() = %d\n", __func__, rtn);
+    return ((rtn == 0) ? _UPI_TRUE_ : _UPI_FALSE_);
+
+  #else   ///< else of UG31XX_USE_SHELL_AP_FOR_FILE_OP
+
+  #ifdef  UG31XX_USE_DAEMON_AP_FOR_FILE_OP
+
+    if(get_file_op_status() & UG31XX_KERNEL_FILE_FINISH)
+    {
+      clear_file_op_status_bit(UG31XX_KERNEL_FILE_EXIST);
+      clear_file_op_status_bit(UG31XX_KERNEL_FILE_READ);
+      set_file_op_status_bit(UG31XX_KERNEL_FILE_WRITE);
+      return (_UPI_FALSE_);
+    }
+
+    if(get_file_op_status() & UG31XX_USER_FILE_WRITE)
+    {
+      clear_file_op_status_bit(UG31XX_KERNEL_FILE_EXIST);
+      clear_file_op_status_bit(UG31XX_KERNEL_FILE_WRITE);
+      set_file_op_status_bit(UG31XX_KERNEL_FILE_READ);
+      set_file_op_status_bit(UG31XX_KERNEL_FILE_FINISH);
+      return (_UPI_TRUE_);
+    }
+
+    clear_file_op_status_bit(UG31XX_KERNEL_FILE_EXIST);
+    clear_file_op_status_bit(UG31XX_KERNEL_FILE_READ);
+    set_file_op_status_bit(UG31XX_KERNEL_FILE_WRITE);
+    set_file_op_status_bit(UG31XX_KERNEL_FILE_FINISH);
+    return (_UPI_FALSE_);
+
+  #else   ///< else of UG31XX_USE_DAEMON_AP_FOR_FILE_OP
+
+    struct file *fp;
+    _upi_u8_ retry;
+
+    retry = 3;
+    while(retry)
+    {
+      fp = filp_open(filename, O_CREAT | O_RDWR, 0644);
+      if(!is_err(fp))
+      {
+        break;
+      }
+
+      retry = retry - 1;
+    }
+    if(retry == 0)
+    {
+      return (_UPI_FALSE_);
+    }
+
+    /// [AT-PM] : Write data to file ; 02/21/2013
+    write_file(fp, data, size);
+
+    filp_close(fp, _UPI_NULL_);
+
+  #endif  ///< end of UG31XX_USE_DAEMON_AP_FOR_FILE_OP
+
+    #endif  ///< end of UG31XX_USE_SHELL_AP_FOR_FILE_OP
+
+    #else
+    int backup_tag = BACKUP_BATTERY_KEY;
+    if (ug31xx_save_config_data("ug31xx", data, size)) {
+        UG31_LOGE("[%s]: fail to write Intel UMIP data\n", __func__);
+        return (_UPI_FALSE_);
+    }
+    return (_UPI_TRUE_);
+    #endif
+
+  #endif  ///< end of uG31xx_BOOT_LOADER
+
+  return (_UPI_TRUE_);
+}
+
+/**
+ * @brief upi_memcmp
+ *
+ *  Memory compare for uG31xx driver
+ *
+ * @para  s1  address of memory 1
+ * @para  s2  address of memory 2
+ * @para  size  size to be compared
+ * @return  0 if the same
+ */
+_upi_u32_ upi_memcmp(void *s1, void *s2, _upi_u32_ size)
+{
+  #ifdef  uG31xx_NO_MEM_UNIT
+    _upi_u64_ idx;
+    _upi_u8_ *ptr_s1;
+    _upi_u8_ *ptr_s2;
+
+    idx = 0;
+    ptr_s1 = (_upi_u8_ *)s1;
+    ptr_s2 = (_upi_u8_ *)s2;
+    while(idx < size)
+    {
+      if(*(ptr_s1 + idx) != *(ptr_s2 + idx))
+      {
+        return (1);
+      }
+      idx = idx + 1;
+    }
+    return (0);
+  #else   ///< else of uG31xx_NO_MEM_UNIT
+    return ((_upi_u32_)memcmp(s1, s2, size));
+  #endif  ///< end of uG31xx_NO_MEM_UNIT
+}
+
+#if defined(uG31xx_OS_ANDROID)
+
+/**
+ * @brief GetTickCount
+ *
+ *  Get system time tick
+ *
+ * @return  time tick
+ */
+_upi_u32_ GetTickCount(void)
+{
+  #ifdef  uG31xx_BOOT_LOADER
+
+    return (0);
+
+  #else   ///< else of uG31xx_BOOT_LOADER
+
+    return jiffies_to_msecs(jiffies);      //20121121/jacky
+
+  #endif  ///< end of uG31xx_BOOT_LOADER
+}
+
+/**
+ * @brief GetSysTickCount
+ *
+ *  Get system time
+ *
+ * @return  system time in millisecond
+ */
+_upi_u32_ GetSysTickCount(void)
+{
+  #ifdef  uG31xx_BOOT_LOADER
+
+    return (0);
+
+  #else   ///< else of uG31xx_BOOT_LOADER
+
+    struct timeval current_tick;
+
+    do_gettimeofday(&current_tick);
+
+    return current_tick.tv_sec * 1000 + current_tick.tv_usec/1000;
+
+  #endif  ///< end of uG31xx_BOOT_LOADER
+}
+
+#endif  ///< end of defined(uG31xx_OS_ANDROID)
+
+/**
+ * @brief upi_memset
+ *
+ *  Set memory initial value for uG31xx driver
+ *
+ * @para  ptr address of memory
+ * @para  value initial value
+ * @para  size  size to be set
+ * @return  NULL
+ */
+void upi_memset(void *ptr, _upi_u8_ value, _upi_u32_ size)
+{
+  #ifdef  uG31xx_NO_MEM_UNIT
+    _upi_u64_ idx;
+    _upi_u8_ *ptr_ptr;
+
+    idx = 0;
+    ptr_ptr = (_upi_u8_ *)ptr;
+    while(idx < size)
+    {
+      *(ptr_ptr + idx) = value;
+      idx = idx + 1;
+    }
+  #else   ///< else of uG31xx_NO_MEM_UNIT
+    memset(ptr, value, size);
+  #endif  ///< end of uG31xx_NO_MEM_UNIT
+}
+
+_upi_u8_ Ug31DebugEnable = LOG_LEVEL_ERROR;
+
+#ifdef  uG31xx_OS_WINDOWS
+
+  unsigned int debugViewLines = 0;
+  CString debugViewFileName = _T("uG3100-1");
+
+#else   ///< else of uG31xx_OS_WINDOWS
+
+#ifndef  uG31xx_BOOT_LOADER
+
+/**
+ * @brief ug31_printk
+ *
+ *  Print debug message
+ *
+ * @para  level message level
+ * @para  fmt message
+ * @return  integer
+ */
+int ug31_printk(int level, const char *fmt, ...)
+{
+  #ifdef  UG31XX_LIB_DEBUG_MSG
+
+    va_list args;
+    int r;
+
+    r = 0;
+    if(level <= Ug31DebugEnable)
+    {
+      va_start(args, fmt);
+      r = vprintk(fmt, args);
+      va_end(args);
+    }
+
+    return (r);
+
+  #else   ///< else of UG31XX_LIB_DEBUG_MSG
+
+    return (0);
+
+  #endif  ///< end of UG31XX_LIB_DEBUG_MSG
+}
+
+/**
+ * @brief ug31_printk_special
+ *
+ *  Print debug message
+ *
+ * @para  level message level
+ * @para  fmt message
+ * @return  integer
+ */
+int ug31_printk_special(int level, const char *fmt, ...)
+{
+  va_list args;
+  int r;
+
+  r = 0;
+  if(level <= Ug31DebugEnable)
+  {
+    va_start(args, fmt);
+    r = vprintk(fmt, args);
+    va_end(args);
+  }
+
+  return (r);
+}
+
+#endif  ///< end of uG31xx_BOOT_LOADER
+
+#endif  ///< end of uG31xx_OS_WINDOWS
+
+#ifndef uG31xx_OS_WINDOWS
+
+/**
+ * @brief upi_strlen
+ *
+ *  Get string length for uG31xx driver
+ *
+ * @para  stream  address of string
+ * @return  string length
+ */
+_upi_u32_ upi_strlen(char *stream)
+{
+  #ifdef  uG31xx_BOOT_LOADER
+
+    return (0);
+
+  #else   ///< else of uG31xx_BOOT_LOADER
+
+    return ((_upi_u32_)strlen(stream));
+
+  #endif  ///< end of uG31xx_BOOT_LOADER
+}
+
+#endif  ///< end of uG31xx_OS_WINDOWS
+
+#ifndef uG31xx_OS_WINDOWS
+
+#ifndef uG31xx_BOOT_LOADER
+
+#define SECURITY_KEY    (0x5A)    //i2c read/write
+#define ONE_BYTE        (0x1)
+#define TWO_BYTE        (0x0)
+
+static struct i2c_client *ug31xx_client = _UPI_NULL_;
+
+void ug31xx_i2c_client_set(struct i2c_client *client)
+{
+  ug31xx_client = client;
+  dev_info(&ug31xx_client->dev, "%s: Ug31xx i2c client saved.\n", __func__);
+}
+
+_upi_s32_ ug31xx_read_i2c(struct i2c_client *client, _upi_u8_ reg, _upi_s32_ *rt_value, _upi_s32_ b_single)
+{
+  struct i2c_msg msg[2];
+  _upi_u8_ data[4];
+  _upi_s32_ err;
+
+  if((!client) || (!client->adapter))
+  {
+    return -ENODEV;
+  }
+
+  if(!rt_value)
+  {
+    return -EINVAL;
+  }
+
+  data[0] = reg;
+
+  msg[0].addr = client->addr;
+  msg[0].flags = 0 | I2C_M_NOSTART;
+  msg[0].len = 1;
+  if(reg >= 0x80)
+  {
+    data[1] = SECURITY_KEY;
+    msg[0].len++;
+  }
+  msg[0].buf = (unsigned char *)data;
+
+  msg[1].addr = client->addr;
+  msg[1].flags = (I2C_M_RD);
+  msg[1].len = b_single ? 1 : 2;
+  msg[1].buf = (unsigned char *)data;
+
+  err = i2c_transfer(client->adapter, msg, sizeof(msg)/sizeof(struct i2c_msg));
+
+  if(err < 0)
+  {
+    return err;
+  }
+
+  if(b_single)
+  {
+    *rt_value = (_upi_s32_)data[0];
+  }
+  else
+  {
+    *rt_value = (_upi_s32_)get_unaligned_le16(data);
+  }
+
+  return 0;
+}
+
+_upi_s32_ ug31xx_write_i2c(struct i2c_client *client, _upi_u8_ reg, _upi_s32_ rt_value, _upi_s32_ b_single)
+{
+  struct i2c_msg msg[1];
+  _upi_u8_ data[4];
+  _upi_s32_ err;
+  _upi_s32_ idx;
+  _upi_s32_ tmp_buf=0;
+
+  if((!client) || (!client->adapter))
+  {
+    return -ENODEV;
+  }
+
+  idx = 0;
+  data[idx++] = reg;
+  if (reg >= 0x80)
+  {
+    data[idx++] = SECURITY_KEY;
+  }
+  data[idx++] = (_upi_u8_)(rt_value & 0x00FF);
+  data[idx++] = (_upi_u8_)((rt_value & 0x0FF00) >> 8);
+
+  msg[0].addr = client->addr;
+  msg[0].flags = 0 | I2C_M_NOSTART;
+  msg[0].len = b_single ? idx-1 : idx;
+  msg[0].buf = (unsigned char *)data;
+
+  err = i2c_transfer(client->adapter, msg, sizeof(msg)/sizeof(struct i2c_msg));
+
+  if(err >= 0)
+  {
+    err = ug31xx_read_i2c(client, reg, &tmp_buf, b_single);
+    if((tmp_buf & 0x00FF) != (rt_value & 0x00FF))
+    {
+      dev_info(&ug31xx_client->dev, "%s: %04x != %04x (%02x)\n", __func__, tmp_buf, rt_value, reg);
+    }
+  }
+  return (err < 0 ? err : 0);
+}
+
+_upi_bool_ _API_I2C_Write(_upi_u16_ writeAddress, _upi_u8_ writeLength, _upi_u8_ *PWriteData)
+{
+  _upi_s32_ i, ret, tmp_buf;
+  _upi_s32_ byte_flag=0;
+  _upi_u8_ retry_cnt = I2C_RETRY_CNT;
+
+  if (!PWriteData)
+  {
+    dev_err(&ug31xx_client->dev, "%s: Write buffer pointer error.\n", __func__);
+    return false;
+  }
+
+  byte_flag = ONE_BYTE;
+
+  for(i=0; i<writeLength; i++)
+  {
+    tmp_buf = PWriteData[i];
+
+    while(retry_cnt--)
+    {
+      ret = ug31xx_write_i2c(ug31xx_client, (_upi_u8_)(writeAddress + i), tmp_buf, byte_flag);
+      if(ret)
+      {
+        dev_err(&ug31xx_client->dev, "%s: Write data(0x%02X) fail retry_cnt(%d). %d\n", __func__, i, retry_cnt, ret);
+        if(retry_cnt == 1)
+        {
+          return (_UPI_FALSE_);
+        }
+      }
+      else
+      {
+        break;
+      }
+    }
+  }
+
+  return (_UPI_TRUE_);
+}
+
+_upi_bool_ _API_I2C_Read(_upi_u16_ readAddress, _upi_u8_ readLength, _upi_u8_ *pReadDataBuffer)
+{
+  _upi_s32_ i, ret, tmp_buf;
+  _upi_s32_ byte_flag = 0;
+  _upi_u8_ retry_cnt = I2C_RETRY_CNT;
+
+  if(!pReadDataBuffer)
+  {
+    dev_err(&ug31xx_client->dev, "%s: Read buffer pointer error.\n", __func__);
+    return false;
+  }
+
+  byte_flag = ONE_BYTE;
+
+  for(i=0; i<readLength; i++)
+  {
+    tmp_buf = 0;
+
+    ret = ug31xx_read_i2c(ug31xx_client, (_upi_u8_)(readAddress + i), &tmp_buf, byte_flag);
+    while(retry_cnt--)
+    {
+      ret = ug31xx_read_i2c(ug31xx_client, (_upi_u8_)(readAddress + i), &tmp_buf, byte_flag);
+      if(ret)
+      {
+        dev_err(&ug31xx_client->dev, "%s: read data(0x%02X) fail retry_cnt(%d). %d\n", __func__, i, retry_cnt, ret);
+        if(retry_cnt == 1)
+        {
+          return (_UPI_FALSE_);
+        }
+      }
+      else
+      {
+        break;
+      }
+    }
+
+    pReadDataBuffer[i] = (_upi_u8_)tmp_buf;
+  }
+
+  return (_UPI_TRUE_);
+}
+
+/**
+ * @brief API_I2C_Read
+ *
+ *  I2C read function for uG31xx driver
+ *
+ * @para  bSecurityMode useless parameter
+ * @para  bHighSpeedMode  useless parameter
+ * @para  bTenBitMode useless parameter
+ * @para  readAddress register address to be read
+ * @para  readLength  length of data to be read
+ * @para  pReadDataBuffer address of buffer
+ * @return  _UPI_TRUE_ if success
+ */
+_upi_bool_ API_I2C_Read(_upi_bool_ bSecurityMode, _upi_bool_ bHighSpeedMode, _upi_bool_ bTenBitMode, _upi_u16_ readAddress, _upi_u8_ readLength, _upi_u8_ *pReadDataBuffer)
+{
+	return (_API_I2C_Read(readAddress, readLength, pReadDataBuffer));
+}
+
+/**
+ * @brief API_I2C_Write
+ *
+ *  I2C write function for uG31xx driver
+ *
+ * @para  bSecurityMode useless parameter
+ * @para  bHighSpeedMode  useless parameter
+ * @para  bTenBitMode useless parameter
+ * @para  writeAddress register address to be written
+ * @para  writeLength  length of data to be written
+ * @para  pWriteData address of buffer
+ * @return  _UPI_TRUE_ if success
+ */
+_upi_bool_ API_I2C_Write(_upi_bool_ bSecurityMode, _upi_bool_ bHighSpeedMode, _upi_bool_ bTenBitMode, _upi_u16_ writeAddress, _upi_u8_ writeLength, _upi_u8_ *pWriteData)
+{
+	return (_API_I2C_Write(writeAddress, writeLength, pWriteData));
+}
+
+/**
+ * @brief API_I2C_Init
+ *
+ *  Initialize i2c device
+ *
+ * @para  client  address of i2c_client
+ * @return  NULL
+ */
+void API_I2C_Init(void *client)
+{
+  ug31xx_i2c_client_set((struct i2c_client *)client);
+}
+
+#endif  ///< end of uG31xx_BOOT_LOADER
+
+#endif  ///< end of uG31xx_OS_WINDOWS
+
+/**
+ * @brief SleepMiniSecond
+ *
+ *  Sleep for mini-seconds
+ *
+ * @para  msec  mini-seconds to be sleep
+ * @return  NULL
+ */
+void SleepMiniSecond(_upi_u32_ msec)
+{
+  #ifdef  uG31xx_OS_WINDOWS
+
+    Sleep(msec);
+
+  #else   ///< else of uG31xx_OS_WINDOWS
+
+    #ifdef  uG31xx_BOOT_LOADER
+
+      volatile int counter = 0;
+      volatile int end_counter = 0;
+      volatile int ms_counter = 0;
+
+      ms_counter = 1000;
+      end_counter = 650 * msec;
+      while(ms_counter)
+      {
+        counter = 0;
+        while(end_counter > counter)
+        {
+          counter ++;
+        }
+        ms_counter = ms_counter - 1;
+      }
+
+    #else   ///< else of uG31xx_BOOT_LOADER
+
+      mdelay(msec);
+
+    #endif  ///< end of uG31xx_BOOT_LOADER
+
+  #endif  ///< end of uG31xx_OS_WINDOWS
+}
+
diff --git a/drivers/power/supply/ASUS_BATTERY/ME176C/ug31xx/uG31xx_API_Platform.h b/drivers/power/supply/ASUS_BATTERY/ME176C/ug31xx/uG31xx_API_Platform.h
new file mode 100644
index 000000000000..8e2643bb834c
--- /dev/null
+++ b/drivers/power/supply/ASUS_BATTERY/ME176C/ug31xx/uG31xx_API_Platform.h
@@ -0,0 +1,245 @@
+/**
+ * @filename  uG31xx_API_Platform.h
+ *
+ *  Header for function required by uG31xx driver
+ *
+ * @author  AllenTeng <allen_teng@upi-semi.com>
+ * @note
+ */
+
+typedef unsigned char       _upi_u8_;
+typedef unsigned short      _upi_u16_;
+typedef unsigned int        _upi_u32_;
+typedef unsigned long long  _upi_u64_;
+typedef char                _upi_s8_;
+typedef short               _upi_s16_;
+typedef int                 _upi_s32_;
+typedef long long           _upi_s64_;
+typedef char                _upi_bool_;
+
+#define _UPI_TRUE_      (1)
+#define _UPI_FALSE_     (0)
+#define _UPI_NULL_      (0)
+
+#define UG31XX_LIB_DEBUG_MSG      ///< [AT-PM] : Enable to enable debug message in linux kernel ; 07/17/2013
+
+#if defined (uG31xx_OS_WINDOWS)
+
+  #pragma pack(push)
+  #pragma pack(1)
+
+  #include <windows.h>
+  #include "../../uG31xx_I2C_DLL/uG3100Dll/uG31xx_I2C.h"
+  #include <assert.h>
+  #include "wDebug.h"
+
+  #define EXPORTS _declspec(dllexport)
+
+#else   ///< else of defined (uG31xx_OS_WINDOWS)
+
+  #ifdef  uG31xx_BOOT_LOADER
+
+    #include "ug31xx_boot_i2c.h"
+
+//    #define UPI_UBOOT_DEBUG_MSG
+
+    #define UPI_BOOT_STATUS_FCC_IS_0            (1<<0)
+    #define UPI_BOOT_STATUS_IC_IS_NOT_ACTIVE    (1<<1)
+    #define UPI_BOOT_STATUS_WRONG_PRODUCT_TYPE  (1<<2)
+    #define UPI_BOOT_STATUS_FC                  (1<<3)
+
+    #define DEFAULT_TIME_TICK               (0xffffffff)
+    #define RESET_COULOMB_COUNTER_DELTA_CAP (10)
+
+  #else   ///< else of uG31xx_BOOT_LOADER
+
+    #ifndef BUILD_UG31XX_LIB
+
+      #include <linux/module.h>
+      #include <linux/delay.h>
+      #include <linux/fs.h>
+      #include <linux/i2c.h>
+      #include <linux/slab.h>
+      #include <linux/jiffies.h>
+      #include <linux/err.h>
+      #include <linux/kernel.h>
+      #include <asm/uaccess.h>
+      #include <asm/unaligned.h>
+
+    #endif  ///< end of BUILD_UG31XX_LIB
+
+  #endif  ///< end of uG31xx_BOOT_LOADER
+
+  #define EXPORTS
+
+  #define GGBX_FILE_TAG         (0x5F47475F) // _GG_
+  #define GGBX_FACTORY_FILE_TAG (0x5F67675F) // _gg_
+
+#endif  ///< end of defined (uG31xx_OS_WINDOWS)
+
+/// ===================================
+/// [AT-PM] : For read / write file operation ; 07/12/2013
+/// ===================================
+
+#ifdef  uG31xx_OS_WINDOWS
+
+  extern _upi_bool_ is_file_exist(const wchar_t *filename);
+  extern _upi_bool_ create_backup_file(const wchar_t *filename, _upi_u8_ *data, _upi_u8_ size);
+  extern _upi_bool_ read_backup_file(const wchar_t *filename, _upi_u8_ *data, _upi_u32_ size);
+  extern _upi_bool_ write_backup_file(const wchar_t *filename, _upi_u8_ *data, _upi_u32_ size);
+
+#else   ///< else of uG31xx_OS_WINDOWS
+
+  #define UG31XX_KERNEL_FILE_EXIST      (1<<0)
+  #define UG31XX_KERNEL_FILE_READ       (1<<1)
+  #define UG31XX_KERNEL_FILE_WRITE      (1<<2)
+  #define UG31XX_KERNEL_FILE_VERSION    (1<<3)
+  #define UG31XX_KERNEL_FILE_FINISH     (1<<4)
+  #define UG31XX_USER_FILE_EXIST        (1<<5)
+  #define UG31XX_USER_FILE_READ         (1<<6)
+  #define UG31XX_USER_FILE_WRITE        (1<<7)
+
+  #ifndef  uG31xx_BOOT_LOADER
+
+    extern _upi_bool_ is_file_exist(char *filename);
+    extern _upi_bool_ create_backup_file(char *filename, _upi_u8_ *data, _upi_u8_ size);
+    extern _upi_bool_ read_backup_file(char *filename, _upi_u8_ *data, _upi_u32_ size);
+    extern _upi_bool_ write_backup_file(char *filename, _upi_u8_ *data, _upi_u32_ size);
+
+    extern void set_shell_ap_name(char *apname);
+    extern _upi_u8_ get_file_op_status(void);
+    extern _upi_u8_ set_file_op_status_bit(_upi_u8_ bit_sts);
+    extern _upi_u8_ clear_file_op_status_bit(_upi_u8_ bit_sts);
+
+  #endif  ///< end of uG31xx_BOOT_LOADER
+
+#endif  ///< end of uG31xx_OS_WINDOWS
+
+/// ===================================
+/// [AT-PM] : For memory operation ; 07/12/2013
+/// ===================================
+
+#ifdef  uG31xx_BOOT_LOADER
+
+  #ifdef  BUILD_UG31XX_LIB
+
+    #define memset
+    #define memcpy
+    #define malloc
+    #define free
+
+  #endif  ///< end of BUILD_UG31XX_LIB
+
+#endif  ///< end of uG31xx_BOOT_LOADER
+
+extern void upi_free(void *obj);
+extern void *upi_malloc(_upi_u32_ size);
+extern void upi_memcpy(void *dest, void *src, _upi_u32_ size);
+extern _upi_u32_ upi_memcmp(void *s1, void *s2, _upi_u32_ size);
+extern void upi_memset(void *ptr, _upi_u8_ value, _upi_u32_ size);
+
+/// ===================================
+/// [AT-PM] : For system time operation ; 07/12/2013
+/// ===================================
+
+extern void SleepMiniSecond(_upi_u32_ msec);
+
+#ifndef uG31xx_OS_WINDOWS
+
+  extern _upi_u32_ GetTickCount(void);
+  extern _upi_u32_ GetSysTickCount(void);
+
+#endif  ///< end of uG31xx_OS_WINDOWS
+
+/// ===================================
+/// [AT-PM] : For debug message operation ; 07/12/2013
+/// ===================================
+
+#define LOG_LEVEL_ERROR       (0)
+#define LOG_LEVEL_INFO        (1)
+#define LOG_LEVEL_NOTICE      (2)
+#define LOG_LEVEL_DEBUG       (3)
+
+extern _upi_u8_ Ug31DebugEnable;
+
+#if defined (uG31xx_OS_WINDOWS)
+
+  #define  _L(X) __L(X)
+  #define __L(X) L##X
+
+  #define DEBUG_FILE      (_T("uG3105"))
+  #define __func__        (_T(__FUNCTION__))
+
+  #define UG31_LOGE(...)  wDebug::LOGE(DEBUG_FILE, 0, _T(__VA_ARGS__));
+  #define UG31_LOGI(...)  wDebug::LOGE(DEBUG_FILE, 0, _T(__VA_ARGS__));
+  #define UG31_LOGN(...)  wDebug::LOGE(DEBUG_FILE, 0, _T(__VA_ARGS__));
+  #define UG31_LOGD(...)  wDebug::LOGE(DEBUG_FILE, 0, _T(__VA_ARGS__));
+
+  #define ug31_printk(...)
+  #define ug31_printk_special(...)
+
+#else   ///< else of defined (uG31xx_OS_WINDOWS)
+
+  #ifdef  uG31xx_BOOT_LOADER
+
+    #ifdef  BUILD_UG31XX_LIB
+
+      #define printf
+
+    #endif  ///< end of BUILD_UG31XX_LIB
+
+    #define UG31_LOGE(...)  printf(__VA_ARGS__)
+    #define UG31_LOGI(...)  printf(__VA_ARGS__)
+    #define UG31_LOGN(...)  printf(__VA_ARGS__)
+    #define UG31_LOGD(...)  printf(__VA_ARGS__)
+
+  #else   ///< else of uG31xx_BOOT_LOADER
+
+    #ifdef  BUILD_UG31XX_LIB
+
+      #define printk
+
+    #endif  ///< end of BUILD_UG31XX_LIB
+
+    #define UG31_LOGE(...)  if(Ug31DebugEnable >= LOG_LEVEL_ERROR)\
+                              printk("<UG31/E>" __VA_ARGS__);
+    #define UG31_LOGI(...)  if(Ug31DebugEnable >= LOG_LEVEL_INFO)\
+                              printk("<UG31/I>" __VA_ARGS__);
+    #define UG31_LOGN(...)  if(Ug31DebugEnable >= LOG_LEVEL_NOTICE)\
+                              printk("<UG31/N>" __VA_ARGS__);
+    #define UG31_LOGD(...)  if(Ug31DebugEnable >= LOG_LEVEL_DEBUG)\
+                              printk("<UG31/D>" __VA_ARGS__);
+
+    extern int ug31_printk(int level, const char *fmt, ...);
+    extern int ug31_printk_special(int level, const char *fmt, ...);
+
+  #endif  ///< end of uG31xx_BOOT_LOADER
+
+#endif  ///< end of defined (uG31xx_OS_WINDOWS)
+
+/// ===================================
+/// [AT-PM] : For string operation ; 07/12/2013
+/// ===================================
+
+#ifndef uG31xx_OS_WINDOWS
+
+  extern _upi_u32_ upi_strlen(char *stream);
+
+#endif  ///< end of uG31xx_OS_WINDOWS
+
+/// ===================================
+/// [AT-PM] : For I2C operation ; 07/13/2013
+/// ===================================
+
+#ifndef uG31xx_OS_WINDOWS
+
+#ifndef uG31xx_BOOT_LOADER
+
+  extern void API_I2C_Init(void *client);
+  extern _upi_bool_ API_I2C_Read(_upi_bool_ bSecurityMode, _upi_bool_ bHighSpeedMode, _upi_bool_ bTenBitMode, _upi_u16_ readAddress, _upi_u8_ readLength, _upi_u8_ *pReadDataBuffer);
+  extern _upi_bool_ API_I2C_Write(_upi_bool_ bSecurityMode, _upi_bool_ bHighSpeedMode, _upi_bool_ bTenBitMode, _upi_u16_ writeAddress, _upi_u8_ writeLength, _upi_u8_ *pWriteData);
+
+#endif  ///< end of uG31xx_BOOT_LOADER
+
+#endif  ///< end of uG31xx_OS_WINDOWS
+
diff --git a/drivers/power/supply/ASUS_BATTERY/ME176C/ug31xx/uG31xx_API_System.c b/drivers/power/supply/ASUS_BATTERY/ME176C/ug31xx/uG31xx_API_System.c
new file mode 100644
index 000000000000..0d4f97468040
--- /dev/null
+++ b/drivers/power/supply/ASUS_BATTERY/ME176C/ug31xx/uG31xx_API_System.c
@@ -0,0 +1,2029 @@
+/**
+ * Copyright @ 2013 uPI Semiconductor Corp. All right reserved.
+ * The information, images, and/or data contained in this material is copyrighted by uPI
+ * Semiconductor Corp., and may not be distributed, modified, reproduced in whole or in part
+ * without the prior, written consent of uPI Semiconductor Corp.
+ */
+
+/**
+ * @filename  uG31xx_API_System.cpp
+ *
+ *  uG31xx system control
+ *
+ * @author  AllenTeng <allen_teng@upi-semi.com>
+ * @revision  $Revision: 645 $
+ */
+
+#include "stdafx.h"     //windows need this??
+#include "uG31xx_API.h"
+
+SystemDataType *ptrSysData = _UPI_NULL_;
+
+#if defined(uG31xx_OS_WINDOWS)
+
+#define SYSTEM_VERSION      (_T("System $Rev: 645 $"))
+
+_upi_bool_ ReadGGBFileToCellDataAndInitSetting(SystemDataType *obj)
+{
+  FILE* stream;
+
+  UG31_LOGI("[%s]: %s\n", __func__, SYSTEM_VERSION);
+
+  _wfopen_s(&stream, obj->ggbFilename, _T("rb, ccs=UTF-8"));
+
+  upi_memset(ptrCellTable, 0x00, sizeof(CELL_TABLE));
+  upi_memset(ptrCellParameter, 0x00, sizeof(CELL_PARAMETER));
+
+  if(!stream)
+  {
+    return (_UPI_FALSE_);
+  }
+  if(fread(ptrCellParameter, sizeof(char), sizeof(CELL_PARAMETER), stream) != sizeof(CELL_PARAMETER))
+  {
+    fclose(stream);
+    return (_UPI_FALSE_);
+  }
+  if(fread(ptrCellTable, sizeof(char), sizeof(CELL_TABLE), stream) != sizeof(CELL_TABLE))
+  {
+    fclose(stream);
+    return (_UPI_FALSE_);
+  }
+
+  fclose(stream);
+
+  return (_UPI_TRUE_);
+}
+
+#else   ///< else of defined(uG31xx_OS_WINDOWS)
+
+#define SYSTEM_VERSION      ("System $Rev: 645 $")
+
+_upi_bool_ ReadGGBXFileToCellDataAndInitSetting(SystemDataType *obj)
+{
+  _sys_u8_ *p_start = _UPI_NULL_;
+  _sys_u8_ *p_end = _UPI_NULL_;
+  _sys_u16_ sum16=0;
+  _sys_u32_ i=0;
+
+  UG31_LOGI("[%s]: %s\n", __func__, SYSTEM_VERSION);
+  UG31_LOGI("[%s]: Tag = %x (%x)\n", __func__, ptrGgbBuf->ggb_tag, GGBX_FILE_TAG);
+
+  /*
+     * check GGBX_FILE tag
+     */
+  if(ptrGgbBuf->ggb_tag != GGBX_FILE_TAG)
+  {
+    UG31_LOGE("[%s] GGBX file tag not correct. tag: %08X\n", __func__, ptrGgbBuf->ggb_tag);
+    return (_UPI_FALSE_);
+  }
+
+  UG31_LOGI("[%s]: Size = %d (%d)\n", __func__, sizeof(GGBX_FILE_HEADER), ptrGgbBuf->length);
+  /*
+     * check GGBX_FILE checksum
+     */
+  p_start = (_sys_u8_ *)ptrGgbBuf + sizeof(GGBX_FILE_HEADER);
+  p_end = p_start + ptrGgbBuf->length - 1;
+  UG31_LOGI("[%s]: SUM Start at %x, end at %x\n", __func__, p_start, p_end);
+  for (; p_start <= p_end; p_start++)
+  {
+    sum16 += *p_start;
+  }
+  UG31_LOGI("[%s]: checksum = %x\n", __func__, sum16);
+
+  UG31_LOGI("[%s]: GGB address = %x,%x\n", __func__, ptrCellTable, ptrCellParameter);
+  /* check done. prepare copy data */
+  upi_memset(ptrCellTable, 0x00, sizeof(CELL_TABLE));
+  upi_memset(ptrCellParameter, 0x00, sizeof(CELL_PARAMETER));
+
+  p_start = (_sys_u8_ *)ptrGgbBuf + sizeof(GGBX_FILE_HEADER);
+  UG31_LOGI("[%s]: Copy %d GGB data start from %x\n", __func__, ptrGgbBuf->num_ggb, p_start);
+  for (i=0; i<ptrGgbBuf->num_ggb; i++)
+  {
+    /* TODO: boundary checking */
+    /* TODO: select right ggb content by sku */
+    upi_memcpy(ptrCellParameter, p_start, sizeof(CELL_PARAMETER));
+    upi_memcpy(ptrCellTable, p_start + ptrGgbBuf->parameter_size, sizeof(CELL_TABLE));
+    p_start += (ptrGgbBuf->parameter_size + ptrGgbBuf->cell_table_size);
+    UG31_LOGI("[%s]: Parameter size = %d (%d), Table size = %d (%d)\n", __func__, ptrGgbBuf->parameter_size, sizeof(CELL_PARAMETER), ptrGgbBuf->cell_table_size, sizeof(CELL_TABLE));
+  }
+
+  UG31_LOGI("[%s]: adc2_gain = %x\n", __func__, ptrCellParameter->adc2_gain);
+  UG31_LOGI("[%s]: rtTable[0] = %x\n", __func__, ptrCellParameter->rtTable[0]);
+  UG31_LOGI("[%S]: SOV_TABLE[0] = %d\n", __func__, ptrCellParameter->SOV_TABLE[0]);
+  UG31_LOGI("[%S]: SOV_TABLE[%d] = %d\n", __func__, SOV_NUMS - 1, ptrCellParameter->SOV_TABLE[SOV_NUMS - 1]);
+  UG31_LOGI("[%s]: adc_d1 = %x\n", __func__, ptrCellParameter->adc_d1);
+  UG31_LOGI("[%s]: adc_d2 = %x\n", __func__, ptrCellParameter->adc_d2);
+  UG31_LOGI("[%s]: adc_d3 = %x\n", __func__, ptrCellParameter->adc_d3);
+  UG31_LOGI("[%s]: adc_d4 = %x\n", __func__, ptrCellParameter->adc_d4);
+  UG31_LOGI("[%s]: adc_d5 = %x\n", __func__, ptrCellParameter->adc_d5);
+  UG31_LOGI("[%s]: CycleCountThrd = %x\n", __func__, ptrCellParameter->CycleCountThrd);
+  UG31_LOGI("[%s]: NacLmdAdjustCfg = %x\n", __func__, ptrCellParameter->NacLmdAdjustCfg);
+  return (_UPI_TRUE_);
+}
+
+#endif  ///< end of defined(uG31xx_OS_WINDOWS)
+
+/**
+ * @brief GetCellNum
+ *
+ *  Get cell number from ggbParameter->ICType
+ *
+ * @para  data  address of SystemDataType
+ * @return  _UPI_NULL_
+ */
+void GetCellNum(SystemDataType *data)
+{
+  switch(ptrCellParameter->ICType)
+  {
+    case  0:
+    case  1:
+      data->cellNum = 1;
+      break;
+    case  2:
+    case  4:
+      data->cellNum = 2;
+      break;
+    case  5:
+      data->cellNum = 3;
+      break;
+    case  3:
+    default:
+      data->cellNum = 0;
+      break;
+  }
+}
+
+/**
+ * @brief SetupAdcChopFunction
+ *
+ *  Setup ADC chop function
+ *
+ * @para  data  address of SystemDataType
+ * @return  _UPI_NULL_
+ */
+void SetupAdcChopFunction(SystemDataType *data)
+{
+  API_I2C_Write(SECURITY,
+                UG31XX_I2C_HIGH_SPEED_MODE,
+                UG31XX_I2C_TEM_BITS_MODE,
+                REG_FW_CTRL,
+                1,
+                &ptrCellParameter->chopCtrl);
+}
+
+/**
+ * @brief CheckAdcChopFunction
+ *
+ *  Check ADC chop function
+ *
+ * @para  data  address of SystemDataType
+ * @return  _UPI_TRUE_ if pass
+ */
+_sys_bool_ CheckAdcChopFunction(SystemDataType *data)
+{
+  _sys_u8_ buf;
+
+  buf = 0;
+  API_I2C_Read(SECURITY,
+               UG31XX_I2C_HIGH_SPEED_MODE,
+               UG31XX_I2C_TEM_BITS_MODE,
+               REG_FW_CTRL,
+               1,
+               &buf);
+  return ((buf == ptrCellParameter->chopCtrl) ? _UPI_TRUE_ : _UPI_FALSE_);
+}
+
+static _sys_u8_ adc1QueueInit[] =
+{
+  SET_A_CURRENT | SET_B_CURRENT | SET_C_CURRENT | SET_D_ET,
+  SET_E_ET | SET_F_ET | SET_G_IT | SET_H_IT,
+  SET_I_IT | SET_J_CURRENT | SET_K_CURRENT | SET_L_CURRENT,
+  SET_M_CURRENT | SET_N_CURRENT | SET_O_CURRENT | SET_P_CURRENT,
+};
+
+static _sys_u8_ adc1QueueNormal[] =
+{
+  SET_A_IT | SET_B_IT | SET_C_ET | SET_D_ET,
+  SET_E_CURRENT | SET_F_CURRENT | SET_G_CURRENT | SET_H_CURRENT,
+  SET_I_CURRENT | SET_J_CURRENT | SET_K_CURRENT | SET_L_CURRENT,
+  SET_M_CURRENT | SET_N_CURRENT | SET_O_CURRENT | SET_P_CURRENT,
+};
+
+/**
+ * @brief SetupAdc1Queue
+ *
+ *  Setup ADC1 conversion queue
+ *
+ * @para  data  address of SystemDataType
+ * @return  _UPI_NULL_
+ */
+void SetupAdc1Queue(SystemDataType *data)
+{
+ 	API_I2C_Write(SECURITY,
+                UG31XX_I2C_HIGH_SPEED_MODE,
+                UG31XX_I2C_TEM_BITS_MODE,
+                REG_ADC_CTR_A,
+                4,
+                &adc1QueueInit[0]);
+}
+
+/**
+ * @brief CheckAdc1Queue
+ *
+ *  Check ADC1 conversion queue
+ *
+ * @para  data  address of SystemDataType
+ * @return  _UPI_TRUE_ if pass
+ */
+_sys_bool_ CheckAdc1Queue(SystemDataType *data)
+{
+  _sys_u8_ adcQueue[4];
+
+  adcQueue[0] = 0;
+  adcQueue[1] = 0;
+  adcQueue[2] = 0;
+  adcQueue[3] = 0;
+  API_I2C_Read(SECURITY,
+               UG31XX_I2C_HIGH_SPEED_MODE,
+               UG31XX_I2C_TEM_BITS_MODE,
+               REG_ADC_CTR_A,
+               4,
+               &adcQueue[0]);
+
+  if(adcQueue[0] != adc1QueueNormal[0])
+  {
+    return (_UPI_FALSE_);
+  }
+  if(adcQueue[1] != adc1QueueNormal[1])
+  {
+    return (_UPI_FALSE_);
+  }
+  if(adcQueue[2] != adc1QueueNormal[2])
+  {
+    return (_UPI_FALSE_);
+  }
+  if(adcQueue[3] != adc1QueueNormal[3])
+  {
+    return (_UPI_FALSE_);
+  }
+  return (_UPI_TRUE_);
+}
+
+static _sys_u8_ adc2Queue1[] =  ///< [AT-PM] : 1 cell application ; 03/07/2014
+{
+  SET_V1_VBAT1 | SET_V2_VBAT1 | SET_V3_VBAT1 | SET_V4_VBAT1,
+  SET_V5_VBAT1 | SET_V6_VBAT1 | SET_V7_VBAT1 | SET_V8_VBAT1,
+  SET_V9_VBAT1 | SET_V10_VBAT1 | SET_V11_VBAT1 | SET_V12_VBAT1,
+};
+
+static _sys_u8_ adc2Queue2[] =  ///< [AT-PM] : 2 cell application ; 03/07/2014
+{
+  SET_V1_VBAT1 | SET_V2_VBAT1 | SET_V3_VBAT2 | SET_V4_VBAT2,
+  SET_V5_VBAT1 | SET_V6_VBAT1 | SET_V7_VBAT2 | SET_V8_VBAT2,
+  SET_V9_VBAT1 | SET_V10_VBAT1 | SET_V11_VBAT2 | SET_V12_VBAT2,
+};
+
+static _sys_u8_ adc2Queue3[] =  ///< [AT-PM] : 3 cell application ; 03/07/2014
+{
+  SET_V1_VBAT1 | SET_V2_VBAT1 | SET_V3_VBAT2 | SET_V4_VBAT2,
+  SET_V5_VBAT3 | SET_V6_VBAT3 | SET_V7_VBAT1 | SET_V8_VBAT1,
+  SET_V9_VBAT2 | SET_V10_VBAT2 | SET_V11_VBAT3 | SET_V12_VBAT3,
+};
+
+/**
+ * @brief SetupAdc2Queue
+ *
+ *  Set ADC2 conversion queue
+ *
+ * @para  data  address of SystemDataType
+ * @return  _UPI_NULL_
+ */
+void SetupAdc2Quene(SystemDataType *data)
+{
+  _sys_u8_ *adc2Queue;
+
+  /// [AT-PM] : Set cell type ; 01/31/2013
+  if(data->cellNum == 1)
+  {
+    adc2Queue = &adc2Queue1[0];
+  }
+  else if(data->cellNum == 2)
+  {
+    adc2Queue = &adc2Queue2[0];
+  }
+  else if(data->cellNum == 3)
+  {
+    adc2Queue = &adc2Queue3[0];
+  }
+  else
+  {
+    adc2Queue = &adc2Queue1[0];
+  }
+
+  API_I2C_Write(SECURITY,
+                UG31XX_I2C_HIGH_SPEED_MODE,
+                UG31XX_I2C_TEM_BITS_MODE, REG_ADC_V1,
+                3,
+                adc2Queue);
+}
+
+/**
+ * @brief CheckAdc2Queue
+ *
+ *  Check ADC2 conversion queue
+ *
+ * @para  data  address of SystemDataType
+ * @return  _UPI_TRUE_ if pass
+ */
+_sys_bool_ CheckAdc2Queue(SystemDataType *data)
+{
+  _sys_u8_ adc2Queue[3];
+  _sys_u8_ *adc2QueuePtr;
+
+  adc2Queue[0] = 0;
+  adc2Queue[1] = 0;
+  adc2Queue[2] = 0;
+  /// [AT-PM] : Set cell type ; 01/31/2013
+  if(data->cellNum == 1)
+  {
+    adc2QueuePtr = &adc2Queue1[0];
+  }
+  else if(data->cellNum == 2)
+  {
+    adc2QueuePtr = &adc2Queue2[0];
+  }
+  else if(data->cellNum == 3)
+  {
+    adc2QueuePtr = &adc2Queue3[0];
+  }
+  else
+  {
+    adc2QueuePtr = &adc2Queue1[0];
+  }
+
+  API_I2C_Read(SECURITY,
+               UG31XX_I2C_HIGH_SPEED_MODE,
+               UG31XX_I2C_TEM_BITS_MODE, REG_ADC_V1,
+               3,
+               &adc2Queue[0]);
+
+  if(adc2QueuePtr[0] != adc2Queue[0])
+  {
+    return (_UPI_FALSE_);
+  }
+  if(adc2QueuePtr[0] != adc2Queue[0])
+  {
+    return (_UPI_FALSE_);
+  }
+  if(adc2QueuePtr[0] != adc2Queue[0])
+  {
+    return (_UPI_FALSE_);
+  }
+  return (_UPI_TRUE_);
+}
+
+/**
+ * @brief EnableCbc
+ *
+ *  Enable CBC function
+ *
+ * @para  data  address of SystemDataType
+ * @return  _UPI_NULL_
+ */
+void EnableCbc(SystemDataType *data)
+{
+  _sys_u8_ tmp8;
+
+  tmp8 = 0;
+  API_I2C_Read(SECURITY,
+               UG31XX_I2C_HIGH_SPEED_MODE,
+               UG31XX_I2C_TEM_BITS_MODE,
+               REG_INTR_CTRL_B,
+               1,
+               &tmp8);
+  tmp8 = tmp8 & (~(INTR_CTRL_B_CBC_32_EN | INTR_CTRL_B_CBC_21_EN));
+  tmp8 = tmp8 | (INTR_CTRL_B_ET_EN | INTR_CTRL_B_IT_EN | INTR_CTRL_B_RID_EN);
+  tmp8 = tmp8 | (ptrCellParameter->cbcEnable << 4);
+  API_I2C_Write(SECURITY,
+                UG31XX_I2C_HIGH_SPEED_MODE,
+                UG31XX_I2C_TEM_BITS_MODE,
+                REG_INTR_CTRL_B,
+                1,
+                &tmp8);
+}
+
+/**
+ * @brief EnableICType
+ *
+ *  Enable IC type
+ *
+ * @para  data  address of SystemDataType
+ * @return  _UPI_NULL_
+ */
+void EnableICType(SystemDataType *data)
+{
+  _sys_u8_ tmp8;
+
+  tmp8 = 0;
+  API_I2C_Read(SECURITY,
+               UG31XX_I2C_HIGH_SPEED_MODE,
+               UG31XX_I2C_TEM_BITS_MODE,
+               REG_CELL_EN,
+               1,
+               &tmp8);
+  tmp8 = tmp8 & (~CELL_EN_APPLICATION);
+  tmp8 = tmp8 | (ptrCellParameter->ICType << 2);
+  API_I2C_Write(SECURITY,
+                UG31XX_I2C_HIGH_SPEED_MODE,
+                UG31XX_I2C_TEM_BITS_MODE,
+                REG_CELL_EN,
+                1,
+                &tmp8);
+}
+
+/**
+ * @brief ConfigGpioFunction
+ *
+ *  Configure GPIO1/2 function
+ *
+ * @para  setting GPIO1/2 setting
+ * @return  register value
+ */
+_sys_u8_ ConfigGpioFunction(_sys_u8_ setting)
+{
+	_sys_u8_ gpioSelData = 0;
+
+	if(setting & FUN_GPIO)
+	{
+		gpioSelData = 0;
+	}
+	if(setting & FUN_ALARM)   //select Alarm function
+	{
+		gpioSelData = 1;
+	}
+	if(setting & FUN_CBC_EN21)	//cbc21 enable
+	{
+		gpioSelData = 2;
+	}if(setting & FUN_CBC_EN32)		//cbc32 Enable
+	{
+		gpioSelData = 3;
+	}
+	if(setting & FUN_PWM)  //PWM function, set PWM cycle
+	{
+		gpioSelData = 4;
+	}
+  UG31_LOGE("[%s]: gpioSelData = %d\n", __func__, gpioSelData);
+	return (gpioSelData);
+}
+
+/**
+ * @brief ConfigureGpio
+ *
+ *  Configure GPIO function
+ *
+ * @para  data  SystemDataType
+ * @return  _UPI_NULL_
+ */
+void ConfigureGpio(SystemDataType *data)
+{
+  _sys_u8_ tmp8;
+
+  tmp8 = 0;
+  API_I2C_Read(SECURITY,
+               UG31XX_I2C_HIGH_SPEED_MODE,
+               UG31XX_I2C_TEM_BITS_MODE,
+               REG_INTR_CTRL_A,
+               1,
+               &tmp8);
+  tmp8 = tmp8 | (ConfigGpioFunction(ptrCellParameter->gpio1) << 2);
+  tmp8 = tmp8 | (ConfigGpioFunction(ptrCellParameter->gpio2) << 5);
+  API_I2C_Write(SECURITY,
+                UG31XX_I2C_HIGH_SPEED_MODE,
+                UG31XX_I2C_TEM_BITS_MODE,
+                REG_INTR_CTRL_A,
+                1,
+                &tmp8);
+  UG31_LOGE("[%s]: REG_INTR_CTRL_A = %x\n", __func__, tmp8);
+  API_I2C_Write(SECURITY,
+                UG31XX_I2C_HIGH_SPEED_MODE,
+                UG31XX_I2C_TEM_BITS_MODE,
+                REG_INTR_CTRL_D,
+                1,
+                &ptrCellParameter->gpio34);
+}
+
+#define ADC1_FAIL_CRITERIA    (0)
+#define ADC2_FAIL_CRITERIA    (5)
+#define ADC_FAIL_MIN_IT_CODE  (IT_IDEAL_CODE_25/2)
+#define ADC_FAIL_MAX_IT_CODE  (IT_IDEAL_CODE_80*11/10)
+
+/**
+ * @brief CheckAdcStatusFail
+ *
+ *  Check ADC status is fail or not
+ *
+ * @para  pUg31xx address of SystemDataType
+ * @return  _UPI_TRUE_ if fail
+ */
+_upi_bool_ CheckAdcStatusFail(SystemDataType *data)
+{
+  API_I2C_Read(NORMAL,
+               UG31XX_I2C_HIGH_SPEED_MODE,
+               UG31XX_I2C_TEM_BITS_MODE,
+               REG_COUNTER_LOW,
+               REG_COUNTER_HIGH - REG_COUNTER_LOW + 1,
+               (unsigned char *)&data->adcCheckData.regCounter);
+
+  API_I2C_Read(NORMAL,
+               UG31XX_I2C_HIGH_SPEED_MODE,
+               UG31XX_I2C_TEM_BITS_MODE,
+               REG_AVE_VBAT1_LOW,
+               REG_AVE_VBAT1_HIGH - REG_AVE_VBAT1_LOW + 1,
+               (unsigned char *)&data->adcCheckData.regVbat1Ave);
+
+  API_I2C_Read(NORMAL,
+               UG31XX_I2C_HIGH_SPEED_MODE,
+               UG31XX_I2C_TEM_BITS_MODE,
+               REG_AVE_IT_LOW,
+               REG_AVE_IT_HIGH - REG_AVE_IT_LOW + 1,
+               (unsigned char *)&data->adcCheckData.regITAve);
+
+  /// [AT-PM] : Compare counter register ; 01/27/2013
+  if(data->adcCheckData.regCounter == data->adcCheckData.lastCounter)
+  {
+    data->adcCheckData.failCounterCurrent = data->adcCheckData.failCounterCurrent + 1;
+    UG31_LOGN("[%s]: Counter fixed (%d) ... %d\n", __func__,
+              data->adcCheckData.regCounter, data->adcCheckData.failCounterCurrent);
+  }
+  else
+  {
+    data->adcCheckData.failCounterCurrent = 0;
+  }
+  data->adcCheckData.lastCounter = data->adcCheckData.regCounter;
+
+  /// [AT-PM] : Compre VBat1 register ; 01/27/2013
+  if(data->adcCheckData.regVbat1Ave == data->adcCheckData.lastVBat1Ave)
+  {
+    data->adcCheckData.failCounterVoltage = data->adcCheckData.failCounterVoltage + 1;
+    UG31_LOGN("[%s]: VBat1 fixed (%d) ... %d\n", __func__,
+              data->adcCheckData.regVbat1Ave, data->adcCheckData.failCounterVoltage);
+  }
+  else
+  {
+    data->adcCheckData.failCounterVoltage = 0;
+  }
+  data->adcCheckData.lastVBat1Ave = data->adcCheckData.regVbat1Ave;
+
+  /// [AT-PM] : Check ADC fail criteria ; 01/27/2013
+  if(data->adcCheckData.failCounterCurrent > ADC1_FAIL_CRITERIA)
+  {
+    data->adcCheckData.failCounterCurrent = 0;
+    return (_UPI_TRUE_);
+  }
+  if(data->adcCheckData.failCounterVoltage > ADC2_FAIL_CRITERIA)
+  {
+    data->adcCheckData.failCounterVoltage = 0;
+    return (_UPI_TRUE_);
+  }
+  if((data->adcCheckData.regITAve < ADC_FAIL_MIN_IT_CODE) ||
+     (data->adcCheckData.regITAve > ADC_FAIL_MAX_IT_CODE))
+  {
+    return (_UPI_TRUE_);
+  }
+  return (_UPI_FALSE_);
+}
+
+/**
+ * @brief DecimateRst
+ *
+ *  Decimate reset filter of ADC
+ *
+ * @return  _UPI_NULL_
+ */
+void DecimateRst(void)
+{
+  _sys_u8_ tmp8;
+
+  tmp8 = 0x00;
+  API_I2C_Read(NORMAL, UG31XX_I2C_HIGH_SPEED_MODE, UG31XX_I2C_TEM_BITS_MODE, REG_ALARM_EN, 1, &tmp8);
+  tmp8 = tmp8 & (~ALARM_EN_DECIMATE_RST);
+  API_I2C_Write(NORMAL, UG31XX_I2C_HIGH_SPEED_MODE, UG31XX_I2C_TEM_BITS_MODE, REG_ALARM_EN, 1, &tmp8);
+  tmp8 = tmp8 | ALARM_EN_DECIMATE_RST;
+  API_I2C_Write(NORMAL, UG31XX_I2C_HIGH_SPEED_MODE, UG31XX_I2C_TEM_BITS_MODE, REG_ALARM_EN, 1,  &tmp8);
+  UG31_LOGN("[%s]: DECIMATE_RST\n", __func__);
+}
+
+/**
+ * @brief AlarmEnable
+ *
+ *  Enable alarm
+ *
+ * @para  alarm REG_ALARM_EN bits
+ * @return  NULL
+ */
+void AlarmEnable(_sys_u8_ alarm)
+{
+  _sys_u8_ tmp8;
+
+  tmp8 = 0;
+  API_I2C_Read(NORMAL, UG31XX_I2C_HIGH_SPEED_MODE, UG31XX_I2C_TEM_BITS_MODE, REG_ALARM_EN, 1, &tmp8);
+  tmp8 = tmp8 | alarm;
+  API_I2C_Write(NORMAL, UG31XX_I2C_HIGH_SPEED_MODE, UG31XX_I2C_TEM_BITS_MODE, REG_ALARM_EN, 1, &tmp8);
+}
+
+/**
+ * @brief AlarmDisable
+ *
+ *  Disable alarm
+ *
+ * @para  alarm REG_ALARM_EN bits
+ * @return  NULL
+ */
+void AlarmDisable(_sys_u8_ alarm)
+{
+  _sys_u8_ tmp8;
+
+  tmp8 = 0;
+  API_I2C_Read(NORMAL, UG31XX_I2C_HIGH_SPEED_MODE, UG31XX_I2C_TEM_BITS_MODE, REG_ALARM_EN, 1, &tmp8);
+  tmp8 = tmp8 & (~alarm);
+  API_I2C_Write(NORMAL, UG31XX_I2C_HIGH_SPEED_MODE, UG31XX_I2C_TEM_BITS_MODE, REG_ALARM_EN, 1, &tmp8);
+}
+
+#define SYS_ALARM_STS_UV1     (ALARM2_STATUS_UV1_ALARM)
+#define SYS_ALARM_STS_OV1     (ALARM2_STATUS_OV1_ALARM)
+#define SYS_ALARM_STS_UV2     (ALARM2_STATUS_UV2_ALARM)
+#define SYS_ALARM_STS_OV2     (ALARM2_STATUS_OV2_ALARM)
+#define SYS_ALARM_STS_UV3     (ALARM2_STATUS_UV3_ALARM)
+#define SYS_ALARM_STS_OV3     (ALARM2_STATUS_OV3_ALARM)
+#define SYS_ALARM_STS_UET     (ALARM1_STATUS_UET_ALARM<<8)
+#define SYS_ALARM_STS_OET     (ALARM1_STATUS_OET_ALARM<<8)
+#define SYS_ALARM_STS_UIT     (ALARM1_STATUS_UIT_ALARM<<8)
+#define SYS_ALARM_STS_OIT     (ALARM1_STATUS_OIT_ALARM<<8)
+#define SYS_ALARM_STS_DOC     (ALARM1_STATUS_DOC_ALARM<<8)
+#define SYS_ALARM_STS_COC     (ALARM1_STATUS_COC_ALARM<<8)
+
+/**
+ * @brief ProcUVAlarm
+ *
+ *  UV alarm function
+ *
+ * @para  data  address of SystemDataType
+ * @return  NULL
+ */
+void ProcUVAlarm(SystemDataType *data)
+{
+  _sys_u8_ tmp8[4];
+
+  /// [AT-PM] : Check alarm is enable or not ; 04/08/2013
+  if(!(ptrCellParameter->alarmEnable & CELL_PARAMETER_ALARM_EN_UV))
+  {
+    /// [AT-PM] : Disable UV and OV alarm ; 04/08/2013
+    AlarmDisable(ALARM_EN_V1_ALARM_EN);
+    return;
+  }
+
+  if(data->uvAlarm.state == _UPI_TRUE_)
+  {
+    /// [AT-PM] : UV alarm has been set -> Wait for OV alarm ; 04/08/2013
+    if(data->alarmSts & SYS_ALARM_STS_OV1)
+    {
+      data->uvAlarm.state = _UPI_FALSE_;
+
+      /// [AT-PM] : Release UV alarm by disable ; 04/08/2013
+      AlarmDisable(ALARM_EN_V1_ALARM_EN);
+
+      /// [AT-PM] : UV release threshold reached -> set alarm threshold ; 04/08/2013
+      tmp8[0] = 0xff;
+      tmp8[1] = 0x7f;
+      tmp8[2] = (_sys_u8_)(data->uvAlarm.alarmThrd & 0x00ff);
+      tmp8[3] = (_sys_u8_)(data->uvAlarm.alarmThrd >> 8);
+    }
+    else
+    {
+      /// [AT-PM] : UV state -> set release threshold ; 04/08/2013
+      tmp8[0] = (_sys_u8_)(data->uvAlarm.releaseThrd & 0x00ff);
+      tmp8[1] = (_sys_u8_)(data->uvAlarm.releaseThrd >> 8);
+      tmp8[2] = 0x00;
+      tmp8[3] = 0x00;
+    }
+  }
+  else
+  {
+    /// [AT-PM] : Normal state ; 04/08/2013
+    if(data->alarmSts & SYS_ALARM_STS_UV1)
+    {
+      data->uvAlarm.state = _UPI_TRUE_;
+
+      /// [AT-PM] : Release UV alarm by disable ; 04/08/2013
+      AlarmDisable(ALARM_EN_V1_ALARM_EN);
+
+      /// [AT-PM] : UV alarm reached -> set release threshold ; 04/08/2013
+      tmp8[0] = (_sys_u8_)(data->uvAlarm.releaseThrd & 0x00ff);
+      tmp8[1] = (_sys_u8_)(data->uvAlarm.releaseThrd >> 8);
+      tmp8[2] = 0x00;
+      tmp8[3] = 0x00;
+    }
+    else
+    {
+      /// [AT-PM] : Normal state -> set alarm threshold ; 04/08/2013
+      tmp8[0] = 0xff;
+      tmp8[1] = 0x7f;
+      tmp8[2] = (_sys_u8_)(data->uvAlarm.alarmThrd & 0x00ff);
+      tmp8[3] = (_sys_u8_)(data->uvAlarm.alarmThrd >> 8);
+    }
+  }
+
+  /// [AT-PM] : Set alarm threshold ; 04/08/2013
+  API_I2C_Write(SECURITY, UG31XX_I2C_HIGH_SPEED_MODE, UG31XX_I2C_TEM_BITS_MODE, REG_OV1_LOW, 4, &tmp8[0]);
+
+  /// [AT-PM] : Enable UV and OV alarm ; 04/08/2013
+  AlarmEnable(ALARM_EN_V1_ALARM_EN);
+}
+
+/**
+ * @brief ProcETAlarm
+ *
+ *  UET and OET alarm function
+ *
+ * @para  data  address of SystemDataType
+ * @return  NULL
+ */
+void ProcETAlarm(SystemDataType *data)
+{
+  _sys_u8_ tmp8[4];
+
+  /// [AT-PM] : Check alarm is enable or not ; 04/08/2013
+  if(!(ptrCellParameter->alarmEnable & (CELL_PARAMETER_ALARM_EN_UET | CELL_PARAMETER_ALARM_EN_OET)))
+  {
+    /// [AT-PM] : Disable UV and OV alarm ; 04/08/2013
+    AlarmDisable(ALARM_EN_ET_ALARM_EN);
+    return;
+  }
+
+  if(data->uetAlarm.state == _UPI_TRUE_)
+  {
+    /// [AT-PM] : UET alarm state -> wait for OET alarm ; 04/08/2013
+    if(data->alarmSts & SYS_ALARM_STS_OET)
+    {
+      data->uetAlarm.state = _UPI_FALSE_;
+
+      /// [AT-PM] : Release by disable ; 04/08/2013
+      AlarmDisable(ALARM_EN_ET_ALARM_EN);
+
+      /// [AT-PM] : UET release met -> set UET and OET alarm ; 04/08/2013
+      tmp8[0] = (_sys_u8_)(data->oetAlarm.alarmThrd & 0x00ff);
+      tmp8[1] = (_sys_u8_)(data->oetAlarm.alarmThrd >> 8);
+      tmp8[2] = (_sys_u8_)(data->uetAlarm.alarmThrd & 0x00ff);
+      tmp8[3] = (_sys_u8_)(data->uetAlarm.alarmThrd >> 8);
+    }
+    else
+    {
+      /// [AT-PM] : Wait OET alarm ; 04/08/2013
+      tmp8[0] = (_sys_u8_)(data->uetAlarm.releaseThrd & 0x00ff);
+      tmp8[1] = (_sys_u8_)(data->uetAlarm.releaseThrd >> 8);
+      tmp8[2] = 0x00;
+      tmp8[3] = 0x00;
+    }
+  }
+  else if(data->oetAlarm.state == _UPI_TRUE_)
+  {
+    /// [AT-PM] : OET alarm state -> wait for UET alarm ; 04/08/2013
+    if(data->alarmSts & SYS_ALARM_STS_UET)
+    {
+      data->oetAlarm.state = _UPI_FALSE_;
+
+      /// [AT-PM] : Release by disable ; 04/08/2013
+      AlarmDisable(ALARM_EN_ET_ALARM_EN);
+
+      /// [AT-PM] : OET release met -> set UET and OET alarm ; 04/08/2013
+      tmp8[0] = (_sys_u8_)(data->oetAlarm.alarmThrd & 0x00ff);
+      tmp8[1] = (_sys_u8_)(data->oetAlarm.alarmThrd >> 8);
+      tmp8[2] = (_sys_u8_)(data->uetAlarm.alarmThrd & 0x00ff);
+      tmp8[3] = (_sys_u8_)(data->uetAlarm.alarmThrd >> 8);
+    }
+    else
+    {
+      /// [AT-PM] : Wait UET alarm ; 04/08/2013
+      tmp8[0] = 0xff;
+      tmp8[1] = 0x7f;
+      tmp8[2] = (_sys_u8_)(data->oetAlarm.releaseThrd & 0x00ff);
+      tmp8[3] = (_sys_u8_)(data->oetAlarm.releaseThrd >> 8);
+    }
+  }
+  else
+  {
+    /// [AT-PM] : Normal state ; 04/08/2013
+    if((data->alarmSts & SYS_ALARM_STS_UET) &&
+       (ptrCellParameter->alarmEnable & CELL_PARAMETER_ALARM_EN_UET))
+    {
+      data->uetAlarm.state = _UPI_TRUE_;
+
+      /// [AT-PM] : Release by disable ; 04/08/2013
+      AlarmDisable(ALARM_EN_ET_ALARM_EN);
+
+      /// [AT-PM] : UET is set -> set UET release threshold ; 04/08/2013
+      tmp8[0] = (_sys_u8_)(data->uetAlarm.releaseThrd & 0x00ff);
+      tmp8[1] = (_sys_u8_)(data->uetAlarm.releaseThrd >> 8);
+      tmp8[2] = 0x00;
+      tmp8[3] = 0x00;
+    }
+    else if((data->alarmSts & SYS_ALARM_STS_OET) &&
+            (ptrCellParameter->alarmEnable & CELL_PARAMETER_ALARM_EN_OET))
+    {
+      data->oetAlarm.state = _UPI_TRUE_;
+
+      /// [AT-PM] : Release by disable ; 04/08/2013
+      AlarmDisable(ALARM_EN_ET_ALARM_EN);
+
+      /// [AT-PM] : OET is set -> set OET release threshold ; 04/08/2013
+      tmp8[0] = 0xff;
+      tmp8[1] = 0x7f;
+      tmp8[2] = (_sys_u8_)(data->oetAlarm.releaseThrd & 0x00ff);
+      tmp8[3] = (_sys_u8_)(data->oetAlarm.releaseThrd >> 8);
+    }
+    else
+    {
+      /// [AT-PM] : Set OET alarm threshold ; 04/08/2013
+      if(ptrCellParameter->alarmEnable & CELL_PARAMETER_ALARM_EN_OET)
+      {
+        tmp8[0] = (_sys_u8_)(data->oetAlarm.alarmThrd & 0x00ff);
+        tmp8[1] = (_sys_u8_)(data->oetAlarm.alarmThrd >> 8);
+      }
+      else
+      {
+        tmp8[0] = 0xff;
+        tmp8[1] = 0x7f;
+      }
+      /// [AT-PM] : Set UET alarm threshold ; 04/11/2013
+      if(ptrCellParameter->alarmEnable & CELL_PARAMETER_ALARM_EN_UET)
+      {
+        tmp8[2] = (_sys_u8_)(data->uetAlarm.alarmThrd & 0x00ff);
+        tmp8[3] = (_sys_u8_)(data->uetAlarm.alarmThrd >> 8);
+      }
+      else
+      {
+        tmp8[2] = 0x00;
+        tmp8[3] = 0x00;
+      }
+    }
+  }
+
+  /// [AT-PM] : Set alarm threshold ; 04/08/2013
+  API_I2C_Write(SECURITY, UG31XX_I2C_HIGH_SPEED_MODE, UG31XX_I2C_TEM_BITS_MODE, REG_EXTR_OVER_TEMP_LOW, 4, &tmp8[0]);
+
+  /// [AT-PM] : Enable UV and OV alarm ; 04/08/2013
+  AlarmEnable(ALARM_EN_ET_ALARM_EN);
+}
+
+/**
+ * @brief EnableAlarm
+ *
+ *  Set UV, UET, and OET alarm functions
+ *
+ * @para  data  address of SystemDataType
+ * @return  NULL
+ */
+void EnableAlarm(SystemDataType *data)
+{
+  /// [AT-PM] : UV alarm ; 04/08/2013
+  ProcUVAlarm(data);
+
+  /// [AT-PM] : UET and OET alarm ; 04/08/2013
+  ProcETAlarm(data);
+}
+
+/// =============================================
+/// [AT-PM] : Extern function region
+/// =============================================
+
+/**
+ * @brief UpiInitSystemData
+ *
+ *  Initialize system variables
+ *
+ * @para  data  address of SystemDataType
+ * @return  SYSTEM_RTN_CODE
+ */
+SYSTEM_RTN_CODE UpiInitSystemData(SystemDataType *data)
+{
+  /// [AT-PM] : Initialize variables ; 01/30/2013
+  data->preITAve = 0;
+  data->cellNum = 0;
+
+  /// [AT-PM] : Load GGB file ; 01/30/2013
+  UG31_LOGN("[%s]: Read GGB\n", __func__);
+  #if defined(uG31xx_OS_WINDOWS)
+
+    if(!ReadGGBFileToCellDataAndInitSetting(data))
+
+  #else   ///< else of defined(uG31xx_OS_WINDOWS)
+
+    if(!ReadGGBXFileToCellDataAndInitSetting(data))
+
+  #endif  ///< end of defined(uG31xx_OS_WINDOWS)
+	{
+ 		return (SYSTEM_RTN_READ_GGB_FAIL);
+	}
+
+  /// [AT-PM] : Set cell number ; 01/31/2013
+  GetCellNum(data);
+  return (SYSTEM_RTN_PASS);
+}
+
+/**
+ * @brief UpiCheckICActive
+ *
+ *  Check IC is actived or not
+ *
+ * @para  data  address of SystemDataType
+ * @return  _UPI_TRUE_ if uG31xx is not actived
+ */
+_upi_bool_ UpiCheckICActive(SystemDataType *data)
+{
+  _upi_u8_ tmp = 0;
+  _upi_bool_ rtn;
+
+  if(!API_I2C_Read(NORMAL, UG31XX_I2C_HIGH_SPEED_MODE, UG31XX_I2C_TEM_BITS_MODE, REG_MODE, 1, &tmp))
+  {
+    UG31_LOGE("[%s]: Get GG_RUN fail.\n", __func__);
+    return (_UPI_TRUE_);
+  }
+
+  if(((tmp & MODE_GG_RUN) == GG_RUN_OPERATION_MODE) && (tmp != 0xFF))
+  {
+    UG31_LOGN("[%s]: uG31xx is actived.\n", __func__);
+
+    rtn = CheckAdcChopFunction(data);
+    if(rtn == _UPI_FALSE_)
+    {
+      UG31_LOGE("[%s]: CheckAdcChopFunction fail\n", __func__);
+      return (_UPI_TRUE_);
+    }
+
+    rtn = CheckAdc1Queue(data);
+    if(rtn == _UPI_FALSE_)
+    {
+      UG31_LOGE("[%s]: CheckAdc1Queue fail\n", __func__);
+      return (_UPI_TRUE_);
+    }
+
+    rtn = CheckAdc2Queue(data);
+    if(rtn == _UPI_FALSE_)
+    {
+      UG31_LOGE("[%s]: CheckAdc2Queue fail\n", __func__);
+      return (_UPI_TRUE_);
+    }
+    return (_UPI_FALSE_);
+  }
+  UG31_LOGE("[%s]: uG31xx is NOT actived.\n", __func__);
+  return (_UPI_TRUE_);
+}
+
+/**
+ * @brief UpiActiveUg31xx
+ *
+ *  Active uG31xx
+ *
+ * @return  SYSTEM_RTN_CODE
+ */
+SYSTEM_RTN_CODE UpiActiveUg31xx(void)
+{
+  _sys_u8_ tmp8;
+
+  /// [AT-PM] : Reset uG31xx ; 01/31/2013
+  tmp8 = PORDET_W_SOFTRESET | IO1DATA_W_HIGH;
+	if(!API_I2C_Write(NORMAL, UG31XX_I2C_HIGH_SPEED_MODE, UG31XX_I2C_TEM_BITS_MODE, REG_CTRL1, 1, &tmp8))
+  {
+		return (SYSTEM_RTN_I2C_FAIL);
+  }
+  tmp8 = IO1DATA_W_HIGH;
+	if(!API_I2C_Write(NORMAL, UG31XX_I2C_HIGH_SPEED_MODE, UG31XX_I2C_TEM_BITS_MODE, REG_CTRL1, 1, &tmp8))
+  {
+		return (SYSTEM_RTN_I2C_FAIL);
+  }
+
+  /// [AT-PM] : Active uG31xx ; 01/31/2013
+  tmp8 = CTRL1_GG_RST | IO1DATA_W_HIGH;
+	if(!API_I2C_Write(NORMAL, UG31XX_I2C_HIGH_SPEED_MODE, UG31XX_I2C_TEM_BITS_MODE, REG_CTRL1, 1, &tmp8))
+  {
+		return (SYSTEM_RTN_I2C_FAIL);
+  }
+  tmp8 = GG_RUN_OPERATION_MODE;
+	if(!API_I2C_Write(NORMAL, UG31XX_I2C_HIGH_SPEED_MODE, UG31XX_I2C_TEM_BITS_MODE, REG_MODE, 1, &tmp8))
+  {
+		return (SYSTEM_RTN_I2C_FAIL);
+  }
+
+  #ifdef	uG31xx_BOOT_LOADER
+    /// [AT-PM] : Delay 255mS for system stable ; 01/31/2013
+    SleepMiniSecond(255);     //2012/08/29/Jacky, need wait 255 ms
+  #endif	///< end of uG31xx_BOOT_LOADER
+  return (SYSTEM_RTN_PASS);
+}
+
+/**
+ * @brief UpiStopUg31xx
+ *
+ *  Stop uG31xx
+ *
+ * @return  SYSTEM_RTN_CODE
+ */
+SYSTEM_RTN_CODE UpiStopUg31xx(void)
+{
+  _sys_u8_ tmp8;
+
+  UG31_LOGN("[%s]: Stop uG31xx\n", __func__);
+
+  /// [AT-PM] : Reset uG31xx ; 01/31/2013
+  tmp8 = PORDET_W_SOFTRESET | IO1DATA_W_HIGH;
+	if(!API_I2C_Write(NORMAL, UG31XX_I2C_HIGH_SPEED_MODE, UG31XX_I2C_TEM_BITS_MODE, REG_CTRL1, 1, &tmp8))
+  {
+		return (SYSTEM_RTN_I2C_FAIL);
+  }
+  tmp8 = IO1DATA_W_HIGH;
+	if(!API_I2C_Write(NORMAL, UG31XX_I2C_HIGH_SPEED_MODE, UG31XX_I2C_TEM_BITS_MODE, REG_CTRL1, 1, &tmp8))
+  {
+		return (SYSTEM_RTN_I2C_FAIL);
+  }
+
+  /// [AT-PM] : Stop uG31xx ; 01/31/2013
+  tmp8 = CTRL1_GG_RST | IO1DATA_W_HIGH;
+	if(!API_I2C_Write(NORMAL, UG31XX_I2C_HIGH_SPEED_MODE, UG31XX_I2C_TEM_BITS_MODE, REG_CTRL1, 1, &tmp8))
+  {
+		return (SYSTEM_RTN_I2C_FAIL);
+  }
+  tmp8 = 0;
+	if(!API_I2C_Write(NORMAL, UG31XX_I2C_HIGH_SPEED_MODE, UG31XX_I2C_TEM_BITS_MODE, REG_MODE, 1, &tmp8))
+  {
+		return (SYSTEM_RTN_I2C_FAIL);
+  }
+  return (SYSTEM_RTN_PASS);
+}
+
+/**
+ * @brief UpiSetupAdc
+ *
+ *  Setup ADC configurations
+ *
+ * @para  data  address of SystemDataType
+ * @return  _UPI_NULL_
+ */
+void UpiSetupAdc(SystemDataType *data)
+{
+  _sys_u8_ tmp8;
+
+  tmp8 = 0;
+  /// [AT-PM] : Set ADC chop function ; 01/31/2013
+	SetupAdcChopFunction(data);
+
+  /// [AT-PM] : Set ADC1 queue ; 01/31/2013
+	SetupAdc1Queue(data);
+
+  /// [AT-PM] : Set ADC2 queue ; 01/31/2013
+	SetupAdc2Quene(data);
+
+  /// [AT-PM] : Enable ADC ; 01/31/2013
+  API_I2C_Read(SECURITY,
+               UG31XX_I2C_HIGH_SPEED_MODE,
+               UG31XX_I2C_TEM_BITS_MODE,
+               REG_INTR_CTRL_A,
+               1,
+               &tmp8);
+  tmp8 = tmp8 | (INTR_CTRL_A_ADC2_EN | INTR_CTRL_A_ADC1_EN);
+  API_I2C_Write(SECURITY,
+                UG31XX_I2C_HIGH_SPEED_MODE,
+                UG31XX_I2C_TEM_BITS_MODE,
+                REG_INTR_CTRL_A,
+                1,
+                &tmp8);
+
+  /// [AT-PM] : Decimate reset ; 01/31/2013
+  DecimateRst();
+
+  /// [AT-PM] : Enable CBC function ; 01/31/2013
+  EnableCbc(data);
+}
+
+/**
+ * @brief UpiSetupSystem
+ *
+ *  Setup uG31xx system
+ *
+ * @para  data  address of SystemDataType
+ * @return  _UPI_NULL_
+ */
+void UpiSetupSystem(SystemDataType *data)
+{
+  _sys_u8_ tmp8;
+
+  tmp8 = 0;
+  /// [AT-PM] : Enable IC type ; 01/31/2013
+  EnableICType(data);
+
+  /// [AT-PM] : Configure GPIO ; 01/31/2013
+  ConfigureGpio(data);
+
+  /// [AT-PM] : Enable cell ; 01/31/2013
+  API_I2C_Read(SECURITY,
+               UG31XX_I2C_HIGH_SPEED_MODE,
+               UG31XX_I2C_TEM_BITS_MODE,
+               REG_CELL_EN,
+               1,
+               &tmp8);
+	tmp8 = tmp8 | (CELL_EN1 | CELL_EN0);
+  API_I2C_Write(SECURITY,
+                UG31XX_I2C_HIGH_SPEED_MODE,
+                UG31XX_I2C_TEM_BITS_MODE,
+                REG_CELL_EN,
+                1,
+                &tmp8);
+}
+
+#define OSC_CNT_TARG          (512)
+#define OSC_CP_SCL_L_TIME     (15739)     ///< [AT-PM] : 15.73876mS ; 05/20/2013
+#define OSC_KHZ_TO_HZ         (1000)
+#define OSC_FREQ_CONVERT(x)   (x*OSC_KHZ_TO_HZ*OSC_KHZ_TO_HZ/OSC_CP_SCL_L_TIME)
+
+/**
+ * @brief UpiCalculateOscFreq
+ *
+ *  OSC calibration
+ *    oscCnt25[9:0] = oscCntTarg[9:0] + oscDeltaCode25[7:0]
+ *    oscCnt80[9:0] = oscCntTarg[9:0] + oscDeltaCode80[7:0]
+ *    oscCnt[9:0] = m*ITcode[15:8] + C[9:0]
+ *    m = (oscCnt80[9:0]-oscCnt25[9:0])/(iTcode80[7:0]-iTcode25[7:0])
+ *    c = oscCnt25[9:0] - m*ITcode25[7:0]
+ *    write oscCnt[9:0] to register 0x97-98
+ *
+ * @para  data  address of SystemDataType
+ * @return  _UPI_NULL_
+ */
+void UpiCalculateOscFreq(SystemDataType *data)
+{
+  _sys_u32_ oscFreq25;
+  _sys_u32_ oscFreq80;
+  _sys_u16_ aveIT;
+  _sys_s32_ tmp32;
+  _sys_s32_ deltaT;
+
+  /// [AT-PM] : Convert OSC frequency from OTP ; 05/17/2013
+  oscFreq25 = OSC_CNT_TARG + ptrOtpData->oscDeltaCode25;
+  oscFreq25 = oscFreq25*OSC_KHZ_TO_HZ*OSC_KHZ_TO_HZ/OSC_CP_SCL_L_TIME;
+  UG31_LOGN("[%s]: oscFreq25 = %d (%d)\n", __func__, (int)oscFreq25, ptrOtpData->oscDeltaCode25);
+  oscFreq80 = OSC_CNT_TARG + ptrOtpData->oscDeltaCode80;
+  oscFreq80 = oscFreq80*OSC_KHZ_TO_HZ*OSC_KHZ_TO_HZ/OSC_CP_SCL_L_TIME;
+  UG31_LOGN("[%s]: oscFreq80 = %d (%d)\n", __func__, (int)oscFreq80, ptrOtpData->oscDeltaCode80);
+
+  /// [AT-PM] : Read ITAve ; 01/27/2013
+  aveIT = 0;
+  API_I2C_Read(NORMAL,
+               UG31XX_I2C_HIGH_SPEED_MODE,
+               UG31XX_I2C_TEM_BITS_MODE,
+               REG_AVE_IT_LOW,
+               REG_AVE_IT_HIGH - REG_AVE_IT_LOW + 1,
+               (_sys_u8_ *)&aveIT);
+  UG31_LOGN("[%s]: aveIT = %d (%d <-> %d)\n", __func__, aveIT, ptrOtpData->aveIT80, ptrOtpData->aveIT25);
+
+  tmp32 = (_sys_s32_)oscFreq80;
+  tmp32 = tmp32 - oscFreq25;
+  deltaT = (_sys_s32_)aveIT;
+  deltaT = deltaT - ptrOtpData->aveIT25;
+  tmp32 = tmp32*deltaT;
+  deltaT = (_sys_s32_)ptrOtpData->aveIT80;
+  deltaT = deltaT - ptrOtpData->aveIT25;
+  tmp32 = tmp32/deltaT + oscFreq25;
+  data->oscFreq = (_sys_u32_)tmp32;
+  UG31_LOGN("[%s]: OSC frequency = %dHz\n", __func__, (int)data->oscFreq);
+}
+
+#define DECIMATE_RST_MIN_TIME     (500)
+
+/**
+ * @brief UpiAdcStatus
+ *
+ *  Check ADC status
+ *
+ * @para  data  address of SystemDataType
+ * @return  _UPI_NULL_
+ */
+void UpiAdcStatus(SystemDataType *data)
+{
+  _upi_u32_ deltaTime;
+
+  data->adcCheckData.decimateRst = CheckAdcStatusFail(data);
+	if(data->adcCheckData.decimateRst == _UPI_TRUE_)      //check ADC Code frozen
+	{
+    #if defined(uG31xx_OS_ANDROID)
+      deltaTime = GetSysTickCount();
+    #else   ///< else of defined(uG31xx_OS_ANDROID)
+      #if defined(BUILD_UG31XX_LIB)
+        deltaTime = GetSysTickCount();
+      #else   ///< else of defined(BUILD_UG31XX_LIB)
+        deltaTime = GetTickCount();
+      #endif  ///< end of defined(BUILD_UG31XX_LIB)
+    #endif  ///< end of defined(uG31xx_OS_ANDROID)
+    if(deltaTime > data->adcCheckData.decimateRstTime)
+    {
+      deltaTime = deltaTime - data->adcCheckData.decimateRstTime;
+      if(deltaTime < DECIMATE_RST_MIN_TIME)
+      {
+        UG31_LOGI("[%s]: No DecimateRst because time interval = %d < %d\n", __func__,
+                  deltaTime,
+                  DECIMATE_RST_MIN_TIME);
+        return;
+      }
+    }
+
+    DecimateRst();
+
+    #if defined(uG31xx_OS_ANDROID)
+      data->adcCheckData.decimateRstTime = GetSysTickCount();
+    #else   ///< else of defined(uG31xx_OS_ANDROID)
+      #if defined(BUILD_UG31XX_LIB)
+        data->adcCheckData.decimateRstTime = GetSysTickCount();
+      #else   ///< else of defined(BUILD_UG31XX_LIB)
+        data->adcCheckData.decimateRstTime = GetTickCount();
+      #endif  ///< end of defined(BUILD_UG31XX_LIB)
+    #endif  ///< end of defined(uG31xx_OS_ANDROID)
+	}
+}
+
+#define BACKUP_TIME_BYTE3           (REG_COC_LOW)
+#define BACKUP_TIME_BYTE2           (REG_COC_HIGH)
+#define BACKUP_NAC_HIGH             (REG_RAM0)
+#define BACKUP_NAC_LOW              (REG_RAM1)
+#define BACKUP_LMD_HIGH             (REG_RAM2)
+#define BACKUP_LMD_LOW              (REG_RAM3)
+#define BACKUP_TABLE_UPDATE_IDX     (REG_UVP_HIGH)
+#define BACKUP_DELTA_CAP_HIGH       (REG_DOC_LOW)
+#define BACKUP_DELTA_CAP_LOW        (REG_DOC_HIGH)
+#define BACKUP_ADC1_CONV_TIME_HIGH  (REG_CBC21_LOW)
+#define BACKUP_ADC1_CONV_TIME_LOW   (REG_CBC21_HIGH)
+#define BACKUP_CYCLE_COUNT_LOW      (REG_CBC32_LOW)
+#define BACKUP_CYCLE_COUNT_HIGH     (REG_CBC32_HIGH)
+#define BACKUP_CC_OFFSET            (REG_INTR_OVER_TEMP_LOW)
+#define BACKUP_STANDBY_RATIO        (REG_INTR_OVER_TEMP_HIGH)
+
+/**
+ * @brief UpiLoadBatInfoFromIC
+ *
+ *  Load battery information from uG31xx
+ *
+ * @para  data  address of SystemDataType
+ * @return  _UPI_NULL_
+ */
+void UpiLoadBatInfoFromIC(SystemDataType *data)
+{
+  _sys_u8_ *u8Ptr;
+  _sys_u8_ u8Temp;
+  _sys_u8_ u8TempHigh;
+  #ifdef	uG31xx_BOOT_LOADER
+    _sys_u32_ u32Temp;
+  #endif	///< end of uG31xx_BOOT_LOADER
+
+  u8Temp = 0;
+  u8TempHigh = 0;
+
+  //Load the time tag
+  u8Ptr = (_sys_u8_ *)&data->timeTagFromIC;
+  *u8Ptr = 0;
+  *(u8Ptr + 1) = 0;
+
+  API_I2C_Read((BACKUP_TIME_BYTE2 < 0x80)? NORMAL: SECURITY,
+               UG31XX_I2C_HIGH_SPEED_MODE,
+               UG31XX_I2C_TEM_BITS_MODE,
+               BACKUP_TIME_BYTE2,
+               1,
+               &u8Temp);
+  *(u8Ptr + 2) = u8Temp;
+  API_I2C_Read((BACKUP_TIME_BYTE3 < 0x80)? NORMAL: SECURITY,
+               UG31XX_I2C_HIGH_SPEED_MODE,
+               UG31XX_I2C_TEM_BITS_MODE,
+               BACKUP_TIME_BYTE3,
+               1,
+               &u8Temp);
+  *(u8Ptr + 3) = u8Temp;
+
+  //Load the NAC
+  API_I2C_Read((BACKUP_NAC_HIGH < 0x80)? NORMAL: SECURITY,
+               UG31XX_I2C_HIGH_SPEED_MODE,
+               UG31XX_I2C_TEM_BITS_MODE,
+               BACKUP_NAC_HIGH,
+               1,
+               &u8TempHigh);
+  API_I2C_Read((BACKUP_NAC_LOW < 0x80)? NORMAL: SECURITY,
+               UG31XX_I2C_HIGH_SPEED_MODE,
+               UG31XX_I2C_TEM_BITS_MODE,
+               BACKUP_NAC_LOW,
+               1,
+               &u8Temp);
+  data->rmFromIC = (_sys_u16_)u8TempHigh;
+  data->rmFromIC = data->rmFromIC*256 + u8Temp;
+
+  // Load LMD
+  API_I2C_Read((BACKUP_LMD_HIGH < 0x80)? NORMAL: SECURITY,
+               UG31XX_I2C_HIGH_SPEED_MODE,
+               UG31XX_I2C_TEM_BITS_MODE,
+               BACKUP_LMD_HIGH,
+               1,
+               &u8TempHigh);
+  API_I2C_Read((BACKUP_LMD_LOW < 0x80)? NORMAL: SECURITY,
+               UG31XX_I2C_HIGH_SPEED_MODE,
+               UG31XX_I2C_TEM_BITS_MODE,
+               BACKUP_LMD_LOW,
+               1,
+               &u8Temp);
+  data->fccFromIC = (_sys_u16_)u8TempHigh;
+  data->fccFromIC = data->fccFromIC*256 + u8Temp;
+  UG31_LOGE("[%s]:timeTag =%d/%x ms,NAC = %d mAh,LMD = %dmAh\n",
+             __func__,
+             (int)data->timeTagFromIC,
+             (int)data->timeTagFromIC,
+             data->rmFromIC,
+             data->fccFromIC);
+
+  /// [AT-PM] : Load table update index ; 02/10/2013
+  API_I2C_Read((BACKUP_TABLE_UPDATE_IDX < 0x80)? NORMAL: SECURITY,
+               UG31XX_I2C_HIGH_SPEED_MODE,
+               UG31XX_I2C_TEM_BITS_MODE,
+               BACKUP_TABLE_UPDATE_IDX,
+               1,
+               &u8Temp);
+  data->tableUpdateIdxFromIC = u8Temp;
+  UG31_LOGN("[%s]: Table Update Index From IC = %d\n", __func__, data->tableUpdateIdxFromIC);
+
+  /// [AT-PM] : Load delta capacity ; 02/10/2013
+  API_I2C_Read((BACKUP_DELTA_CAP_HIGH < 0x80)? NORMAL: SECURITY,
+               UG31XX_I2C_HIGH_SPEED_MODE,
+               UG31XX_I2C_TEM_BITS_MODE,
+               BACKUP_DELTA_CAP_HIGH,
+               1,
+               &u8TempHigh);
+  API_I2C_Read((BACKUP_DELTA_CAP_LOW < 0x80)? NORMAL: SECURITY,
+               UG31XX_I2C_HIGH_SPEED_MODE,
+               UG31XX_I2C_TEM_BITS_MODE,
+               BACKUP_DELTA_CAP_LOW,
+               1,
+               &u8Temp);
+  data->deltaCapFromIC = (_sys_u16_)u8TempHigh;
+  data->deltaCapFromIC = data->deltaCapFromIC*256 + u8Temp;
+  UG31_LOGN("[%s]: Delta Capacity From IC = %d (0x%02x%02x)\n", __func__, data->deltaCapFromIC, u8TempHigh, u8Temp);
+
+  /// [AT-PM] : Load ADC1 conversion time ; 02/10/2013
+  API_I2C_Read((BACKUP_ADC1_CONV_TIME_HIGH < 0x80)? NORMAL: SECURITY,
+               UG31XX_I2C_HIGH_SPEED_MODE,
+               UG31XX_I2C_TEM_BITS_MODE,
+               BACKUP_ADC1_CONV_TIME_HIGH,
+               1,
+               &u8TempHigh);
+  API_I2C_Read((BACKUP_ADC1_CONV_TIME_LOW < 0x80)? NORMAL: SECURITY,
+               UG31XX_I2C_HIGH_SPEED_MODE,
+               UG31XX_I2C_TEM_BITS_MODE,
+               BACKUP_ADC1_CONV_TIME_LOW,
+               1,
+               &u8Temp);
+  data->adc1ConvTime = u8TempHigh*256 + u8Temp;
+  UG31_LOGN("[%s]: ADC1 Conversion Time From IC = %d\n", __func__, data->adc1ConvTime);
+
+  /// [AT-PM] : Load cycle count ; 10/14/2013
+  API_I2C_Read((BACKUP_CYCLE_COUNT_LOW < 0x80)? NORMAL: SECURITY,
+               UG31XX_I2C_HIGH_SPEED_MODE,
+               UG31XX_I2C_TEM_BITS_MODE,
+               BACKUP_CYCLE_COUNT_LOW,
+               1,
+               &u8Temp);
+  API_I2C_Read(( BACKUP_CYCLE_COUNT_HIGH< 0x80)? NORMAL: SECURITY,
+               UG31XX_I2C_HIGH_SPEED_MODE,
+               UG31XX_I2C_TEM_BITS_MODE,
+               BACKUP_CYCLE_COUNT_HIGH,
+               1,
+               &u8TempHigh);
+  data->cycleCount = u8TempHigh;
+  data->cycleCount = (data->cycleCount)*256 + u8Temp;
+  UG31_LOGN("[%s]: Cycle Count From IC = %d\n", __func__, data->cycleCount);
+
+  /// [AT-PM] : Load cc offset ; 12/10/2013
+  u8Ptr = (_sys_u8_ *)&data->ccOffset;
+  API_I2C_Read((BACKUP_CC_OFFSET < 0x80)? NORMAL: SECURITY,
+               UG31XX_I2C_HIGH_SPEED_MODE,
+               UG31XX_I2C_TEM_BITS_MODE,
+               BACKUP_CC_OFFSET,
+               1,
+               u8Ptr);
+  UG31_LOGN("[%s]: CC Offset From IC = %d\n", __func__, data->ccOffset);
+
+  /// [AT-PM] : Load standby ratio ; 01/03/2014
+  u8Ptr = (_sys_u8_ *)&data->standbyDsgRatio;
+  API_I2C_Read(( BACKUP_STANDBY_RATIO< 0x80)? NORMAL: SECURITY,
+               UG31XX_I2C_HIGH_SPEED_MODE,
+               UG31XX_I2C_TEM_BITS_MODE,
+               BACKUP_STANDBY_RATIO,
+               1,
+               u8Ptr);
+  UG31_LOGN("[%s]: Standby Ratio From IC = %d\n", __func__, data->standbyDsgRatio);
+
+  /// [AT-PM] : Get RSOC ; 01/31/2013
+  if(data->fccFromIC == 0)
+  {
+    data->rsocFromIC = 0;
+  }
+  else
+  {
+    #ifdef	uG31xx_BOOT_LOADER
+      u32Temp = (_sys_u32_)data->rmFromIC;
+      u32Temp = u32Temp*100 + 50;
+      u32Temp = u32Temp/data->fccFromIC;
+      data->rsocFromIC = (_sys_u8_)u32Temp;
+    #else	///< else of uG31xx_BOOT_LOADER
+      data->rsocFromIC = (_sys_u8_)CalculateRsoc(data->rmFromIC, data->fccFromIC);
+    #endif	///< end of uG31xx_BOOT_LOADER
+  }
+
+  data->rmFromICBackup = data->rmFromIC;
+  data->fccFromICBackup = data->fccFromIC;
+  data->rsocFromICBackup = data->rsocFromIC;
+}
+
+/**
+ * @brief UpiUpdateBatInfoFromIC
+ *
+ *  Update battery information from uG31xx
+ *
+ * @para  data  address of SystemDataType
+ * @para  deltaQ  delta capacity from coulomb counter
+ * @para  suspend set _UPI_TRUE_ for suspend operation
+ * @return  _UPI_NULL_
+ */
+void UpiUpdateBatInfoFromIC(SystemDataType *data, _sys_s16_ deltaQ, _sys_bool_ suspend)
+{
+  _sys_s32_ tmp32;
+  _sys_u8_ oldRsoc;
+
+  oldRsoc = data->rsocFromIC;
+
+  tmp32 = (_sys_s32_)data->rmFromIC;
+  tmp32 = tmp32 + deltaQ;
+  #ifdef  UPI_UBOOT_DEBUG_MSG
+    printf("[UpiUpdateBatInfoFromIC] RM = %d + %d = %d\n", data->rmFromIC, deltaQ, tmp32);
+  #endif  ///< end of UPI_UBOOT_DEBUG_MSG
+  if(tmp32 < 0)
+  {
+    tmp32 = 0;
+  }
+  if(tmp32 > data->fccFromIC)
+  {
+    tmp32 = (_sys_s32_)data->fccFromIC;
+  }
+  UG31_LOGN("[%s]: RM = %d + %d = %d\n", __func__,
+            data->rmFromIC, deltaQ, (int)tmp32);
+  data->rmFromIC = (_sys_u16_)tmp32;
+
+        #ifdef  UPI_UBOOT_DEBUG_MSG
+                printf("[UpiUpdateBatInfoFromIC] fccFromIC = %d, rsocFromIC = %d\n", data->fccFromIC, data->rsocFromIC);
+        #endif  ///< end of UPI_UBOOT_DEBUG_MSG
+  if(data->fccFromIC == 0)
+  {
+    data->rsocFromIC = 0;
+    data->tpCount = 0;
+    return;
+  }
+
+  /// [AT-PM] : Check RM should not larger than FCC ; 12/24/2013
+  if(data->rmFromIC > data->fccFromIC)
+  {
+    data->rmFromIC = data->fccFromIC;
+  }
+
+  /// [AT-PM] : Calculate new RSOC ; 12/24/2013
+  #ifdef	uG31xx_BOOT_LOADER
+    tmp32 = tmp32*100 + 50;
+    tmp32 = tmp32/data->fccFromIC;
+    data->rsocFromIC = (_sys_u8_)tmp32;
+  #else	///< else of uG31xx_BOOT_LOADER
+    data->rsocFromIC = (_sys_u8_)CalculateRsoc(data->rmFromIC, data->fccFromIC);
+  #endif	///< end of uG31xx_BOOT_LOADER
+
+  /// [AT-PM] : Check taper condition reached ; 12/26/2013
+  if((data->voltage > ptrCellParameter->TPVoltage) &&
+     (data->curr < ptrCellParameter->TPCurrent) &&
+     (data->curr >= ptrCellParameter->standbyCurrent) &&
+     (suspend == _UPI_FALSE_))
+  {
+    data->tpCount = data->tpCount + 1;
+    if(data->tpCount > 3)
+    {
+      data->tpCount = 3;
+      data->rsocFromIC = 100;
+      data->rmFromIC = data->fccFromIC;
+      return;
+    }
+  }
+  else
+  {
+    data->tpCount = 0;
+  }
+
+  /// [AT-PM] : Check RSOC not 100 before taper condition ; 12/26/2013
+  if((data->curr >= ptrCellParameter->standbyCurrent) &&
+     (data->rsocFromIC >= 100) &&
+     (oldRsoc != 100))
+  {
+    data->rsocFromIC = 99;
+    tmp32 = (_sys_s32_)data->rsocFromIC;
+    tmp32 = tmp32*data->fccFromIC/CONST_PERCENTAGE;
+    data->rmFromIC = (_sys_u16_)tmp32;
+    return;
+  }
+
+  /// [AT-PM] : Previous rsoc is 0 not in charging -> keep it ; 03/07/2014
+  if(oldRsoc == 0)
+  {
+    return;
+  }
+
+  /// [AT-PM] : Operation for EDVF ; 02/25/2014
+  if(data->voltage > ptrCellParameter->edv1Voltage)
+  {
+    if(data->rsocFromIC > 0)
+    {
+      return;
+    }
+
+    /// [AT-PM] : Force RSOC > 0 ; 02/25/2014
+    data->rsocFromIC = 1;
+    data->rmFromIC = data->fccFromIC/CONST_PERCENTAGE;
+  }
+  else
+  {
+    /// [AT-PM] : Set RSOC to 0 if not in charging ; 02/25/2014
+    if((data->curr < ptrCellParameter->standbyCurrent) &&
+       (data->rsocFromIC != 0))
+    {
+      data->rsocFromIC = data->rsocFromIC - 1;
+      tmp32 = (_sys_s32_)data->rsocFromIC;
+      tmp32 = tmp32*(data->fccFromIC)/CONST_PERCENTAGE;
+      data->rmFromIC = (_sys_u16_)tmp32;
+      return;
+    }
+  }
+}
+
+#define SAVE_BATINFO_0_VOLT_THRESHOLD     (300)
+
+/**
+ * @brief UpiSaveBatInfoTOIC
+ *
+ *  Save battery information from uG31xx
+ *
+ * @para  data  address of SystemDataType
+ * @return  _UPI_NULL_
+ */
+void UpiSaveBatInfoTOIC(SystemDataType *data)
+{
+  _sys_u8_ *u8Ptr;
+  _sys_u8_ u8Temp;
+  _sys_u8_ u8Temp1;
+  _sys_u16_ u16Temp;
+
+  #if defined(uG31xx_OS_ANDROID)
+
+    data->timeTagFromIC = GetSysTickCount();
+
+  #else   ///< else of defined(uG31xx_OS_ANDROID)
+
+    #if defined(BUILD_UG31XX_LIB)
+
+      data->timeTagFromIC = GetSysTickCount();
+
+    #else   ///< else of defined(BUILD_UG31XX_LIB)
+
+      data->timeTagFromIC = GetTickCount();
+
+    #endif  ///< end of defined(BUILD_UG31XX_LIB)
+
+  #endif  ///< end of defined(uG31xx_OS_ANDROID)
+
+  u16Temp = ptrCellParameter->edv1Voltage - SAVE_BATINFO_0_VOLT_THRESHOLD;
+  if(data->voltage < u16Temp)
+  {
+    UG31_LOGE("[%d]: Voltage = %d < %d - %d -> Set NAC = 0 from %d\n", __func__,
+              data->voltage,
+              ptrCellParameter->edv1Voltage,
+              SAVE_BATINFO_0_VOLT_THRESHOLD,
+              data->rmFromIC);
+    data->rmFromIC = 0;
+  }
+  UG31_LOGE("[%s]:timeTag =%d/%x ms,NAC = %d maH,LMD = %d maH\n",
+  						__func__,
+  						(int)data->timeTagFromIC,
+  						(int)data->timeTagFromIC,
+  						data->rmFromIC,
+  						data->fccFromIC);
+
+  //save the time tag
+  u8Ptr = (_sys_u8_ *)&data->timeTagFromIC;
+  API_I2C_Write((BACKUP_TIME_BYTE2 < 0x80)? NORMAL: SECURITY,
+                UG31XX_I2C_HIGH_SPEED_MODE,
+                UG31XX_I2C_TEM_BITS_MODE,
+                BACKUP_TIME_BYTE2,
+                1,
+                (u8Ptr + 2));
+  API_I2C_Write((BACKUP_TIME_BYTE3 < 0x80)? NORMAL: SECURITY,
+                UG31XX_I2C_HIGH_SPEED_MODE,
+                UG31XX_I2C_TEM_BITS_MODE,
+                BACKUP_TIME_BYTE3,
+                1,
+                (u8Ptr + 3));
+
+   //save the NAC
+  u8Temp = (_sys_u8_)((data->rmFromIC & 0xff00)/256);
+  API_I2C_Write((BACKUP_NAC_HIGH < 0x80)? NORMAL: SECURITY,
+                UG31XX_I2C_HIGH_SPEED_MODE,
+                UG31XX_I2C_TEM_BITS_MODE,
+                BACKUP_NAC_HIGH,
+                1,
+                &u8Temp);
+  u8Temp = (_sys_u8_)(data->rmFromIC & 0x00ff);
+  API_I2C_Write((BACKUP_NAC_LOW < 0x80)? NORMAL: SECURITY,
+                UG31XX_I2C_HIGH_SPEED_MODE,
+                UG31XX_I2C_TEM_BITS_MODE,
+                BACKUP_NAC_LOW,
+                1,
+                &u8Temp);
+
+  // save LMD
+  u8Temp = (_sys_u8_)((data->fccFromIC & 0xff00)/256);
+  API_I2C_Write((BACKUP_LMD_HIGH < 0x80)? NORMAL: SECURITY,
+                UG31XX_I2C_HIGH_SPEED_MODE,
+                UG31XX_I2C_TEM_BITS_MODE,
+                BACKUP_LMD_HIGH,
+                1,
+                &u8Temp);
+  u8Temp = (_sys_u8_)(data->fccFromIC & 0x00ff);
+  API_I2C_Write((BACKUP_LMD_LOW < 0x80)? NORMAL: SECURITY,
+                UG31XX_I2C_HIGH_SPEED_MODE,
+                UG31XX_I2C_TEM_BITS_MODE,
+                BACKUP_LMD_LOW,
+                1,
+                &u8Temp);
+
+  /// [AT-PM] : Save table update index ; 02/10/2013
+  u8Temp = data->tableUpdateIdxFromIC;
+  API_I2C_Write((BACKUP_TABLE_UPDATE_IDX < 0x80)? NORMAL: SECURITY,
+                UG31XX_I2C_HIGH_SPEED_MODE,
+                UG31XX_I2C_TEM_BITS_MODE,
+                BACKUP_TABLE_UPDATE_IDX,
+                1,
+                &u8Temp);
+  UG31_LOGN("[%s]: Save Table Update Index = %d\n", __func__, data->tableUpdateIdxFromIC);
+  /// [AT-PM] : Save delta capacity ; 02/10/2013
+  u16Temp = (_sys_u16_)data->deltaCapFromIC;
+  u8Temp = (_sys_u8_)(u16Temp >> 8);
+  API_I2C_Write((BACKUP_DELTA_CAP_HIGH < 0x80)? NORMAL: SECURITY,
+                UG31XX_I2C_HIGH_SPEED_MODE,
+                UG31XX_I2C_TEM_BITS_MODE,
+                BACKUP_DELTA_CAP_HIGH,
+                1,
+                &u8Temp);
+  u8Temp1 = (_sys_u8_)(u16Temp & 0x00ff);
+  API_I2C_Write((BACKUP_DELTA_CAP_LOW < 0x80)? NORMAL: SECURITY,
+                UG31XX_I2C_HIGH_SPEED_MODE,
+                UG31XX_I2C_TEM_BITS_MODE,
+                BACKUP_DELTA_CAP_LOW,
+                1,
+                &u8Temp1);
+  UG31_LOGN("[%s]: Save Delta Capacity = %d - 0x%02x%02x\n", __func__, data->deltaCapFromIC, u8Temp, u8Temp1);
+
+  /// [AT-PM] : Save adc1 conversion time ; 02/10/2013
+  u8Temp = data->adc1ConvTime >> 8;
+  API_I2C_Write((BACKUP_ADC1_CONV_TIME_HIGH < 0x80)? NORMAL: SECURITY,
+                UG31XX_I2C_HIGH_SPEED_MODE,
+                UG31XX_I2C_TEM_BITS_MODE,
+                BACKUP_ADC1_CONV_TIME_HIGH,
+                1,
+                &u8Temp);
+  u8Temp = data->adc1ConvTime & 0x00ff;
+  API_I2C_Write((BACKUP_ADC1_CONV_TIME_LOW < 0x80)? NORMAL: SECURITY,
+                UG31XX_I2C_HIGH_SPEED_MODE,
+                UG31XX_I2C_TEM_BITS_MODE,
+                BACKUP_ADC1_CONV_TIME_LOW,
+                1,
+                &u8Temp);
+  UG31_LOGN("[%s]: Save ADC1 Conversion Time = %d\n", __func__, data->adc1ConvTime);
+
+  /// [AT-PM] : Save cycle count ; 10/14/2013
+  u8Temp = data->cycleCount >> 8;
+  API_I2C_Write((BACKUP_CYCLE_COUNT_HIGH < 0x80)? NORMAL: SECURITY,
+                UG31XX_I2C_HIGH_SPEED_MODE,
+                UG31XX_I2C_TEM_BITS_MODE,
+                BACKUP_CYCLE_COUNT_HIGH,
+                1,
+                &u8Temp);
+  u8Temp = data->cycleCount & 0x00ff;
+  API_I2C_Write((BACKUP_CYCLE_COUNT_LOW < 0x80)? NORMAL: SECURITY,
+                UG31XX_I2C_HIGH_SPEED_MODE,
+                UG31XX_I2C_TEM_BITS_MODE,
+                BACKUP_CYCLE_COUNT_LOW,
+                1,
+                &u8Temp);
+  UG31_LOGN("[%s]: Save Cycle Count = %d\n", __func__, data->cycleCount);
+
+  /// [AT-PM] : Save coulomb counter offset ; 12/10/2013
+  u8Ptr = (_sys_u8_ *)&data->ccOffset;
+  API_I2C_Write((BACKUP_CC_OFFSET < 0x80)? NORMAL: SECURITY,
+                UG31XX_I2C_HIGH_SPEED_MODE,
+                UG31XX_I2C_TEM_BITS_MODE,
+                BACKUP_CC_OFFSET,
+                1,
+                u8Ptr);
+  UG31_LOGN("[%s]: Save coulomb counter offset = %d\n", __func__, data->ccOffset);
+
+  /// [AT-PM] : Save standby ratio ; 01/03/2014
+  u8Ptr = (_sys_u8_ *)&data->standbyDsgRatio;
+  API_I2C_Write((BACKUP_STANDBY_RATIO < 0x80)? NORMAL: SECURITY,
+                UG31XX_I2C_HIGH_SPEED_MODE,
+                UG31XX_I2C_TEM_BITS_MODE,
+                BACKUP_STANDBY_RATIO,
+                1,
+                u8Ptr);
+  UG31_LOGN("[%s]: Save standby ratio = %d\n", __func__, data->standbyDsgRatio);
+}
+
+/**
+ * @brief UpiInitAlarm
+ *
+ *  Initialize alarm function of uG3105
+ *
+ * @para  data  address of SystemDataType
+ * @return  NULL
+ */
+void UpiInitAlarm(SystemDataType *data)
+{
+  /// [AT-PM] : Set GPIO as alarm pin ; 04/08/2013
+  ConfigureGpio(data);
+
+  /// [AT-PM] : Set delay time ; 04/08/2013
+  API_I2C_Write(SECURITY,
+                UG31XX_I2C_HIGH_SPEED_MODE,
+                UG31XX_I2C_TEM_BITS_MODE,
+                REG_TIMER,
+                1,
+                &ptrCellParameter->alarm_timer);
+  API_I2C_Write(SECURITY,
+                UG31XX_I2C_HIGH_SPEED_MODE,
+                UG31XX_I2C_TEM_BITS_MODE,
+                REG_CLK_DIVA,
+                1,
+                &ptrCellParameter->clkDivA);
+  API_I2C_Write(SECURITY,
+                UG31XX_I2C_HIGH_SPEED_MODE,
+                UG31XX_I2C_TEM_BITS_MODE,
+                REG_CLK_DIVB,
+                1,
+                &ptrCellParameter->clkDivB);
+
+  /// [AT-PM] : Enable alarm ; 04/08/2013
+  data->alarmSts = 0;
+  data->uvAlarm.state = _UPI_FALSE_;
+  data->uetAlarm.state = _UPI_FALSE_;
+  data->oetAlarm.state = _UPI_FALSE_;
+  EnableAlarm(data);
+}
+
+/**
+ * @brief UpiAlarmStatus
+ *
+ *  Get alarm status
+ *
+ * @para  data  address of SystemDataType
+ * @return  NULL
+ */
+_sys_u8_ UpiAlarmStatus(SystemDataType *data)
+{
+  _sys_u8_ sts;
+  _sys_u8_ tmp8[2];
+
+  sts = 0;
+  tmp8[0] = 0;
+  tmp8[1] = 0;
+
+  /// [AT-PM] : Read alarm status from uG3105 ; 04/08/2013
+  API_I2C_Read(NORMAL, UG31XX_I2C_HIGH_SPEED_MODE, UG31XX_I2C_TEM_BITS_MODE, REG_ALARM1_STATUS, 2, &tmp8[0]);
+  data->alarmSts = (_sys_u16_)tmp8[0];
+  data->alarmSts = data->alarmSts*256 + tmp8[1];
+
+  /// [AT-PM] : Enable alarm ; 04/08/2013
+  EnableAlarm(data);
+
+  /// [AT-PM] : Update current alarm status ; 04/08/2013
+  tmp8[0] = data->uvAlarm.state == _UPI_TRUE_ ? ALARM_STATUS_UV : 0;
+  sts = sts | tmp8[0];
+  tmp8[0] = data->uetAlarm.state == _UPI_TRUE_ ? ALARM_STATUS_UET : 0;
+  sts = sts | tmp8[0];
+  tmp8[0] = data->oetAlarm.state == _UPI_TRUE_ ? ALARM_STATUS_OET : 0;
+  sts = sts | tmp8[0];
+  return (sts);
+}
+
+typedef struct TableStorageST {
+  _cap_u8_ addr;
+  _cap_u8_ size;
+} ALIGNED_ATTRIBUTE TableStorageType;
+
+TableStorageType TableStorage[] = {
+  { REG_RAM4,     28, },
+  { REG_OV2_LOW,  11,  },
+  { 0,            0,  },
+};
+
+/**
+ * @brief UpiLoadTableFromIC
+ *
+ *  Load table form IC
+ *
+ * @para  data point of _sys_u8_ type
+ * @return  NULL
+ */
+void UpiLoadTableFromIC(_sys_u8_ *data)
+{
+  _sys_u8_ idx;
+  _sys_u8_ offset;
+
+  idx = 0;
+  offset = 0;
+  while(TableStorage[idx].size)
+  {
+    API_I2C_Read((TableStorage[idx].addr < 0x80) ? NORMAL : SECURITY,
+                 UG31XX_I2C_HIGH_SPEED_MODE,
+                 UG31XX_I2C_TEM_BITS_MODE,
+                 TableStorage[idx].addr,
+                 TableStorage[idx].size,
+                 &data[offset]);
+    offset = offset + TableStorage[idx].size;
+    idx = idx + 1;
+  }
+
+  idx = 0;
+  while(idx < offset)
+  {
+    UG31_LOGD("[%s]: Load data[%d] = 0x%02x\n", __func__, idx, data[idx]);
+    idx = idx + 1;
+  }
+}
+
+/**
+ * @brief UpiLoadTableFromIC
+ *
+ *  Save table to IC
+ *
+ * @para  data point of _sys_u8_ type
+ * @return  NULL
+ */
+void UpiSaveTableToIC(_sys_u8_ *data, _sys_u8_ *buf, _sys_u8_ size)
+{
+  _sys_u8_ idx;
+  _sys_u8_ addr;
+  _sys_u8_ cnt;
+  _sys_u8_ offset;
+
+  idx = 0;
+  offset = 0;
+  while(TableStorage[idx].size)
+  {
+    addr = TableStorage[idx].addr;
+    cnt = 0;
+    while(cnt < TableStorage[idx].size)
+    {
+      if(buf[offset] != data[offset])
+      {
+        API_I2C_Write((TableStorage[idx].addr < 0x80) ? NORMAL : SECURITY,
+                      UG31XX_I2C_HIGH_SPEED_MODE,
+                      UG31XX_I2C_TEM_BITS_MODE,
+                      addr,
+                      1,
+                      &data[offset]);
+        UG31_LOGD("[%s]: Save data[%d] = 0x%02x to 0x%02x\n", __func__, offset, data[offset], addr);
+      }
+      addr = addr + 1;
+      cnt = cnt + 1;
+      offset = offset + 1;
+    }
+    idx = idx + 1;
+  }
+
+  upi_memcpy(buf, data, size);
+}
+
+/**
+ * @brief UpiSetupAdc1Queue
+ *
+ *  Setup ADC1 queue for normal operation
+ *
+ * @para  data  address of SystemDataType structure
+ * @return  NULL
+ */
+void UpiSetupAdc1Queue(SystemDataType *data)
+{
+  _sys_u8_ tmp8;
+
+  tmp8 = 0;
+  /// [AT-PM] : Disable ADC1 ; 06/04/2013
+  API_I2C_Read(SECURITY,
+               UG31XX_I2C_HIGH_SPEED_MODE,
+               UG31XX_I2C_TEM_BITS_MODE,
+               REG_INTR_CTRL_A,
+               1,
+               &tmp8);
+  tmp8 = tmp8 & (~INTR_CTRL_A_ADC1_EN);
+  API_I2C_Write(SECURITY,
+                UG31XX_I2C_HIGH_SPEED_MODE,
+                UG31XX_I2C_TEM_BITS_MODE,
+                REG_INTR_CTRL_A,
+                1,
+                &tmp8);
+
+  /// [AT-PM] : Set ADC1 queue ; 06/04/2013
+ 	API_I2C_Write(SECURITY,
+                UG31XX_I2C_HIGH_SPEED_MODE,
+                UG31XX_I2C_TEM_BITS_MODE,
+                REG_ADC_CTR_A,
+                4,
+                &adc1QueueNormal[0]);
+
+  /// [AT-PM] : Enable ADC ; 01/31/2013
+  API_I2C_Read(SECURITY,
+               UG31XX_I2C_HIGH_SPEED_MODE,
+               UG31XX_I2C_TEM_BITS_MODE,
+               REG_INTR_CTRL_A,
+               1,
+               &tmp8);
+  tmp8 = tmp8 | (INTR_CTRL_A_ADC2_EN | INTR_CTRL_A_ADC1_EN);
+  API_I2C_Write(SECURITY,
+                UG31XX_I2C_HIGH_SPEED_MODE,
+                UG31XX_I2C_TEM_BITS_MODE,
+                REG_INTR_CTRL_A,
+                1,
+                &tmp8);
+
+  /// [AT-PM] : Decimate reset ; 01/31/2013
+  DecimateRst();
+}
+
+/**
+ * @brief UpiAllocateTableBuf
+ *
+ *  Allocate table buffer
+ *
+ * @para  data  address of SystemDataType structure
+ * @return  NULL
+ */
+void UpiAllocateTableBuf(_sys_u8_ **data, _sys_u8_ *size)
+{
+  _sys_u8_ idx = 0;
+  _sys_u8_ lSize = 0;
+
+  while(TableStorage[idx].size)
+  {
+    lSize = lSize + TableStorage[idx].size;
+    idx = idx + 1;
+  }
+  *size = lSize;
+
+  upi_memset(*data, 0, lSize);
+
+  UG31_LOGD("[%s]: Table buffer address = %d (%d)\n", __func__, (int)(*data), lSize);
+}
+
+/**
+ * @brief UpiFreeTableBuf
+ *
+ *  Free table buffer
+ *
+ * @para  data  address of SystemDataType structure
+ * @return  NULL
+ */
+void UpiFreeTableBuf(_sys_u8_ **data)
+{
+  UG31_LOGD("[%s]: Free address 0x%02x\n", __func__, (unsigned int)(*data));
+}
+
+/**
+ * @brief UpiPrintSystemVersion
+ *
+ *  Print system module version
+ *
+ * @return  NULL
+ */
+void UpiPrintSystemVersion(void)
+{
+  UG31_LOGE("[%s]: %s\n", __func__,
+            SYSTEM_VERSION);
+}
+
+
+/**
+ * Copyright @ 2013 uPI Semiconductor Corp. All right reserved.
+ * The information, images, and/or data contained in this material is copyrighted by uPI
+ * Semiconductor Corp., and may not be distributed, modified, reproduced in whole or in part
+ * without the prior, written consent of uPI Semiconductor Corp.
+ */
diff --git a/drivers/power/supply/ASUS_BATTERY/ME176C/ug31xx/uG31xx_API_System.h b/drivers/power/supply/ASUS_BATTERY/ME176C/ug31xx/uG31xx_API_System.h
new file mode 100644
index 000000000000..18657e2f672d
--- /dev/null
+++ b/drivers/power/supply/ASUS_BATTERY/ME176C/ug31xx/uG31xx_API_System.h
@@ -0,0 +1,275 @@
+/**
+ * @filename  uG31xx_API_System.h
+ *
+ *  Interface of ug31xx system control
+ *
+ * @author  AllenTeng <allen_teng@upi-semi.com>
+ * @revision  $Revision: 107 $
+ */
+
+#define UG31XX_SYSTEM_VERSION     (7)
+
+typedef unsigned char   _sys_u8_;
+typedef signed char     _sys_s8_;
+typedef unsigned short  _sys_u16_;
+typedef signed short    _sys_s16_;
+typedef unsigned int   _sys_u32_;
+typedef signed int     _sys_s32_;
+typedef char            _sys_bool_;
+
+typedef enum _SYSTEM_RTN_CODE {
+  SYSTEM_RTN_PASS = 0,
+  SYSTEM_RTN_READ_GGB_FAIL,
+  SYSTEM_RTN_I2C_FAIL,
+} SYSTEM_RTN_CODE;
+
+typedef struct AlarmDataST {
+  _sys_u16_ alarmThrd;
+  _sys_u16_ releaseThrd;
+  _sys_bool_ state;
+} ALIGNED_ATTRIBUTE AlarmDataType;
+
+typedef struct SystemDataST {
+
+  #if defined (uG31xx_OS_WINDOWS)
+    const wchar_t* ggbFilename;
+    const wchar_t* otpFileName;
+  #endif  ///< end of defined (uG31xx_OS_WINDOWS)
+
+  ADC_CHECK adcCheckData;			//add for adc error check 20121025/jacky
+
+  _sys_u16_ voltage;
+  _sys_s16_ curr;
+  _sys_u8_ tpCount;
+
+  _sys_u16_ preITAve;
+  _sys_u8_ cellNum;
+
+  _sys_u16_ rmFromIC;
+  _sys_u16_ fccFromIC;
+  _sys_u8_ rsocFromIC;
+  _sys_u32_ timeTagFromIC;
+  _sys_u8_ tableUpdateIdxFromIC;
+  _sys_s16_ deltaCapFromIC;
+  _sys_u16_ adc1ConvTime;
+  _sys_u32_ oscFreq;
+  _sys_u16_ cycleCount;
+  _sys_s8_ ccOffset;
+  _sys_u8_ predictRsoc;
+  _sys_u8_ standbyDsgRatio;
+
+  _sys_u16_ rmFromICBackup;
+  _sys_u16_ fccFromICBackup;
+  _sys_u8_ rsocFromICBackup;
+
+  AlarmDataType uvAlarm;
+  AlarmDataType oetAlarm;
+  AlarmDataType uetAlarm;
+  _sys_u16_ alarmSts;
+} ALIGNED_ATTRIBUTE SystemDataType;
+
+extern SystemDataType *ptrSysData;
+
+/**
+ * @brief UpiInitSystemData
+ *
+ *  Initialize system data
+ *
+ * @para  data  address of BootDataType
+ * @return  _UPI_NULL_
+ */
+extern SYSTEM_RTN_CODE UpiInitSystemData(SystemDataType *data);
+
+/**
+ * @brief UpiCheckICActive
+ *
+ *  Check IC is actived or not
+ *
+ * @return  _UPI_TRUE_ if uG31xx is not actived
+ */
+extern _upi_bool_ UpiCheckICActive(SystemDataType *data);
+
+/**
+ * @brief UpiActiveUg31xx
+ *
+ *  Active uG31xx
+ *
+ * @return  SYSTEM_RTN_CODE
+ */
+extern SYSTEM_RTN_CODE UpiActiveUg31xx(void);
+
+/**
+ * @brief UpiStopUg31xx
+ *
+ *  Stop uG31xx
+ *
+ * @return  SYSTEM_RTN_CODE
+ */
+extern SYSTEM_RTN_CODE UpiStopUg31xx(void);
+
+/**
+ * @brief UpiSetupAdc
+ *
+ *  Setup ADC configurations
+ *
+ * @para  data  address of SystemDataType
+ * @return  _UPI_NULL_
+ */
+extern void UpiSetupAdc(SystemDataType *data);
+
+/**
+ * @brief UpiDecimateRst
+ *
+ *  Decimate reset filter of ADC
+ *
+ * @return  _UPI_NULL_
+ */
+extern void UpiDecimateRst(void);
+
+/**
+ * @brief UpiSetupSystem
+ *
+ *  Setup uG31xx system
+ *
+ * @para  data  address of SystemDataType
+ * @return  _UPI_NULL_
+ */
+extern void UpiSetupSystem(SystemDataType *data);
+
+/**
+ * @brief UpiCalculateOscFreq
+ *
+ *  OSC calibration
+ *    oscCnt25[9:0] = oscCntTarg[9:0] + oscDeltaCode25[7:0]
+ *    oscCnt80[9:0] = oscCntTarg[9:0] + oscDeltaCode80[7:0]
+ *    oscCnt[9:0] = m*ITcode[15:8] + C[9:0]
+ *    m = (oscCnt80[9:0]-oscCnt25[9:0])/(iTcode80[7:0]-iTcode25[7:0])
+ *    c = oscCnt25[9:0] - m*ITcode25[7:0]
+ *    write oscCnt[9:0] to register 0x97-98
+ *
+ * @para  data  address of SystemDataType
+ * @return  _UPI_NULL_
+ */
+extern void UpiCalculateOscFreq(SystemDataType *data);
+
+/**
+ * @brief UpiAdcStatus
+ *
+ *  Check ADC status
+ *
+ * @para  data  address of SystemDataType
+ * @return  _UPI_NULL_
+ */
+extern void UpiAdcStatus(SystemDataType *data);
+
+/**
+ * @brief UpiLoadBatInfoFromIC
+ *
+ *  Load battery information from uG31xx
+ *
+ * @para  data  address of SystemDataType
+ * @return  _UPI_NULL_
+ */
+extern void UpiLoadBatInfoFromIC(SystemDataType *data);
+
+/**
+ * @brief UpiUpdateBatInfoFromIC
+ *
+ *  Update battery information from uG31xx
+ *
+ * @para  data  address of SystemDataType
+ * @para  deltaQ  delta capacity from coulomb counter
+ * @para  suspend set _UPI_TRUE_ for suspend operation
+ * @return  _UPI_NULL_
+ */
+extern void UpiUpdateBatInfoFromIC(SystemDataType *data, _sys_s16_ deltaQ, _sys_bool_ suspend);
+
+/**
+ * @brief UpiSaveBatInfoTOIC
+ *
+ *  Save battery information from uG31xx
+ *
+ * @para  data  address of SystemDataType
+ * @return  _UPI_NULL_
+ */
+extern void UpiSaveBatInfoTOIC(SystemDataType *data);
+
+/**
+ * @brief UpiInitAlarm
+ *
+ *  Initialize alarm function of uG3105
+ *
+ * @para  data  address of SystemDataType
+ * @return  NULL
+ */
+extern void UpiInitAlarm(SystemDataType *data);
+
+/**
+ * @brief UpiAlarmStatus
+ *
+ *  Get alarm status
+ *
+ * @para  data  address of SystemDataType
+ * @return  NULL
+ */
+extern _sys_u8_ UpiAlarmStatus(SystemDataType *data);
+
+/**
+ * @brief UpiLoadTableFromIC
+ *
+ *  Load table form IC
+ *
+ * @para  data point of _sys_u8_ type
+ * @return  NULL
+ */
+extern void UpiLoadTableFromIC(_sys_u8_ *data);
+
+/**
+ * @brief UpiLoadTableFromIC
+ *
+ *  Save table to IC
+ *
+ * @para  data point of _sys_u8_ type
+ * @return  NULL
+ */
+extern void UpiSaveTableToIC(_sys_u8_ *data, _sys_u8_ *buf, _sys_u8_ size);
+
+/**
+ * @brief UpiSetupAdc1Queue
+ *
+ *  Setup ADC1 queue for normal operation
+ *
+ * @para  data  address of SystemDataType structure
+ * @return  NULL
+ */
+extern void UpiSetupAdc1Queue(SystemDataType *data);
+
+/**
+ * @brief UpiAllocateTableBuf
+ *
+ *  Allocate table buffer
+ *
+ * @para  data  address of SystemDataType structure
+ * @return  NULL
+ */
+extern void UpiAllocateTableBuf(_sys_u8_ **data, _sys_u8_ *size);
+
+/**
+ * @brief UpiFreeTableBuf
+ *
+ *  Free table buffer
+ *
+ * @para  data  address of SystemDataType structure
+ * @return  NULL
+ */
+extern void UpiFreeTableBuf(_sys_u8_ **data);
+
+/**
+ * @brief UpiPrintSystemVersion
+ *
+ *  Print system module version
+ *
+ * @return  NULL
+ */
+extern void UpiPrintSystemVersion(void);
+
diff --git a/drivers/power/supply/ASUS_BATTERY/ME176C/ug31xx/uG31xx_Platform.h b/drivers/power/supply/ASUS_BATTERY/ME176C/ug31xx/uG31xx_Platform.h
new file mode 100644
index 000000000000..cf0ac17c3e56
--- /dev/null
+++ b/drivers/power/supply/ASUS_BATTERY/ME176C/ug31xx/uG31xx_Platform.h
@@ -0,0 +1,35 @@
+/**
+ * @filename  uG31xx_Platform.h
+ *
+ *  Define the platform for uG31xx driver
+ *
+ * @author  AllenTeng <allen_teng@upi-semi.com>
+ * @revision  $Revision: 81 $
+ */
+
+#ifndef BUILD_UG31XX_LIB
+
+  #ifndef uG31xx_OS_ANDROID
+
+    #define uG31xx_OS_WINDOWS
+
+  #endif  ///< end of uG31xx_OS_ANDROID
+
+#endif  ///< end of BUILD_UG31XX_LIB
+
+/// [AT-PM] : Used for ANDROID linux kernel ; 09/08/2013
+//#define uG31xx_OS_ANDROID
+//#define UG31XX_USE_SHELL_AP_FOR_FILE_OP
+//#define UG31XX_USE_DAEMON_AP_FOR_FILE_OP
+//#define UG31XX_SHELL_ALGORITHM
+//#define ANDROID_SHELL_ALGORITHM
+//#define UG31XX_CELL_REPLACE_TEST
+//#define UG31XX_2_PERCENT_1_MIN
+//#define UG31XX_ADC_NO_TEMP_COMPENSATION
+//#define FEATURE_DISABLE_SUSPEND_OPERATION
+
+/// [AT-PM] : Used for ANDROID boot code ; 09/08/2013
+//#define uG31xx_BOOT_LOADER
+//#define uG31xx_ALIGNED_4
+//#define uG31xx_NO_MEM_UNIT
+
diff --git a/drivers/power/supply/ASUS_BATTERY/ME176C/ug31xx/uG31xx_Reg_Def.h b/drivers/power/supply/ASUS_BATTERY/ME176C/ug31xx/uG31xx_Reg_Def.h
new file mode 100644
index 000000000000..6acc6497ffcb
--- /dev/null
+++ b/drivers/power/supply/ASUS_BATTERY/ME176C/ug31xx/uG31xx_Reg_Def.h
@@ -0,0 +1,668 @@
+/**
+ * @filename RegDef.h
+ *
+ *  uG31xx register definition
+ *
+ * @author AllenTeng <allen.kuoliang.teng@gmail.com>
+ * @revision  $Revision: 253 $
+ * @note register table release date 2012/11/05
+ */
+
+#define INTERNAL_REGISTER_GROUP_A     (0x00)
+  #define REG_MODE                    (INTERNAL_REGISTER_GROUP_A + 0)     ///< 0x00
+    #define MODE_GG_RUN               (1<<4)
+      #define GG_RUN_STANDBY_MODE     (0<<4)
+      #define GG_RUN_OPERATION_MODE   (1<<4)
+  #define REG_CTRL1                   (INTERNAL_REGISTER_GROUP_A + 1)     ///< 0x01
+    #define CTRL1_PORDET              (1<<4)
+      #define PORDET_R_NO_POR         (0<<4)
+      #define PORDET_R_POR            (1<<4)
+      #define PORDET_W_RELEASE        (0<<4)
+      #define PORDET_W_SOFTRESET      (1<<4)
+    #define CTRL1_VTM_EOC             (1<<3)
+    #define CTRL1_GG_EOC              (1<<2)
+    #define CTRL1_GG_RST              (1<<1)
+    #define CTRL1_IO1DATA             (1<<0)
+      #define IO1DATA_R_LOW           (0<<0)
+      #define IO1DATA_R_HIGH          (1<<0)
+      #define IO1DATA_W_LOW           (0<<0)
+      #define IO1DATA_W_HIGH          (1<<0)
+
+#define INTERNAL_REGISTER_GROUP_B     (0x02)
+  #define REG_CHARGE_LOW              (INTERNAL_REGISTER_GROUP_B + 0)     ///< 0x02
+  #define REG_CHARGE_HIGH             (INTERNAL_REGISTER_GROUP_B + 1)     ///< 0x03
+  #define REG_COUNTER_LOW             (INTERNAL_REGISTER_GROUP_B + 2)     ///< 0x04
+  #define REG_COUNTER_HIGH            (INTERNAL_REGISTER_GROUP_B + 3)     ///< 0x05
+  #define REG_AVE_CURRENT_LOW         (INTERNAL_REGISTER_GROUP_B + 4)     ///< 0x06
+  #define REG_AVE_CURRENT_HIGH        (INTERNAL_REGISTER_GROUP_B + 5)     ///< 0x07
+  #define REG_AVE_VBAT1_LOW           (INTERNAL_REGISTER_GROUP_B + 6)     ///< 0x08
+  #define REG_AVE_VBAT1_HIGH          (INTERNAL_REGISTER_GROUP_B + 7)     ///< 0x09
+  #define REG_AVE_IT_LOW              (INTERNAL_REGISTER_GROUP_B + 8)     ///< 0x0A
+  #define REG_AVE_IT_HIGH             (INTERNAL_REGISTER_GROUP_B + 9)     ///< 0x0B
+  #define REG_AVE_OFFSET_CURRENT_LOW  (INTERNAL_REGISTER_GROUP_B + 10)    ///< 0x0C
+  #define REG_AVE_OFFSET_CURRENT_HIGH (INTERNAL_REGISTER_GROUP_B + 11)    ///< 0x0D
+  #define REG_AVE_ET_LOW              (INTERNAL_REGISTER_GROUP_B + 12)    ///< 0x0E
+  #define REG_AVE_ET_HIGH             (INTERNAL_REGISTER_GROUP_B + 13)    ///< 0x0F
+  #define REG_AVE_RID_LOW             (INTERNAL_REGISTER_GROUP_B + 14)    ///< 0x10
+  #define REG_AVE_RID_HIGH            (INTERNAL_REGISTER_GROUP_B + 15)    ///< 0x11
+  #define REG_ALARM1_STATUS           (INTERNAL_REGISTER_GROUP_B + 16)    ///< 0x12
+    #define ALARM1_STATUS_COC_ALARM   (1<<5)
+    #define ALARM1_STATUS_DOC_ALARM   (1<<4)
+    #define ALARM1_STATUS_OIT_ALARM   (1<<3)
+    #define ALARM1_STATUS_UIT_ALARM   (1<<2)
+    #define ALARM1_STATUS_OET_ALARM   (1<<1)
+    #define ALARM1_STATUS_UET_ALARM   (1<<0)
+  #define REG_ALARM2_STATUS           (INTERNAL_REGISTER_GROUP_B + 17)    ///< 0x13
+    #define ALARM2_STATUS_OV3_ALARM   (1<<5)
+    #define ALARM2_STATUS_UV3_ALARM   (1<<4)
+    #define ALARM2_STATUS_OV2_ALARM   (1<<3)
+    #define ALARM2_STATUS_UV2_ALARM   (1<<2)
+    #define ALARM2_STATUS_OV1_ALARM   (1<<1)
+    #define ALARM2_STATUS_UV1_ALARM   (1<<0)
+  #define REG_INTR_STATUS             (INTERNAL_REGISTER_GROUP_B + 18)    ///< 0x14
+    #define INTR_STATUS_CBC_STS32     (1<<7)
+      #define CBC_STS32_ENABLE        (0<<7)
+      #define CBC_STS32_DISABLE       (1<<7)
+    #define INTR_STATUS_CBC_STS21     (1<<6)
+      #define CBC_STS21_ENABLE        (0<<6)
+      #define CBC_STS21_DISABLE       (1<<6)
+    #define INTR_STATUS_STB_STS       (1<<5)
+    #define INTR_STATUS_ET_STS        (1<<4)
+    #define INTR_STATUS_IT_STS        (1<<3)
+    #define INTR_STATUS_RID_STS       (1<<2)
+    #define INTR_STATUS_LVD_STS       (1<<1)
+    #define INTR_STATUS_AL_STS        (1<<0)
+  #define REG_ALARM_EN                (INTERNAL_REGISTER_GROUP_B + 19)    ///< 0x15
+    #define ALARM_EN_COC_ALARM_EN     (1<<7)
+    #define ALARM_EN_DOC_ALARM_EN     (1<<6)
+    #define ALARM_EN_IT_ALARM_EN      (1<<5)
+    #define ALARM_EN_ET_ALARM_EN      (1<<4)
+    #define ALARM_EN_DECIMATE_RST     (1<<3)
+    #define ALARM_EN_V3_ALARM_EN      (1<<2)
+    #define ALARM_EN_V2_ALARM_EN      (1<<1)
+    #define ALARM_EN_V1_ALARM_EN      (1<<0)
+  #define REG_CTRL2                   (INTERNAL_REGISTER_GROUP_B + 20)    ///< 0x16
+    #define CTRL2_IO4DATA             (1<<2)
+      #define IO4DATA_R_LOW           (0<<2)
+      #define IO4DATA_R_HIGH          (1<<2)
+      #define IO4DATA_W_LOW           (0<<2)
+      #define IO4DATA_W_HIGH          (1<<2)
+    #define CTRL2_IO3DATA             (1<<1)
+      #define IO3DATA_R_LOW           (0<<1)
+      #define IO3DATA_R_HIGH          (1<<1)
+      #define IO3DATA_W_LOW           (0<<1)
+      #define IO3DATA_W_HIGH          (1<<1)
+    #define CTRL2_IO2DATA             (1<<0)
+      #define IO2DATA_R_LOW           (0<<0)
+      #define IO2DATA_R_HIGH          (1<<0)
+      #define IO2DATA_W_LOW           (0<<0)
+      #define IO2DATA_W_HIGH          (1<<0)
+
+#define INTERNAL_REGISTER_GROUP_C     (0x20)
+  #define REG_RAM0                    (INTERNAL_REGISTER_GROUP_C + 0)     ///< 0x20
+  #define REG_RAM1                    (INTERNAL_REGISTER_GROUP_C + 1)     ///< 0x21
+  #define REG_RAM2                    (INTERNAL_REGISTER_GROUP_C + 2)     ///< 0x22
+  #define REG_RAM3                    (INTERNAL_REGISTER_GROUP_C + 3)     ///< 0x23
+  #define REG_RAM4                    (INTERNAL_REGISTER_GROUP_C + 4)     ///< 0x24
+  #define REG_RAM5                    (INTERNAL_REGISTER_GROUP_C + 5)     ///< 0x25
+  #define REG_RAM6                    (INTERNAL_REGISTER_GROUP_C + 6)     ///< 0x26
+  #define REG_RAM7                    (INTERNAL_REGISTER_GROUP_C + 7)     ///< 0x27
+  #define REG_RAM8                    (INTERNAL_REGISTER_GROUP_C + 8)     ///< 0x28
+  #define REG_RAM9                    (INTERNAL_REGISTER_GROUP_C + 9)     ///< 0x29
+  #define REG_RAM10                   (INTERNAL_REGISTER_GROUP_C + 10)    ///< 0x2A
+  #define REG_RAM11                   (INTERNAL_REGISTER_GROUP_C + 11)    ///< 0x2B
+  #define REG_RAM12                   (INTERNAL_REGISTER_GROUP_C + 12)    ///< 0x2C
+  #define REG_RAM13                   (INTERNAL_REGISTER_GROUP_C + 13)    ///< 0x2D
+  #define REG_RAM14                   (INTERNAL_REGISTER_GROUP_C + 14)    ///< 0x2E
+  #define REG_RAM15                   (INTERNAL_REGISTER_GROUP_C + 15)    ///< 0x2F
+  #define REG_RAM16                   (INTERNAL_REGISTER_GROUP_C + 16)    ///< 0x30
+  #define REG_RAM17                   (INTERNAL_REGISTER_GROUP_C + 17)    ///< 0x31
+  #define REG_RAM18                   (INTERNAL_REGISTER_GROUP_C + 18)    ///< 0x32
+  #define REG_RAM19                   (INTERNAL_REGISTER_GROUP_C + 19)    ///< 0x33
+  #define REG_RAM20                   (INTERNAL_REGISTER_GROUP_C + 20)    ///< 0x34
+  #define REG_RAM21                   (INTERNAL_REGISTER_GROUP_C + 21)    ///< 0x35
+  #define REG_RAM22                   (INTERNAL_REGISTER_GROUP_C + 22)    ///< 0x36
+  #define REG_RAM23                   (INTERNAL_REGISTER_GROUP_C + 23)    ///< 0x37
+  #define REG_RAM24                   (INTERNAL_REGISTER_GROUP_C + 24)    ///< 0x38
+  #define REG_RAM25                   (INTERNAL_REGISTER_GROUP_C + 25)    ///< 0x39
+  #define REG_RAM26                   (INTERNAL_REGISTER_GROUP_C + 26)    ///< 0x3A
+  #define REG_RAM27                   (INTERNAL_REGISTER_GROUP_C + 27)    ///< 0x3B
+  #define REG_RAM28                   (INTERNAL_REGISTER_GROUP_C + 28)    ///< 0x3C
+  #define REG_RAM29                   (INTERNAL_REGISTER_GROUP_C + 29)    ///< 0x3D
+  #define REG_RAM30                   (INTERNAL_REGISTER_GROUP_C + 30)    ///< 0x3E
+  #define REG_RAM31                   (INTERNAL_REGISTER_GROUP_C + 31)    ///< 0x3F
+
+#define INTERNAL_REGISTER_GROUP_D     (0x40)
+  #define REG_VBAT2_LOW               (INTERNAL_REGISTER_GROUP_D + 0)     ///< 0x40
+  #define REG_VBAT2_HIGH              (INTERNAL_REGISTER_GROUP_D + 1)     ///< 0x41
+  #define REG_VBAT3_LOW               (INTERNAL_REGISTER_GROUP_D + 2)     ///< 0x42
+  #define REG_VBAT3_HIGH              (INTERNAL_REGISTER_GROUP_D + 3)     ///< 0x43
+  #define REG_VBAT1_LOW               (INTERNAL_REGISTER_GROUP_D + 4)     ///< 0x44
+  #define REG_VBAT1_HIGH              (INTERNAL_REGISTER_GROUP_D + 5)     ///< 0x45
+  #define REG_VBAT2_AVE_LOW           (INTERNAL_REGISTER_GROUP_D + 6)     ///< 0x46
+  #define REG_VBAT2_AVE_HIGH          (INTERNAL_REGISTER_GROUP_D + 7)     ///< 0x47
+  #define REG_VBAT3_AVE_LOW           (INTERNAL_REGISTER_GROUP_D + 8)     ///< 0x48
+  #define REG_VBAT3_AVE_HIGH          (INTERNAL_REGISTER_GROUP_D + 9)     ///< 0x49
+  #define REG_V1_LOW                  (INTERNAL_REGISTER_GROUP_D + 10)    ///< 0x4A
+  #define REG_V1_HIGH                 (INTERNAL_REGISTER_GROUP_D + 11)    ///< 0x4B
+  #define REG_V2_LOW                  (INTERNAL_REGISTER_GROUP_D + 12)    ///< 0x4C
+  #define REG_V2_HIGH                 (INTERNAL_REGISTER_GROUP_D + 13)    ///< 0x4D
+  #define REG_V3_LOW                  (INTERNAL_REGISTER_GROUP_D + 14)    ///< 0x4E
+  #define REG_V3_HIGH                 (INTERNAL_REGISTER_GROUP_D + 15)    ///< 0x4F
+  #define REG_INTR_TEMPER_LOW         (INTERNAL_REGISTER_GROUP_D + 16)    ///< 0x50
+  #define REG_INTR_TEMPER_HIGH        (INTERNAL_REGISTER_GROUP_D + 17)    ///< 0x51
+  #define REG_EXTR_TEMPER_LOW         (INTERNAL_REGISTER_GROUP_D + 18)    ///< 0x52
+  #define REG_EXTR_TEMPER_HIGH        (INTERNAL_REGISTER_GROUP_D + 19)    ///< 0x53
+  #define REG_RID_LOW                 (INTERNAL_REGISTER_GROUP_D + 20)    ///< 0x54
+  #define REG_RID_HIGH                (INTERNAL_REGISTER_GROUP_D + 21)    ///< 0x55
+  #define REG_CURRENT_LOW             (INTERNAL_REGISTER_GROUP_D + 22)    ///< 0x56
+  #define REG_CURRENT_HIGH            (INTERNAL_REGISTER_GROUP_D + 23)    ///< 0x57
+  #define REG_ADC1_OFFSET_LOW         (INTERNAL_REGISTER_GROUP_D + 24)    ///< 0x58
+  #define REG_ADC1_OFFSET_HIGH        (INTERNAL_REGISTER_GROUP_D + 25)    ///< 0x59
+
+  #define OTP6_BYTE1                  (INTERNAL_REGISTER_GROUP_D + 48)    ///< 0x70
+    #define AVE_IT25_7_3              (63<<3)
+    #define DELTA_ET_3_2              (3<<1)
+    #define DELTA_VREF_4              (1<<0)
+  #define OTP6_BYTE2                  (INTERNAL_REGISTER_GROUP_D + 49)    ///< 0x71
+    #define AVE_IT25_15_8             (255<<0)
+  #define OTP6_BYTE3                  (INTERNAL_REGISTER_GROUP_D + 50)    ///< 0x72
+    #define AVE_IT80_7_3              (63<<3)
+    #define INDEX_ADC1_200_25_4       (1<<2)
+    #define INDEX_ADC1_100_25_4       (1<<1)
+    #define INDEX_ADC2_200_25_4       (1<<0)
+  #define OTP6_BYTE4                  (INTERNAL_REGISTER_GROUP_D + 51)    ///< 0x73
+    #define AVE_IT80_15_8             (255<<0)
+
+#define INTERNAL_REGISTER_GROUP_E     (0x8F)
+  #define REG_TIMER                   (INTERNAL_REGISTER_GROUP_E + 0)     ///< 0x8F
+    #define TIMER_TIMER_ITSET         (3<<6)
+      #define TIMER_ITSET_4           (0<<6)
+      #define TIMER_ITSET_9           (1<<6)
+      #define TIMER_ITSET_14          (2<<6)
+      #define TIMER_ITSET_19          (3<<6)
+    #define TIMER_TIMER_ETSET         (3<<4)
+      #define TIMER_ETSET_4           (0<<4)
+      #define TIMER_ETSET_9           (1<<4)
+      #define TIMER_ETSET_14          (2<<4)
+      #define TIMER_ETSET_19          (3<<4)
+    #define TIMER_TIMER_VSET          (3<<2)
+      #define TIMER_VSET_4            (0<<2)
+      #define TIMER_VSET_9            (1<<2)
+      #define TIMER_VSET_14           (2<<2)
+      #define TIMER_VSET_19           (3<<2)
+    #define TIMER_TIMER_CSET          (3<<0)
+      #define TIMER_CSET_4            (0<<0)
+      #define TIMER_CSET_9            (1<<0)
+      #define TIMER_CSET_14           (2<<0)
+      #define TIMER_CSET_19           (3<<0)
+  #define REG_CLK_DIVA                (INTERNAL_REGISTER_GROUP_E + 1)     ///< 0x90
+    #define CLK_DIVA_FW_CLK_CDIV      (15<<4)
+      #define FW_CLK_CDIV_31US        (0<<4)
+      #define FW_CLK_CDIV_61US        (1<<4)
+      #define FW_CLK_CDIV_122US       (2<<4)
+      #define FW_CLK_CDIV_244US       (3<<4)
+      #define FW_CLK_CDIV_488US       (4<<4)
+      #define FW_CLK_CDIV_977US       (5<<4)
+      #define FW_CLK_CDIV_2MS         (6<<4)
+      #define FW_CLK_CDIV_4MS         (7<<4)
+      #define FW_CLK_CDIV_8MS         (8<<4)
+      #define FW_CLK_CDIV_16MS        (9<<4)
+      #define FW_CLK_CDIV_31MS        (10<<4)
+      #define FW_CLK_CDIV_62MS        (11<<4)
+      #define FW_CLK_CDIV_125MS       (12<<4)
+      #define FW_CLK_CDIV_250MS       (13<<4)
+      #define FW_CLK_CDIV_500MS       (14<<4)
+      #define FW_CLK_CDIV_1S          (15<<4)
+    #define CLK_DIVA_FW_CLK_VDIV      (15<<0)
+      #define FW_CLK_VDIV_31US        (0<<0)
+      #define FW_CLK_VDIV_61US        (1<<0)
+      #define FW_CLK_VDIV_122US       (2<<0)
+      #define FW_CLK_VDIV_244US       (3<<0)
+      #define FW_CLK_VDIV_488US       (4<<0)
+      #define FW_CLK_VDIV_977US       (5<<0)
+      #define FW_CLK_VDIV_2MS         (6<<0)
+      #define FW_CLK_VDIV_4MS         (7<<0)
+      #define FW_CLK_VDIV_8MS         (8<<0)
+      #define FW_CLK_VDIV_16MS        (9<<0)
+      #define FW_CLK_VDIV_31MS        (10<<0)
+      #define FW_CLK_VDIV_62MS        (11<<0)
+      #define FW_CLK_VDIV_125MS       (12<<0)
+      #define FW_CLK_VDIV_250MS       (13<<0)
+      #define FW_CLK_VDIV_500MS       (14<<0)
+      #define FW_CLK_VDIV_1S          (15<<0)
+  #define REG_CLK_DIVB                (INTERNAL_REGISTER_GROUP_E + 2)     ///< 0x91
+    #define CLK_DIVB_FW_CLK_ETDIV     (15<<4)
+      #define FW_CLK_ETDIV_31US       (0<<4)
+      #define FW_CLK_ETDIV_61US       (1<<4)
+      #define FW_CLK_ETDIV_122US      (2<<4)
+      #define FW_CLK_ETDIV_244US      (3<<4)
+      #define FW_CLK_ETDIV_488US      (4<<4)
+      #define FW_CLK_ETDIV_977US      (5<<4)
+      #define FW_CLK_ETDIV_2MS        (6<<4)
+      #define FW_CLK_ETDIV_4MS        (7<<4)
+      #define FW_CLK_ETDIV_8MS        (8<<4)
+      #define FW_CLK_ETDIV_16MS       (9<<4)
+      #define FW_CLK_ETDIV_31MS       (10<<4)
+      #define FW_CLK_ETDIV_62MS       (11<<4)
+      #define FW_CLK_ETDIV_125MS      (12<<4)
+      #define FW_CLK_ETDIV_250MS      (13<<4)
+      #define FW_CLK_ETDIV_500MS      (14<<4)
+      #define FW_CLK_ETDIV_1S         (15<<4)
+    #define CLK_DIVB_FW_CLK_ITDIV     (15<<0)
+      #define FW_CLK_ITDIV_31US       (0<<0)
+      #define FW_CLK_ITDIV_61US       (1<<0)
+      #define FW_CLK_ITDIV_122US      (2<<0)
+      #define FW_CLK_ITDIV_244US      (3<<0)
+      #define FW_CLK_ITDIV_488US      (4<<0)
+      #define FW_CLK_ITDIV_977US      (5<<0)
+      #define FW_CLK_ITDIV_2MS        (6<<0)
+      #define FW_CLK_ITDIV_4MS        (7<<0)
+      #define FW_CLK_ITDIV_8MS        (8<<0)
+      #define FW_CLK_ITDIV_16MS       (9<<0)
+      #define FW_CLK_ITDIV_31MS       (10<<0)
+      #define FW_CLK_ITDIV_62MS       (11<<0)
+      #define FW_CLK_ITDIV_125MS      (12<<0)
+      #define FW_CLK_ITDIV_250MS      (13<<0)
+      #define FW_CLK_ITDIV_500MS      (14<<0)
+      #define FW_CLK_ITDIV_1S         (15<<0)
+  #define REG_INTR_CTRL_D             (INTERNAL_REGISTER_GROUP_E + 3)     ///< 0x92
+    #define INTR_CTRL_D_GPIO4_SEL     (7<<3)
+      #define GPIO4_SEL_GPIO1         (0<<3)
+      #define GPIO4_SEL_ALARM         (1<<3)
+      #define GPIO4_SEL_CBC_EN21      (2<<3)
+      #define GPIO4_SEL_CBC_EN32      (3<<3)
+      #define GPIO4_SEL_PWM           (4<<3)
+      #define GPIO4_SEL_ADC1_D        (6<<3)
+      #define GPIO4_SEL_ADC2_D        (7<<3)
+    #define INTR_CTRL_D_GPIO3_SEL     (7<<0)
+      #define GPIO3_SEL_GPIO1         (0<<0)
+      #define GPIO3_SEL_ALARM         (1<<0)
+      #define GPIO3_SEL_CBC_EN21      (2<<0)
+      #define GPIO3_SEL_CBC_EN32      (3<<0)
+      #define GPIO3_SEL_PWM           (4<<0)
+      #define GPIO3_SEL_ADC1_D        (6<<0)
+      #define GPIO3_SEL_ADC2_D        (7<<0)
+  #define OSCTUNE_J1                  (INTERNAL_REGISTER_GROUP_E + 4)     ///< 0x93
+    #define OSCTUNE_J_LOW             (255<<0)
+  #define OSCTUNE_J2                  (INTERNAL_REGISTER_GROUP_E + 5)     ///< 0x94
+    #define OSCTUNE_J_HIGH            (3<<0)
+  #define OSCTUNE_K1                  (INTERNAL_REGISTER_GROUP_E + 6)     ///< 0x95
+    #define OSCTUNE_K_LOW             (255<<0)
+  #define OSCTUNE_K2                  (INTERNAL_REGISTER_GROUP_E + 7)     ///< 0x96
+    #define OSCTUNE_K_HIGH            (3<<0)
+  #define OSCTUNE_CNTA                (INTERNAL_REGISTER_GROUP_E + 8)     ///< 0x97
+    #define OSCTUNE_CNT_LOW           (255<<0)
+  #define OSCTUNE_CNTB                (INTERNAL_REGISTER_GROUP_E + 9)     ///< 0x98
+    #define OSCTUNE_CNT_HIGH          (3<<0)
+  #define ADC1_TARGET_A               (INTERNAL_REGISTER_GROUP_E + 10)    ///< 0x99
+    #define TARGET_A_LOW              (255<<0)
+  #define ADC1_TARGET_B               (INTERNAL_REGISTER_GROUP_E + 11)    ///< 0x9A
+    #define TARGET_A_HIGH             (3<<0)
+  #define REG_INTR_CTRL_A             (INTERNAL_REGISTER_GROUP_E + 12)    ///< 0x9B
+    #define INTR_CTRL_A_GPIO2_SEL     (7<<5)
+      #define GPIO2_SEL_GPIO1         (0<<5)
+      #define GPIO2_SEL_ALARM         (1<<5)
+      #define GPIO2_SEL_CBC_EN21      (2<<5)
+      #define GPIO2_SEL_CBC_EN32      (3<<5)
+      #define GPIO2_SEL_PWM           (4<<5)
+    #define INTR_CTRL_A_GPIO1_SEL     (7<<2)
+      #define GPIO1_SEL_GPIO1         (0<<2)
+      #define GPIO1_SEL_ALARM         (1<<2)
+      #define GPIO1_SEL_CBC_EN21      (2<<2)
+      #define GPIO1_SEL_CBC_EN32      (3<<2)
+      #define GPIO1_SEL_PWM           (4<<2)
+      #define GPIO1_SEL_OSCOUT        (7<<2)
+    #define INTR_CTRL_A_ADC2_EN       (1<<1)
+    #define INTR_CTRL_A_ADC1_EN       (1<<0)
+  #define REG_INTR_CTRL_B             (INTERNAL_REGISTER_GROUP_E + 13)    ///< 0x9C
+    #define INTR_CTRL_B_OSC_CNT_EN    (1<<7)
+    #define INTR_CTRL_B_PWM_EN        (1<<6)
+    #define INTR_CTRL_B_CBC_32_EN     (1<<5)
+    #define INTR_CTRL_B_CBC_21_EN     (1<<4)
+    #define INTR_CTRL_B_STB_EN        (1<<3)
+    #define INTR_CTRL_B_ET_EN         (1<<2)
+    #define INTR_CTRL_B_IT_EN         (1<<1)
+    #define INTR_CTRL_B_RID_EN        (1<<0)
+  #define REG_ITNR_CTRL_C             (INTERNAL_REGISTER_GROUP_E + 14)    ///< 0x9D
+    #define INTR_CTRL_C_BGRCAL_FINISH (1<<7)
+    #define INTR_CTRL_C_FW_V_DIVIDE   (1<<6)
+    #define INTR_CTRL_C_BGRCAL_START  (1<<5)
+    #define INTR_CTRL_C_BGR_CALEN     (1<<4)
+    #define INTR_CTRL_C_PWM_SET       (3<<2)
+      #define PWM_SET_32K             (0<<2)
+      #define PWM_SET_16K             (1<<2)
+      #define PWM_SET_8K              (2<<2)
+      #define PWM_SET_4K              (3<<2)
+    #define INTR_CTRL_C_TIMER_SET     (3<<0)
+      #define TIMER_SET_OV_UV         (0<<0)
+      #define TIMER_SET_OC_UC         (1<<0)
+      #define TIMER_SET_OIT_UIT       (2<<0)
+      #define TIMER_SET_OET_UET       (3<<0)
+  #define REG_CELL_EN                 (INTERNAL_REGISTER_GROUP_E + 15)    ///< 0x9E
+    #define CELL_EN_APPLICATION       (7<<2)
+      #define APPLICATION_UG3100      (0<<2)
+      #define APPLICATION_UG3101      (1<<2)
+      #define APPLICATION_UG3102      (2<<2)
+      #define APPLICATION_UG3103_2    (4<<2)
+      #define APPLICATION_UG3103_3    (5<<2)
+    #define CELL_EN1                  (1<<1)
+    #define CELL_EN0                  (1<<0)
+
+#define INTERNAL_REGISTER_GROUP_F     (0x9F)
+  #define REG_COC_LOW                 (INTERNAL_REGISTER_GROUP_F + 0)     ///< 0x9F
+  #define REG_COC_HIGH                (INTERNAL_REGISTER_GROUP_F + 1)     ///< 0xA0
+  #define REG_DOC_LOW                 (INTERNAL_REGISTER_GROUP_F + 2)     ///< 0xA1
+  #define REG_DOC_HIGH                (INTERNAL_REGISTER_GROUP_F + 3)     ///< 0xA2
+  #define REG_UC_LOW                  (INTERNAL_REGISTER_GROUP_F + 4)     ///< 0xA3
+  #define REG_UC_HIGH                 (INTERNAL_REGISTER_GROUP_F + 5)     ///< 0xA4
+  #define REG_OV1_LOW                 (INTERNAL_REGISTER_GROUP_F + 6)     ///< 0xA5
+  #define REG_OV1_HIGH                (INTERNAL_REGISTER_GROUP_F + 7)     ///< 0xA6
+  #define REG_UV1_LOW                 (INTERNAL_REGISTER_GROUP_F + 8)     ///< 0xA7
+  #define REG_UV1_HIGH                (INTERNAL_REGISTER_GROUP_F + 9)     ///< 0xA8
+  #define REG_OV2_LOW                 (INTERNAL_REGISTER_GROUP_F + 10)    ///< 0xA9
+  #define REG_OV2_HIGH                (INTERNAL_REGISTER_GROUP_F + 11)    ///< 0xAA
+  #define REG_UV2_LOW                 (INTERNAL_REGISTER_GROUP_F + 12)    ///< 0xAB
+  #define REG_UV2_HIGH                (INTERNAL_REGISTER_GROUP_F + 13)    ///< 0xAC
+  #define REG_OV3_LOW                 (INTERNAL_REGISTER_GROUP_F + 14)    ///< 0xAD
+  #define REG_OV3_HIGH                (INTERNAL_REGISTER_GROUP_F + 15)    ///< 0xAE
+  #define REG_UV3_LOW                 (INTERNAL_REGISTER_GROUP_F + 16)    ///< 0xAF
+  #define REG_UV3_HIGH                (INTERNAL_REGISTER_GROUP_F + 17)    ///< 0xB0
+  #define REG_OVP_LOW                 (INTERNAL_REGISTER_GROUP_F + 18)    ///< 0xB1
+  #define REG_OVP_HIGH                (INTERNAL_REGISTER_GROUP_F + 19)    ///< 0xB2
+  #define REG_UVP_LOW                 (INTERNAL_REGISTER_GROUP_F + 20)    ///< 0xB3
+  #define REG_UVP_HIGH                (INTERNAL_REGISTER_GROUP_F + 21)    ///< 0xB4
+  #define REG_INTR_OVER_TEMP_LOW      (INTERNAL_REGISTER_GROUP_F + 22)    ///< 0xB5
+  #define REG_INTR_OVER_TEMP_HIGH     (INTERNAL_REGISTER_GROUP_F + 23)    ///< 0xB6
+  #define REG_INTR_UNDER_TEMP_LOW     (INTERNAL_REGISTER_GROUP_F + 24)    ///< 0xB7
+  #define REG_INTR_UNDER_TEMP_HIGH    (INTERNAL_REGISTER_GROUP_F + 25)    ///< 0xB8
+  #define REG_EXTR_OVER_TEMP_LOW      (INTERNAL_REGISTER_GROUP_F + 26)    ///< 0xB9
+  #define REG_EXTR_OVER_TEMP_HIGH     (INTERNAL_REGISTER_GROUP_F + 27)    ///< 0xBA
+  #define REG_EXTR_UNDER_TEMP_LOW     (INTERNAL_REGISTER_GROUP_F + 28)    ///< 0xBB
+  #define REG_EXTR_UNDER_TEMP_HIGH    (INTERNAL_REGISTER_GROUP_F + 29)    ///< 0xBC
+  #define REG_CBC21_LOW               (INTERNAL_REGISTER_GROUP_F + 30)    ///< 0xBD
+  #define REG_CBC21_HIGH              (INTERNAL_REGISTER_GROUP_F + 31)    ///< 0xBE
+  #define REG_CBC32_LOW               (INTERNAL_REGISTER_GROUP_F + 32)    ///< 0xBF
+  #define REG_CBC32_HIGH              (INTERNAL_REGISTER_GROUP_F + 33)    ///< 0xC0
+
+#define INTERNAL_REGISTER_GROUP_G     (0xC1)
+  #define REG_FW_CTRL                 (INTERNAL_REGISTER_GROUP_G + 0)     ///< 0xC1
+    #define FW_CTRL_CHOP2_EN          (1<<3)
+    #define FW_CTRL_CHOPPING2         (1<<2)
+    #define FW_CTRL_CHOP1_EN          (1<<1)
+    #define FW_CTRL_CHOPPING1         (1<<0)
+  #define REG_OTP_CTRL                (INTERNAL_REGISTER_GROUP_G + 1)     ///< 0xC2
+    #define OTP_CTRL_IT_CAL80         (1<<7)
+    #define OTP_CTRL_IT_CAL25         (1<<6)
+    #define OTP_CTRL_ADC2_200MV       (1<<5)
+    #define OTP_CTRL_ADC2_100MV       (1<<4)
+    #define OTP_CTRL_ADC1_200MV       (1<<3)
+    #define OTP_CTRL_ADC1_100MV       (1<<2)
+    #define OTP_CTRL_OTP_PTM          (3<<0)
+  #define REG_OTP_PPROG_ON            (INTERNAL_REGISTER_GROUP_G + 2)     ///< 0xC3
+    #define OTP_PPROG_ON_VALUE        (0xDD)
+  #define REG_OTP_PPROG_OFF           (INTERNAL_REGISTER_GROUP_G + 3)     ///< 0xC4
+    #define OTP_PPROG_OFF_VALUE       (0xDE)
+
+#define INTERNAL_REGISTER_GROUP_H     (0xC5)
+  #define REG_ADC_CTR_A               (INTERNAL_REGISTER_GROUP_H + 0)     ///< 0xC5
+    #define ADC_CTR_A_SET_A           (3<<6)
+      #define SET_A_CURRENT           (0<<6)
+      #define SET_A_ET                (1<<6)
+      #define SET_A_RID_IN            (2<<6)
+      #define SET_A_IT                (3<<6)
+    #define ADC_CTR_A_SET_B           (3<<4)
+      #define SET_B_CURRENT           (0<<4)
+      #define SET_B_ET                (1<<4)
+      #define SET_B_RID_IN            (2<<4)
+      #define SET_B_IT                (3<<4)
+    #define ADC_CTR_A_SET_C           (3<<2)
+      #define SET_C_CURRENT           (0<<2)
+      #define SET_C_ET                (1<<2)
+      #define SET_C_RID_IN            (2<<2)
+      #define SET_C_IT                (3<<2)
+    #define ADC_CTR_A_SET_D           (3<<0)
+      #define SET_D_CURRENT           (0<<0)
+      #define SET_D_ET                (1<<0)
+      #define SET_D_RID_IN            (2<<0)
+      #define SET_D_IT                (3<<0)
+  #define REG_ADC_CTR_B               (INTERNAL_REGISTER_GROUP_H + 1)     ///< 0xC6
+    #define ADC_CTR_B_SET_E           (3<<6)
+      #define SET_E_CURRENT           (0<<6)
+      #define SET_E_ET                (1<<6)
+      #define SET_E_RID_IN            (2<<6)
+      #define SET_E_IT                (3<<6)
+    #define ADC_CTR_B_SET_F           (3<<4)
+      #define SET_F_CURRENT           (0<<4)
+      #define SET_F_ET                (1<<4)
+      #define SET_F_RID_IN            (2<<4)
+      #define SET_F_IT                (3<<4)
+    #define ADC_CTR_B_SET_G           (3<<2)
+      #define SET_G_CURRENT           (0<<2)
+      #define SET_G_ET                (1<<2)
+      #define SET_G_RID_IN            (2<<2)
+      #define SET_G_IT                (3<<2)
+    #define ADC_CTR_B_SET_H           (3<<0)
+      #define SET_H_CURRENT           (0<<0)
+      #define SET_H_ET                (1<<0)
+      #define SET_H_RID_IN            (2<<0)
+      #define SET_H_IT                (3<<0)
+  #define REG_ADC_CTR_C               (INTERNAL_REGISTER_GROUP_H + 2)     ///< 0xC7
+    #define ADC_CTR_C_SET_I           (3<<6)
+      #define SET_I_CURRENT           (0<<6)
+      #define SET_I_ET                (1<<6)
+      #define SET_I_RID_IN            (2<<6)
+      #define SET_I_IT                (3<<6)
+    #define ADC_CTR_C_SET_J           (3<<4)
+      #define SET_J_CURRENT           (0<<4)
+      #define SET_J_ET                (1<<4)
+      #define SET_J_RID_IN            (2<<4)
+      #define SET_J_IT                (3<<4)
+    #define ADC_CTR_C_SET_K           (3<<2)
+      #define SET_K_CURRENT           (0<<2)
+      #define SET_K_ET                (1<<2)
+      #define SET_K_RID_IN            (2<<2)
+      #define SET_K_IT                (3<<2)
+    #define ADC_CTR_C_SET_L           (3<<0)
+      #define SET_L_CURRENT           (0<<0)
+      #define SET_L_ET                (1<<0)
+      #define SET_L_RID_IN            (2<<0)
+      #define SET_L_IT                (3<<0)
+  #define REG_ADC_CTR_D               (INTERNAL_REGISTER_GROUP_H + 3)     ///< 0xC8
+    #define ADC_CTR_D_SET_M           (3<<6)
+      #define SET_M_CURRENT           (0<<6)
+      #define SET_M_ET                (1<<6)
+      #define SET_M_RID_IN            (2<<6)
+      #define SET_M_IT                (3<<6)
+    #define ADC_CTR_D_SET_N           (3<<4)
+      #define SET_N_CURRENT           (0<<4)
+      #define SET_N_ET                (1<<4)
+      #define SET_N_RID_IN            (2<<4)
+      #define SET_N_IT                (3<<4)
+    #define ADC_CTR_D_SET_O           (3<<2)
+      #define SET_O_CURRENT           (0<<2)
+      #define SET_O_ET                (1<<2)
+      #define SET_O_RID_IN            (2<<2)
+      #define SET_O_IT                (3<<2)
+    #define ADC_CTR_D_SET_P           (3<<0)
+      #define SET_P_CURRENT           (0<<0)
+      #define SET_P_ET                (1<<0)
+      #define SET_P_RID_IN            (2<<0)
+      #define SET_P_IT                (3<<0)
+  #define REG_ADC_V1                  (INTERNAL_REGISTER_GROUP_H + 4)     ///< 0xC9
+    #define ADC_CTR_V1_SET_V1         (3<<6)
+      #define SET_V1_GND              (0<<6)
+      #define SET_V1_VBAT1            (1<<6)
+      #define SET_V1_VBAT2            (2<<6)
+      #define SET_V1_VBAT3            (3<<6)
+    #define ADC_CTR_V1_SET_V2         (3<<4)
+      #define SET_V2_GND              (0<<4)
+      #define SET_V2_VBAT1            (1<<4)
+      #define SET_V2_VBAT2            (2<<4)
+      #define SET_V2_VBAT3            (3<<4)
+    #define ADC_CTR_V1_SET_V3         (3<<2)
+      #define SET_V3_GND              (0<<2)
+      #define SET_V3_VBAT1            (1<<2)
+      #define SET_V3_VBAT2            (2<<2)
+      #define SET_V3_VBAT3            (3<<2)
+    #define ADC_CTR_V1_SET_V4         (3<<0)
+      #define SET_V4_GND              (0<<0)
+      #define SET_V4_VBAT1            (1<<0)
+      #define SET_V4_VBAT2            (2<<0)
+      #define SET_V4_VBAT3            (3<<0)
+  #define REG_ADC_V2                  (INTERNAL_REGISTER_GROUP_H + 5)     ///< 0xCA
+    #define ADC_CTR_V2_SET_V5         (3<<6)
+      #define SET_V5_GND              (0<<6)
+      #define SET_V5_VBAT1            (1<<6)
+      #define SET_V5_VBAT2            (2<<6)
+      #define SET_V5_VBAT3            (3<<6)
+    #define ADC_CTR_V2_SET_V6         (3<<4)
+      #define SET_V6_GND              (0<<4)
+      #define SET_V6_VBAT1            (1<<4)
+      #define SET_V6_VBAT2            (2<<4)
+      #define SET_V6_VBAT3            (3<<4)
+    #define ADC_CTR_V2_SET_V7         (3<<2)
+      #define SET_V7_GND              (0<<2)
+      #define SET_V7_VBAT1            (1<<2)
+      #define SET_V7_VBAT2            (2<<2)
+      #define SET_V7_VBAT3            (3<<2)
+    #define ADC_CTR_V2_SET_V8         (3<<0)
+      #define SET_V8_GND              (0<<0)
+      #define SET_V8_VBAT1            (1<<0)
+      #define SET_V8_VBAT2            (2<<0)
+      #define SET_V8_VBAT3            (3<<0)
+  #define REG_ADC_V3                  (INTERNAL_REGISTER_GROUP_H + 6)     ///< 0xCB
+    #define ADC_CTR_V3_SET_V9         (3<<6)
+      #define SET_V9_GND              (0<<6)
+      #define SET_V9_VBAT1            (1<<6)
+      #define SET_V9_VBAT2            (2<<6)
+      #define SET_V9_VBAT3            (3<<6)
+    #define ADC_CTR_V3_SET_V10        (3<<4)
+      #define SET_V10_GND             (0<<4)
+      #define SET_V10_VBAT1           (1<<4)
+      #define SET_V10_VBAT2           (2<<4)
+      #define SET_V10_VBAT3           (3<<4)
+    #define ADC_CTR_V3_SET_V11        (3<<2)
+      #define SET_V11_GND             (0<<2)
+      #define SET_V11_VBAT1           (1<<2)
+      #define SET_V11_VBAT2           (2<<2)
+      #define SET_V11_VBAT3           (3<<2)
+    #define ADC_CTR_V3_SET_V12        (3<<0)
+      #define SET_V12_GND             (0<<0)
+      #define SET_V12_VBAT1           (1<<0)
+      #define SET_V12_VBAT2           (2<<0)
+      #define SET_V12_VBAT3           (3<<0)
+
+#define INTERNAL_REGISTER_GROUP_I     (0xCC)
+  #define KCONFIG_D1                  (INTERNAL_REGISTER_GROUP_I + 0)     ///< 0xCC
+    #define KCONFIG_D_LOW             (255<<0)
+  #define KCONFIG_D2                  (INTERNAL_REGISTER_GROUP_I + 1)     ///< 0xCD
+    #define KCONFIG_D_HIGH            (255<<0)
+
+#define INTERNAL_REGISTER_GROUP_J     (0xCE)
+  #define KCONFIG_A1                  (INTERNAL_REGISTER_GROUP_J + 0)     ///< 0xCE
+    #define KCONFIG_A1_KGG1_OSC       (255<<0)
+  #define KCONFIG_A2                  (INTERNAL_REGISTER_GROUP_J + 1)     ///< 0xCF
+    #define KCONFIG_A2_KGG1_DSM2_L    (255<<0)
+  #define KCONFIG_A3                  (INTERNAL_REGISTER_GROUP_J + 2)     ///< 0xD0
+    #define KCONFIG_A3_KGG1_DSM2_M    (255<<0)
+  #define KCONFIG_A4                  (INTERNAL_REGISTER_GROUP_J + 3)     ///< 0xD1
+    #define KCONFIG_A4_KGG1_DSM2_H    (255<<0)
+  #define KCONFIG_A5                  (INTERNAL_REGISTER_GROUP_J + 4)     ///< 0xD2
+    #define KCONFIG_A5_KGG1_DSM1_L    (255<<0)
+  #define KCONFIG_A6                  (INTERNAL_REGISTER_GROUP_J + 5)     ///< 0xD3
+    #define KCONFIG_A6_KGG1_DSM1_M    (255<<0)
+  #define KCONFIG_A7                  (INTERNAL_REGISTER_GROUP_J + 6)     ///< 0xD4
+    #define KCONFIG_A7_KGG1_DSM1_H    (255<<0)
+  #define KCONFIG_A8                  (INTERNAL_REGISTER_GROUP_J + 7)     ///< 0xD5
+    #define KCONFIG_A8_KGG1_MBIAS_L   (255<<0)
+  #define KCONFIG_A9                  (INTERNAL_REGISTER_GROUP_J + 8)     ///< 0xD6
+    #define KCONFIG_A9_KGG1_MBIAS_H   (3<<0)
+
+  #define KCONFIG_H1                  (INTERNAL_REGISTER_GROUP_J + 9)     ///< 0xD7
+    #define KCONFIG_H1_KGG1_IDO_LOW   (15<<4)
+    #define KCONFIG_H1_KGG1_MBIAS     (3<<2)
+    #define KCONFIG_H1_KGG1_OSC       (3<<2)
+  #define KCONFIG_H2                  (INTERNAL_REGISTER_GROUP_J + 10)    ///< 0xD8
+    #define KCONFIG_H2_KGG1_IDO_HIGH  (255<<0)
+  #define KCONFIG_H3                  (INTERNAL_REGISTER_GROUP_J + 11)    ///< 0xD9
+    #define KCONFIG_H3_KGG1_BGAP_LOW  (63<<2)
+    #define KCONFIG_H3_KGG1_DSM2      (3<<0)
+  #define KCONFIG_H4                  (INTERNAL_REGISTER_GROUP_J + 12)    ///< 0xDA
+    #define KCONFIG_H3_KGG1_BGAP_HIGH (127<<0)
+  #define KCONFIG_H5                  (INTERNAL_REGISTER_GROUP_J + 13)    ///< 0xDB
+    #define KCONFIG_H5_WIRE_V_DIVIDE  (1<<6)
+    #define KCONFIG_H5_KGG1_BGAP_CAL  (63<<0)
+
+#define INTERNAL_REGISTER_GROUP_K     (0xDC)
+  #define KCONFIG_CAL1                (INTERNAL_REGISTER_GROUP_K + 0)     ///< 0xDC
+    #define KCONFIG_CAL1_KGG1_OSC_L   (255<<0)
+  #define KCONFIG_CAL2                (INTERNAL_REGISTER_GROUP_K + 1)     ///< 0xDD
+    #define KCONFIG_CAL2_KGG1_OSC_H   (255<<0)
+  #define KCONFIG_CAL3                (INTERNAL_REGISTER_GROUP_K + 2)     ///< 0xDE
+    #define KCONFIG_CAL3_KGG1_DSM2    (255<<0)
+  #define KCONFIG_CAL4                (INTERNAL_REGISTER_GROUP_K + 3)     ///< 0xDF
+    #define KCONFIG_CAL4_KGG1_DSM1    (255<<0)
+
+#define INTERNAL_REGISTER_GROUP_L     (0xE0)
+  #define OTP1_BYTE1                  (INTERNAL_REGISTER_GROUP_L + 0)     ///< 0xE0
+    #define DELTA_VREF_3_0            (15<<4)
+    #define INDEX_ADC1_200_25_3_0     (15<<0)
+  #define OTP1_BYTE2                  (INTERNAL_REGISTER_GROUP_L + 1)     ///< 0xE1
+    #define FT_IT_6_3                 (15<<4)
+    #define INDEX_ADC1_100_25_3_0     (15<<0)
+  #define OTP1_BYTE3                  (INTERNAL_REGISTER_GROUP_L + 2)     ///< 0xE2
+    #define FT_IT_10_7                (15<<4)
+    #define INDEX_ADC2_200_25_3_0     (15<<0)
+  #define OTP1_BYTE4                  (INTERNAL_REGISTER_GROUP_L + 3)     ///< 0xE3
+    #define FT_IT_14_11               (15<<4)
+    #define INDEX_ADC2_100_25_3_0     (15<<0)
+
+  #define OTP2_BYTE1                  (INTERNAL_REGISTER_GROUP_L + 16)    ///< 0xF0
+    #define DELTA_ET_1                (1<<7)
+    #define INDEX_ADC2_100_25_4       (1<<6)
+    #define DELTA_ET_0                (1<<5)
+    #define PRODUCT_TYPE              (3<<3)
+    #define ITDELTACODE25_10_8        (7<<0)
+  #define OTP2_BYTE2                  (INTERNAL_REGISTER_GROUP_L + 17)    ///< 0xF1
+    #define ITDELTACODE25_7_0         (255<<0)
+  #define OTP2_BYTE3                  (INTERNAL_REGISTER_GROUP_L + 18)    ///< 0xF2
+    #define OTP_CELL_EN               (31<<3)
+    #define ITDELTACODE80_10_8        (7<<0)
+  #define OTP2_BYTE4                  (INTERNAL_REGISTER_GROUP_L + 19)    ///< 0xF3
+    #define ITDELTACODE80_7_0         (255<<0)
+
+  #define OTP3_BYTE1                  (INTERNAL_REGISTER_GROUP_L + 20)    ///< 0xF4
+    #define DEVADDR_9_0               (63<<2)
+    #define ADC1DELTACODE25_200_9     (1<<1)
+    #define ADC1DELTACODE25_200_8     (1<<0)
+  #define OTP3_BYTE2                  (INTERNAL_REGISTER_GROUP_L + 21)    ///< 0xF5
+    #define BGRTUNE_5_0               (63<<2)
+    #define ADC1DELTACODE80_200_9_8   (3<<0)
+  #define OTP3_BYTE3                  (INTERNAL_REGISTER_GROUP_L + 22)    ///< 0xF6
+    #define OSCDELTACODE25            (255<<0)
+  #define OTP3_BYTE4                  (INTERNAL_REGISTER_GROUP_L + 23)    ///< 0xF7
+    #define OSCDELTACODE80            (255<<0)
+
+  #define OTP4_BYTE1                  (INTERNAL_REGISTER_GROUP_L + 24)    ///< 0xF8
+    #define ADC1DELTACODE25_200_7_0   (255<<0)
+  #define OTP4_BYTE2                  (INTERNAL_REGISTER_GROUP_L + 25)    ///< 0xF9
+    #define ADC1DELTACODE80_200_7_0   (255<<0)
+  #define OTP4_BYTE3                  (INTERNAL_REGISTER_GROUP_L + 26)    ///< 0xFA
+    #define ADC1DELTACODE25_100_7_0   (255<<0)
+  #define OTP4_BYTE4                  (INTERNAL_REGISTER_GROUP_L + 27)    ///< 0xFB
+    #define ADC1DELTACODE80_100_7_0   (255<<0)
+
+  #define OTP5_BYTE1                  (INTERNAL_REGISTER_GROUP_L + 28)    ///< 0xFC
+    #define ADC2DELTACODE25_100_6     (1<<7)
+    #define ADC2DELTACODE25_100_5_0   (63<<1)
+    #define ADC1DELTACODE25_100_8     (1<<0)
+  #define OTP5_BYTE2                  (INTERNAL_REGISTER_GROUP_L + 29)    ///< 0xFD
+    #define ADC2DELTACODE80_100_6_0   (127<<1)
+    #define ADC1DELTACODE80_100_8     (1<<0)
+  #define OTP5_BYTE3                  (INTERNAL_REGISTER_GROUP_L + 30)    ///< 0xFE
+    #define ADC2DELTACODE25_200_7     (1<<7)
+    #define ADC2DELTACODE25_200_6_0   (127<<0)
+  #define OTP5_BYTE4                  (INTERNAL_REGISTER_GROUP_L + 31)    ///< 0xFF
+    #define ADC2DELTACODE80_200_7_0   (255<<0)
+
diff --git a/drivers/power/supply/ASUS_BATTERY/ME176C/ug31xx/ug31xx_gauge.c b/drivers/power/supply/ASUS_BATTERY/ME176C/ug31xx/ug31xx_gauge.c
new file mode 100644
index 000000000000..8e0f1c465528
--- /dev/null
+++ b/drivers/power/supply/ASUS_BATTERY/ME176C/ug31xx/ug31xx_gauge.c
@@ -0,0 +1,4466 @@
+/*
+ * Copyright (c) 2012, uPI Semiconductor Corp. All Rights Reserved.
+ */
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/param.h>
+#include <linux/i2c.h>
+#include <linux/delay.h>
+#include <linux/slab.h>
+#include <linux/interrupt.h>
+#include <linux/power_supply.h>
+#include <linux/idr.h>
+#include <linux/reboot.h>
+#include <linux/notifier.h>
+#include <linux/jiffies.h>
+#include <linux/err.h>
+#include <asm/unaligned.h>
+#include <linux/wakelock.h>
+#include <linux/kobject.h>
+#include <linux/string.h>
+#include <linux/sysfs.h>
+#include <linux/seq_file.h>
+
+// [Webber] ++++++++++++++++++++++++++++++++++++++++++++++++
+// include ME176C Gauge Battery Data (provide by vendor)
+#include "ug31xx_ggb_data_k013.h"
+// [Webber] ------------------------------------------------
+
+
+#include "uG31xx_Platform.h"
+#include "ug31xx_gauge.h"
+#include "uG31xx_API_Platform.h"
+#include <linux/ioctl.h>
+#include <asm/uaccess.h>
+#include <linux/miscdevice.h>
+#include <linux/proc_fs.h>
+#include <linux/version.h>
+
+#include <linux/timer.h>
+#include <linux/android_alarm.h>
+#include <linux/hrtimer.h>
+//Carlisle add for ACPI match ++
+#include <linux/acpi.h>
+//Carlisle add for ACPI match --
+
+//#define	UPI_CALLBACK_FUNC	            ///< [AT-PM] : Used for removing callback function ; 04/15/2013
+#define	UG31XX_DYNAMIC_POLLING	      ///< [AT-PM] : Used for dynamic polling time ; 04/30/2013
+//#define UG31XX_WAIT_CHARGER_FC        ///< [AT-PM] : Used for full charge status decided by charger ; 07/25/2013
+//#define UG31XX_DYNAMIC_TAPER_CURRENT  ///< [AT-PM] : Used for changing taper current threshold ; 09/01/2013
+//#define UG31XX_REGISTER_I2C     ///< [AT-PM] : Used for register I2C inside module ; 09/03/2013
+#define UG31XX_REGISTER_POWERSUPPLY   ///< [AT-PM] : Used for register powersupply class ; 09/05/2013
+#define UG31XX_SHOW_EXT_TEMP    ///< [FC] : Set temperature reference by external ; 09/30/2013
+#define UG31XX_MISC_DEV
+#define UG31XX_PROBE_CHARGER_OFF      ///< [AT-PM] : Used for charger off at probe ; 12/06/2013
+#define UG31XX_EARLY_SUSPEND			///< [AT-PM] : Used for early suspend instead of suspend ; 12/07/2013
+#define UG31XX_KOBJECT      ///< [AT-PM] : Used for register kobject ; 12/23/2013
+#define UG31XX_USER_SPACE_ALGORITHM     ///< [AT-PM] : Used for user space algorithm operation ; 12/24/2013
+#define UG31XX_USER_SPACE_BACKUP        ///< [AT-PM] : Used for user space backup operation ; 12/30/2013
+#define FEATRUE_K_BOARD_OFFSET
+//#define UG31XX_CALI_BO_EARLY_SUSPEND    ///< [AT-PM] : Used for calibrate board offset in early suspend ; 02/27/2014
+#define UG31XX_PROC_DEV
+
+
+#include <linux/switch.h>
+#include <linux/earlysuspend.h>
+#define ENABLE_BATTERY_SHIFTx
+bool ug31xx_probe_done = false;//TOM
+EXPORT_SYMBOL(ug31xx_probe_done);//TOM
+int Status;
+//extern int entry_mode;
+struct switch_dev batt_dev;
+
+#define UG31XX_USER_DAEMON_VER_LENGTH    (16)
+#define UG31XX_CALI_BO_FACTORY_DELAY	 (300)
+#define UG31XX_CALI_BO_CHARGER_OFF_DELAY (2000)
+#define UG31XX_CALI_BO_LOW_TEMP         (100)
+#define UG31XX_CALI_BO_HIGH_TEMP        (450)
+#define UG31XX_CALI_BO_LOOP             (5)
+#define	UG31XX_CALI_BO_LOOP_EOC		(100)
+#define UG31XX_CALI_BO_UP_PSOC  	(90)
+#define UG31XX_CALI_BO_LW_PSOC  	(30)
+#define UG31XX_RETRY_DELAY_TIME         (30) ///< [FC] : retry timer ; 03/11/2014
+#define UG31XX_RESET_DELAY_TIME         (5) ///< [FC] : reset timer ; 03/11/2014
+#define UG31XX_RETRY_TIME               (5) ///< [FC] : retry time ; 03/11/2014
+#define UG31XX_KBO_PASS_COUNT           (20)
+#define UG31XX_KBO_FAIL_COUNT           (10)
+#define UG31XX_KBO_PASS_MAX             (40)
+#define UG31XX_KBO_PASS_MIN             (-40)
+#define UG31XX_TIME_MSEC_TO_SEC         (1000)
+#define UG31XX_TIME_USEC_TO_SEC         (1000000)
+#define UG31XX_KBO_WAKE_LOCK_TIMEOUT    (10)
+
+
+struct ug31xx_gauge {
+#if defined(CONFIG_HAS_EARLYSUSPEND) && defined(UG31XX_EARLY_SUSPEND)
+	struct early_suspend es;
+#endif	///< end of defined(CONFIG_HAS_EARLYSUSPEND) && defined(UG31XX_EARLY_SUSPEND)
+	struct i2c_client       *client;
+	struct device           *dev;
+	struct delayed_work     batt_info_update_work;
+	struct delayed_work     batt_power_update_work;
+	struct delayed_work     batt_probe_work;
+	struct delayed_work     batt_retry_work;
+	struct delayed_work     batt_reinitial_work;
+	struct delayed_work     board_offset_cali_work;
+	struct delayed_work     shell_algorithm_work;
+	struct delayed_work     shell_backup_work;
+	struct delayed_work     shell_timeout_work;
+#ifdef FEATRUE_K_BOARD_OFFSET
+	struct delayed_work     kbo_work;
+	struct delayed_work     kbo_check_work;
+	struct delayed_work     cos_work;
+	struct delayed_work     cos_check_work;
+#endif ///< for FEATRUE_K_BOARD_OFFSET
+	struct delayed_work     stop_charging_work;
+  struct delayed_work     curr_check_work;
+	struct wake_lock        batt_wake_lock;
+	struct wake_lock        shell_algorithm_wake_lock;
+	struct wake_lock        shell_timeout_wake_lock;
+	struct mutex            info_update_lock;
+
+	u32 cable_status;
+	u32 polling_time;         ///< [AT-PM] : unit in second ; 12/10/2013
+	u32 update_time;          ///< [AT-PM] : unit in second ; 12/10/2013
+	u32 batt_volt;            ///< [AT-PM] : unit in mV ; 10/07/2013
+	int batt_capacity;        ///< [AT-PM] : unit in % ; 10/07/2013
+	int batt_capacity_shifted;///< [AT-PM] : unit in % ; 10/07/2013 chris add.
+	int batt_capacity_last;   ///< [AT-PM] : unit in % ; 10/07/2013
+	int batt_capacity_real;   ///< [AT-PM] : unit in % ; 11/27/2013
+	u32 batt_charge_now;      ///< [AT-PM] : unit in mAh ; 10/07/2013
+	u32 batt_charge_full;     ///< [AT-PM] : unit in mAh ; 10/07/2013
+	int batt_charge_counter;  ///< [AT-PM] : unit in mAh ; 02/18/2014
+	int batt_current;         ///< [AT-PM] : unit in mA ; 10/07/2013
+	int batt_current_last;    ///< [AT-PM] : unit in mA ; 10/07/2013
+	int batt_temp;            ///< [AT-PM] : unit in 0.1oC ; 10/07/2013
+	int batt_avg_temp;        ///< [AT-PM] : unit in 0.1oC ; 11/27/2013
+	int batt_ready;
+	int batt_remove;
+	int batt_alarm_sts;
+	int batt_status;
+	int batt_cycle_count;
+	int batt_ntc_sts;
+	int board_offset;
+	char effective_board_offset[8];
+	char daemon_ver[UG31XX_USER_DAEMON_VER_LENGTH];
+	int daemon_uevent_count;
+	int force_fc_time;
+    struct hrtimer kbo_timer;
+};
+
+static void batt_info_update_work_func(struct work_struct *work);
+
+#define CABLE_STATUS_CHANGE_RELEASE_COUNT (1)
+
+#define GAUGE_err(...)        printk(KERN_ERR "<BATT> " __VA_ARGS__);
+#define GAUGE_notice(...)     printk(KERN_NOTICE "<BATT> " __VA_ARGS__);
+#define GAUGE_info(...)       printk(KERN_INFO "<BATT> " __VA_ARGS__);
+
+#ifdef UG31XX_MISC_DEV
+
+#define UG31XX_IOC_MAGIC 'U'
+#define UG31XX_IOCTL_RESET                    _IO(UG31XX_IOC_MAGIC, 1)
+#define UG31XX_IOCTL_ENABLE_SUSPEND_LOG       _IO(UG31XX_IOC_MAGIC, 2)
+#define UG31XX_IOCTL_ENABLE_LOG               _IO(UG31XX_IOC_MAGIC, 3)
+#define UG31XX_IOCTL_DISABLE_LOG              _IO(UG31XX_IOC_MAGIC, 4)
+#define UG31XX_IOCTL_I2C_READ                 _IOWR(UG31XX_IOC_MAGIC, 5, unsigned char *)
+#define UG31XX_IOCTL_I2C_WRITE                _IOWR(UG31XX_IOC_MAGIC, 6, unsigned char *)
+#define UG31XX_IOCTL_RESET_CYCLE_COUNT        _IO(UG31XX_IOC_MAGIC, 7)
+#define UG31XX_IOCTL_BACKUP_SIZE              _IOWR(UG31XX_IOC_MAGIC, 8, unsigned char *)
+#define UG31XX_IOCTL_BACKUP_READ              _IOWR(UG31XX_IOC_MAGIC, 9, unsigned char *)
+#define UG31XX_IOCTL_BACKUP_WRITE             _IOWR(UG31XX_IOC_MAGIC, 10, unsigned char *)
+#define UG31XX_IOCTL_DAEMON_GET_CNTL          _IOWR(UG31XX_IOC_MAGIC, 11, unsigned char *)
+#define UG31XX_IOCTL_DAEMON_SET_CNTL          _IOWR(UG31XX_IOC_MAGIC, 12, unsigned char *)
+#define UG31XX_IOCTL_DAEMON_DELAY             _IOWR(UG31XX_IOC_MAGIC, 13, unsigned char *)
+#define UG31XX_IOCTL_DAEMON_FILENAME          _IOWR(UG31XX_IOC_MAGIC, 14, unsigned char *)
+#define UG31XX_IOCTL_ALGORITHM_SIZE           _IOWR(UG31XX_IOC_MAGIC, 15, unsigned char *)
+#define UG31XX_IOCTL_ALGORITHM_START          _IOWR(UG31XX_IOC_MAGIC, 16, unsigned char *)
+#define UG31XX_IOCTL_ALGORITHM_UPDATE         _IOWR(UG31XX_IOC_MAGIC, 17, unsigned char *)
+#define UG31XX_IOCTL_ALGORITHM_OPTION         _IOWR(UG31XX_IOC_MAGIC, 18, unsigned char *)
+#define UG31XX_IOCTL_ALGORITHM_BACKUP         _IOWR(UG31XX_IOC_MAGIC, 19, unsigned char *)
+#define UG31XX_IOCTL_ALGORITHM_BACKUP_BUFFER  _IOWR(UG31XX_IOC_MAGIC, 20, unsigned char *)
+#define UG31XX_IOCTL_ALGORITHM_BACKUP_SIZE    _IOWR(UG31XX_IOC_MAGIC, 21, unsigned char *)
+#define UG31XX_IOCTL_ALGORITHM_TABLE_SIZE     _IOWR(UG31XX_IOC_MAGIC, 22, unsigned char *)
+#define UG31XX_IOCTL_ALGORITHM_TABLE_DATA     _IOWR(UG31XX_IOC_MAGIC, 23, unsigned char *)
+#define UG31XX_IOCTL_ALGORITHM_TABLE_BUF      _IOWR(UG31XX_IOC_MAGIC, 24, unsigned char *)
+#define UG31XX_IOCTL_ALGORITHM_VERSION        _IOWR(UG31XX_IOC_MAGIC, 25, unsigned char *)
+#define UG31XX_IOCTL_ALGORITHM_LOCK           _IO(UG31XX_IOC_MAGIC, 26)
+#define UG31XX_IOCTL_ALGORITHM_UNLOCK         _IO(UG31XX_IOC_MAGIC, 27)
+#ifdef FEATRUE_K_BOARD_OFFSET
+#define UG31XX_IOCTL_ALGORITHM_READ_BO        _IOWR(UG31XX_IOC_MAGIC, 28, unsigned char *)
+#define UG31XX_IOCTL_ALGORITHM_WRITE_BO       _IOWR(UG31XX_IOC_MAGIC, 29, unsigned char *)
+#endif ///< for FEATRUE_K_BOARD_OFFSET
+#define UG31XX_IOCTL_ALGORITHM_GET_DATA       _IO(UG31XX_IOC_MAGIC, 30)
+#define UG31XX_IOCTL_ALGORITHM_GET_DATA_RUN   _IOWR(UG31XX_IOC_MAGIC, 31, unsigned char *)
+#define UG31XX_IOCTL_ALGORITHM_SET_DATA       _IO(UG31XX_IOC_MAGIC, 32)
+#define UG31XX_IOCTL_ALGORITHM_SET_DATA_RUN   _IOWR(UG31XX_IOC_MAGIC, 33, unsigned char *)
+#define UG31XX_IOCTL_ALGORITHM_SET_DATA_END   _IO(UG31XX_IOC_MAGIC, 34)
+#ifdef FEATRUE_K_BOARD_OFFSET
+#define UG31XX_IOCTL_ALGORITHM_READ_COS       _IOWR(UG31XX_IOC_MAGIC, 35, unsigned char *)
+#define UG31XX_IOCTL_ALGORITHM_WRITE_COS      _IOWR(UG31XX_IOC_MAGIC, 36, unsigned char *)
+#define UG31XX_IOCTL_ALGORITHM_MODE_COS       _IO(UG31XX_IOC_MAGIC, 37)
+#endif ///< for FEATRUE_K_BOARD_OFFSET
+#define UG31XX_IOCTL_CURRENT_NOW              _IOWR(UG31XX_IOC_MAGIC, 38, unsigned char *)
+#define UG31XX_IOCTL_CC_CHG_OFFSET_25_READ    _IOWR(UG31XX_IOC_MAGIC, 40, unsigned char *)
+#define UG31XX_IOCTL_CC_CHG_OFFSET_25_WRITE   _IOWR(UG31XX_IOC_MAGIC, 41, unsigned char *)
+#define UG31XX_IOCTL_CC_CHG_OFFSET_50_READ    _IOWR(UG31XX_IOC_MAGIC, 42, unsigned char *)
+#define UG31XX_IOCTL_CC_CHG_OFFSET_50_WRITE   _IOWR(UG31XX_IOC_MAGIC, 43, unsigned char *)
+#define UG31XX_IOCTL_CC_CHG_OFFSET_75_READ    _IOWR(UG31XX_IOC_MAGIC, 44, unsigned char *)
+#define UG31XX_IOCTL_CC_CHG_OFFSET_75_WRITE   _IOWR(UG31XX_IOC_MAGIC, 45, unsigned char *)
+#define UG31XX_IOCTL_CC_CHG_OFFSET_100_READ   _IOWR(UG31XX_IOC_MAGIC, 46, unsigned char *)
+#define UG31XX_IOCTL_CC_CHG_OFFSET_100_WRITE  _IOWR(UG31XX_IOC_MAGIC, 47, unsigned char *)
+#define UG31XX_IOCTL_CALI_RSOC_TIME_READ      _IOWR(UG31XX_IOC_MAGIC, 48, unsigned char *)
+#define UG31XX_IOCTL_CALI_RSOC_TIME_WRITE     _IOWR(UG31XX_IOC_MAGIC, 49, unsigned char *)
+#define UG31XX_IOCTL_RESET_TOTALLY      	    _IO(UG31XX_IOC_MAGIC, 50)
+#define UG31XX_IOCTL_DAEMON_EVENT             _IOWR(UG31XX_IOC_MAGIC, 51, unsigned char *)
+
+#define UG31XX_IOCTL_CMD(cmd)         (((_IOC_DIR(cmd)) << 16) | (_IOC_NR(cmd)))
+
+#endif	///< end of UG31XX_MISC_DEV
+
+#define UG31XX_IOCTL_TRANS_DATA_SIZE      (0x400)
+
+#ifdef  UG31XX_CELL_REPLACE_TEST
+
+#define UG31XX_WAKE_LOCK_TIMEOUT      		(60)
+
+#else   ///< else of UG31XX_CELL_REPLACE_TEST
+
+#define UG31XX_WAKE_LOCK_TIMEOUT      		(1)
+
+#endif  ///< end of UG31XX_CELL_REPLACE_TEST
+
+/* Functions Declaration */
+#ifdef	UG31XX_REGISTER_POWERSUPPLY
+
+static int ug31xx_battery_get_property(struct power_supply *psy,
+				       enum power_supply_property psp,
+				       union power_supply_propval *val);
+
+#endif	///< end of UG31XX_REGISTER_POWERSUPPLY
+
+#ifdef	UPI_CALLBACK_FUNC
+
+static int ug31xx_power_get_property(struct power_supply *psy,
+				     enum power_supply_property psp,
+				     union power_supply_propval *val);
+
+#else	///< else of UPI_CALLBACK_FUNC
+
+#ifdef	UG31XX_REGISTER_POWERSUPPLY
+
+static void ug31xx_battery_external_power_changed(struct power_supply *psy);
+
+#endif	///< end of UG31XX_REGISTER_POWERSUPPLY
+
+#endif	///< end of UPI_CALLBACK_FUNC
+
+#ifdef	UG31XX_REGISTER_POWERSUPPLY
+
+static int ug31xx_update_psp(enum power_supply_property psp,
+			     union power_supply_propval *val);
+
+#endif	///< end of UG31XX_REGISTER_POWERSUPPLY
+
+/* Extern Function */
+extern char FactoryGGBXFile[];
+
+/* Global Variables */
+static struct ug31xx_gauge *ug31 = NULL;
+unsigned char cur_cable_status = UG31XX_NO_CABLE;
+ug31xx_drv_status_t ug31xx_drv_status = UG31XX_DRV_NOT_READY;
+static bool charger_detect_full = false;
+static bool curr_charger_full_status = false;
+static int charge_termination_current = 0;          ///< [AT-PM] : Set charging termination current (0 = from GGB settings) ; 09/05/2013
+static int cable_status_changed = 0;
+static bool force_power_supply_change = true;
+static bool charger_full_status = false;
+static bool charger_dc_in_before_suspend = false;
+static unsigned char op_options = LKM_OPTIONS_DEBUG_ERROR;	///< [AT-PM] : Set to "LKM_OPTIONS_ENABLE_REVERSE_CURRENT" to enable reverse current direction feature ; 11/12/2013
+static int rsense_value = 0;                        ///< [AT-PM] : Set R-Sense value (0 = from GGB settings) ; 09/05/2013
+static int ug31xx_backup_file_status = 0;
+static unsigned short design_capacity = 0;
+static bool probe_with_cable = false;
+static bool in_early_suspend = false;
+static int delta_q_in_suspend = 0;
+static bool user_space_algorithm_response = true;
+static int user_space_algorithm_prev_fc_sts = 0;
+static int user_space_algorithm_now_fc_sts = 0;
+static bool user_space_in_progress = false;
+static bool force_update_backup_file = false;
+static bool enable_board_offset_cali_at_eoc = false;
+static int kbo_result = 0;
+static int kbo_pass_queue[UG31XX_KBO_PASS_COUNT];
+static int kbo_fail_queue[UG31XX_KBO_FAIL_COUNT];
+#ifdef FEATRUE_K_BOARD_OFFSET
+static bool kbo_file_exist = false;
+static bool kbo_start_flag = false;
+#endif ///< for FEATRUE_K_BOARD_OFFSET
+
+static int cos_result = 0;
+static bool cos_file_exist = false;
+static int cos_file_written = 100;
+static bool cos_mode = false;
+static int board_offset_cali_loop = 0;
+static int board_offset_cali_loop_max = UG31XX_CALI_BO_LOOP;
+static int board_offset_cali_loop_eoc = 0;
+static int board_offset_cali_avg = 0;
+static int board_offset_cali_init = 0;
+static bool board_offset_cali_finish = false;
+static bool board_offset_cali_run = false;
+static int board_offset_cali_eoc_buf[UG31XX_CALI_BO_LOOP_EOC];
+static int ggb_board_offset = 0;
+static int ntc_offset = 0;
+static int standby_current = 0;
+static int ggb_board_gain = 1000;
+static unsigned int ggb_config = 0;
+static unsigned int cc_chg_offset_25 = 0;
+static unsigned int cc_chg_offset_50 = 0;
+static unsigned int cc_chg_offset_75 = 0;
+static unsigned int cc_chg_offset_100 = 0;
+static unsigned int cali_rsoc_time = 3600;
+static int curr_direction_changed = 0;
+static int retry_cnt = 0;
+static int ioctl_data_trans_cnt = 0;
+static int ioctl_data_trans_size = 0;
+static unsigned char *ioctl_data_trans_ptr = NULL;
+static unsigned char ioctl_data_trans_buf[UG31XX_IOCTL_TRANS_DATA_SIZE];
+static int kbo_pass_cnt = 0;
+static int kbo_fail_cnt = 0;
+static int kbo_cnt = 0;
+static int op_actions = UG31XX_OP_NORMAL;
+static int force_fc_current_thrd = 0;
+static int force_fc_timeout = 0;
+static unsigned int daemon_uevent_request = 0;
+static bool fix_time_60s = false;
+static bool fix_time_2s = false;
+
+#define CHARGER_LIST_NUM      (1)
+static char *charger_list[] = {"ac"};
+
+static void get_ggb_array(void)
+{
+}
+
+static void set_project_config(void)
+{
+	ggb_board_offset = 8;
+	ggb_board_gain = 908;
+}
+
+static void update_project_config(void)
+{
+  unsigned int buf[4];
+
+	if(ug31_module.get_charge_termination_current() != charge_termination_current)
+	{
+		ug31_module.set_charge_termination_current(charge_termination_current);
+	}
+	if(ug31_module.get_rsense() != rsense_value)
+	{
+		ug31_module.set_rsense(rsense_value);
+	}
+	if(ug31_module.get_ggb_board_offset() != ggb_board_offset)
+	{
+		ug31_module.set_ggb_board_offset(ggb_board_offset);
+	}
+	if(ug31_module.get_ntc_offset() != ntc_offset)
+	{
+		ug31_module.set_ntc_offset(ntc_offset);
+	}
+	if(ug31_module.get_standby_current() != standby_current)
+	{
+		ug31_module.set_standby_current(standby_current);
+	}
+	if(ug31_module.get_ggb_board_gain() != ggb_board_gain)
+	{
+		ug31_module.set_ggb_board_gain(ggb_board_gain);
+	}
+	if(ug31_module.get_ggb_config() != ggb_config)
+	{
+		ug31_module.set_ggb_config(ggb_config);
+	}
+
+  ug31_module.get_cc_chg_offset(&buf[0], &buf[1], &buf[2], &buf[3]);
+  if((buf[0] != cc_chg_offset_25) ||
+     (buf[1] != cc_chg_offset_50) ||
+     (buf[2] != cc_chg_offset_75) ||
+     (buf[3] != cc_chg_offset_100))
+  {
+    ug31_module.set_cc_chg_offset(cc_chg_offset_25,
+                                  cc_chg_offset_50,
+                                  cc_chg_offset_75,
+                                  cc_chg_offset_100);
+  }
+}
+/*-----------------------Tom add charger API interface -----*/
+extern int bq24192_is_charging(void);
+extern void bq24192_charge_enable(int enable);
+/*----------------------------------------------------------*/
+
+static bool is_charging_full(void)
+{
+  int charger_status;
+
+  if((ug31->force_fc_time > force_fc_timeout) &&
+     (cur_cable_status != UG31XX_NO_CABLE))
+  {
+    GAUGE_notice("[%s]: force fc reached.\n", __func__);
+    return (true);
+  }
+
+  charger_status = bq24192_is_charging();
+  if (charger_status == POWER_SUPPLY_STATUS_FULL)
+  {
+    GAUGE_info("[%s] charging full\n", __func__);
+    return (true);
+  }
+  else
+  {
+    return (false);
+  }
+}
+
+static bool is_charging(void)
+{
+  int charger_status;
+
+  charger_status = bq24192_is_charging();
+  if ((charger_status == POWER_SUPPLY_STATUS_FULL) ||
+      (charger_status == POWER_SUPPLY_STATUS_CHARGING))
+  {
+    //GAUGE_info("[%s] charging\n", __func__);
+    return (true);
+  }
+  else
+  {
+    //GAUGE_info("[%s] isn't charging\n", __func__);
+    return (false);
+  }
+}
+
+#ifdef UG31XX_MISC_DEV
+
+static int ug31xx_misc_open(struct inode *inode, struct file *file)
+{
+  UG31_LOGN("[%s]\n", __func__);
+  return 0;
+}
+
+static int ug31xx_misc_release(struct inode *inode, struct file *file)
+{
+  UG31_LOGN("[%s]\n", __func__);
+  return 0;
+}
+
+static long ug31xx_misc_ioctl(struct file *file, unsigned int cmd, unsigned long arg)
+{
+  int rc = 0;
+  unsigned char val[2];
+  unsigned char data = 0;
+  unsigned char *backup_buf;
+  int backup_size;
+  unsigned char backup_file[256];
+
+  /// [AT-PM] : Check UG31XX_IOC_MAGIC ; 06/09/2014
+  if(_IOC_TYPE(cmd) != UG31XX_IOC_MAGIC)
+  {
+    UG31_LOGE("[%s]: UG31XX_IOC_MAGIC mismatched.\n", __func__);
+    return (-ENOTTY);
+  }
+
+  switch (UG31XX_IOCTL_CMD(cmd))
+  {
+    case (UG31XX_IOCTL_CMD(UG31XX_IOCTL_RESET)):
+      UG31_LOGN("[%s] cmd -> RESET\n", __func__);
+      op_options = op_options | LKM_OPTIONS_FORCE_RESET;
+      cancel_delayed_work_sync(&ug31->batt_info_update_work);
+      schedule_delayed_work(&ug31->batt_info_update_work, 0*HZ);
+      break;
+
+    case (UG31XX_IOCTL_CMD(UG31XX_IOCTL_ENABLE_SUSPEND_LOG)):
+      UG31_LOGN("[%s] cmd -> ENABLE_SUSPEND_LOG\n", __func__);
+      op_options = op_options | LKM_OPTIONS_ENABLE_SUSPEND_DATA_LOG;
+      break;
+
+    case (UG31XX_IOCTL_CMD(UG31XX_IOCTL_ENABLE_LOG)):
+      UG31_LOGN("[%s] cmd -> ENABLE_LOG\n", __func__);
+      op_options = op_options | LKM_OPTIONS_ENABLE_DEBUG_LOG;
+      break;
+
+    case (UG31XX_IOCTL_CMD(UG31XX_IOCTL_DISABLE_LOG)):
+      UG31_LOGN("[%s] cmd -> DISABLE_LOG\n", __func__);
+      op_options = op_options & (~LKM_OPTIONS_ENABLE_DEBUG_LOG);
+      break;
+
+    case (UG31XX_IOCTL_CMD(UG31XX_IOCTL_I2C_READ)):
+      UG31_LOGN("[%s] cmd -> I2C_READ\n", __func__);
+      if(copy_from_user((void *)&val[0], (void __user *)arg, sizeof(unsigned char)))
+      {
+        rc = -EINVAL;
+        UG31_LOGE("[%s] copy_from_user fail\n", __func__);
+        break;
+      }
+      UG31_LOGN("[%s] read addr: 0x%x\n", __func__, val[0]);
+      if(ug31_module.ug31xx_i2c_read(val[0], &data))
+      {
+        rc = -EINVAL;
+        UG31_LOGE("[%s] I2C read fail\n", __func__);
+        break;
+      }
+      UG31_LOGN("[%s] read data: 0x%x\n", __func__, data);
+      if(copy_to_user((void __user *)arg, (void *)&data, sizeof(unsigned char)))
+      {
+        rc = -EINVAL;
+        UG31_LOGE("[%s] copy_to_user fail\n", __func__);
+        break;
+      }
+      break;
+
+    case (UG31XX_IOCTL_CMD(UG31XX_IOCTL_I2C_WRITE)):
+      UG31_LOGN("[%s] cmd -> I2C_WRITE\n", __func__);
+      if(copy_from_user((void *)&val[0], (void __user *)arg, sizeof(val)))
+      {
+        rc = -EINVAL;
+        UG31_LOGE("[%s] copy_from_user fail\n", __func__);
+        break;
+      }
+      UG31_LOGN("[%s] write addr: 0x%x, data: 0x%x\n", __func__, val[0], val[1]);
+      if(ug31_module.ug31xx_i2c_write(val[0], &val[1]))
+      {
+        rc = -EINVAL;
+        UG31_LOGE("[%s] I2C write fail\n", __func__);
+        break;
+      }
+      break;
+
+    case (UG31XX_IOCTL_CMD(UG31XX_IOCTL_RESET_CYCLE_COUNT)):
+      UG31_LOGN("[%s] cmd -> RESET_CYCLE_COUNT\n", __func__);
+      rc = ug31_module.reset_cycle_count();
+      break;
+
+    case (UG31XX_IOCTL_CMD(UG31XX_IOCTL_BACKUP_SIZE)):
+      UG31_LOGN("[%s] cmd -> UG31XX_IOCTL_BACKUP_SIZE\n", __func__);
+      backup_buf = ug31_module.get_backup_buffer(&backup_size);
+      data = (unsigned char)backup_size;
+      if(copy_to_user((void __user *)arg, (void *)&data, sizeof(unsigned char)))
+      {
+        rc = -EINVAL;
+        UG31_LOGE("[%s] copy_to_user fail\n", __func__);
+      }
+      break;
+
+    case (UG31XX_IOCTL_CMD(UG31XX_IOCTL_BACKUP_READ)):
+      UG31_LOGN("[%s] cmd -> UG31XX_IOCTL_BACKUP_READ\n", __func__);
+      backup_buf = ug31_module.get_backup_buffer(&backup_size);
+      if(copy_to_user((void __user *)arg, (void *)backup_buf, backup_size))
+      {
+        rc = -EINVAL;
+        UG31_LOGE("[%s] copy_to_user fail\n", __func__);
+      }
+      break;
+
+    case (UG31XX_IOCTL_CMD(UG31XX_IOCTL_BACKUP_WRITE)):
+      UG31_LOGN("[%s] cmd -> UG31XX_IOCTL_BACKUP_WRITE\n", __func__);
+      backup_buf = ug31_module.get_backup_buffer(&backup_size);
+      if(copy_from_user((void *)backup_buf, (void __user *)arg, backup_size))
+      {
+        rc = -EINVAL;
+        UG31_LOGE("[%s] copy_from_user fail\n", __func__);
+      }
+      break;
+
+    case (UG31XX_IOCTL_CMD(UG31XX_IOCTL_DAEMON_GET_CNTL)):
+      UG31_LOGN("[%s] cmd -> UG31XX_IOCTL_DAEMON_GET_CNTL\n", __func__);
+      mutex_lock(&ug31->info_update_lock);
+      data = ug31_module.get_backup_daemon_cntl();
+      mutex_unlock(&ug31->info_update_lock);
+      if(copy_to_user((void __user *)arg, (void *)&data, 1))
+      {
+        rc = -EINVAL;
+        UG31_LOGE("[%s] copy_to_user fail\n", __func__);
+      }
+      break;
+
+    case (UG31XX_IOCTL_CMD(UG31XX_IOCTL_DAEMON_SET_CNTL)):
+      UG31_LOGN("[%s] cmd -> UG31XX_IOCTL_DAEMON_SET_CNTL\n", __func__);
+      if(copy_from_user((void *)&data, (void __user *)arg, 1))
+      {
+        rc = -EINVAL;
+        UG31_LOGE("[%s] copy_from_user fail\n", __func__);
+      }
+      mutex_lock(&ug31->info_update_lock);
+      ug31_module.set_backup_daemon_cntl(data);
+      mutex_unlock(&ug31->info_update_lock);
+      break;
+
+    case (UG31XX_IOCTL_CMD(UG31XX_IOCTL_DAEMON_DELAY)):
+      UG31_LOGN("[%s] cmd -> UG31XX_IOCTL_DAEMON_DELAY\n", __func__);
+      mutex_lock(&ug31->info_update_lock);
+      data = ug31_module.get_backup_daemon_period();
+      mutex_unlock(&ug31->info_update_lock);
+      data = data - 1;
+      if(copy_to_user((void __user *)arg, (void *)&data, 1))
+      {
+        rc = -EINVAL;
+        UG31_LOGE("[%s] copy_to_user fail\n", __func__);
+      }
+      break;
+
+    case (UG31XX_IOCTL_CMD(UG31XX_IOCTL_DAEMON_FILENAME)):
+      UG31_LOGN("[%s] cmd -> UG31XX_IOCTL_DAEMON_FILENAME\n", __func__);
+      sprintf(backup_file, "%s", UPI_UG31XX_BACKUP_FILE);
+      if(copy_to_user((void __user *)arg, (void *)backup_file, 256))
+      {
+        rc = -EINVAL;
+        UG31_LOGE("[%s] copy_to_user fail\n", __func__);
+      }
+      break;
+
+    case (UG31XX_IOCTL_CMD(UG31XX_IOCTL_ALGORITHM_SIZE)):
+      UG31_LOGN("[%s] cmd -> UG31XX_IOCTL_ALGORITHM_SIZE (%d, %d)\n", __func__, sizeof(unsigned long), sizeof(unsigned long long));
+      backup_buf = ug31_module.shell_memory(&backup_size);
+      val[0] = backup_size/256;
+      val[1] = backup_size%256;
+      if(copy_to_user((void __user *)arg, (void *)&val[0], sizeof(val)))
+      {
+        rc = -EINVAL;
+        UG31_LOGE("[%s] copy_to_user fail\n", __func__);
+      }
+      break;
+
+    case (UG31XX_IOCTL_CMD(UG31XX_IOCTL_ALGORITHM_START)):
+      UG31_LOGN("[%s] cmd -> UG31XX_IOCTL_ALGORITHM_START\n", __func__);
+      backup_buf = ug31_module.shell_memory(&backup_size);
+      if(copy_to_user((void __user *)arg, (void *)backup_buf, backup_size))
+      {
+        rc = -EINVAL;
+        UG31_LOGE("[%s] copy_to_user fail\n", __func__);
+      }
+      break;
+
+    case (UG31XX_IOCTL_CMD(UG31XX_IOCTL_ALGORITHM_UPDATE)):
+      UG31_LOGI("[%s] cmd -> UG31XX_IOCTL_ALGORITHM_UPDATE\n", __func__);
+      backup_buf = ug31_module.shell_memory(&backup_size);
+      ug31_module.backup_pointer();
+      if(copy_from_user((void *)backup_buf, (void __user *)arg, backup_size))
+      {
+        rc = -EINVAL;
+        UG31_LOGE("[%s] copy_from_user fail\n", __func__);
+      }
+      ug31_module.restore_pointer();
+      schedule_delayed_work(&ug31->shell_algorithm_work, 0*HZ);
+      break;
+
+    case (UG31XX_IOCTL_CMD(UG31XX_IOCTL_ALGORITHM_OPTION)):
+      UG31_LOGN("[%s] cmd -> UG31XX_IOCTL_ALGORITHM_OPTION\n", __func__);
+      if(copy_to_user((void __user *)arg, (void *)&op_options, sizeof(op_options)))
+      {
+        rc = -EINVAL;
+        UG31_LOGE("[%s] copy_to_user fail\n", __func__);
+      }
+      break;
+
+    case (UG31XX_IOCTL_CMD(UG31XX_IOCTL_ALGORITHM_BACKUP)):
+      UG31_LOGI("[%s] cmd -> UG31XX_IOCTL_ALGORITHM_BACKUP\n", __func__);
+      backup_buf = ug31_module.shell_memory(&backup_size);
+      ug31_module.backup_pointer();
+      if(copy_from_user((void *)backup_buf, (void __user *)arg, backup_size))
+      {
+        rc = -EINVAL;
+        UG31_LOGE("[%s] copy_from_user fail\n", __func__);
+      }
+      ug31_module.restore_pointer();
+
+      if(Status == 1){
+	     if(ug31->batt_capacity == 100)
+      			schedule_delayed_work(&ug31->shell_backup_work, 3600*HZ);
+		  else
+			   schedule_delayed_work(&ug31->shell_backup_work, 0*HZ);
+	   } else
+		  schedule_delayed_work(&ug31->shell_backup_work, 0*HZ);
+
+      break;
+
+    case (UG31XX_IOCTL_CMD(UG31XX_IOCTL_ALGORITHM_BACKUP_BUFFER)):
+      UG31_LOGN("[%s] cmd -> UG31XX_IOCTL_ALGORITHM_BACKUP_BUFFER\n", __func__);
+      backup_buf = ug31_module.shell_backup_memory(&backup_size);
+      if(copy_to_user((void __user *)arg, (void *)backup_buf, backup_size))
+      {
+        rc = -EINVAL;
+        UG31_LOGE("[%s] copy_to_user fail\n", __func__);
+      }
+      break;
+
+    case (UG31XX_IOCTL_CMD(UG31XX_IOCTL_ALGORITHM_BACKUP_SIZE)):
+      UG31_LOGN("[%s] cmd -> UG31XX_IOCTL_ALGORITHM_BACKUP_SIZE\n", __func__);
+      backup_buf = ug31_module.shell_backup_memory(&backup_size);
+      val[0] = backup_size/256;
+      val[1] = backup_size%256;
+      if(copy_to_user((void __user *)arg, (void *)&val[0], sizeof(val)))
+      {
+        rc = -EINVAL;
+        UG31_LOGE("[%s] copy_to_user fail\n", __func__);
+      }
+      break;
+
+    case (UG31XX_IOCTL_CMD(UG31XX_IOCTL_ALGORITHM_TABLE_SIZE)):
+      UG31_LOGN("[%s] cmd -> UG31XX_IOCTL_ALGORITHM_TABLE_SIZE\n", __func__);
+      backup_buf = ug31_module.shell_table_memory(&backup_size);
+      val[0] = backup_size/256;
+      val[1] = backup_size%256;
+      if(copy_to_user((void __user *)arg, (void *)&val[0], sizeof(val)))
+      {
+        rc = -EINVAL;
+        UG31_LOGE("[%s] copy_to_user fail\n", __func__);
+      }
+      break;
+
+    case (UG31XX_IOCTL_CMD(UG31XX_IOCTL_ALGORITHM_TABLE_DATA)):
+      UG31_LOGN("[%s] cmd -> UG31XX_IOCTL_ALGORITHM_TABLE_DATA\n", __func__);
+      backup_buf = ug31_module.shell_table_memory(&backup_size);
+      if(copy_to_user((void __user *)arg, (void *)backup_buf, backup_size))
+      {
+        rc = -EINVAL;
+        UG31_LOGE("[%s] copy_to_user fail\n", __func__);
+      }
+      break;
+
+    case (UG31XX_IOCTL_CMD(UG31XX_IOCTL_ALGORITHM_TABLE_BUF)):
+      UG31_LOGN("[%s] cmd -> UG31XX_IOCTL_ALGORITHM_TABLE_BUF\n", __func__);
+      backup_buf = ug31_module.shell_table_buf_memory(&backup_size);
+      if(copy_to_user((void __user *)arg, (void *)backup_buf, backup_size))
+      {
+        rc = -EINVAL;
+        UG31_LOGE("[%s] copy_to_user fail\n", __func__);
+      }
+      break;
+
+    case (UG31XX_IOCTL_CMD(UG31XX_IOCTL_ALGORITHM_VERSION)):
+      UG31_LOGE("[%s] cmd -> UG31XX_IOCTL_ALGORITHM_VERSION\n", __func__);
+      if(copy_from_user((void *)ug31->daemon_ver, (void __user *)arg, UG31XX_USER_DAEMON_VER_LENGTH))
+      {
+        rc = -EINVAL;
+        UG31_LOGE("[%s] copy_from_user fail\n", __func__);
+      }
+      ug31->daemon_uevent_count = 0;
+#ifdef FEATRUE_K_BOARD_OFFSET
+      kbo_file_exist = false;
+      schedule_delayed_work(&ug31->kbo_check_work, msecs_to_jiffies(UG31XX_CALI_BO_FACTORY_DELAY));
+      schedule_delayed_work(&ug31->cos_check_work, msecs_to_jiffies(UG31XX_CALI_BO_FACTORY_DELAY + 1000)*HZ);
+#endif ///< for FEATRUE_K_BOARD_OFFSET
+      break;
+
+    case (UG31XX_IOCTL_CMD(UG31XX_IOCTL_ALGORITHM_LOCK)):
+      UG31_LOGI("[%s] cmd -> UG31XX_IOCTL_ALGORITHM_LOCK\n", __func__);
+      if(wake_lock_active(&ug31->shell_timeout_wake_lock) != 0)
+      {
+        wake_unlock(&ug31->shell_timeout_wake_lock);
+      }
+      wake_lock(&ug31->shell_timeout_wake_lock);
+      mutex_lock(&ug31->info_update_lock);
+      user_space_in_progress = true;
+      schedule_delayed_work(&ug31->shell_timeout_work, 1*HZ);
+      break;
+
+    case (UG31XX_IOCTL_CMD(UG31XX_IOCTL_ALGORITHM_UNLOCK)):
+      UG31_LOGI("[%s] cmd -> UG31XX_IOCTL_ALGORITHM_UNLOCK\n", __func__);
+      user_space_in_progress = false;
+      mutex_unlock(&ug31->info_update_lock);
+      if(wake_lock_active(&ug31->shell_timeout_wake_lock) != 0)
+      {
+        wake_unlock(&ug31->shell_timeout_wake_lock);
+      }
+      break;
+#ifdef FEATRUE_K_BOARD_OFFSET
+    case (UG31XX_IOCTL_CMD(UG31XX_IOCTL_ALGORITHM_READ_BO)):
+      UG31_LOGN("[%s] cmd -> UG31XX_IOCTL_ALGORITHM_READ_BO\n", __func__);
+      backup_size = kbo_result;
+      if(backup_size < 0)
+      {
+        backup_size = backup_size + 65536;
+      }
+      val[0] = backup_size/256;
+      val[1] = backup_size%256;
+      UG31_LOGE("[%s] board offset = %d (%02x%02x)\n", __func__,
+                kbo_result,
+                val[0],
+                val[1]);
+      if(copy_to_user((void __user *)arg, (void *)&val[0], sizeof(val)))
+      {
+        rc = -EINVAL;
+        UG31_LOGE("[%s] copy_to_user fail\n", __func__);
+      }
+      break;
+
+    case (UG31XX_IOCTL_CMD(UG31XX_IOCTL_ALGORITHM_WRITE_BO)):
+      UG31_LOGN("[%s] cmd -> UG31XX_IOCTL_ALGORITHM_WRITE_BO\n", __func__);
+      if(copy_from_user((void *)&val[0], (void __user *)arg, 2))
+      {
+        rc = -EINVAL;
+        UG31_LOGE("[%s] copy_from_user fail\n", __func__);
+      }
+      kbo_result = val[0];
+      kbo_result = kbo_result*256 + val[1];
+      if(val[0] & 0x80)
+      {
+        kbo_result = kbo_result - 65536;
+      }
+      UG31_LOGE("[%s] board offset = %d (%02x%02x)\n", __func__,
+                kbo_result,
+                val[0],
+                val[1]);
+      kbo_file_exist = true;
+      ug31_module.set_board_offset(kbo_result, UG31XX_BOARD_OFFSET_FROM_UPI_BO);
+      break;
+#endif ///< for FEATRUE_K_BOARD_OFFSET
+    case (UG31XX_IOCTL_CMD(UG31XX_IOCTL_ALGORITHM_GET_DATA)):
+      UG31_LOGN("[%s] cmd -> UG31XX_IOCTL_ALGORITHM_GET_DATA\n", __func__);
+      ioctl_data_trans_cnt = 0;
+      ioctl_data_trans_ptr = ug31_module.shell_memory(&ioctl_data_trans_size);
+      break;
+
+    case (UG31XX_IOCTL_CMD(UG31XX_IOCTL_ALGORITHM_GET_DATA_RUN)):
+      UG31_LOGN("[%s] cmd -> UG31XX_IOCTL_ALGORITHM_GET_DATA_RUN (%d)\n", __func__,
+                ioctl_data_trans_cnt);
+      memcpy(ioctl_data_trans_buf, ioctl_data_trans_ptr, UG31XX_IOCTL_TRANS_DATA_SIZE);
+      if(copy_to_user((void __user *)arg, (void *)ioctl_data_trans_buf, UG31XX_IOCTL_TRANS_DATA_SIZE))
+      {
+        rc = -EINVAL;
+        UG31_LOGE("[%s] copy_to_user fail\n", __func__);
+      }
+      ioctl_data_trans_cnt = ioctl_data_trans_cnt + 1;
+      ioctl_data_trans_ptr = ioctl_data_trans_ptr + UG31XX_IOCTL_TRANS_DATA_SIZE;
+      break;
+
+    case (UG31XX_IOCTL_CMD(UG31XX_IOCTL_ALGORITHM_SET_DATA)):
+      UG31_LOGN("[%s] cmd -> UG31XX_IOCTL_ALGORITHM_SET_DATA\n", __func__);
+      ioctl_data_trans_cnt = 0;
+      ioctl_data_trans_ptr = ug31_module.shell_memory(&ioctl_data_trans_size);
+      ug31_module.backup_pointer();
+      break;
+
+    case (UG31XX_IOCTL_CMD(UG31XX_IOCTL_ALGORITHM_SET_DATA_RUN)):
+      UG31_LOGI("[%s] cmd -> UG31XX_IOCTL_ALGORITHM_SET_DATA_RUN (%d)\n", __func__,
+                ioctl_data_trans_cnt);
+      if(copy_from_user((void *)ioctl_data_trans_buf, (void __user *)arg, UG31XX_IOCTL_TRANS_DATA_SIZE))
+      {
+        rc = -EINVAL;
+        UG31_LOGE("[%s] copy_from_user fail\n", __func__);
+      }
+      memcpy(ioctl_data_trans_ptr, ioctl_data_trans_buf, UG31XX_IOCTL_TRANS_DATA_SIZE);
+      ioctl_data_trans_cnt = ioctl_data_trans_cnt + 1;
+      ioctl_data_trans_ptr = ioctl_data_trans_ptr + UG31XX_IOCTL_TRANS_DATA_SIZE;
+      break;
+
+    case (UG31XX_IOCTL_CMD(UG31XX_IOCTL_ALGORITHM_SET_DATA_END)):
+      UG31_LOGI("[%s] cmd -> UG31XX_IOCTL_ALGORITHM_SET_DATA_END\n", __func__);
+      ug31_module.restore_pointer();
+      schedule_delayed_work(&ug31->shell_algorithm_work, 0*HZ);
+      break;
+
+#ifdef FEATRUE_K_BOARD_OFFSET
+    case UG31XX_IOCTL_ALGORITHM_READ_COS:
+      UG31_LOGN("[%s] cmd -> UG31XX_IOCTL_ALGORITHM_READ_COS\n", __func__);
+      backup_size = cos_result;
+      if(backup_size < 0)
+      {
+        backup_size = backup_size + 65536;
+      }
+      val[0] = backup_size/256;
+      val[1] = backup_size%256;
+      UG31_LOGE("[%s] board offset = %d (%02x%02x)\n", __func__,
+                cos_result,
+                val[0],
+                val[1]);
+      if(copy_to_user((void __user *)arg, (void *)&val[0], sizeof(val)))
+      {
+        rc = -EINVAL;
+        UG31_LOGE("[%s] copy_to_user fail\n", __func__);
+      }
+      cos_file_written = 0;
+      break;
+
+    case UG31XX_IOCTL_ALGORITHM_WRITE_COS:
+      UG31_LOGN("[%s] cmd -> UG31XX_IOCTL_ALGORITHM_WRITE_COS\n", __func__);
+      if(copy_from_user((void *)&val[0], (void __user *)arg, 2))
+      {
+        rc = -EINVAL;
+        UG31_LOGE("[%s] copy_from_user fail\n", __func__);
+      }
+      cos_result = val[0];
+      cos_result = cos_result*256 + val[1];
+      if(val[0] & 0x80)
+      {
+        cos_result = cos_result - 65536;
+      }
+      UG31_LOGE("[%s] board offset = %d (%02x%02x)\n", __func__,
+                cos_result,
+                val[0],
+                val[1]);
+      cos_file_exist = true;
+      ug31_module.set_board_offset(cos_result, UG31XX_BOARD_OFFSET_FROM_UPI_COS);
+      break;
+
+    case UG31XX_IOCTL_ALGORITHM_MODE_COS:
+      UG31_LOGI("[%s] cmd -> UG31XX_IOCTL_ALGORITHM_MODE_COS\n", __func__);
+      cos_mode = true;
+      break;
+#endif ///< for FEATRUE_K_BOARD_OFFSET
+
+    case (UG31XX_IOCTL_CMD(UG31XX_IOCTL_CC_CHG_OFFSET_25_READ)):
+      val[0] = (unsigned char)cc_chg_offset_25;
+      if(copy_to_user((void __user *)arg, (void *)&val[0], 1))
+      {
+        rc = -EINVAL;
+        UG31_LOGE("[%s] copy_to_user fail\n", __func__);
+      }
+      break;
+
+    case (UG31XX_IOCTL_CMD(UG31XX_IOCTL_CC_CHG_OFFSET_25_WRITE)):
+      if(copy_from_user((void *)&val[0], (void __user *)arg, 1))
+      {
+        rc = -EINVAL;
+        UG31_LOGE("[%s] copy_from_user fail\n", __func__);
+      }
+      cc_chg_offset_25 = (unsigned int)val[0];
+      mutex_lock(&ug31->info_update_lock);
+      ug31_module.set_cc_chg_offset(cc_chg_offset_25, cc_chg_offset_50, cc_chg_offset_75, cc_chg_offset_100);
+      mutex_unlock(&ug31->info_update_lock);
+      break;
+
+    case (UG31XX_IOCTL_CMD(UG31XX_IOCTL_CC_CHG_OFFSET_50_READ)):
+      val[0] = (unsigned char)cc_chg_offset_50;
+      if(copy_to_user((void __user *)arg, (void *)&val[0], 1))
+      {
+        rc = -EINVAL;
+        UG31_LOGE("[%s] copy_to_user fail\n", __func__);
+      }
+      break;
+
+    case (UG31XX_IOCTL_CMD(UG31XX_IOCTL_CC_CHG_OFFSET_50_WRITE)):
+      if(copy_from_user((void *)&val[0], (void __user *)arg, 1))
+      {
+        rc = -EINVAL;
+        UG31_LOGE("[%s] copy_from_user fail\n", __func__);
+      }
+      cc_chg_offset_50 = (unsigned int)val[0];
+      mutex_lock(&ug31->info_update_lock);
+      ug31_module.set_cc_chg_offset(cc_chg_offset_25, cc_chg_offset_50, cc_chg_offset_75, cc_chg_offset_100);
+      mutex_unlock(&ug31->info_update_lock);
+      break;
+
+    case (UG31XX_IOCTL_CMD(UG31XX_IOCTL_CC_CHG_OFFSET_75_READ)):
+      val[0] = (unsigned char)cc_chg_offset_75;
+      if(copy_to_user((void __user *)arg, (void *)&val[0], 1))
+      {
+        rc = -EINVAL;
+        UG31_LOGE("[%s] copy_to_user fail\n", __func__);
+      }
+      break;
+
+    case (UG31XX_IOCTL_CMD(UG31XX_IOCTL_CC_CHG_OFFSET_75_WRITE)):
+      if(copy_from_user((void *)&val[0], (void __user *)arg, 1))
+      {
+        rc = -EINVAL;
+        UG31_LOGE("[%s] copy_from_user fail\n", __func__);
+      }
+      cc_chg_offset_75 = (unsigned int)val[0];
+      mutex_lock(&ug31->info_update_lock);
+      ug31_module.set_cc_chg_offset(cc_chg_offset_25, cc_chg_offset_50, cc_chg_offset_75, cc_chg_offset_100);
+      mutex_unlock(&ug31->info_update_lock);
+      break;
+
+    case (UG31XX_IOCTL_CMD(UG31XX_IOCTL_CC_CHG_OFFSET_100_READ)):
+      val[0] = (unsigned char)cc_chg_offset_100;
+      if(copy_to_user((void __user *)arg, (void *)&val[0], 1))
+      {
+        rc = -EINVAL;
+        UG31_LOGE("[%s] copy_to_user fail\n", __func__);
+      }
+      break;
+
+    case (UG31XX_IOCTL_CMD(UG31XX_IOCTL_CC_CHG_OFFSET_100_WRITE)):
+      if(copy_from_user((void *)&val[0], (void __user *)arg, 1))
+      {
+        rc = -EINVAL;
+        UG31_LOGE("[%s] copy_from_user fail\n", __func__);
+      }
+      cc_chg_offset_100 = (unsigned int)val[0];
+      mutex_lock(&ug31->info_update_lock);
+      ug31_module.set_cc_chg_offset(cc_chg_offset_25, cc_chg_offset_50, cc_chg_offset_75, cc_chg_offset_100);
+      mutex_unlock(&ug31->info_update_lock);
+      break;
+
+    case (UG31XX_IOCTL_CMD(UG31XX_IOCTL_CALI_RSOC_TIME_READ)):
+      val[0] = (unsigned char)(cali_rsoc_time % 256);
+      val[1] = (unsigned char)(cali_rsoc_time / 256);
+      if(copy_to_user((void __user *)arg, (void *)&val[0], 2))
+      {
+        rc = -EINVAL;
+        UG31_LOGE("[%s] copy_to_user fail\n", __func__);
+      }
+      break;
+
+    case (UG31XX_IOCTL_CMD(UG31XX_IOCTL_CALI_RSOC_TIME_WRITE)):
+      if(copy_from_user((void *)&val[0], (void __user *)arg, 2))
+      {
+        rc = -EINVAL;
+        UG31_LOGE("[%s] copy_from_user fail\n", __func__);
+      }
+      cali_rsoc_time = (int)val[1];
+      cali_rsoc_time = cali_rsoc_time * 256 + val[0];
+      break;
+
+	case (UG31XX_IOCTL_CMD(UG31XX_IOCTL_RESET_TOTALLY)):
+		UG31_LOGN("[%s] cmd -> UG31XX_IOCTL_RESET_TOTALLY\n", __func__);
+		op_options = op_options | LKM_OPTIONS_FORCE_RESET_TOTALLY;
+		cancel_delayed_work_sync(&ug31->batt_info_update_work);
+		schedule_delayed_work(&ug31->batt_info_update_work, 0*HZ);
+		break;
+
+  case (UG31XX_IOCTL_CMD(UG31XX_IOCTL_DAEMON_EVENT)):
+    val[0] = (unsigned char)(daemon_uevent_request % 256);
+    val[1] = (unsigned char)(daemon_uevent_request / 256);
+    if(copy_to_user((void __user *)arg, (void *)&val[0], 2))
+    {
+      rc = -EINVAL;
+      UG31_LOGE("[%s] copy_to_user fail\n", __func__);
+    }
+    daemon_uevent_request = 0;
+    break;
+
+    default:
+      UG31_LOGE("[%s] invalid cmd %d\n", __func__, _IOC_NR(cmd));
+      rc = -EINVAL;
+      break;
+  }
+
+  return (rc);
+}
+
+static struct file_operations ug31xx_fops = {
+  .owner = THIS_MODULE,
+  .open = ug31xx_misc_open,
+  .release = ug31xx_misc_release,
+  .unlocked_ioctl = ug31xx_misc_ioctl,
+  .compat_ioctl = ug31xx_misc_ioctl
+};
+
+struct miscdevice ug31xx_misc = {
+  .minor = MISC_DYNAMIC_MINOR,
+  .name = "ug31xx",
+  .fops = &ug31xx_fops
+};
+
+#endif	///< end of UG31XX_MISC_DEV
+
+#ifdef  UG31XX_KOBJECT
+
+struct ug31xx_kobj {
+  struct kobject kobj;
+  int driver_version;
+  int local_version;
+};
+
+#define to_ug31xx_kobj(x) container_of(x, struct ug31xx_kobj, kobj)
+
+struct ug31xx_attribute {
+  struct attribute attr;
+  ssize_t (*show)(struct ug31xx_kobj *obj, struct ug31xx_attribute *attr, char *buf);
+};
+
+#define to_ug31xx_attr(x) container_of(x, struct ug31xx_attribute, attr)
+
+static ssize_t ug31xx_attr_show(struct kobject *kobj, struct attribute *attr, char *buf)
+{
+  struct ug31xx_attribute *attribute;
+  struct ug31xx_kobj *obj;
+
+  attribute = to_ug31xx_attr(attr);
+  obj = to_ug31xx_kobj(kobj);
+
+  if(!attribute->show)
+  {
+    return (-EIO);
+  }
+
+  return (attribute->show(obj, attribute, buf));
+}
+
+static struct sysfs_ops ug31xx_sysfs_ops = {
+  .show   = ug31xx_attr_show,
+};
+
+static void ug31xx_release(struct kobject *kobj)
+{
+  kfree(to_ug31xx_kobj(kobj));
+}
+
+static struct attribute *ug31xx_default_attrs[] = {
+  NULL,
+};
+
+static struct kobj_type ug31xx_ktype = {
+  .sysfs_ops      = &ug31xx_sysfs_ops,
+  .release        = ug31xx_release,
+  .default_attrs  = ug31xx_default_attrs,
+};
+
+enum UG31XX_KOBJ_ENV {
+  UG31XX_KOBJ_ENV_UPDATE_CAPACITY = 0,
+  UG31XX_KOBJ_ENV_BACKUP_DATA,
+#ifdef FEATRUE_K_BOARD_OFFSET
+  UG31XX_KOBJ_ENV_BACKUP_BO_CHECK,
+  UG31XX_KOBJ_ENV_BACKUP_BO_WRITE,
+  UG31XX_KOBJ_ENV_BACKUP_BO_INIT,
+  UG31XX_KOBJ_ENV_BACKUP_COS_CHECK,
+  UG31XX_KOBJ_ENV_BACKUP_COS_WRITE,
+  UG31XX_KOBJ_ENV_BACKUP_COS_INIT,
+#endif ///< for FEATRUE_K_BOARD_OFFSET
+  UG31XX_KOBJ_ENV_COUNT,
+};
+
+static struct kset *ug31xx_set;
+static struct ug31xx_kobj *ug31_kobj;
+static int kobj_event_env = UG31XX_KOBJ_ENV_COUNT;
+
+static void change_ug31xx_kobj(void)
+{
+  char *cmd1a[] = {"OP_NAME=update_capacity", "OP_ACTION=normal", NULL};
+  char *cmd1b[] = {"OP_NAME=update_capacity", "OP_ACTION=early_suspend", NULL};
+  char *cmd1c[] = {"OP_NAME=update_capacity", "OP_ACTION=suspend", NULL};
+  char *cmd1d[] = {"OP_NAME=update_capacity", "OP_ACTION=resume", NULL};
+  char *cmd1e[] = {"OP_NAME=update_capacity", "OP_ACTION=late_resume", NULL};
+  char *cmd2[] = {"OP_NAME=backup_data", NULL};
+  char *cmd3[] = {"OP_NAME=backup_data", "OP_ACTION=write", NULL};
+  char *cmd4[] = {"OP_NAME=backup_bo", "OP_ACTION=check", NULL};
+  char *cmd5[] = {"OP_NAME=backup_bo", "OP_ACTION=write", NULL};
+  char *cmd6[] = {"OP_NAME=backup_bo", "OP_ACTION=init", NULL};
+#ifdef FEATRUE_K_BOARD_OFFSET
+  char *cmd7[] = {"OP_NAME=backup_bo", "OP_ACTION=check_cos", NULL};
+  char *cmd8[] = {"OP_NAME=backup_bo", "OP_ACTION=write_cos", NULL};
+  char *cmd9[] = {"OP_NAME=backup_bo", "OP_ACTION=init_cos", NULL};
+#endif ///< for FEATRUE_K_BOARD_OFFSET
+  if(ug31xx_drv_status == UG31XX_DRV_NOT_READY)
+  {
+    return;
+  }
+
+  GAUGE_notice("[%s]: Send change uevent (%d).\n", __func__, kobj_event_env);
+
+  switch(kobj_event_env)
+  {
+    case UG31XX_KOBJ_ENV_UPDATE_CAPACITY:
+      user_space_algorithm_prev_fc_sts = ug31_module.get_full_charge_status();
+
+      if(op_actions == UG31XX_OP_NORMAL)
+      {
+        #ifdef  UG31XX_USER_SPACE_ALGORITHM
+
+        if(wake_lock_active(&ug31->shell_algorithm_wake_lock) != 0)
+        {
+          wake_unlock(&ug31->shell_algorithm_wake_lock);
+        }
+        wake_lock_timeout(&ug31->shell_algorithm_wake_lock, UG31XX_WAKE_LOCK_TIMEOUT*HZ);
+
+        #endif  ///< end of UG31XX_USER_SPACE_ALGORITHM
+
+        kobject_uevent_env(&ug31_kobj->kobj, KOBJ_CHANGE, cmd1a);
+        daemon_uevent_request = daemon_uevent_request | UG31XX_KOBJ_CMD1A;
+      }
+      else
+      {
+        if(op_actions == UG31XX_OP_EARLY_SUSPEND)
+        {
+          kobject_uevent_env(&ug31_kobj->kobj, KOBJ_CHANGE, cmd1b);
+          daemon_uevent_request = daemon_uevent_request | UG31XX_KOBJ_CMD1B;
+        }
+        else if(op_actions == UG31XX_OP_SUSPEND)
+        {
+          kobject_uevent_env(&ug31_kobj->kobj, KOBJ_CHANGE, cmd1c);
+          daemon_uevent_request = daemon_uevent_request | UG31XX_KOBJ_CMD1C;
+        }
+        else if(op_actions == UG31XX_OP_RESUME)
+        {
+          kobject_uevent_env(&ug31_kobj->kobj, KOBJ_CHANGE, cmd1d);
+          daemon_uevent_request = daemon_uevent_request | UG31XX_KOBJ_CMD1D;
+        }
+        else if(op_actions == UG31XX_OP_LATE_RESUME)
+        {
+          kobject_uevent_env(&ug31_kobj->kobj, KOBJ_CHANGE, cmd1e);
+          daemon_uevent_request = daemon_uevent_request | UG31XX_KOBJ_CMD1E;
+        }
+        else
+        {
+          GAUGE_err("[%s]: Un-known uevent (%d - %d).\n", __func__, kobj_event_env, op_actions);
+        }
+      }
+      break;
+    case UG31XX_KOBJ_ENV_BACKUP_DATA:
+      if(force_update_backup_file == true)
+      {
+        force_update_backup_file = false;
+        kobject_uevent_env(&ug31_kobj->kobj, KOBJ_CHANGE, cmd3);
+        daemon_uevent_request = daemon_uevent_request | UG31XX_KOBJ_CMD3;
+      }
+      else
+      {
+        kobject_uevent_env(&ug31_kobj->kobj, KOBJ_CHANGE, cmd2);
+        daemon_uevent_request = daemon_uevent_request | UG31XX_KOBJ_CMD2;
+      }
+      break;
+    case UG31XX_KOBJ_ENV_BACKUP_BO_CHECK:
+      kobject_uevent_env(&ug31_kobj->kobj, KOBJ_CHANGE, cmd4);
+      daemon_uevent_request = daemon_uevent_request | UG31XX_KOBJ_CMD4;
+      break;
+    case UG31XX_KOBJ_ENV_BACKUP_BO_WRITE:
+      kobject_uevent_env(&ug31_kobj->kobj, KOBJ_CHANGE, cmd5);
+      daemon_uevent_request = daemon_uevent_request | UG31XX_KOBJ_CMD5;
+      break;
+    case UG31XX_KOBJ_ENV_BACKUP_BO_INIT:
+      kobject_uevent_env(&ug31_kobj->kobj, KOBJ_CHANGE, cmd6);
+      daemon_uevent_request = daemon_uevent_request | UG31XX_KOBJ_CMD6;
+      break;
+#ifdef FEATRUE_K_BOARD_OFFSET
+    case UG31XX_KOBJ_ENV_BACKUP_COS_CHECK:
+      kobject_uevent_env(&ug31_kobj->kobj, KOBJ_CHANGE, cmd7);
+      daemon_uevent_request = daemon_uevent_request | UG31XX_KOBJ_CMD7;
+      break;
+    case UG31XX_KOBJ_ENV_BACKUP_COS_WRITE:
+      kobject_uevent_env(&ug31_kobj->kobj, KOBJ_CHANGE, cmd8);
+      daemon_uevent_request = daemon_uevent_request | UG31XX_KOBJ_CMD8;
+      break;
+    case UG31XX_KOBJ_ENV_BACKUP_COS_INIT:
+      kobject_uevent_env(&ug31_kobj->kobj, KOBJ_CHANGE, cmd9);
+      daemon_uevent_request = daemon_uevent_request | UG31XX_KOBJ_CMD9;
+      break;
+#endif ///< for FEATRUE_K_BOARD_OFFSET
+    default:
+      break;
+  }
+
+  kobj_event_env = UG31XX_KOBJ_ENV_COUNT;
+  ug31->daemon_uevent_count = ug31->daemon_uevent_count + 1;
+}
+
+static void create_ug31xx_kobj(void)
+{
+  int rtn;
+
+  ug31xx_set = kset_create_and_add("upi", NULL, kernel_kobj);
+
+  ug31_kobj = kzalloc(sizeof(struct ug31xx_kobj), GFP_KERNEL);
+  if(!ug31_kobj)
+  {
+    GAUGE_err("[%s]: create ug31_kobj fail.\n", __func__);
+    return;
+  }
+
+  ug31_kobj->kobj.kset = ug31xx_set;
+  ug31_kobj->driver_version = 21;
+  ug31_kobj->local_version = 0;
+
+  rtn = kobject_init_and_add(&ug31_kobj->kobj, &ug31xx_ktype, NULL, "ug31xx");
+  if(rtn)
+  {
+    kobject_put(&ug31_kobj->kobj);
+    GAUGE_err("[%s]: kobject_init_and_add fail\n", __func__);
+    return;
+  }
+
+  kobject_uevent(&ug31_kobj->kobj, KOBJ_ADD);
+}
+
+static void destroy_ug31xx_kobj(void)
+{
+  kobject_put(&ug31_kobj->kobj);
+}
+
+#endif  ///< end of UG31XX_KOBJECT
+
+#ifdef	UG31XX_REGISTER_POWERSUPPLY
+
+static enum power_supply_property ug31xx_batt_props[] = {
+	POWER_SUPPLY_PROP_STATUS,
+	POWER_SUPPLY_PROP_HEALTH,
+	POWER_SUPPLY_PROP_PRESENT,
+	POWER_SUPPLY_PROP_VOLTAGE_NOW,
+	POWER_SUPPLY_PROP_VOLTAGE_AVG,
+	POWER_SUPPLY_PROP_CURRENT_NOW,
+	POWER_SUPPLY_PROP_CURRENT_AVG,
+	POWER_SUPPLY_PROP_CAPACITY,
+	POWER_SUPPLY_PROP_TEMP,
+	POWER_SUPPLY_PROP_TEMP_AMBIENT,
+	POWER_SUPPLY_PROP_CHARGE_NOW,
+	POWER_SUPPLY_PROP_CHARGE_FULL,
+	POWER_SUPPLY_PROP_CHARGE_COUNTER,
+	POWER_SUPPLY_PROP_SERIAL_NUMBER,
+};
+
+#endif	///< end of UG31XX_REGISTER_POWERSUPPLY
+
+#ifdef	UPI_CALLBACK_FUNC
+static enum power_supply_property ug31xx_pwr_props[] = {
+	POWER_SUPPLY_PROP_ONLINE,
+};
+#endif	///< end of UPI_CALLBACK_FUNC
+
+#ifdef	UPI_CALLBACK_FUNC
+static char *supply_list[] = {
+	"battery",
+	"ac",
+	"usb",
+};
+#endif	///< end of UPI_CALLBACK_FUNC
+
+#ifdef	UG31XX_REGISTER_POWERSUPPLY
+
+static struct power_supply ug31xx_supply[] = {
+	{
+		.name			= "battery",
+		.type			= POWER_SUPPLY_TYPE_BATTERY,
+		.properties		= ug31xx_batt_props,
+		.num_properties 	= ARRAY_SIZE(ug31xx_batt_props),
+		.get_property		= ug31xx_battery_get_property,
+
+#ifndef	UPI_CALLBACK_FUNC
+		.external_power_changed	= ug31xx_battery_external_power_changed,
+#endif	///< end of UPI_CALLBACK_FUNC
+
+	},
+#ifdef	UPI_CALLBACK_FUNC
+	{
+		.name			= "ac",
+		.type			= POWER_SUPPLY_TYPE_MAINS,
+		.supplied_to		= supply_list,
+		.num_supplicants	= ARRAY_SIZE(supply_list),
+		.properties 		= ug31xx_pwr_props,
+		.num_properties		= ARRAY_SIZE(ug31xx_pwr_props),
+		.get_property		= ug31xx_power_get_property,
+	},
+	{
+		.name			= "usb",
+		.type			= POWER_SUPPLY_TYPE_USB,
+		.supplied_to		= supply_list,
+		.num_supplicants	= ARRAY_SIZE(supply_list),
+		.properties 		= ug31xx_pwr_props,
+		.num_properties 	= ARRAY_SIZE(ug31xx_pwr_props),
+		.get_property 		= ug31xx_power_get_property,
+	},
+#endif	///< end of UPI_CALLBACK_FUNC
+};
+
+static int ug31xx_battery_get_property(struct power_supply *psy,
+				       enum power_supply_property psp,
+				       union power_supply_propval *val)
+{
+	int ret = 0;
+
+	switch (psp) {
+	case POWER_SUPPLY_PROP_HEALTH:
+		val->intval = POWER_SUPPLY_HEALTH_GOOD;
+		break;
+	case POWER_SUPPLY_PROP_PRESENT:
+		val->intval = 1;
+		break;
+	case POWER_SUPPLY_PROP_STATUS:
+	case POWER_SUPPLY_PROP_VOLTAGE_NOW:
+	case POWER_SUPPLY_PROP_VOLTAGE_AVG:
+	case POWER_SUPPLY_PROP_CURRENT_NOW:
+	case POWER_SUPPLY_PROP_CURRENT_AVG:
+	case POWER_SUPPLY_PROP_CAPACITY:
+	case POWER_SUPPLY_PROP_TEMP:
+	case POWER_SUPPLY_PROP_TEMP_AMBIENT:
+	case POWER_SUPPLY_PROP_CHARGE_NOW:
+	case POWER_SUPPLY_PROP_CHARGE_FULL:
+	case POWER_SUPPLY_PROP_CHARGE_COUNTER:
+	case POWER_SUPPLY_PROP_SERIAL_NUMBER:
+		if (ug31xx_update_psp(psp, val))
+			return -EINVAL;
+		break;
+	default:
+		return -EINVAL;
+	}
+	return ret;
+}
+
+#endif	///< end of UG31XX_REGISTER_POWERSUPPLY
+
+#ifdef	UPI_CALLBACK_FUNC
+
+static int ug31xx_power_get_property(struct power_supply *psy,
+				     enum power_supply_property psp,
+				     union power_supply_propval *val)
+{
+	int ret = 0;
+
+	switch (psp)
+	{
+	case POWER_SUPPLY_PROP_ONLINE:
+		if((psy->type == POWER_SUPPLY_TYPE_MAINS) && (cur_cable_status == UG31XX_AC_ADAPTER_CABLE))
+		{
+			val->intval = 1;
+		}
+		else if((psy->type == POWER_SUPPLY_TYPE_USB) && (cur_cable_status == UG31XX_USB_PC_CABLE))
+		{
+			val->intval = 1;
+		}
+		else
+		{
+			val->intval = 0;
+		}
+		break;
+	default:
+		return -EINVAL;
+	}
+	return ret;
+}
+
+#endif	///< end of UPI_CALLBACK_FUNC
+
+static void check_backup_file_routine(void)
+{
+	if(ug31xx_drv_status != UG31XX_DRV_INIT_OK)
+	{
+		return;
+	}
+
+	/// [AT-PM] : Enable check backup file ; 05/14/2013
+	if(op_options & LKM_OPTIONS_DISABLE_BACHUP_FILE)
+	{
+		ug31_module.set_backup_file(false);
+	}
+	else
+	{
+		ug31_module.set_backup_file(true);
+
+    #ifdef  UG31XX_USER_SPACE_BACKUP
+
+		kobj_event_env = UG31XX_KOBJ_ENV_BACKUP_DATA;
+		change_ug31xx_kobj();
+
+    #else   ///< else of UG31XX_USER_SPACE_BACKUP
+
+		ug31xx_backup_file_status = ug31_module.chk_backup_file();
+		if((ug31xx_backup_file_status > 0) && (!(op_options & LKM_OPTIONS_FORCE_RESET)))
+		{
+			GAUGE_err("[%s] Gauge driver version mismatched.\n", __func__);
+			op_options = op_options | LKM_OPTIONS_FORCE_RESET;
+			#ifdef  UG31XX_USE_DAEMON_AP_FOR_FILE_OP
+				set_file_op_status_bit(UG31XX_KERNEL_FILE_VERSION);
+			#endif  ///< end of UG31XX_USE_DAEMON_AP_FOR_FILE_OP
+		}
+		else
+		{
+			#ifdef  UG31XX_USE_DAEMON_AP_FOR_FILE_OP
+				clear_file_op_status_bit(UG31XX_KERNEL_FILE_VERSION);
+			#endif  ///< end of UG31XX_USE_DAEMON_AP_FOR_FILE_OP
+		}
+
+    #endif  ///< end of UG31XX_USER_SPACE_BACKUP
+	}
+}
+
+#ifdef	UG31XX_REGISTER_POWERSUPPLY
+
+static int ug31xx_update_psp(enum power_supply_property psp,
+			     union power_supply_propval *val)
+{
+	if (ug31xx_drv_status == UG31XX_DRV_NOT_READY) {
+		GAUGE_err("[%s] Gauge driver not init finish\n", __func__);
+		return -EINVAL;
+	}
+
+	if(psp == POWER_SUPPLY_PROP_TEMP)
+	{
+		val->intval = ug31->batt_temp;
+	}
+	if(psp == POWER_SUPPLY_PROP_TEMP_AMBIENT)
+	{
+		val->intval = ug31->batt_avg_temp;
+	}
+	if(psp == POWER_SUPPLY_PROP_CAPACITY)
+	{
+		if (ug31->batt_status == POWER_SUPPLY_STATUS_FULL)
+		{
+			ug31->batt_capacity = 100;
+		}
+		val->intval = ug31->batt_capacity;
+		val->intval = ug31->batt_capacity_shifted;
+		if (ug31->batt_ntc_sts != UPI_UG31XX_NTC_NORMAL)
+			val->intval = -99;
+	}
+	if(psp == POWER_SUPPLY_PROP_VOLTAGE_NOW)
+	{
+		if(Status == 1){
+			if(ug31->batt_capacity == 100)
+				val->intval = ug31->batt_volt * 1000;
+			else{
+					mutex_lock(&ug31->info_update_lock);
+					val->intval = ug31_module.get_voltage_now();
+					mutex_unlock(&ug31->info_update_lock);
+					val->intval = val->intval * 1000;
+			}
+		}else{
+			mutex_lock(&ug31->info_update_lock);
+			val->intval = ug31_module.get_voltage_now();
+			mutex_unlock(&ug31->info_update_lock);
+			val->intval = val->intval * 1000;
+		}
+	}
+	if(psp == POWER_SUPPLY_PROP_VOLTAGE_AVG)
+	{
+		val->intval = ug31->batt_volt * 1000;
+	}
+	if(psp == POWER_SUPPLY_PROP_CURRENT_NOW)
+	{
+		if(Status == 1){
+			if (ug31->batt_capacity == 100){
+				val->intval = ug31->batt_current * 1000;
+				if((is_charging() == false) && (val->intval > 0))
+				{
+					val->intval = 0;
+				}
+			} else {
+					mutex_lock(&ug31->info_update_lock);
+					val->intval = ug31_module.get_current_now();
+					mutex_unlock(&ug31->info_update_lock);
+
+					if((is_charging() == false) && (val->intval > 0))
+					{
+						val->intval = 0;
+					}
+					val->intval = val->intval * 1000;
+			}
+		} else {
+			mutex_lock(&ug31->info_update_lock);
+			val->intval = ug31_module.get_current_now();
+			mutex_unlock(&ug31->info_update_lock);
+
+			if((is_charging() == false) && (val->intval > 0))
+			{
+				val->intval = 0;
+			}
+			val->intval = val->intval * 1000;
+		}
+	}
+	if(psp == POWER_SUPPLY_PROP_CURRENT_AVG)
+	{
+		val->intval = ug31->batt_current * 1000;
+	}
+	if(psp == POWER_SUPPLY_PROP_STATUS)
+	{
+		if(is_charging())
+		{
+//Webber [TT-559041] ++++++
+               if(ug31->batt_capacity == 100) {
+					ug31->batt_status = POWER_SUPPLY_STATUS_FULL;
+			   } else {
+					ug31->batt_status = POWER_SUPPLY_STATUS_CHARGING;
+			   }
+//Webber [TT-559041] ------
+		}
+		else
+		{
+			ug31->batt_status = POWER_SUPPLY_STATUS_DISCHARGING;
+		}
+		val->intval = ug31->batt_status;
+		if (ug31->batt_ntc_sts != UPI_UG31XX_NTC_NORMAL)
+			val->intval = POWER_SUPPLY_STATUS_UNKNOWN;
+	}
+
+	if(psp == POWER_SUPPLY_PROP_CHARGE_NOW)
+	{
+		val->intval = ug31->batt_charge_now;
+	}
+	if (psp == POWER_SUPPLY_PROP_CHARGE_FULL)
+	{
+		val->intval =ug31->batt_charge_full;
+	}
+	if(psp == POWER_SUPPLY_PROP_CHARGE_COUNTER)
+	{
+		val->intval = ug31->batt_charge_counter;
+	}
+	if(psp == POWER_SUPPLY_PROP_SERIAL_NUMBER)
+	{
+		if(kbo_file_exist == true)
+		{
+			sprintf(ug31->effective_board_offset, "F%d", ug31->board_offset);
+		}
+		else if(cos_file_exist == true)
+		{
+			sprintf(ug31->effective_board_offset, "B%d", ug31->board_offset);
+		}
+		else if(board_offset_cali_finish == true)
+		{
+			sprintf(ug31->effective_board_offset, "C%d", ug31->board_offset);
+		}
+		else
+		{
+			sprintf(ug31->effective_board_offset, "G%d", ug31->board_offset);
+		}
+		val->strval = ug31->effective_board_offset;
+	}
+
+	return 0;
+}
+#else	///< else of UG31XX_REGISTER_POWERSUPPLY
+
+#endif  ///< end of UG31XX_REGISTER_POWERSUPPLY
+
+static int ug31xx_powersupply_init(struct i2c_client *client)
+{
+  #ifdef  UG31XX_REGISTER_POWERSUPPLY
+	int i, ret;
+	for (i = 0; i < ARRAY_SIZE(ug31xx_supply); i++) {
+		ret = power_supply_register(&client->dev, &ug31xx_supply[i]);
+		if (ret) {
+			GAUGE_err("[%s] Failed to register power supply\n", __func__);
+			do {
+				power_supply_unregister(&ug31xx_supply[i]);
+			} while ((--i) >= 0);
+			return ret;
+		}
+	}
+  #else   ///< else of UG31XX_REGISTER_POWERSUPPLY
+
+  #endif  ///< end of UG31XX_REGISTER_POWERSUPPLY
+  return 0;
+}
+
+#ifdef	UPI_CALLBACK_FUNC
+
+int ug31xx_cable_callback(unsigned char usb_cable_state)
+{
+	int old_cable_status = cur_cable_status;
+
+	cur_cable_status = usb_cable_state;
+
+	if(ug31xx_drv_status == UG31XX_DRV_NOT_READY)
+	{
+		GAUGE_err("[%s] Gauge driver not init finish\n", __func__);
+		return (0);
+	}
+
+	if(old_cable_status != cur_cable_status)
+	{
+		cable_status_changed = CABLE_STATUS_CHANGE_RELEASE_COUNT;
+		GAUGE_notice("[%s] Cable status changed (%d -> %d)\n", __func__,
+					old_cable_status,
+					cur_cable_status)
+	}
+
+#ifdef  UG31XX_REGISTER_POWERSUPPLY
+
+	if(cur_cable_status == UG31XX_NO_CABLE)
+	{
+		if(old_cable_status == UG31XX_AC_ADAPTER_CABLE)
+		{
+			power_supply_changed(&ug31xx_supply[PWR_SUPPLY_AC]);
+		}
+		else if(old_cable_status == UG31XX_USB_PC_CABLE)
+		{
+			power_supply_changed(&ug31xx_supply[PWR_SUPPLY_USB]);
+		}
+	}
+	else if(cur_cable_status == UG31XX_USB_PC_CABLE)
+	{
+		power_supply_changed(&ug31xx_supply[PWR_SUPPLY_USB]);
+	}
+	else if(cur_cable_status == UG31XX_AC_ADAPTER_CABLE)
+	{
+		power_supply_changed(&ug31xx_supply[PWR_SUPPLY_AC]);
+	}
+#endif  ///< end of UG31XX_REGISTER_POWERSUPPLY
+	return (0);
+}
+EXPORT_SYMBOL(ug31xx_cable_callback);
+
+#else	///< else of UPI_CALLBACK_FUNC
+
+#ifdef	UG31XX_REGISTER_POWERSUPPLY
+
+static void ug31xx_battery_external_power_changed(struct power_supply *psy)
+{
+  /*Tom
+	int old_cable_status = cur_cable_status;
+    if (power_supply_am_i_supplied(psy)) {
+        switch (get_charger_type()) {
+        case USB_IN:
+            cur_cable_status = UG31XX_USB_PC_CABLE;
+            GAUGE_err("[%s] UG31XX_USB_PC_CABLE\n", __func__);
+            break;
+        case AC_IN:
+            cur_cable_status = UG31XX_AC_ADAPTER_CABLE;
+            GAUGE_err("[%s] UG31XX_AC_ADAPTER_CABLE\n", __func__);
+            break;
+        case CABLE_OUT:
+            cur_cable_status = UG31XX_NO_CABLE;
+            GAUGE_err("[%s] UG31XX_NO_CABLE\n", __func__);
+            break;
+        case PAD_SUPPLY:
+            cur_cable_status = UG31XX_PAD_POWER;
+            GAUGE_err("[%s] UG31XX_PAD_POWER\n", __func__);
+            break;
+        }
+    }
+    else {
+        cur_cable_status = UG31XX_NO_CABLE;
+        GAUGE_err("[%s] UG31XX_NO_CABLE\n", __func__);
+    }
+
+	if(ug31xx_drv_status == UG31XX_DRV_NOT_READY)
+	{
+		GAUGE_err("[%s] Gauge driver not init finish\n", __func__);
+		return;
+	}
+
+	if(old_cable_status != cur_cable_status)
+	{
+		cable_status_changed = CABLE_STATUS_CHANGE_RELEASE_COUNT;
+	}*/
+}
+
+#endif	///< end of UG31XX_REGISTER_POWERSUPPLY
+
+#endif	///< end of UPI_CALLBACK_FUNC
+
+static void set_default_batt_status(void)
+{
+	ug31->polling_time		= 5;
+	ug31->update_time		= 5;
+	ug31->batt_volt			= 3700;
+	ug31->batt_capacity		= 50;
+	ug31->batt_capacity_shifted	= ug31->batt_capacity;
+	ug31->batt_capacity_real	= 50;
+	ug31->batt_charge_now	= 1000;
+	ug31->batt_charge_full	= 2000;
+	ug31->batt_charge_counter = 0;
+	ug31->batt_current		= 0;
+	ug31->batt_temp			= 250;
+	ug31->batt_avg_temp		= 250;
+	ug31->batt_ready		= UPI_UG31XX_MODULE_NOT_READY;
+	ug31->batt_alarm_sts		= 0;
+	ug31->batt_remove		= UPI_UG31XX_BATTERY_REMOVED;
+	ug31->batt_cycle_count	= 0;
+	ug31->batt_ntc_sts		= UPI_UG31XX_NTC_NORMAL;
+
+	ug31->batt_capacity_last	= ug31->batt_capacity;
+	ug31->batt_current_last	= ug31->batt_current;
+
+	ug31->board_offset		= 0;
+	cable_status_changed		= 0;
+}
+
+static void show_abnormal_batt_status(void)
+{
+	set_default_batt_status();
+
+	ug31->batt_capacity = 120;
+
+	GAUGE_notice("ABN STS -> V=%d(mV) C=%d(mA) T=%d-%d(0.1oC) RSOC=%d(%d)(%%) RM=%d(mAh) FCC=%d(mAh) Q=%d(mAh) STS=%d CYCLE=%d\n",
+		ug31->batt_volt,
+		ug31->batt_current,
+		ug31->batt_temp,
+		ug31->batt_avg_temp,
+		ug31->batt_capacity,
+		ug31->batt_capacity_real,
+		ug31->batt_charge_now,
+		ug31->batt_charge_full,
+		ug31->batt_charge_counter,
+		ug31->batt_status,
+		ug31->batt_cycle_count);
+}
+
+static void show_default_batt_status(void)
+{
+	set_default_batt_status();
+
+	GAUGE_notice("DEF STS -> V=%d(mV) C=%d(mA) T=%d-%d(0.1oC) RSOC=%d(%d)(%%) RM=%d(mAh) FCC=%d(mAh) Q=%d(mAh) STS=%d CYCLE=%d\n",
+		ug31->batt_volt,
+		ug31->batt_current,
+		ug31->batt_temp,
+		ug31->batt_avg_temp,
+		ug31->batt_capacity,
+		ug31->batt_capacity_real,
+		ug31->batt_charge_now,
+		ug31->batt_charge_full,
+		ug31->batt_charge_counter,
+		ug31->batt_status,
+		ug31->batt_cycle_count);
+}
+
+static void show_abnormal_batt_status_for_retry(void)
+{
+	set_default_batt_status();
+
+	if(probe_with_cable == true)
+	{
+	  ug31->batt_capacity = 0;
+	}
+  else
+  {
+	  ug31->batt_capacity = 120;
+  }
+
+	GAUGE_notice("ABN STS (retry) -> V=%d(mV) C=%d(mA) T=%d-%d(0.1oC) RSOC=%d(%d)(%%) RM=%d(mAh) FCC=%d(mAh) Q=%d(mAh) STS=%d CYCLE=%d\n",
+		ug31->batt_volt,
+		ug31->batt_current,
+		ug31->batt_temp,
+		ug31->batt_avg_temp,
+		ug31->batt_capacity,
+		ug31->batt_capacity_real,
+		ug31->batt_charge_now,
+		ug31->batt_charge_full,
+		ug31->batt_charge_counter,
+		ug31->batt_status,
+		ug31->batt_cycle_count);
+}
+
+static void asus_print_all(void)
+{
+    int temperature;
+    int temperature10;
+
+    /*  UNKN means UNKOWN, CHRG mean CHARGING, DISC means DISCHARGING,
+        NOTC means NOT CHARGING
+    */
+    char batt_status_str[5][5] = {
+        "UNKN",
+        "CHRG",
+        "DISC",
+        "NOTC",
+        "FULL"
+    };
+    char *negative_sign = "-";
+
+    /* printk(...) does not support %f and %e (float point and double) */
+    if (ug31->batt_temp >= 10 || ug31->batt_temp <= -10) {
+        temperature10 = ug31->batt_temp/10;
+        temperature = ug31->batt_temp - (temperature10 * 10);
+        if (temperature < 0) {
+            temperature = -temperature;
+        }
+        negative_sign = "";
+    }
+    else {
+        temperature10 = 0;
+        temperature = ug31->batt_temp < 0 ?
+                    -ug31->batt_temp : ug31->batt_temp;
+        if (ug31->batt_temp >= 0)
+            negative_sign = "";
+    }
+
+    GAUGE_notice("P:%d(%d-%d)%%, V:%dmV, C:%dmA, T:%s%d.%dC(%d), "
+        "S:%s, R:%dmAh, F:%dmAh, Q:%dmAh, CC:%d, P:%d(%d)s, BO:%d, %s-%s (%d)\n",
+        ug31->batt_capacity_shifted,
+        ug31->batt_capacity,
+        ug31->batt_capacity_real,
+        ug31->batt_volt,
+        ug31->batt_current,
+        negative_sign,
+        temperature10,
+        temperature,
+        ug31->batt_avg_temp,
+        batt_status_str[ug31->batt_status],
+        ug31->batt_charge_now,
+        ug31->batt_charge_full,
+        ug31->batt_charge_counter,
+        ug31->batt_cycle_count,
+        ug31->polling_time,
+        ug31->update_time,
+        ug31->board_offset,
+        ug31_module.get_version(),
+        ug31->daemon_ver,
+        ug31->daemon_uevent_count);
+}
+
+static int asus_battery_cap_shifted(int rsoc)
+{
+#ifdef ENABLE_BATTERY_SHIFT
+    int ret;
+
+    ret = ((ret >= 100) ? 100 : rsoc);
+
+    /* start percentage shift:
+        battery percentage remapping according
+        to battery discharging curve
+    */
+
+    if (ret == 99) {
+        ret = 100;
+        return ret;
+    }
+    else if (ret >= 84 && ret <= 98) {
+        ret++;
+        return ret;
+    }
+
+    /* missing 26%, 47%, 58%, 69%, 79% */
+    if (ret > 70 && ret < 80)
+        ret -= 1;
+    else if (ret > 60 && ret <= 70)
+        ret -= 2;
+    else if (ret > 50 && ret <= 60)
+        ret -= 3;
+    else if (ret > 30 && ret <= 50)
+        ret -= 4;
+    else if (ret >= 0 && ret <= 30)
+        ret -= 5;
+
+    /* final check to avoid negative value */
+    if (ret < 0)
+        ret = 0;
+
+    return ret;
+#else
+    return rsoc;
+#endif
+}
+
+#define MAX_BATTERY_UPDATE_INTERVAL     (600)
+#define	BUSY_BATTERY_UPDATE_RSOC_LOW    (5)
+#define BUSY_BATTERY_UPDATE_RSOC_HIGH   (95)
+static int is_COS(void)
+{
+	char *start;
+	static char COS_CMDLINE[] = "androidboot.mode=charger";
+
+	start = strstr(saved_command_line,COS_CMDLINE);
+	if(start != NULL){
+		return 1;
+	}else{
+		return 0;
+	}
+}
+
+static void show_update_batt_status(void)
+{
+	ug31->batt_capacity_last	= ug31->batt_capacity;
+	ug31->batt_current_last	= ug31->batt_current;
+
+#ifdef  UG31XX_DYNAMIC_POLLING
+	ug31->polling_time		= (u32)ug31_module.get_polling_time();
+	if(Status == 1)
+	{
+		if(ug31->batt_capacity == 100)
+			ug31->update_time	= 3600;
+		else
+			ug31->update_time	= (u32)ug31_module.get_update_time();
+	}else
+		ug31->update_time		= (u32)ug31_module.get_update_time();
+
+#else   ///< else of UG31XX_DYNAMIC_POLLING
+	ug31->polling_time		= 5;
+	ug31->update_time		= 5;
+#endif  ///< end of UG31XX_DYNAMIC_POLLING
+	ug31->batt_volt			= (u32)ug31_module.get_voltage();
+	ug31->batt_capacity		= (int)ug31_module.get_relative_state_of_charge();
+	ug31->batt_capacity_shifted	= asus_battery_cap_shifted(ug31->batt_capacity);
+	ug31->batt_capacity_real	= (int)ug31_module.get_predict_rsoc();
+	ug31->batt_charge_now	= (u32)ug31_module.get_remaining_capacity();
+	ug31->batt_charge_full	= (u32)ug31_module.get_full_charge_capacity();
+	ug31->batt_charge_counter = ug31_module.get_cumulative_capacity();
+	ug31->batt_current		= ug31_module.get_current();
+#ifdef UG31XX_SHOW_EXT_TEMP
+	ug31->batt_temp			= ug31_module.get_external_temperature();
+#else   ///< else of UG31XX_SHOW_EXT_TEMP
+	ug31->batt_temp			= ug31_module.get_internal_temperature();
+#endif  ///< end of UG31XX_SHOW_EXT_TEMP
+	ug31->batt_avg_temp		= ug31_module.get_avg_external_temperature();
+	ug31->batt_ready		= ug31_module.get_module_ready();
+	ug31->batt_alarm_sts		= ug31_module.get_alarm_status();
+	ug31->batt_remove		= ug31_module.get_battery_removed();
+	ug31->batt_cycle_count	= ug31_module.get_cycle_count();
+	ug31->batt_ntc_sts		= ug31_module.get_ntc_status();
+	ug31->board_offset		= ug31_module.get_board_offset();
+
+	if(fix_time_60s == true)
+	{
+		ug31->polling_time = 60;
+		ug31->update_time = 60;
+	}
+	if(fix_time_2s == true)
+	{
+		ug31->polling_time = 2;
+		ug31->update_time = 2;
+	}
+
+	if(cable_status_changed > 0)
+	{
+		ug31->update_time = 3;
+		cable_status_changed = cable_status_changed - 1;
+		force_power_supply_change = true;
+	}
+
+	if(ug31->batt_capacity != ug31->batt_capacity_last)
+	{
+		force_update_backup_file = true;
+	}
+
+	if(ug31->batt_capacity != 100)
+	{
+		enable_board_offset_cali_at_eoc = true;
+	}
+
+	asus_print_all();
+}
+
+static void adjust_cell_table(void)
+{
+	int rtn;
+
+	if(op_options & LKM_OPTIONS_ADJUST_DESIGN_CAPACITY)
+	{
+		if(design_capacity >= 1)
+		{
+			rtn = ug31_module.adjust_cell_table(design_capacity, 0);
+			GAUGE_info("[%s] design capacity has been adjusted. (%d)\n", __func__, rtn);
+		}
+	}
+	op_options = op_options & (~LKM_OPTIONS_ADJUST_DESIGN_CAPACITY);
+}
+
+#ifdef UG31XX_WAKEUP_ALARM
+
+static void ug31xx_gauge_alarm(struct alarm *alarm)
+{
+  GAUGE_info("[%s] wake up alarm\n", __func__);
+}
+
+static void ug31xx_program_alarm(int seconds)
+{
+	ktime_t low_interval = ktime_set(seconds, 0);
+	ktime_t slack = ktime_set(20, 0);
+	ktime_t next;
+
+	next = ktime_add(ug31->last_poll, low_interval);
+	alarm_start_range(&ug31->wakeup_alarm, next, ktime_add(next, slack));
+}
+
+#endif ///< end of UG31XX_WAKEUP_ALARM
+
+#define	UG31_BATTERY_MAX_UPDATE_INTERVAL	(100)
+
+static void batt_power_update_work_func(struct work_struct *work)
+{
+	struct ug31xx_gauge *ug31_dev;
+
+	ug31_dev = container_of(work, struct ug31xx_gauge, batt_power_update_work.work);
+
+	#ifdef  UG31XX_REGISTER_POWERSUPPLY
+
+	if(wake_lock_active(&ug31_dev->batt_wake_lock) != 0)
+	{
+		wake_unlock(&ug31_dev->batt_wake_lock);
+	}
+	wake_lock_timeout(&ug31->batt_wake_lock, UG31XX_WAKE_LOCK_TIMEOUT*HZ);
+	power_supply_changed(&ug31xx_supply[PWR_SUPPLY_BATTERY]);
+
+	#endif  ///< end of UG31XX_REGISTER_POWERSUPPLY
+
+	schedule_delayed_work(&ug31_dev->batt_power_update_work, ug31_dev->polling_time*HZ);
+	GAUGE_info("[%s] issue power_supply_changed.\n", __func__);
+}
+
+/// =================================================================
+/// Charger control for initial capacity prediction (Start)
+/// =================================================================
+/* Tom ++ */
+bool is_upi_do_disablecharger = false;
+EXPORT_SYMBOL(is_upi_do_disablecharger);
+/* Tom -- */
+static void start_charging(void)
+{
+	int ret = 0;
+
+	bq24192_charge_enable(1);
+   is_upi_do_disablecharger = false;
+	if (ret < 0) {
+		GAUGE_err("%s: fail to start charging\n", __func__);
+    }
+    else {
+        GAUGE_info("ug31xx: start charging completely\n");
+    }
+}
+
+static void stop_charging(void)
+{
+	int ret = 0;
+
+	bq24192_charge_enable(0);
+   is_upi_do_disablecharger = true;
+	if (ret < 0) {
+		GAUGE_err("%s: fail to stop charging\n", __func__);
+    }
+    else {
+        GAUGE_info("ug31xx: stop charging completely\n");
+    }
+}
+
+static ssize_t batt_switch_name(struct switch_dev *sdev, char *buf)
+{
+	const char* FAIL = "0xFFFF";
+
+	if (ug31xx_drv_status == UG31XX_DRV_NOT_READY) {
+		GAUGE_err("[%s] Gauge driver not init finish\n", __func__);
+		return sprintf(buf, "%s\n", FAIL);
+	}
+
+	return sprintf(buf, "%s-%s\n", ug31_module.get_version(), ug31->daemon_ver);
+}
+
+/// =================================================================
+/// Charger control for initial capacity prediction (Stop)
+/// =================================================================
+
+#define FORCE_FC_RSOC_THRESHOLD     (99)
+
+static void chk_force_fc_status(void)
+{
+  if((ug31_module.get_relative_state_of_charge() != FORCE_FC_RSOC_THRESHOLD) ||
+     (cur_cable_status == UG31XX_NO_CABLE) ||
+     (ug31_module.get_current() >= force_fc_current_thrd))
+  {
+    ug31->force_fc_time = 0;
+    return;
+  }
+
+  ug31->force_fc_time = ug31->force_fc_time + ug31_module.get_delta_time();
+}
+
+static void curr_check_work_func(struct work_struct *work)
+{
+  int current_now;
+
+  mutex_lock(&ug31->info_update_lock);
+
+  current_now = ug31_module.get_current_now();
+
+  if((current_now >= 0) &&
+     (cur_cable_status == UG31XX_NO_CABLE))
+  {
+    ug31_module.reset_q_from_cc();
+  }
+
+  mutex_unlock(&ug31->info_update_lock);
+}
+
+#define UG31_BATTERY_WORK_MAX_INTERVAL      (30)
+#define UG31XX_PROBE_CHARGER_OFF_DELAY      (1)
+
+static void start_calibrate_board_offset(void)
+{
+	if(kbo_file_exist == true)
+	{
+		GAUGE_err("[%s] Board offset has been calibrated in factory\n", __func__);
+		return;
+	}
+
+  if(cos_file_exist == true)
+  {
+		GAUGE_err("[%s] Board offset has been calibrated in COS\n", __func__);
+		return;
+  }
+
+	if(board_offset_cali_run == true)
+	{
+		GAUGE_err("[%s] Board offset calibration is already running\n", __func__);
+		return;
+	}
+
+	if(ug31->batt_avg_temp < UG31XX_CALI_BO_LOW_TEMP)
+	{
+		GAUGE_err("[%s] No board offset calibration because of low temperature (%d < %d)\n", __func__,
+				ug31->batt_avg_temp,
+				UG31XX_CALI_BO_LOW_TEMP);
+		return;
+	}
+
+	if(ug31->batt_avg_temp > UG31XX_CALI_BO_HIGH_TEMP)
+	{
+		GAUGE_err("[%s] No board offset calibration because of high temperature (%d > %d)\n", __func__,
+				ug31->batt_avg_temp,
+				UG31XX_CALI_BO_HIGH_TEMP);
+		return;
+	}
+
+	mutex_lock(&ug31->info_update_lock);
+	board_offset_cali_init = ug31_module.get_board_offset();
+	mutex_unlock(&ug31->info_update_lock);
+	schedule_delayed_work(&ug31->board_offset_cali_work, UG31XX_PROBE_CHARGER_OFF_DELAY*HZ);
+	GAUGE_info("[%s] Wait %d seconds to calibrate board offset (%d)\n", __func__,
+			UG31XX_PROBE_CHARGER_OFF_DELAY,
+			board_offset_cali_init);
+	stop_charging();
+	board_offset_cali_run = true;
+
+	if(wake_lock_active(&ug31->batt_wake_lock) != 0)
+	{
+		wake_unlock(&ug31->batt_wake_lock);
+	}
+	wake_lock_timeout(&ug31->batt_wake_lock, UG31XX_PROBE_CHARGER_OFF_DELAY*HZ);
+}
+
+static void cal_avg_board_offset(void)
+{
+  if(board_offset_cali_loop == 0)
+  {
+    return;
+  }
+  board_offset_cali_avg = board_offset_cali_avg/board_offset_cali_loop;
+  GAUGE_info("[%s]: New board offset = %d\n", __func__, board_offset_cali_avg);
+
+  ug31_module.set_board_offset(board_offset_cali_avg, UG31XX_BOARD_OFFSET_NOT_FROM_UPI_BO);
+
+  board_offset_cali_avg = 0;
+  board_offset_cali_loop = 0;
+  board_offset_cali_finish = true;
+  board_offset_cali_run = false;
+}
+
+static void stop_calibrate_board_offset(void)
+{
+	if(board_offset_cali_run == false)
+	{
+		GAUGE_err("[%s] No board offset calibration is running.\n", __func__);
+		return;
+	}
+
+	cancel_delayed_work_sync(&ug31->board_offset_cali_work);
+
+	start_charging();
+	board_offset_cali_run = false;
+
+	mutex_lock(&ug31->info_update_lock);
+	cal_avg_board_offset();
+	mutex_unlock(&ug31->info_update_lock);
+}
+
+static void batt_info_update_work_func(struct work_struct *work)
+{
+	int gg_status;
+	struct ug31xx_gauge *ug31_dev;
+	int prev_fc_sts;
+	int now_fc_sts;
+	bool now_is_charging;
+
+	ug31_dev = container_of(work, struct ug31xx_gauge, batt_info_update_work.work);
+
+	gg_status = 0;
+
+	if(ug31xx_drv_status == UG31XX_DRV_NOT_READY)
+	{
+		return;
+	}
+
+	if(wake_lock_active(&ug31_dev->batt_wake_lock) != 0)
+	{
+		wake_unlock(&ug31_dev->batt_wake_lock);
+	}
+	wake_lock_timeout(&ug31_dev->batt_wake_lock, UG31XX_WAKE_LOCK_TIMEOUT*HZ);
+
+	curr_charger_full_status = is_charging_full();
+
+	if(curr_charger_full_status == true)
+  	{
+    		schedule_delayed_work(&ug31->curr_check_work, 1*HZ);
+  	}
+
+	if ((charger_full_status == false) && (curr_charger_full_status == true))
+	{
+		charger_detect_full = true;
+		force_power_supply_change = true;
+	}
+	charger_full_status = curr_charger_full_status;
+
+	/// [AT-PM] : Update gauge information ; 02/04/2013
+
+	mutex_lock(&ug31_dev->info_update_lock);
+	ug31_module.set_options(op_options);
+	if(op_options & (LKM_OPTIONS_FORCE_RESET | LKM_OPTIONS_FORCE_RESET_TOTALLY))
+	{
+		now_is_charging = is_charging();
+	 	if(now_is_charging == true)
+	  	{
+	    		stop_charging();
+	  	}
+
+		if(op_options & LKM_OPTIONS_FORCE_RESET)
+		{
+			ug31_module.reset(FactoryGGBXFile, true);
+		}
+		else
+		{
+			ug31_module.reset(FactoryGGBXFile, false);
+		}
+
+	  if(now_is_charging == true)
+	  {
+	    start_charging();
+	  }
+#ifdef FEATRUE_K_BOARD_OFFSET
+		if(kbo_file_exist == true)
+		{
+			ug31_module.set_board_offset(kbo_result, UG31XX_BOARD_OFFSET_FROM_UPI_BO);
+		} else {// 2014/06/24 TOM
+                        GAUGE_err("[%s] kbo_file_exist == false, check it again!!!.\n", __func__);
+                        schedule_delayed_work(&ug31->kbo_check_work, msecs_to_jiffies(UG31XX_CALI_BO_FACTORY_DELAY));
+                }
+		if(cos_file_exist == true)
+		{
+			ug31_module.set_board_offset(cos_result, UG31XX_BOARD_OFFSET_FROM_UPI_COS);
+		} else {// 2014/06/24 TOM
+                        schedule_delayed_work(&ug31->cos_check_work, msecs_to_jiffies(UG31XX_CALI_BO_FACTORY_DELAY + 1000)*HZ);
+                }
+#endif ///< for FEATRUE_K_BOARD_OFFSET
+	}
+	op_options = op_options & (~(LKM_OPTIONS_FORCE_RESET | LKM_OPTIONS_FORCE_RESET_TOTALLY));
+	adjust_cell_table();
+	update_project_config();
+
+	ug31_module.set_cable_out((cur_cable_status == UG31XX_NO_CABLE) ? UG31XX_CABLE_OUT : UG31XX_CABLE_IN);
+
+	prev_fc_sts = ug31_module.get_full_charge_status();
+	gg_status = ug31_module.update((user_space_algorithm_response == true) ? UG31XX_USER_SPACE_RESPONSE : UG31XX_USER_SPACE_NO_RESPONSE);
+	now_fc_sts = ug31_module.get_full_charge_status();
+	if(gg_status == 0)
+	{
+	    	chk_force_fc_status();
+
+		if(charger_detect_full == true)
+		{
+			charger_detect_full = false;
+			gg_status = ug31_module.set_charger_full(UG31XX_CHARGER_DETECTS_FULL_STEP);
+		}
+
+		#ifndef UG31XX_WAIT_CHARGER_FC
+
+			if((prev_fc_sts == 0) && (now_fc_sts == 1))
+			{
+				gg_status = ug31_module.set_charger_full(UG31XX_TAPER_REACHED);
+			}
+
+			if((is_charging() == true) && (now_fc_sts == -1))
+			{
+				gg_status = ug31_module.set_charger_full(UG31XX_TAPER_REACHED);
+			}
+
+			if(curr_charger_full_status == true)
+			{
+				gg_status = ug31_module.set_charger_full(UG31XX_CHARGER_DETECTS_FULL_STEP);
+			}
+
+		#endif  ///< end of UG31XX_WAIT_CHARGER_FC
+
+		if(in_early_suspend == true)
+		{
+			delta_q_in_suspend = delta_q_in_suspend + ug31_module.get_delta_q();
+		}
+	}
+
+  #ifdef  STOP_IF_NTC_CHECK_FAIL
+
+  if(ug31_module.get_ntc_status() != UPI_UG31XX_NTC_NORMAL)
+  {
+    ug31xx_drv_status = UG31XX_DRV_NOT_READY;
+  }
+
+  #endif  ///< end of STOP_IF_NTC_CHECK_FAIL
+
+	if(gg_status == 0)
+	{
+		show_update_batt_status();
+	}
+	else
+	{
+		show_abnormal_batt_status();
+		GAUGE_err("[%s] Fail to update gauge info.\n", __func__);
+	}
+	mutex_unlock(&ug31_dev->info_update_lock);
+
+	curr_direction_changed = ug31_dev->batt_current_last*ug31_dev->batt_current;
+  #ifdef  UG31XX_USER_SPACE_ALGORITHM
+
+    if(curr_direction_changed < 0)
+    {
+      force_power_supply_change = true;
+    }
+
+    if(user_space_algorithm_response == false)
+    {
+      if((ug31_dev->batt_capacity != ug31_dev->batt_capacity_last) ||
+         (force_power_supply_change == true))
+      {
+        force_power_supply_change = false;
+
+        cancel_delayed_work_sync(&ug31_dev->batt_power_update_work);
+        schedule_delayed_work(&ug31_dev->batt_power_update_work, 0*HZ);
+      }
+    }
+
+  #else   ///< else of UG31XX_USER_SPACE_ALGORITHM
+
+  	if((ug31_dev->batt_capacity != ug31_dev->batt_capacity_last) ||
+  	   (curr_direction_changed < 0) ||
+  	   (force_power_supply_change == true))
+  	{
+  	  force_power_supply_change = false;
+
+  	  cancel_delayed_work_sync(&ug31_dev->batt_power_update_work);
+  	  schedule_delayed_work(&ug31_dev->batt_power_update_work, 0*HZ);
+  	}
+
+  #endif  ///< end of UG31XX_USER_SPACE_ALGORITHM
+
+	#ifdef  UG31XX_USER_SPACE_ALGORITHM
+	mutex_lock(&ug31_dev->info_update_lock);
+	if(ug31_module.get_decimate_rst_sts() == UG31XX_DECIMATE_RST_NOT_ACTIVE)
+	{
+		user_space_algorithm_response = false;
+		op_actions = UG31XX_OP_NORMAL;
+		kobj_event_env = UG31XX_KOBJ_ENV_UPDATE_CAPACITY;
+		change_ug31xx_kobj();
+	}
+	mutex_unlock(&ug31_dev->info_update_lock);
+  #endif  ///< end of UG31XX_USER_SPACE_ALGORITHM
+
+	mutex_lock(&ug31_dev->info_update_lock);
+	check_backup_file_routine();
+	#ifndef	UG31XX_USER_SPACE_ALGORITHM
+		if(in_early_suspend == false)
+		{
+			ug31_module.set_capacity_suspend_mode(_UPI_FALSE_);
+		}
+	#endif	///< end of UG31XX_USER_SPACE_ALGORITHM
+	mutex_unlock(&ug31_dev->info_update_lock);
+
+	if(op_options & LKM_OPTIONS_FORCE_RESET)
+	{
+		batt_info_update_work_func(&ug31_dev->batt_info_update_work.work);
+	}
+	else
+	{
+		schedule_delayed_work(&ug31_dev->batt_info_update_work, ug31_dev->update_time*HZ);
+	}
+
+	if((curr_charger_full_status == true) &&
+	   (enable_board_offset_cali_at_eoc == true) &&
+	   (ug31_dev->batt_capacity == 100) &&
+	   (kbo_file_exist == false) &&
+	   (cos_file_exist == false) &&
+	   (board_offset_cali_loop_eoc < UG31XX_CALI_BO_LOOP_EOC))
+	{
+		enable_board_offset_cali_at_eoc = false;
+		board_offset_cali_loop_max = UG31XX_CALI_BO_LOOP_EOC;
+		start_calibrate_board_offset();
+	}
+
+#ifdef FEATRUE_K_BOARD_OFFSET
+  /// [AT-PM] : Check board offset calibration file exist ; 02/13/2014
+  if(kbo_file_exist == true)
+  {
+    schedule_delayed_work(&ug31->kbo_check_work, msecs_to_jiffies(UG31XX_CALI_BO_FACTORY_DELAY));
+  }
+  if(cos_file_exist == true)
+  {
+    schedule_delayed_work(&ug31->cos_check_work, msecs_to_jiffies(UG31XX_CALI_BO_FACTORY_DELAY));
+  }
+#endif ///< for FEATRUE_K_BOARD_OFFSET
+}
+
+#ifdef  UG31XX_WAIT_CHARGER_FC
+
+int ug31xx_charger_detect_full(bool is_charger_full)
+{
+	charger_detect_full = is_charger_full;
+
+	if(ug31xx_drv_status != UG31XX_DRV_NOT_READY)
+	{
+		cancel_delayed_work_sync(&ug31->batt_info_update_work);
+		batt_info_update_work_func(&ug31_dev->batt_info_update_work.work);
+	}
+
+	if(charger_detect_full == true)
+	{
+		GAUGE_info("[%s] charger_detect_full = true\n", __func__);
+	}
+	else
+	{
+		GAUGE_info("[%s] charger_detect_full = false\n", __func__);
+	}
+	return (0);
+}
+EXPORT_SYMBOL(ug31xx_charger_detect_full);
+
+#endif  ///< end of UG31XX_WAIT_CHARGER_FC
+
+#ifdef  UG31XX_DYNAMIC_TAPER_CURRENT
+
+int ug31xx_set_charge_termination_current(int curr)
+{
+	charge_termination_current = curr;
+	GAUGE_info("[%s] charge_termination_current = %d\n", __func__, charge_termination_current);
+	return (0);
+}
+EXPORT_SYMBOL(ug31xx_set_charge_termination_current);
+
+#endif  ///< end of UG31XX_DYNAMIC_TAPER_CURRENT
+
+#ifdef UG31XX_PROC_DEV
+#if LINUX_VERSION_CODE < KERNEL_VERSION(3, 10, 0)
+int ug31xx_get_proc_rsoc(char *buf, char **start, off_t off, int count,
+                         int *eof, void *data )
+{
+  int len = 0;
+  len += sprintf(buf+len, "%d\n", ug31_module.get_predict_rsoc());
+  return len;
+}
+
+int ug31xx_get_proc_psoc(char *buf, char **start, off_t off, int count,
+                         int *eof, void *data )
+{
+  int len = 0;
+  len += sprintf(buf+len, "%d\n", ug31_module.get_relative_state_of_charge());
+  return len;
+}
+
+int ug31xx_get_proc_rm(char *buf, char **start, off_t off, int count,
+		       int *eof, void *data )
+{
+  int len = 0;
+  len += sprintf(buf+len, "%d\n", ug31_module.get_remaining_capacity());
+  return len;
+}
+
+int ug31xx_get_proc_fcc(char *buf, char **start, off_t off, int count,
+			int *eof, void *data )
+{
+  int len = 0;
+  len += sprintf(buf+len, "%d\n", ug31_module.get_full_charge_capacity());
+  return len;
+}
+
+int ug31xx_get_proc_curr(char *buf, char **start, off_t off, int count,
+                         int *eof, void *data )
+{
+  int len = 0;
+  len += sprintf(buf+len, "%d\n", ug31_module.get_current_now());
+  return len;
+}
+
+int ug31xx_get_proc_temp(char *buf, char **start, off_t off, int count, int *eof, void *data)
+{
+  int len = 0;
+  int value;
+
+  value = ug31_module.get_avg_external_temperature();
+  len += sprintf(buf+len, "%d.%d\n", value/10, value%10);
+  return len;
+}
+
+int ug31xx_get_proc_upi_60(char *buf, char **start, off_t off, int count, int *eof, void *data)
+{
+	int len;
+
+	fix_time_60s = true;
+	fix_time_2s = false;
+
+	len = 0;
+	len += sprintf(buf + len, "Fix polling time to 60 seconds\n");
+	return (len);
+}
+
+int ug31xx_get_proc_upi_2(char *buf, char **start, off_t off, int count, int *eof, void *data)
+{
+	int len;
+
+	fix_time_60s = false;
+	fix_time_2s = true;
+
+	len = 0;
+	len += sprintf(buf + len, "Fix polling time to 2 seconds\n");
+	return (len);
+}
+
+int ug31xx_get_proc_upi_auto(char *buf, char **start, off_t off, int count, int *eof, void *data)
+{
+	int len;
+
+	fix_time_60s = false;
+	fix_time_2s = false;
+
+	len = 0;
+	len += sprintf(buf + len, "Set polling time to %d(%d) seconds\n", ug31->polling_time, ug31->update_time);
+	return (len);
+}
+
+#ifdef FEATRUE_K_BOARD_OFFSET
+int ug31xx_get_proc_kbo_start(char *buf, char **start, off_t off, int count, int *eof, void *data)
+{
+	int len;
+
+  cancel_delayed_work(&ug31->kbo_work);
+  hrtimer_cancel(&ug31->kbo_timer);
+  if(wake_lock_active(&ug31->batt_wake_lock) != 0)
+  {
+  	wake_unlock(&ug31->batt_wake_lock);
+  }
+  wake_lock_timeout(&ug31->batt_wake_lock, UG31XX_KBO_WAKE_LOCK_TIMEOUT*HZ);
+
+  kbo_start_flag = true;
+  kbo_pass_cnt = 0;
+  kbo_fail_cnt = 0;
+  memset(kbo_pass_queue, 0, sizeof(kbo_pass_queue));
+  memset(kbo_fail_queue, 0, sizeof(kbo_fail_queue));
+  stop_charging();
+
+  mutex_lock(&ug31->info_update_lock);
+  ug31_module.set_board_offset(0, UG31XX_BOARD_OFFSET_NOT_FROM_UPI_BO);
+  mutex_unlock(&ug31->info_update_lock);
+
+  GAUGE_info("[%s] init kbo_result = %d.\n", __func__,
+  	   kbo_result);
+
+  hrtimer_start(&ug31->kbo_timer,
+        ktime_set(UG31XX_CALI_BO_CHARGER_OFF_DELAY / UG31XX_TIME_MSEC_TO_SEC,
+              (UG31XX_CALI_BO_CHARGER_OFF_DELAY % UG31XX_TIME_MSEC_TO_SEC) * UG31XX_TIME_USEC_TO_SEC),
+    HRTIMER_MODE_REL);
+  GAUGE_info("[%s] wait %d ms to kbo.\n", __func__,
+	   UG31XX_CALI_BO_CHARGER_OFF_DELAY);
+	len = 0;
+	len += sprintf(buf + len, "Start board offset calibration.\n");
+	return (len);
+}
+
+int ug31xx_get_proc_kbo_result(char *buf, char **start, off_t off, int count, int *eof, void *data)
+{
+	int len;
+
+	kobj_event_env = UG31XX_KOBJ_ENV_BACKUP_BO_WRITE;
+	change_ug31xx_kobj();
+
+	kbo_start_flag = false;
+	len = 0;
+	len += sprintf(buf + len, "Board offset = %d.\n", kbo_result);
+	return (len);
+}
+
+int ug31xx_get_proc_kbo_stop(char *buf, char **start, off_t off, int count, int *eof, void *data)
+{
+	int len;
+
+	start_charging();
+
+	cancel_delayed_work(&ug31->kbo_work);
+
+	kbo_start_flag = false;
+	len = 0;
+	len += sprintf(buf + len, "Stop board offset calibration.\n");
+	return (len);
+}
+#endif  ///< end of FEATRUE_K_BOARD_OFFSET
+#else
+struct proc_dir_entry *battery;	//Maybe unnecessary
+int ug31xx_get_proc_rsoc(struct seq_file *m, void *p)
+{
+  seq_printf(m, "%d\n", ug31_module.get_predict_rsoc());
+  return 0;
+}
+
+static int proc_rsoc_open(struct inode *inode, struct file *file)
+{
+	return single_open(file, ug31xx_get_proc_rsoc, NULL);
+}
+
+static const struct file_operations proc_rsoc_ops = {
+	.open       = proc_rsoc_open,
+	.read       = seq_read,
+	.llseek     = seq_lseek,
+	.release    = seq_release
+};
+
+int ug31xx_get_proc_psoc(struct seq_file *m, void *p)
+{
+  seq_printf(m, "%d\n", ug31_module.get_relative_state_of_charge());
+  return 0;
+}
+
+static int proc_psoc_open(struct inode *inode, struct file *file)
+{
+	return single_open(file, ug31xx_get_proc_psoc, NULL);
+}
+
+static const struct file_operations proc_psoc_ops = {
+	.open       = proc_psoc_open,
+	.read       = seq_read,
+	.llseek     = seq_lseek,
+	.release    = seq_release
+};
+
+int ug31xx_get_proc_rm(struct seq_file *m, void *p)
+{
+  seq_printf(m, "%d\n", ug31_module.get_remaining_capacity());
+  return 0;
+}
+
+static int proc_rm_open(struct inode *inode, struct file *file)
+{
+	return single_open(file, ug31xx_get_proc_rm, NULL);
+}
+
+static const struct file_operations proc_rm_ops = {
+	.open       = proc_rm_open,
+	.read       = seq_read,
+	.llseek     = seq_lseek,
+	.release    = seq_release
+};
+
+int ug31xx_get_proc_fcc(struct seq_file *m, void *p)
+{
+  seq_printf(m, "%d\n", ug31_module.get_full_charge_capacity());
+  return 0;
+}
+
+static int proc_fcc_open(struct inode *inode, struct file *file)
+{
+	return single_open(file, ug31xx_get_proc_fcc, NULL);
+}
+
+static const struct file_operations proc_fcc_ops = {
+	.open       = proc_fcc_open,
+	.read       = seq_read,
+	.llseek     = seq_lseek,
+	.release    = seq_release
+};
+
+int ug31xx_get_proc_curr(struct seq_file *m, void *p)
+{
+  seq_printf(m, "%d\n", ug31_module.get_current_now());
+  return 0;
+}
+
+static int proc_curr_open(struct inode *inode, struct file *file)
+{
+	return single_open(file, ug31xx_get_proc_curr, NULL);
+}
+
+static const struct file_operations proc_curr_ops = {
+	.open       = proc_curr_open,
+	.read       = seq_read,
+	.llseek     = seq_lseek,
+	.release    = seq_release
+};
+
+int ug31xx_get_proc_temp(struct seq_file *m, void *p)
+{
+  int value;
+
+  value = ug31_module.get_avg_external_temperature();
+  seq_printf(m, "%d.%d\n", value/10, value%10);
+  return 0;
+}
+
+static int proc_temp_open(struct inode *inode, struct file *file)
+{
+	return single_open(file, ug31xx_get_proc_temp, NULL);
+}
+
+static const struct file_operations proc_temp_ops = {
+	.open       = proc_temp_open,
+	.read       = seq_read,
+	.llseek     = seq_lseek,
+	.release    = seq_release
+};
+
+
+int ug31xx_get_proc_upi_60(struct seq_file *m, void *p)
+{
+	fix_time_60s = true;
+	fix_time_2s = false;
+
+	seq_printf(m, "Fix polling time to 60 seconds\n");
+	return 0;
+}
+
+static int proc_upi_60_open(struct inode *inode, struct file *file)
+{
+	return single_open(file, ug31xx_get_proc_upi_60, NULL);
+}
+
+static const struct file_operations proc_upi_60_ops = {
+	.open       = proc_upi_60_open,
+	.read       = seq_read,
+	.llseek     = seq_lseek,
+	.release    = seq_release
+};
+
+
+int ug31xx_get_proc_upi_2(struct seq_file *m, void *p)
+{
+	fix_time_60s = false;
+	fix_time_2s = true;
+
+	seq_printf(m, "Fix polling time to 2 seconds\n");
+	return 0;
+}
+
+static int proc_upi_2_open(struct inode *inode, struct file *file)
+{
+	return single_open(file, ug31xx_get_proc_upi_2, NULL);
+}
+
+static const struct file_operations proc_upi_2_ops = {
+	.open       = proc_upi_2_open,
+	.read       = seq_read,
+	.llseek     = seq_lseek,
+	.release    = seq_release
+};
+
+int ug31xx_get_proc_upi_auto(struct seq_file *m, void *p)
+{
+	fix_time_60s = false;
+	fix_time_2s = false;
+
+	seq_printf(m, "Set polling time to %d(%d) seconds\n", ug31->polling_time, ug31->update_time);
+	return 0;
+}
+
+static int proc_upi_auto_open(struct inode *inode, struct file *file)
+{
+	return single_open(file, ug31xx_get_proc_upi_auto, NULL);
+}
+
+static const struct file_operations proc_upi_auto_ops = {
+	.open       = proc_upi_auto_open,
+	.read       = seq_read,
+	.llseek     = seq_lseek,
+	.release    = seq_release
+};
+
+#ifdef  FEATRUE_K_BOARD_OFFSET
+int ug31xx_get_proc_kbo_start(struct seq_file *m, void *p)
+{
+  cancel_delayed_work(&ug31->kbo_work);
+  hrtimer_cancel(&ug31->kbo_timer);
+  if(wake_lock_active(&ug31->batt_wake_lock) != 0)
+  {
+  	wake_unlock(&ug31->batt_wake_lock);
+  }
+  wake_lock_timeout(&ug31->batt_wake_lock, UG31XX_KBO_WAKE_LOCK_TIMEOUT*HZ);
+
+  kbo_start_flag = true;
+  kbo_pass_cnt = 0;
+  kbo_fail_cnt = 0;
+  memset(kbo_pass_queue, 0, sizeof(kbo_pass_queue));
+  memset(kbo_fail_queue, 0, sizeof(kbo_fail_queue));
+  stop_charging();
+
+  mutex_lock(&ug31->info_update_lock);
+  ug31_module.set_board_offset(0, UG31XX_BOARD_OFFSET_NOT_FROM_UPI_BO);
+  mutex_unlock(&ug31->info_update_lock);
+
+  GAUGE_info("[%s] init kbo_result = %d.\n", __func__,
+  	   kbo_result);
+
+  hrtimer_start(&ug31->kbo_timer,
+        ktime_set(UG31XX_CALI_BO_CHARGER_OFF_DELAY / UG31XX_TIME_MSEC_TO_SEC,
+              (UG31XX_CALI_BO_CHARGER_OFF_DELAY % UG31XX_TIME_MSEC_TO_SEC) * UG31XX_TIME_USEC_TO_SEC),
+    HRTIMER_MODE_REL);
+  GAUGE_info("[%s] wait %d ms to kbo.\n", __func__,
+	   UG31XX_CALI_BO_CHARGER_OFF_DELAY);
+	seq_printf(m, "Start board offset calibration.\n");
+  return (0);
+}
+
+static int kbo_start_open(struct inode *inode, struct file *file)
+{
+	return single_open(file, ug31xx_get_proc_kbo_start, NULL);
+}
+
+static const struct file_operations kbo_start_ops = {
+	.open       = kbo_start_open,
+	.read       = seq_read,
+	.llseek     = seq_lseek,
+	.release    = seq_release
+};
+
+int ug31xx_get_proc_kbo_result(struct seq_file *m, void *p)
+{
+	int len;
+
+	kobj_event_env = UG31XX_KOBJ_ENV_BACKUP_BO_WRITE;
+	change_ug31xx_kobj();
+
+	kbo_start_flag = false;
+
+	seq_printf(m, "Board offset = %d.\n", kbo_result);
+	return (0);
+}
+
+static int kbo_result_open(struct inode *inode, struct file *file)
+{
+	return single_open(file, ug31xx_get_proc_kbo_result, NULL);
+}
+
+
+static const struct file_operations kbo_result_ops = {
+	.open       = kbo_result_open,
+	.read       = seq_read,
+	.llseek     = seq_lseek,
+	.release    = seq_release
+};
+
+int ug31xx_get_proc_kbo_stop(struct seq_file *m, void *p)
+{
+	int len;
+
+	start_charging();
+
+	cancel_delayed_work(&ug31->kbo_work);
+
+	kbo_start_flag = false;
+  ug31_module.set_board_offset(kbo_result, UG31XX_BOARD_OFFSET_FROM_UPI_BO);
+	seq_printf(m, "Stop board offset calibration.\n");
+	return (0);
+}
+
+static int kbo_stop_open(struct inode *inode, struct file *file)
+{
+	return single_open(file, ug31xx_get_proc_kbo_stop, NULL);
+}
+
+static const struct file_operations kbo_stop_ops = {
+	.open       = kbo_stop_open,
+	.read       = seq_read,
+	.llseek     = seq_lseek,
+	.release    = seq_release
+};
+#endif  ///< end of FEATRUE_K_BOARD_OFFSET
+
+/* Read the state-of-health information of the battery from DUT  */
+int ug31xx_get_proc_battery_soh(struct seq_file *m, void *p)
+{
+	seq_printf(m,"FCC=%d(mAh),DC=%d(mAh),RM=%d(mAh),TEMP=%d(C),VOLT=%d(mV),CUR=%d(mA),CC=%d",ug31_module.get_full_charge_capacity(),ug31_module.get_design_capacity(),ug31_module.get_remaining_capacity(),(ug31_module.get_external_temperature()/10),ug31_module.get_voltage_now(),ug31_module.get_current_now(),ug31_module.get_cycle_count());
+	return 0;
+}
+static int proc_battery_soh_open(struct inode *inode, struct file *file)
+{
+	return single_open(file, ug31xx_get_proc_battery_soh, NULL);
+}
+static const struct file_operations proc_battery_soh_ops = {
+	.open       = proc_battery_soh_open,
+	.read       = seq_read,
+	.llseek     = seq_lseek,
+	.release    = seq_release
+};
+/* Read the state-of-health information of the battery from DUT */
+#endif
+#endif  ///< end of UG31XX_PROC_DEV
+
+static bool calibrate_rsoc_request = false;
+
+static void calibrate_rsoc(void)
+{
+  int table_rsoc;
+  int current_rsoc;
+
+  if(calibrate_rsoc_request == false)
+  {
+    return;
+  }
+
+  if(charger_dc_in_before_suspend == true)
+  {
+    return;
+  }
+
+  mutex_lock(&ug31->info_update_lock);
+
+  if(ug31_module.get_suspend_time() > cali_rsoc_time)
+  {
+    table_rsoc = ug31_module.get_table_rsoc();
+    current_rsoc = ug31_module.get_relative_state_of_charge();
+
+    if(table_rsoc < current_rsoc)
+    {
+      ug31_module.set_capacity_force(table_rsoc);
+    }
+  }
+
+  mutex_unlock(&ug31->info_update_lock);
+
+  calibrate_rsoc_request = false;
+}
+
+#if defined(CONFIG_HAS_EARLYSUSPEND) && defined(UG31XX_EARLY_SUSPEND)
+
+static void ug31xx_early_suspend(struct early_suspend *e)
+{
+	struct ug31xx_gauge *ug31_dev = container_of(e, struct ug31xx_gauge, es);
+
+	if(ug31xx_drv_status == UG31XX_DRV_NOT_READY)
+	{
+		GAUGE_err("[%s] Gauge driver not init finish\n", __func__);
+		return;
+	}
+
+	dev_info(&ug31_dev->client->dev, "enter %s\n", __func__);
+
+	op_actions = UG31XX_OP_EARLY_SUSPEND;
+	kobj_event_env = UG31XX_KOBJ_ENV_UPDATE_CAPACITY;
+	change_ug31xx_kobj();
+
+	charger_dc_in_before_suspend = is_charging();
+
+  mutex_lock(&ug31_dev->info_update_lock);
+  ug31_module.suspend((charger_dc_in_before_suspend == true) ? 1 : 0);
+  mutex_unlock(&ug31_dev->info_update_lock);
+
+  batt_info_update_work_func(&ug31_dev->batt_info_update_work.work);
+
+	mutex_lock(&ug31_dev->info_update_lock);
+  in_early_suspend = true;
+	ug31_module.set_capacity_suspend_mode(_UPI_TRUE_);
+	mutex_unlock(&ug31_dev->info_update_lock);
+
+#ifdef  UG31XX_CALI_BO_EARLY_SUSPEND
+
+  if((is_charging() == true) &&
+    (cur_cable_status == UG31XX_AC_ADAPTER_CABLE) &&
+    (board_offset_cali_finish == false) &&
+    (ug31_module.get_predict_rsoc() >= UG31XX_CALI_BO_LW_PSOC) &&
+    (ug31_module.get_predict_rsoc() <= UG31XX_CALI_BO_UP_PSOC))
+  {
+    board_offset_cali_loop_max = UG31XX_CALI_BO_LOOP;
+    start_calibrate_board_offset();
+  }
+
+#endif  ///< end of UG31XX_CALI_BO_EARLY_SUSPEND
+
+	delta_q_in_suspend = 0;
+	GAUGE_info("[%s] Driver early suspend.\n", __func__);
+}
+
+static void ug31xx_late_resume(struct early_suspend *e)
+{
+	struct ug31xx_gauge *ug31_dev = container_of(e, struct ug31xx_gauge, es);
+	bool charger_dc_in_after_resume;
+
+	if(ug31xx_drv_status == UG31XX_DRV_NOT_READY)
+	{
+		GAUGE_err("[%s] Gauge driver not init finish\n", __func__);
+		return;
+	}
+
+	dev_info(&ug31_dev->client->dev, "enter %s\n", __func__);
+
+	op_actions = UG31XX_OP_LATE_RESUME;
+	kobj_event_env = UG31XX_KOBJ_ENV_UPDATE_CAPACITY;
+	change_ug31xx_kobj();
+
+	cancel_delayed_work_sync(&ug31_dev->batt_info_update_work);
+
+	stop_calibrate_board_offset();
+
+	charger_dc_in_after_resume = is_charging();
+
+  mutex_lock(&ug31_dev->info_update_lock);
+  ug31_module.resume((user_space_algorithm_response == true) ? UG31XX_USER_SPACE_RESPONSE : UG31XX_USER_SPACE_NO_RESPONSE);
+  mutex_unlock(&ug31_dev->info_update_lock);
+
+	batt_info_update_work_func(&ug31_dev->batt_info_update_work.work);
+
+  calibrate_rsoc_request = true;
+  #ifndef UG31XX_USER_SPACE_ALGORITHM
+  calibrate_rsoc();
+  #endif  ///< end of UG31XX_USER_SPACE_ALGORITHM
+
+	force_power_supply_change = true;
+	in_early_suspend = false;
+	GAUGE_info("[%s] Gauge late resumed.\n", __func__);
+}
+
+static void ug31xx_config_earlysuspend(struct ug31xx_gauge *chip)
+{
+	chip->es.level = EARLY_SUSPEND_LEVEL_BLANK_SCREEN - 2;
+	chip->es.suspend = ug31xx_early_suspend;
+	chip->es.resume = ug31xx_late_resume;
+	register_early_suspend(&chip->es);
+}
+
+#else	///< else of defined(CONFIG_HAS_EARLYSUSPEND) && defined(UG31XX_EARLY_SUSPEND)
+
+#define ug31xx_early_suspend NULL
+#define ug31xx_late_resume NULL
+
+static void ug31xx_config_earlysuspend(struct ug31xx_gauge *chip) { return; }
+
+#endif	///< end of defined(CONFIG_HAS_EARLYSUSPEND) && defined(UG31XX_EARLY_SUSPEND)
+
+static void cal_avg_board_offset_eoc(void)
+{
+	int tmp;
+	int idx1;
+	int idx2;
+
+	/// [AT-PM] : Sorting the buffer from minimum to maximum ; 02/12/2014
+	idx1 = 0;
+	while(idx1 < UG31XX_CALI_BO_LOOP_EOC)
+	{
+		idx2 = idx1;
+		while(idx2 < UG31XX_CALI_BO_LOOP_EOC)
+		{
+			if(board_offset_cali_eoc_buf[idx1] < board_offset_cali_eoc_buf[idx2])
+			{
+				tmp = board_offset_cali_eoc_buf[idx1];
+				board_offset_cali_eoc_buf[idx1] = board_offset_cali_eoc_buf[idx2];
+				board_offset_cali_eoc_buf[idx2] = tmp;
+			}
+			idx2 = idx2 + 1;
+		}
+		idx1 = idx1 + 1;
+	}
+
+	/// [AT-PM] : Get the average for the half buffer ; 02/12/2014
+	idx1 = 0;
+	tmp = 0;
+	while(idx1 < UG31XX_CALI_BO_LOOP_EOC/2)
+	{
+		tmp = tmp + board_offset_cali_eoc_buf[idx1];
+		idx1 = idx1 + 1;
+	}
+	GAUGE_info("[%s] Get the average for the half buffer %d / %d\n", __func__,
+			tmp,
+			idx1);
+	tmp = tmp/idx1;
+
+	/// [AT-PM] : Update the board offset ; 02/12/2014
+	ug31_module.set_board_offset(tmp, UG31XX_BOARD_OFFSET_NOT_FROM_UPI_BO);
+
+	board_offset_cali_avg = 0;
+	board_offset_cali_loop = 0;
+	board_offset_cali_finish = true;
+	board_offset_cali_run = false;
+}
+
+/**
+ * @brief board_offset_cali_work_func
+ *
+ *  Work for calibrate board offset
+ *
+ * @para  work  address of struct work_struct
+ * @return  NULL
+ */
+static void board_offset_cali_work_func(struct work_struct *work)
+{
+	int board_offset_cali_before;
+	int board_offset_cali_now;
+
+	/// [AT-PM] : Wake-lock for calibration ; 02/14/2014
+	if(wake_lock_active(&ug31->batt_wake_lock) != 0)
+	{
+		wake_unlock(&ug31->batt_wake_lock);
+	}
+	wake_lock_timeout(&ug31->batt_wake_lock, UG31XX_WAKE_LOCK_TIMEOUT*HZ);
+
+	/// [AT-PM] : Check charging and cable status before calibration ; 02/14/2014
+	if((is_charging() == true) )
+	{
+		start_charging();
+		GAUGE_info("[%s]: Cable is removed. (%d)\n", __func__, board_offset_cali_loop);
+
+		mutex_lock(&ug31->info_update_lock);
+		cal_avg_board_offset();
+		mutex_unlock(&ug31->info_update_lock);
+		GAUGE_err("[%s] * cancel Board offset calibration before start *\n", __func__);
+		return;
+	}
+
+	/// [AT-PM] : Board offset calibration ; 02/12/2014
+	mutex_lock(&ug31->info_update_lock);
+	board_offset_cali_before = ug31_module.get_board_offset();
+	ug31_module.calibrate_offset(UG31XX_BOARD_OFFSET_CALI_FULL);
+	board_offset_cali_now = ug31_module.get_board_offset();
+	ug31_module.set_board_offset(board_offset_cali_before, UG31XX_BOARD_OFFSET_NOT_FROM_UPI_BO);
+	mutex_unlock(&ug31->info_update_lock);
+
+	/// [AT-PM] : Check chargig and cable status after calibration ; 02/14/2014
+	if((is_charging() == true) )
+	{
+		start_charging();
+		GAUGE_info("[%s]: Cable is removed. (%d)\n", __func__, board_offset_cali_loop);
+
+		mutex_lock(&ug31->info_update_lock);
+		cal_avg_board_offset();
+		mutex_unlock(&ug31->info_update_lock);
+  GAUGE_info("[%s] Board offset calibration done\n", __func__);
+		return;
+	}
+
+	/// [AT-PM] : Accumulate calibrated board offset ; 02/14/2014
+	board_offset_cali_avg = board_offset_cali_avg + board_offset_cali_now;
+	board_offset_cali_loop = board_offset_cali_loop + 1;
+	if(board_offset_cali_loop_max == UG31XX_CALI_BO_LOOP_EOC)
+	{
+		GAUGE_info("[%s] board_offset_cali_eoc_buf[%d] = %d\n", __func__,
+				board_offset_cali_loop_eoc,
+				board_offset_cali_now);
+		board_offset_cali_eoc_buf[board_offset_cali_loop_eoc] = board_offset_cali_now;
+		board_offset_cali_loop_eoc = board_offset_cali_loop_eoc + 1;
+
+		/// [AT-PM] : Check maximum calibration loop in EOC ; 02/14/2014
+		if(board_offset_cali_loop_eoc >= UG31XX_CALI_BO_LOOP_EOC)
+		{
+			start_charging();
+			GAUGE_info("[%s] Board offset calibration at EOC done (%d)\n", __func__, board_offset_cali_loop_eoc);
+
+			mutex_lock(&ug31->info_update_lock);
+			cal_avg_board_offset_eoc();
+			mutex_unlock(&ug31->info_update_lock);
+			return;
+		}
+	}
+
+	/// [AT-PM] : Check maximum calibration loop ; 02/14/2014
+	if(board_offset_cali_loop >= board_offset_cali_loop_max)
+	{
+		start_charging();
+		GAUGE_info("[%s] Board offset calibration done (%d)\n", __func__, board_offset_cali_loop);
+
+		mutex_lock(&ug31->info_update_lock);
+		cal_avg_board_offset();
+		mutex_unlock(&ug31->info_update_lock);
+		return;
+	}
+
+	/// [AT-PM] : Wait for next calibration ; 02/14/2014
+	schedule_delayed_work(&ug31->board_offset_cali_work, UG31XX_PROBE_CHARGER_OFF_DELAY*HZ);
+	GAUGE_info("[%s] Wait %d seconds to calibrate board offset\n", __func__, UG31XX_PROBE_CHARGER_OFF_DELAY);
+
+	/// [AT-PM] : Wake lock for next calibration ; 02/14/2014
+	if(wake_lock_active(&ug31->batt_wake_lock) != 0)
+	{
+		wake_unlock(&ug31->batt_wake_lock);
+	}
+	wake_lock_timeout(&ug31->batt_wake_lock, UG31XX_PROBE_CHARGER_OFF_DELAY*HZ);
+}
+
+static void shell_timeout_work_func(struct work_struct *work)
+{
+  if(user_space_in_progress == true)
+  {
+    UG31_LOGI("[%s]: Daemon timeout\n", __func__);
+    user_space_in_progress = false;
+    mutex_unlock(&ug31->info_update_lock);
+    if(wake_lock_active(&ug31->shell_timeout_wake_lock) != 0)
+    {
+      wake_unlock(&ug31->shell_timeout_wake_lock);
+    }
+  }
+}
+
+static void shell_backup_work_func(struct work_struct *work)
+{
+  ug31xx_backup_file_status = ug31_module.shell_backup();
+
+  if((ug31xx_backup_file_status > 0) && (!(op_options & LKM_OPTIONS_FORCE_RESET)))
+  {
+    UG31_LOGE("[%s] Gauge driver version mismatched.\n", __func__);
+    op_options = op_options | LKM_OPTIONS_FORCE_RESET;
+    cancel_delayed_work_sync(&ug31->batt_info_update_work);
+    schedule_delayed_work(&ug31->batt_info_update_work, 0*HZ);
+    return;
+  }
+
+  if(ug31xx_backup_file_status < 0)
+  {
+    show_update_batt_status();
+    cancel_delayed_work_sync(&ug31->batt_info_update_work);
+    schedule_delayed_work(&ug31->batt_info_update_work, ug31->update_time*HZ);
+  }
+}
+
+static void shell_algorithm_work_func(struct work_struct *work)
+{
+	mutex_lock(&ug31->info_update_lock);
+
+	ug31_module.shell_update();
+
+	user_space_algorithm_now_fc_sts = ug31_module.get_full_charge_status();
+	#ifndef UG31XX_WAIT_CHARGER_FC
+
+		if((user_space_algorithm_prev_fc_sts == 0) && (user_space_algorithm_now_fc_sts == 1))
+		{
+			ug31_module.set_charger_full(UG31XX_TAPER_REACHED);
+		}
+
+		if((is_charging() == true) && (user_space_algorithm_now_fc_sts == -1))
+		{
+			ug31_module.set_charger_full(UG31XX_TAPER_REACHED);
+		}
+
+		if(curr_charger_full_status == true)
+		{
+			ug31_module.set_charger_full(UG31XX_CHARGER_DETECTS_FULL_STEP);
+		}
+
+	#endif  ///< end of UG31XX_WAIT_CHARGER_FC
+
+	show_update_batt_status();
+
+	if((ug31->batt_capacity != ug31->batt_capacity_last) ||
+	   (force_power_supply_change == true))
+	{
+		force_power_supply_change = false;
+
+		cancel_delayed_work_sync(&ug31->batt_power_update_work);
+		schedule_delayed_work(&ug31->batt_power_update_work, 0*HZ);
+	}
+
+	if(in_early_suspend == false)
+	{
+		ug31_module.set_capacity_suspend_mode(_UPI_FALSE_);
+	}
+
+	mutex_unlock(&ug31->info_update_lock);
+
+  calibrate_rsoc();
+
+	user_space_algorithm_response = true;
+
+	if(curr_direction_changed < 0)
+	{
+		cancel_delayed_work_sync(&ug31->batt_info_update_work);
+		batt_info_update_work_func(&ug31->batt_info_update_work.work);
+	}
+}
+
+/**
+ * @brief batt_reinitial_work_func
+ *
+ *  Retry to initial or reset gauge
+ *
+ * @para  work  address of struct work_struct
+ * @return  NULL
+ */
+static void batt_reinitial_work_func(struct work_struct *work)
+{
+	int rtn;
+  if(retry_cnt % UG31XX_RETRY_TIME != 0)
+  {
+    GAUGE_info("[%s] initial, retry count = %d\n", __func__, retry_cnt);
+    rtn = ug31_module.initial(FactoryGGBXFile, ((probe_with_cable == true) ? UG31XX_CABLE_IN : UG31XX_CABLE_OUT));
+    if(rtn != 0)
+    {
+      start_charging();
+      schedule_delayed_work(&ug31->batt_retry_work, UG31XX_RETRY_DELAY_TIME*HZ);
+    }
+    else
+    {
+      schedule_delayed_work(&ug31->batt_probe_work, 0*HZ);
+    }
+  }
+  else
+  {
+    GAUGE_info("[%s] reset, retry count = %d\n", __func__, retry_cnt);
+    rtn = ug31_module.reset(FactoryGGBXFile, true);
+    if(rtn != 0)
+    {
+      start_charging();
+      schedule_delayed_work(&ug31->batt_retry_work, UG31XX_RETRY_DELAY_TIME*HZ);
+    }
+    else
+    {
+      schedule_delayed_work(&ug31->batt_probe_work, 0*HZ);
+    }
+  }
+  retry_cnt++;
+}
+
+/**
+ * @brief batt_retry_work_func
+ *
+ *  Retry to initial gauge
+ *
+ * @para  work  address of struct work_struct
+ * @return  NULL
+ */
+static void batt_retry_work_func(struct work_struct *work)
+{
+#ifdef  UG31XX_PROBE_CHARGER_OFF
+
+  probe_with_cable = is_charging();
+
+  if(probe_with_cable == true)
+  {
+    schedule_delayed_work(&ug31->batt_reinitial_work, UG31XX_PROBE_CHARGER_OFF_DELAY*HZ);
+    GAUGE_info("[%s] Wait %d seconds to register driver %s\n", __func__, UG31XX_PROBE_CHARGER_OFF_DELAY, ug31->client->name);
+    stop_charging();
+  }
+  else
+  {
+    schedule_delayed_work(&ug31->batt_reinitial_work, 0*HZ);
+    GAUGE_info("[%s] No wait because not in charging\n", __func__);
+  }
+
+#else   ///< else of UG31XX_PROBE_CHARGER_OFF
+
+  schedule_delayed_work(&ug31->batt_reinitial_work, 0*HZ);
+
+#endif  ///< end of UG31XX_PROBE_CHARGER_OFF
+}
+
+#ifdef FEATRUE_K_BOARD_OFFSET
+/**
+ *	@brief kbo_work_func
+ *
+ *	Calibrate board offsest function in factory
+ *
+ *	@para	work	address of struct work_strut
+ *	@return	NULL
+ */
+static void kbo_work_func(struct work_struct *work)
+{
+	int board_offset;
+	int idx;
+	int tmp32 = 0;
+
+	mutex_lock(&ug31->info_update_lock);
+	ug31_module.set_cable_out(UG31XX_CABLE_IN);
+	board_offset = ug31_module.get_current_now();
+	mutex_unlock(&ug31->info_update_lock);
+
+  if((board_offset < UG31XX_KBO_PASS_MAX) && (board_offset > UG31XX_KBO_PASS_MIN))
+  {
+    if(kbo_pass_cnt < UG31XX_KBO_PASS_COUNT)
+    {
+      kbo_pass_queue[kbo_pass_cnt] = board_offset;
+
+      for(idx = 0; idx <= kbo_pass_cnt; idx++)
+      {
+        tmp32 = tmp32 + kbo_pass_queue[idx];
+      }
+      kbo_result = tmp32 / (kbo_pass_cnt + 1);
+
+      GAUGE_info("[%s]: PASS result[%d] = %d (%d)\n", __func__, kbo_pass_cnt, board_offset, kbo_result);
+
+      kbo_pass_cnt = kbo_pass_cnt + 1;
+    }
+  }
+  else
+  {
+    if(kbo_fail_cnt < UG31XX_KBO_FAIL_COUNT)
+    {
+      kbo_fail_queue[kbo_fail_cnt] = board_offset;
+
+      for(idx = 0; idx <= kbo_fail_cnt; idx++)
+      {
+        tmp32 = tmp32 + kbo_fail_queue[idx];
+      }
+      kbo_result = tmp32 / (kbo_fail_cnt + 1);
+
+      GAUGE_info("[%s]: FAIL result[%d] = %d (%d)\n", __func__, kbo_fail_cnt, board_offset, kbo_result);
+
+      kbo_fail_cnt = kbo_fail_cnt + 1;
+    }
+  }
+
+  if((kbo_pass_cnt < UG31XX_KBO_PASS_COUNT) && (kbo_fail_cnt < UG31XX_KBO_FAIL_COUNT))
+  {
+    hrtimer_start(&ug31->kbo_timer,
+      ktime_set(UG31XX_CALI_BO_FACTORY_DELAY / UG31XX_TIME_MSEC_TO_SEC,
+                (UG31XX_CALI_BO_FACTORY_DELAY % UG31XX_TIME_MSEC_TO_SEC) * UG31XX_TIME_USEC_TO_SEC),
+      HRTIMER_MODE_REL);
+  }
+}
+
+/**
+ *	@brief kbo_check_work_func
+ *
+ *	Check board offsest file existed or not
+ *
+ *	@para	work	address of struct work_strut
+ *	@return	NULL
+ */
+static void kbo_check_work_func(struct work_struct *work)
+{
+  if(kbo_file_exist == true)
+  {
+    kobj_event_env = UG31XX_KOBJ_ENV_BACKUP_BO_CHECK;
+  }
+  else
+  {
+    kobj_event_env = UG31XX_KOBJ_ENV_BACKUP_BO_INIT;
+  }
+  change_ug31xx_kobj();
+}
+
+/**
+ * @brief kbo_timer_func
+ *
+ *  Board offset calibration timer handler
+ *
+ * @para  hrtimer
+ * @return  hrtimer_restart
+ */
+static enum hrtimer_restart kbo_timer_func(struct hrtimer *timer)
+{
+  schedule_delayed_work(&ug31->kbo_work, 0);
+  return HRTIMER_NORESTART;
+}
+
+/**
+ * @brief cos_work_func
+ *
+ *  Write COS calibration result to file
+ *
+ * @para  work  address of work_struct
+ * @return  NULL
+ */
+static void cos_work_func(struct work_struct *work)
+{
+  if(cos_file_written == 0)
+  {
+    return;
+  }
+  cos_file_written = cos_file_written - 1;
+
+  if(cos_mode == true)
+  {
+    kobj_event_env = UG31XX_KOBJ_ENV_BACKUP_COS_WRITE;
+    change_ug31xx_kobj();
+  }
+
+  schedule_delayed_work(&ug31->cos_work, msecs_to_jiffies(UG31XX_CALI_BO_FACTORY_DELAY));
+}
+
+/**
+ * @brief cos_check_work_func
+ *
+ *  Check board offset in COS file existed or not
+ *
+ * @para  work  address of struct work_struct
+ * @return  NULL
+ */
+static void cos_check_work_func(struct work_struct *work)
+{
+  if(kbo_file_exist == true)
+  {
+    return;
+  }
+
+  if(cos_file_exist == true)
+  {
+    kobj_event_env = UG31XX_KOBJ_ENV_BACKUP_COS_CHECK;
+  }
+  else
+  {
+    kobj_event_env = UG31XX_KOBJ_ENV_BACKUP_COS_INIT;
+  }
+  change_ug31xx_kobj();
+}
+
+#endif ///< for FEATRUE_K_BOARD_OFFSET
+/**
+ * @brief batt_probe_work_func
+ *
+ *  Register uG31xx driver
+ *
+ * @para  work  address of struct work_struct
+ * @return  NULL
+ */
+static void batt_probe_work_func(struct work_struct *work)
+{
+	int rtn;
+	int board_offset_cali_before;
+	int board_offset_cali_now;
+#ifdef UG31XX_PROC_DEV
+	struct proc_dir_entry *ent;
+#endif  ///< end of UG31XX_PROC_DEV
+
+	ug31_module.set_options(op_options);
+	rtn = ug31_module.initial(FactoryGGBXFile, ((probe_with_cable == true) ? UG31XX_CABLE_IN : UG31XX_CABLE_OUT));
+	op_options = op_options & (~LKM_OPTIONS_FORCE_RESET);
+	if(rtn != 0)
+	{
+		goto initial_fail;
+	}
+
+	op_options = op_options | LKM_OPTIONS_ADJUST_DESIGN_CAPACITY;
+	adjust_cell_table();
+
+	ug31_module.set_shell_ap(UPI_UG31XX_SHELL_AP, strlen(UPI_UG31XX_SHELL_AP));
+	ug31_module.set_backup_file_name(UPI_UG31XX_BACKUP_FILE, strlen(UPI_UG31XX_BACKUP_FILE));
+	ug31_module.set_suspend_file_name(UPI_UG31XX_BACKUP_SUSPEND, strlen(UPI_UG31XX_BACKUP_SUSPEND));
+
+	charge_termination_current = ug31_module.get_charge_termination_current();
+	rsense_value = ug31_module.get_rsense();
+	ggb_board_offset = ug31_module.get_ggb_board_offset();
+	ntc_offset = ug31_module.get_ntc_offset();
+	standby_current = ug31_module.get_standby_current();
+	ggb_board_gain = ug31_module.get_ggb_board_gain();
+	ggb_config = ug31_module.get_ggb_config();
+  ug31_module.get_cc_chg_offset(&cc_chg_offset_25, &cc_chg_offset_50, &cc_chg_offset_75, &cc_chg_offset_100);
+	set_project_config();
+	update_project_config();
+	GAUGE_info("[%s] ug31_module initialized. (%s)\n", __func__, ug31_module.get_version());
+
+#ifdef UG31XX_SHOW_EXT_TEMP
+	ug31_module.set_battery_temp_external();
+#else  ///< else of UG31XX_SHOW_EXT_TEMP
+	ug31_module.set_battery_temp_internal();
+#endif  ///< end of UG31XX_SHOW_EXT_TEMP
+	GAUGE_info("[%s] set battery temperature from external\n", __func__);
+
+	INIT_DELAYED_WORK(&ug31->batt_info_update_work, batt_info_update_work_func);
+	INIT_DELAYED_WORK(&ug31->batt_power_update_work, batt_power_update_work_func);
+	INIT_DELAYED_WORK(&ug31->board_offset_cali_work, board_offset_cali_work_func);
+	INIT_DELAYED_WORK(&ug31->shell_algorithm_work, shell_algorithm_work_func);
+	INIT_DELAYED_WORK(&ug31->shell_backup_work, shell_backup_work_func);
+	INIT_DELAYED_WORK(&ug31->shell_timeout_work, shell_timeout_work_func);
+#ifdef FEATRUE_K_BOARD_OFFSET
+	INIT_DELAYED_WORK(&ug31->kbo_work, kbo_work_func);
+	INIT_DELAYED_WORK(&ug31->kbo_check_work, kbo_check_work_func);
+	INIT_DELAYED_WORK(&ug31->cos_work, cos_work_func);
+	INIT_DELAYED_WORK(&ug31->cos_check_work, cos_check_work_func);
+#endif ///< for FEATRUE_K_BOARD_OFFSET
+  INIT_DELAYED_WORK(&ug31->curr_check_work, curr_check_work_func);
+
+// 20141024 Tom +++++++
+        if(ug31_module.get_ntc_status() != UPI_UG31XX_NTC_NORMAL)
+        {
+                GAUGE_err("[%s] maybe no insert battery or battery thermistor abnomal\n", __func__);
+                goto pwr_supply_fail;
+        }
+// 20141024 Tom -------
+
+	if(ug31xx_powersupply_init(ug31->client))
+	{
+		goto pwr_supply_fail;
+	}
+	ug31xx_drv_status = UG31XX_DRV_INIT_OK;
+
+#ifdef	UPI_CALLBACK_FUNC
+
+	if (cur_cable_status)
+	{
+		ug31xx_cable_callback(cur_cable_status);
+	}
+
+#endif	///< end of UPI_CALLBACK_FUNC
+
+#ifdef UG31XX_MISC_DEV
+
+	rtn = misc_register(&ug31xx_misc);
+	if(rtn < 0)
+	{
+		GAUGE_err("[%s] Unable to register misc deive\n", __func__);
+		misc_deregister(&ug31xx_misc);
+	}
+
+#endif	///< end of UG31XX_MISC_DEV
+
+#ifdef UG31XX_PROC_DEV
+#if LINUX_VERSION_CODE < KERNEL_VERSION(3, 10, 0)
+	ent = create_proc_read_entry("BMSSOC", 0744, NULL, ug31xx_get_proc_rsoc, NULL );
+	if(!ent)
+	{
+		GAUGE_err("create /proc/BMSSOC fail\n");
+	}
+	ent = create_proc_read_entry("RSOC", 0744, NULL, ug31xx_get_proc_psoc, NULL );
+	if(!ent)
+	{
+		GAUGE_err("create /proc/RSOC fail\n");
+	}
+	ent = create_proc_read_entry("RM", 0744, NULL, ug31xx_get_proc_rm, NULL );
+	if(!ent)
+	{
+		GAUGE_err("create /proc/RM fail\n");
+	}
+	ent = create_proc_read_entry("FCC", 0744, NULL, ug31xx_get_proc_fcc, NULL );
+	if(!ent)
+	{
+		GAUGE_err("create /proc/FCC fail\n");
+	}
+	ent = create_proc_read_entry("bat_current", 0744, NULL, ug31xx_get_proc_curr, NULL );
+	if(!ent)
+	{
+		GAUGE_err("create /proc/bat_current fail\n");
+	}
+	ent = create_proc_read_entry("upi_60", 0744, NULL, ug31xx_get_proc_upi_60, NULL);
+	if(!ent)
+	{
+		GAUGE_err("create /proc/upi_60 fail\n");
+	}
+	ent = create_proc_read_entry("upi_2", 0744, NULL, ug31xx_get_proc_upi_2, NULL);
+	if(!ent)
+	{
+		GAUGE_err("create /proc/upi_2 fail\n");
+	}
+	ent = create_proc_read_entry("upi_auto", 0744, NULL, ug31xx_get_proc_upi_auto, NULL);
+	if(!ent)
+	{
+		GAUGE_err("create /proc/upi_auto fail\n");
+	}
+	ent = create_proc_read_entry("driver/BatTemp", 0744, NULL, ug31xx_get_proc_temp, NULL);
+	if(!ent)
+	{
+		GAUGE_err("create /proc/driver/BatTemp fail\n");
+	}
+#ifdef FEATRUE_K_BOARD_OFFSET
+	ent = create_proc_read_entry("kbo_start", 0744, NULL, ug31xx_get_proc_kbo_start, NULL);
+	if(!ent)
+	{
+		GAUGE_err("create /proc/kbo_start fail\n");
+	}
+	ent = create_proc_read_entry("kbo_result", 0744, NULL, ug31xx_get_proc_kbo_result, NULL);
+	if(!ent)
+	{
+		GAUGE_err("create /proc/kbo_result fail\n");
+	}
+	ent = create_proc_read_entry("kbo_stop", 0744, NULL, ug31xx_get_proc_kbo_stop, NULL);
+	if(!ent)
+	{
+		GAUGE_err("create /proc/kbo_stop fail\n");
+	}
+#endif ///< for FEATRUE_K_BOARD_OFFSET
+#else
+	ent = proc_create("BMSSOC", 0744, NULL, &proc_rsoc_ops);
+	if(!ent)
+	{
+		GAUGE_err("create /proc/BMSSOC fail\n");
+	}
+	ent = proc_create("RSOC", 0744, NULL, &proc_psoc_ops);
+	if(!ent)
+	{
+		GAUGE_err("create /proc/RSOC fail\n");
+	}
+	ent = proc_create("RM", 0744, NULL, &proc_rm_ops);
+	if(!ent)
+	{
+		GAUGE_err("create /proc/RM fail\n");
+	}
+	ent = proc_create("FCC", 0744, NULL, &proc_fcc_ops);
+	if(!ent)
+	{
+		GAUGE_err("create /proc/FCC fail\n");
+	}
+	ent = proc_create("bat_current", 0744, NULL, &proc_curr_ops);
+	if(!ent)
+	{
+		GAUGE_err("create /proc/bat_current fail\n");
+	}
+	ent = proc_create("upi_60", 0744, NULL, &proc_upi_60_ops);
+	if(!ent)
+	{
+		GAUGE_err("create /proc/upi_60 fail\n");
+	}
+	ent = proc_create("upi_2", 0744, NULL, &proc_upi_2_ops);
+	if(!ent)
+	{
+		GAUGE_err("create /proc/upi_2 fail\n");
+	}
+	ent = proc_create("upi_auto", 0744, NULL, &proc_upi_auto_ops);
+	if(!ent)
+	{
+		GAUGE_err("create /proc/upi_auto fail\n");
+	}
+	ent = proc_create("driver/BatTemp", 0744, NULL, &proc_temp_ops);
+	if(!ent)
+	{
+		GAUGE_err("create /proc/driver/BatTemp fail\n");
+	}
+#ifdef  FEATRUE_K_BOARD_OFFSET
+	ent = proc_create("kbo_start", 0744, NULL, &kbo_start_ops);
+	if(!ent)
+	{
+		GAUGE_err("create /proc/kbo_start fail\n");
+	}
+	ent = proc_create("kbo_result", 0744, NULL, &kbo_result_ops);
+	if(!ent)
+	{
+		GAUGE_err("create /proc/kbo_result fail\n");
+	}
+	ent = proc_create("kbo_stop", 0744, NULL, &kbo_stop_ops);
+	if(!ent)
+	{
+		GAUGE_err("create /proc/kbo_stop fail\n");
+	}
+#endif  ///< end of FEATRUE_K_BOARD_OFFSET
+	ent = proc_create("read_battery_soh", 0744, NULL, &proc_battery_soh_ops);
+        if(!ent)
+	{
+		GAUGE_err("create /proc/proc_battery_soh_ops fail\n");
+	}
+#endif
+#endif	///< end of UG31XX_PROC_DEV
+
+	/* request charger driver to update "power supply changed" */
+	//tan request_power_supply_changed();
+	//power_supply_changed(&ug31xx_supply[PWR_SUPPLY_BATTERY]);//tan#
+
+	/* register switch device for battery information versions report */
+	batt_dev.name = "battery";
+	batt_dev.print_name = batt_switch_name;
+	if (switch_dev_register(&batt_dev) < 0) {
+		GAUGE_err("%s: fail to register battery switch\n", __func__);
+		goto pwr_supply_fail;
+	}
+	ug31xx_config_earlysuspend(ug31);
+
+	schedule_delayed_work(&ug31->batt_info_update_work, 0*HZ);
+
+	force_power_supply_change = true;
+	ug31xx_probe_done = true;
+	GAUGE_info("[%s] Driver %s registered done\n", __func__, ug31->client->name);
+   if(probe_with_cable == true)
+	{
+		start_charging();
+	}
+	return;
+
+pwr_supply_fail:
+	start_charging();
+	kfree(ug31);
+	return;
+
+initial_fail:
+	start_charging();
+	show_abnormal_batt_status_for_retry();
+	ug31xx_powersupply_init(ug31->client);
+	schedule_delayed_work(&ug31->batt_retry_work, UG31XX_RESET_DELAY_TIME*HZ);
+	return;
+}
+
+/**
+ * @brief stop_charging_work_func
+ *
+ *  Stop charging
+ *
+ * @para  work  address of struct work_struct
+ * @return  NULL
+ */
+static void stop_charging_work_func(struct work_struct *work)
+{
+	stop_charging();
+	schedule_delayed_work(&ug31->batt_probe_work, UG31XX_PROBE_CHARGER_OFF_DELAY*HZ);
+	return;
+}
+
+static int ug31xx_i2c_probe(struct i2c_client *client,
+				      const struct i2c_device_id *id)
+{
+	struct i2c_adapter *adapter = to_i2c_adapter(client->dev.parent);
+
+	pr_info("<BATT> ++++++++++++++++ %s ++++++++++++++++\n", __func__);
+	if (!i2c_check_functionality(adapter, I2C_FUNC_SMBUS_BYTE))
+	{
+		return -EIO;
+	}
+
+	Status = is_COS();
+
+	ug31 = kzalloc(sizeof(*ug31), GFP_KERNEL);
+	if (!ug31)
+	{
+		return -ENOMEM;
+	}
+
+	show_default_batt_status();
+
+	ug31->client = client;
+	ug31->dev = &client->dev;
+	sprintf(ug31->daemon_ver, "UPI");
+	ug31->daemon_uevent_count = 0;
+
+	i2c_set_clientdata(client, ug31);
+	API_I2C_Init(ug31->client);
+
+	mutex_init(&ug31->info_update_lock);
+	wake_lock_init(&ug31->batt_wake_lock, WAKE_LOCK_SUSPEND, "ug31xx_driver_update");
+	wake_lock_init(&ug31->shell_algorithm_wake_lock, WAKE_LOCK_SUSPEND, "ug31xx_shell_algorithm");
+	wake_lock_init(&ug31->shell_timeout_wake_lock, WAKE_LOCK_SUSPEND, "ug31xx_shell_timeout");
+#ifdef UG31XX_WAKEUP_ALARM
+  	ug31->last_poll = alarm_get_elapsed_realtime();
+	alarm_init(&ug31->wakeup_alarm, ANDROID_ALARM_ELAPSED_REALTIME_WAKEUP,
+		ug31xx_gauge_alarm);
+#endif ///< end of UG31XX_WAKEUP_ALARM
+  /// [FC] : Add timer to handle kbo delay ; 04/10/2014
+  hrtimer_init(&ug31->kbo_timer, CLOCK_MONOTONIC, HRTIMER_MODE_REL);
+  ug31->kbo_timer.function = kbo_timer_func;
+
+  get_ggb_array();
+
+	INIT_DELAYED_WORK(&ug31->batt_probe_work, batt_probe_work_func);
+	INIT_DELAYED_WORK(&ug31->batt_retry_work, batt_retry_work_func);
+	INIT_DELAYED_WORK(&ug31->batt_reinitial_work, batt_reinitial_work_func);
+  INIT_DELAYED_WORK(&ug31->stop_charging_work, stop_charging_work_func);
+  INIT_DELAYED_WORK(&ug31->curr_check_work, curr_check_work_func);
+
+#ifdef  UG31XX_PROBE_CHARGER_OFF
+
+	probe_with_cable = is_charging();
+
+	if(probe_with_cable == true)
+	{
+		schedule_delayed_work(&ug31->stop_charging_work, UG31XX_PROBE_CHARGER_OFF_DELAY*HZ);
+		GAUGE_info("[%s] Wait %d seconds to register driver %s\n", __func__, UG31XX_PROBE_CHARGER_OFF_DELAY, ug31->client->name);
+	}
+	else
+	{
+		schedule_delayed_work(&ug31->batt_probe_work, 0*HZ);
+		GAUGE_info("[%s] No wait because not in charging\n", __func__);
+	}
+
+#else   ///< else of UG31XX_PROBE_CHARGER_OFF
+
+	schedule_delayed_work(&ug31->batt_probe_work, 0*HZ);
+
+#endif  ///< end of UG31XX_PROBE_CHARGER_OFF
+
+	return 0;
+}
+
+static int ug31xx_i2c_remove(struct i2c_client *client)
+{
+	struct ug31xx_gauge *ug31_dev;
+
+	#ifdef  UG31XX_REGISTER_POWERSUPPLY
+
+  	int i;
+
+	#endif  ///< end of UG31XX_REGISTER_POWERSUPPLY
+
+	if(ug31xx_drv_status == UG31XX_DRV_NOT_READY)
+	{
+		GAUGE_err("[%s] Gauge driver not init finish\n", __func__);
+		return (0);
+	}
+
+	mutex_lock(&ug31->info_update_lock);
+	wake_lock_destroy(&ug31->batt_wake_lock);
+	wake_lock_destroy(&ug31->shell_algorithm_wake_lock);
+	wake_lock_destroy(&ug31->shell_timeout_wake_lock);
+
+	#ifdef  UG31XX_REGISTER_POWERSUPPLY
+
+	for (i = 0; i < ARRAY_SIZE(ug31xx_supply); i++)
+	{
+		power_supply_unregister(&ug31xx_supply[i]);
+	}
+
+	#endif  ///< end of UG31XX_REGISTER_POWERSUPPLY
+
+	#ifdef UG31XX_MISC_DEV
+
+	misc_deregister(&ug31xx_misc);
+
+	#endif	///< end of UG31XX_MISC_DEV
+
+	#ifdef UG31XX_PROC_DEV
+
+	remove_proc_entry( "RSOC",NULL );
+	remove_proc_entry( "PSOC",NULL );
+	remove_proc_entry( "RM",NULL );
+	remove_proc_entry( "FCC",NULL );
+	remove_proc_entry( "bat_current",NULL );
+	remove_proc_entry( "upi_60", NULL );
+	remove_proc_entry( "upi2", NULL );
+	remove_proc_entry( "upi_auto", NULL );
+#ifdef FEATRUE_K_BOARD_OFFSET
+	remove_proc_entry( "kbo_start", NULL );
+	remove_proc_entry( "kbo_result", NULL );
+	remove_proc_entry( "kbo_stop", NULL );
+#endif ///< for FEATRUE_K_BOARD_OFFSET
+
+	#endif	///< end of UG31XX_PROC_DEV
+
+	cancel_delayed_work_sync(&ug31->batt_info_update_work);
+	cancel_delayed_work_sync(&ug31->batt_power_update_work);
+
+	ug31_module.uninitial();
+	GAUGE_info("[%s] Driver removed.\n", __func__);
+
+	ug31_dev = i2c_get_clientdata(client);
+	if(ug31_dev)
+	{
+		kfree(ug31_dev);
+	}
+
+	mutex_unlock(&ug31->info_update_lock);
+	mutex_destroy(&ug31->info_update_lock);
+
+	if(ug31)
+	{
+		kfree(ug31);
+	}
+	return 0;
+}
+
+static int ug31xx_i2c_suspend(struct i2c_client *client, pm_message_t mesg)
+{
+	int gg_status;
+
+	if(ug31xx_drv_status == UG31XX_DRV_NOT_READY)
+	{
+		GAUGE_err("[%s] Gauge driver not init finish\n", __func__);
+		return (0);
+	}
+
+	op_actions = UG31XX_OP_SUSPEND;
+	kobj_event_env = UG31XX_KOBJ_ENV_UPDATE_CAPACITY;
+	change_ug31xx_kobj();
+
+	cancel_delayed_work_sync(&ug31->batt_info_update_work);
+
+	#if !(defined(CONFIG_HAS_EARLYSUSPEND) && defined(UG31XX_EARLY_SUSPEND))
+
+	mutex_lock(&ug31->info_update_lock);
+	ug31_module.set_backup_file(false);
+	mutex_unlock(&ug31->info_update_lock);
+
+	charger_dc_in_before_suspend = is_charging();
+
+	mutex_lock(&ug31->info_update_lock);
+	gg_status = ug31_module.suspend((charger_dc_in_before_suspend == true) ? 1 : 0);
+	if(gg_status == 0)
+	{
+		show_update_batt_status();
+		GAUGE_info("[%s] Driver suspend.\n", __func__);
+	}
+	else
+	{
+		show_abnormal_batt_status();
+		GAUGE_err("[%s] Fail in suspend.\n", __func__);
+	}
+	rsoc_before_suspend = ug31_module.get_predict_rsoc();
+	mutex_unlock(&ug31->info_update_lock);
+
+	#endif	///< end of defined(CONFIG_HAS_EARLYSUSPEND) && defined(UG31XX_EARLY_SUSPEND)
+
+	mutex_lock(&ug31->info_update_lock);
+	gg_status = ug31_module.set_capacity_suspend_mode(_UPI_TRUE_);
+  /// Setting wakeup alarm
+#ifdef UG31XX_WAKEUP_ALARM
+	ug31->last_poll = alarm_get_elapsed_realtime();
+	ug31xx_program_alarm(UG31XX_WAKEUP_ALARM_TIME);
+#endif ///< end of UG31XX_WAKEUP_ALARM
+	mutex_unlock(&ug31->info_update_lock);
+
+	ug31xx_drv_status = UG31XX_DRV_SUSPEND;
+	GAUGE_info("[%s] ug31xx_i2c_suspend() end\n", __func__);
+	return 0;
+}
+
+static int ug31xx_i2c_resume(struct i2c_client *client)
+{
+	#if !(defined(CONFIG_HAS_EARLYSUSPEND) && defined(UG31XX_EARLY_SUSPEND))
+
+	int gg_status;
+	int prev_fc_sts;
+	int now_fc_sts;
+	bool charger_dc_in_after_resume;
+	int prev_rsoc;
+
+	if(ug31xx_drv_status == UG31XX_DRV_NOT_READY)
+	{
+		GAUGE_err("[%s] Gauge driver not init finish\n", __func__);
+		return (0);
+	}
+
+	op_actions = UG31XX_OP_RESUME;
+	kobj_event_env = UG31XX_KOBJ_ENV_UPDATE_CAPACITY;
+	change_ug31xx_kobj();
+  curr_check_work_func(&ug31->curr_check_work.work);
+
+	charger_dc_in_after_resume = is_charging();
+
+	mutex_lock(&ug31->info_update_lock);
+	prev_fc_sts = ug31_module.get_full_charge_status();
+	prev_rsoc = rsoc_before_suspend;
+	gg_status = ug31_module.resume((user_space_algorithm_response == true) ? UG31XX_USER_SPACE_RESPONSE : UG31XX_USER_SPACE_NO_RESPONSE);
+	delta_q_in_suspend = delta_q_in_suspend + ug31_module.get_delta_q();
+	now_fc_sts = ug31_module.get_full_charge_status();
+	if(gg_status == 0)
+	{
+		if(charger_detect_full == true)
+		{
+			charger_detect_full = false;
+			gg_status = ug31_module.set_charger_full(UG31XX_CHARGER_DETECTS_FULL_STEP);
+		}
+
+		#ifndef UG31XX_WAIT_CHARGER_FC
+
+		if(charger_dc_in_before_suspend == false)
+		{
+			GAUGE_info("[%s] Enter suspend without charger\n", __func__);
+		}
+		else
+		{
+			GAUGE_info("[%s] Enter suspend with charger\n", __func__);
+			if((prev_fc_sts == 0) && (now_fc_sts == 1))
+			{
+				gg_status = ug31_module.set_charger_full(UG31XX_CHARGER_DETECTS_FULL_STEP);
+				curr_charger_full_status = is_charging_full();
+				GAUGE_info("[%s] [FC] status changed (0->1)\n", __func__);
+			}
+			else
+			{
+				if(charger_dc_in_after_resume == false)
+				{
+					GAUGE_info("[%s] Exit suspend without charger\n", __func__);
+					prev_rsoc = (100 - prev_rsoc)*(ug31_module.get_design_capacity())/100;
+					if(delta_q_in_suspend > prev_rsoc)
+					{
+						GAUGE_info("[%s] Charged capacity is enouth to check full charged (%d) > (%d)\n", __func__, delta_q_in_suspend, prev_rsoc);
+
+						if(ug31_module.get_predict_rsoc() > 90)
+						{
+							gg_status = ug31_module.set_charger_full(UG31XX_CHARGER_DETECTS_FULL_STEP);
+							GAUGE_info("[%s] Set to full charge status\n", __func__);
+						}
+					}
+				}
+				else
+				{
+					GAUGE_info("[%s] Exit suspend with charger\n", __func__);
+					curr_charger_full_status = is_charging_full();
+					if(curr_charger_full_status == true)
+					{
+						GAUGE_info("[%s] Charger detects full\n", __func__);
+						gg_status = ug31_module.set_charger_full(UG31XX_CHARGER_DETECTS_FULL_STEP);
+						GAUGE_info("[%s] Set to full charge status\n", __func__);
+					}
+					else
+					{
+						prev_rsoc = (100 - prev_rsoc)*(ug31_module.get_design_capacity())/100;
+						if(delta_q_in_suspend > prev_rsoc)
+						{
+							GAUGE_info("[%s] Charged capacity is enouth to check full charged (%d) > (%d)\n", __func__, delta_q_in_suspend, prev_rsoc);
+							if(ug31_module.get_predict_rsoc() > 95)
+							{
+								gg_status = ug31_module.set_charger_full(UG31XX_CHARGER_DETECTS_FULL_STEP);
+								GAUGE_info("[%s] Set to full charge status\n", __func__);
+							}
+						}
+					}
+				}
+			}
+		}
+
+		#endif  ///< end of UG31XX_WAIT_CHARGER_FC
+
+		if(gg_status == 0)
+		{
+			show_update_batt_status();
+			GAUGE_info("[%s] Gauge resumed.\n", __func__);
+		}
+		else
+		{
+			show_abnormal_batt_status();
+			GAUGE_err("[%s] Fail to set charger full.\n", __func__);
+		}
+	}
+	else
+	{
+		show_abnormal_batt_status();
+		GAUGE_err("[%s] Fail to resume.\n", __func__);
+	}
+	mutex_unlock(&ug31->info_update_lock);
+
+	schedule_delayed_work(&ug31->batt_info_update_work, 0*HZ);
+
+  calibrate_rsoc_request = true;
+  #ifndef UG31XX_USER_SPACE_ALGORITHM
+  calibrate_rsoc();
+  #endif  ///< end of UG31XX_USER_SPACE_ALGORITHM
+
+	force_power_supply_change = true;
+
+	#else   ///< else of defined(CONFIG_HAS_EARLYSUSPEND) && defined(UG31XX_EARLY_SUSPEND)
+
+	int time_interval;
+	int predict_rsoc;
+
+	if(ug31xx_drv_status == UG31XX_DRV_NOT_READY)
+	{
+		GAUGE_err("[%s] Gauge driver not init finish\n", __func__);
+		return (0);
+	}
+
+	op_actions = UG31XX_OP_RESUME;
+	kobj_event_env = UG31XX_KOBJ_ENV_UPDATE_CAPACITY;
+	change_ug31xx_kobj();
+  curr_check_work_func(&ug31->curr_check_work.work);
+
+	curr_charger_full_status = is_charging_full();
+	if(curr_charger_full_status == true)
+	{
+		charger_detect_full = true;
+	}
+
+	mutex_lock(&ug31->info_update_lock);
+	time_interval = ug31_module.get_update_interval();
+	predict_rsoc = ug31_module.get_predict_rsoc();
+	mutex_unlock(&ug31->info_update_lock);
+	if(cable_status_changed > 0)
+	{
+		GAUGE_info("[%s]: cable status changed (%d) -> schedule batt_info_update_work for %d seconds\n", __func__,
+					cable_status_changed,
+					ug31->update_time);
+		cable_status_changed = 0;
+		schedule_delayed_work(&ug31->batt_info_update_work, ug31->update_time*HZ);
+	}
+	else
+	{
+		if(time_interval > MAX_BATTERY_UPDATE_INTERVAL)
+		{
+			batt_info_update_work_func(&ug31->batt_info_update_work.work);
+			GAUGE_info("[%s]: time interval = %d > %d -> re-schedule batt_info_update_work.\n", __func__,
+				time_interval,
+				MAX_BATTERY_UPDATE_INTERVAL);
+		}
+		else if((predict_rsoc < BUSY_BATTERY_UPDATE_RSOC_LOW) &&
+			(time_interval > ug31->update_time))
+		{
+			batt_info_update_work_func(&ug31->batt_info_update_work.work);
+			GAUGE_info("[%s]: predict rsoc = %d < %d and time interval = %d > %d -> re-schedule batt_info_update_work", __func__,
+				predict_rsoc,
+				BUSY_BATTERY_UPDATE_RSOC_LOW,
+				time_interval,
+				ug31->update_time);
+		}
+		else if((predict_rsoc > BUSY_BATTERY_UPDATE_RSOC_HIGH) &&
+			(time_interval > ug31->update_time))
+		{
+			batt_info_update_work_func(&ug31->batt_info_update_work.work);
+			GAUGE_info("[%s]: predict rsoc = %d > %d and time interval = %d > %d -> re-schedule batt_info_update_work", __func__,
+				predict_rsoc,
+				BUSY_BATTERY_UPDATE_RSOC_HIGH,
+				time_interval,
+				ug31->update_time);
+		}
+		else
+		{
+			schedule_delayed_work(&ug31->batt_info_update_work, ug31->update_time*HZ);
+			GAUGE_info("[%s]: time interval = %d <= %d -> schedule batt_info_update_work for %d seconds\n", __func__,
+						time_interval,
+						MAX_BATTERY_UPDATE_INTERVAL,
+						ug31->update_time);
+		}
+	}
+
+        #ifndef UG31XX_USER_SPACE_ALGORITHM
+		mutex_lock(&ug31->info_update_lock);
+		ug31_module.set_capacity_suspend_mode(_UPI_FALSE_);
+		mutex_unlock(&ug31->info_update_lock);
+        #endif  ///< end of UG31XX_USER_SPACE_ALGORITHM
+
+	#endif	///< end of defined(CONFIG_HAS_EARLYSUSPEND) && defined(UG31XX_EARLY_SUSPEND)
+
+	ug31xx_drv_status = UG31XX_DRV_INIT_OK;
+
+	GAUGE_info("[%s] ug31xx_i2c_resume() end\n", __func__);
+	return 0;
+}
+
+static void ug31xx_i2c_shutdown(struct i2c_client *client)
+{
+	int gg_status = 0;
+
+	if(ug31xx_drv_status == UG31XX_DRV_NOT_READY)
+	{
+		GAUGE_err("[%s] Gauge driver not init finish\n", __func__);
+		return;
+	}
+
+	cancel_delayed_work_sync(&ug31->batt_info_update_work);
+	cancel_delayed_work_sync(&ug31->batt_power_update_work);
+	cancel_delayed_work_sync(&ug31->board_offset_cali_work);
+	cancel_delayed_work_sync(&ug31->shell_algorithm_work);
+	cancel_delayed_work_sync(&ug31->shell_backup_work);
+	cancel_delayed_work_sync(&ug31->shell_timeout_work);
+#ifdef FEATRUE_K_BOARD_OFFSET
+	cancel_delayed_work_sync(&ug31->kbo_work);
+	cancel_delayed_work_sync(&ug31->kbo_check_work);
+	cancel_delayed_work_sync(&ug31->cos_work);
+	cancel_delayed_work_sync(&ug31->cos_check_work);
+#endif ///< for FEATRUE_K_BOARD_OFFSET
+  cancel_delayed_work_sync(&ug31->curr_check_work);
+	mutex_lock(&ug31->info_update_lock);
+	gg_status = ug31_module.shutdown();
+	if(gg_status == 0)
+	{
+		show_update_batt_status();
+		GAUGE_info("[%s] Gauge driver shutdown.\n", __func__);
+	}
+	else
+	{
+		show_abnormal_batt_status();
+		GAUGE_err("[%s] Fail to shutdown gauge.\n", __func__);
+	}
+	mutex_unlock(&ug31->info_update_lock);
+	GAUGE_info("[%s] Driver shutdown. gg_status=0x%02x\n", __func__, gg_status);
+}
+
+static const struct i2c_device_id ug31xx_i2c_id[] = {
+	{ "UPIG3105", 0 },
+	{ },
+};
+
+MODULE_DEVICE_TABLE(i2c, ug31xx_i2c_id);
+
+//Carlisle add for match via ACPI +++
+#ifdef CONFIG_ACPI
+static struct acpi_device_id ug31xx_acpi_match[] = {
+	{"UPIG3105", 0},
+	{}
+};
+MODULE_DEVICE_TABLE(acpi, ug31xx_acpi_match);
+#endif
+//Carlisle add for match via ACPI ---
+
+static struct i2c_driver ug31xx_i2c_driver = {
+	.driver    = {
+		.name  = UG31XX_DEV_NAME,
+		.owner = THIS_MODULE,
+//Carlisle add for match via ACPI +++
+#ifdef CONFIG_ACPI
+		.acpi_match_table = ACPI_PTR(ug31xx_acpi_match),
+#endif
+//Carlisle add for match via ACPI ---
+	},
+	.probe     = ug31xx_i2c_probe,
+	.remove    = ug31xx_i2c_remove,
+	.suspend   = ug31xx_i2c_suspend,
+	.resume    = ug31xx_i2c_resume,
+	.shutdown  = ug31xx_i2c_shutdown,
+	.id_table  = ug31xx_i2c_id,
+};
+
+#ifdef	UG31XX_REGISTER_I2C
+
+static struct i2c_board_info ug31xx_i2c_board_info = {
+	.type          = "ug31xx-gauge",
+	.flags         = 0x00,
+	.addr          = 0x70,
+	.platform_data = NULL,
+	.archdata      = NULL,
+	.irq           = -1,
+};
+
+
+#define	UG31XX_I2C_ADAPTER	(1)
+
+static struct i2c_client *i2c_client;
+static struct i2c_adapter *i2c_adap;
+
+#endif	///< end of UG31XX_REGISTER_I2C
+
+static int __init ug31xx_i2c_init(void)
+{
+	int ret = 0;
+
+	//Tom if (entry_mode == 5) return -1;
+	//Tom hwid = Read_HW_ID();	ok
+	pr_info("<BATT> ++++++++++++++++ %s ++++++++++++++++\n", __func__);
+
+	#ifdef	UG31XX_REGISTER_I2C
+		i2c_adap = i2c_get_adapter(UG31XX_I2C_ADAPTER);
+		if (!i2c_adap)
+		{
+			GAUGE_err("[%s] Cannot get i2c adapter %d\n", __func__, UG31XX_I2C_ADAPTER);
+			ret = -ENODEV;
+			goto err1;
+		}
+
+
+		i2c_client = i2c_new_device(i2c_adap, &ug31xx_i2c_board_info);
+		if (!i2c_client) {
+			GAUGE_err("[%s] Unable to add I2C device for 0x%x\n", __func__,
+				   ug31xx_i2c_board_info.addr);
+			ret = -ENODEV;
+			goto err2;
+		}
+	#endif	///< end of UG31XX_REGISTER_I2C
+
+	ret =  i2c_add_driver(&ug31xx_i2c_driver);
+	if (ret)
+	{
+		#ifdef	UG31XX_REGISTER_I2C
+			goto err3;
+		#else	///< else of UG31XX_REGISTER_I2C
+			goto err1;
+		#endif	///< end of UG31XX_REGISTER_I2C
+	}
+
+	create_ug31xx_kobj();
+
+	return 0;
+
+#ifdef	UG31XX_REGISTER_I2C
+err3:
+	i2c_unregister_device(i2c_client);
+err2:
+	i2c_put_adapter(i2c_adap);
+#endif	///< end of UG31XX_REGISTER_I2C
+err1:
+	return ret;
+}
+module_init(ug31xx_i2c_init);
+
+static void __exit ug31xx_i2c_exit(void)
+{
+	#ifdef	UG31XX_REGISTER_I2C
+		i2c_put_adapter(i2c_adap);
+	#endif	///< end of UG31XX_REGISTER_I2C
+	i2c_del_driver(&ug31xx_i2c_driver);
+	#ifdef	UG31XX_REGISTER_I2C
+		i2c_unregister_device(i2c_client);
+	#endif	///< end of UG31XX_REGISTER_I2C
+
+	destroy_ug31xx_kobj();
+}
+module_exit(ug31xx_i2c_exit);
+
+MODULE_DESCRIPTION("ug31xx gauge driver");
+MODULE_LICENSE("GPL");
+
+module_param(op_options, byte, 0644);
+MODULE_PARM_DESC(op_options, "Set operation options for uG31xx driver.");
+module_param(design_capacity, ushort, 0644);
+MODULE_PARM_DESC(design_capacity, "Set new design capacity for uG31xx driver.");
+module_param(kbo_result, int, 0644);
+MODULE_PARM_DESC(kbo_result, "Set board offset for uG31xx driver.");
+module_param(charge_termination_current, int, 0644);
+MODULE_PARM_DESC(charge_termination_current, "Set charge termination current for uG31xx driver.");
+module_param(rsense_value, int, 0644);
+MODULE_PARM_DESC(rsense_value, "Set RSense resistance for uG31xx driver");
+module_param(ggb_board_offset, int, 0644);
+MODULE_PARM_DESC(ggb_board_offset, "Set board offset in GGB file");
+module_param(ntc_offset, int, 0644);
+MODULE_PARM_DESC(ntc_offset, "Set NTC offset");
+module_param(standby_current, int, 0644);
+MODULE_PARM_DESC(standby_current, "Set current for suspend mode.");
+module_param(ggb_board_gain, int, 0644);
+MODULE_PARM_DESC(ggb_board_gain, "Set board gain in GGB file");
+module_param(ggb_config, uint, 0644);
+MODULE_PARM_DESC(ggb_config, "Set config in GGB file");
+module_param(force_fc_current_thrd, uint, 0644);
+MODULE_PARM_DESC(force_fc_current_thrd, "Set force FC current threshold");
+module_param(force_fc_timeout, uint, 0644);
+MODULE_PARM_DESC(force_fc_timeout, "Set force FC timeout threshold");
+module_param(cc_chg_offset_25, uint, 0644);
+MODULE_PARM_DESC(cc_chg_offset_25, "Set CC mode charging offset below 25%");
+module_param(cc_chg_offset_50, uint, 0644);
+MODULE_PARM_DESC(cc_chg_offset_50, "Set CC mode charging offset below 50%");
+module_param(cc_chg_offset_75, uint, 0644);
+MODULE_PARM_DESC(cc_chg_offset_75, "Set CC mode charging offset below 75%");
+module_param(cc_chg_offset_100, uint, 0644);
+MODULE_PARM_DESC(cc_chg_offset_100, "Set CC mode charging offset below 100%");
+module_param(cali_rsoc_time, int, 0644);
+MODULE_PARM_DESC(cali_rsoc_time, "Set time threshold for calibrating rsoc");
+
diff --git a/drivers/power/supply/ASUS_BATTERY/ME176C/ug31xx/ug31xx_gauge.h b/drivers/power/supply/ASUS_BATTERY/ME176C/ug31xx/ug31xx_gauge.h
new file mode 100644
index 000000000000..7441ff3a4ee0
--- /dev/null
+++ b/drivers/power/supply/ASUS_BATTERY/ME176C/ug31xx/ug31xx_gauge.h
@@ -0,0 +1,213 @@
+/*
+ * Copyright (c) 2012, uPI Semiconductor Corp. All Rights Reserved.
+ */
+
+#ifndef __UPI_ug31xx_GAUGE_H
+#define __UPI_ug31xx_GAUGE_H
+
+#define UG31XX_DEV_NAME        "ug31xx-gauge"
+
+typedef enum {
+ 	UG31XX_DRV_NOT_READY = 0,
+ 	UG31XX_DRV_INIT_OK,
+ 	UG31XX_DRV_SUSPEND,
+} ug31xx_drv_status_t;
+
+typedef enum {
+  UG31XX_GPIO_1 = 0,
+  UG31XX_GPIO_2,
+  UG31XX_GPIO_3,
+  UG31XX_GPIO_4,
+} ug31xx_gpio_idx_t;
+
+typedef enum {
+  UG31XX_GPIO_STS_LOW = 0,
+  UG31XX_GPIO_STS_HIGH,
+  UG31XX_GPIO_STS_UNKNOWN,
+} ug31xx_gpio_status_t;
+
+#define UPI_UG31XX_SHELL_AP         ("/system/bin/upi_gg_ctl")
+#define	UPI_UG31XX_BACKUP_FILE		  ("/sdcard/upi_gg")
+#define UPI_UG31XX_BACKUP_SUSPEND   ("/sdcard/upi_table")
+#define	UPI_UG31XX_MODULE_READY		  (1)
+#define	UPI_UG31XX_MODULE_NOT_READY	(0)
+#define	UPI_UG31XX_BATTERY_REMOVED	(1)
+#define	UPI_UG31XX_BATTERY_INSERTED	(0)
+#define	UPI_UG31XX_ALARM_STATUS_UV	(1<<0)
+#define	UPI_UG31XX_ALARM_STATUS_UET	(1<<1)
+#define	UPI_UG31XX_ALARM_STATUS_OET	(1<<2)
+#define UPI_UG31XX_NTC_NORMAL       (0)
+#define UPI_UG31XX_NTC_OPEN         (1)
+#define UPI_UG31XX_NTC_SHORT        (2)
+
+#ifndef _LKM_OPTIONS_
+
+#define _LKM_OPTIONS_
+#define LKM_OPTIONS_FORCE_RESET             (1<<0)
+#define LKM_OPTIONS_ENABLE_SUSPEND_DATA_LOG (1<<1)
+#define LKM_OPTIONS_ENABLE_DEBUG_LOG        (3<<2)
+  #define LKM_OPTIONS_DEBUG_ERROR           (0<<2)
+  #define LKM_OPTIONS_DEBUG_INFO            (1<<2)
+  #define LKM_OPTIONS_DEBUG_NOTICE          (2<<2)
+  #define LKM_OPTIONS_DEBUG_DEBUG           (3<<2)
+#define LKM_OPTIONS_ENABLE_REVERSE_CURRENT  (1<<4)
+#define LKM_OPTIONS_ADJUST_DESIGN_CAPACITY  (1<<5)
+#define LKM_OPTIONS_DISABLE_BACHUP_FILE     (1<<6)
+#define LKM_OPTIONS_FORCE_RESET_TOTALLY     (1<<7)
+
+#endif  ///< end of _LKM_OPTIONS_
+
+#define UG31XX_KOBJ_CMD1A     (1<<0)
+#define UG31XX_KOBJ_CMD1B     (1<<1)
+#define UG31XX_KOBJ_CMD1C     (1<<2)
+#define UG31XX_KOBJ_CMD1D     (1<<3)
+#define UG31XX_KOBJ_CMD1E     (1<<4)
+#define UG31XX_KOBJ_CMD2      (1<<5)
+#define UG31XX_KOBJ_CMD3      (1<<6)
+#define UG31XX_KOBJ_CMD4      (1<<7)
+#define UG31XX_KOBJ_CMD5      (1<<8)
+#define UG31XX_KOBJ_CMD6      (1<<9)
+#define UG31XX_KOBJ_CMD7      (1<<10)
+#define UG31XX_KOBJ_CMD8      (1<<11)
+#define UG31XX_KOBJ_CMD9      (1<<12)
+
+struct ug31xx_module_interface {
+	int (*initial)(char *ggb, unsigned char cable);
+	int (*uninitial)(void);
+	int (*suspend)(char dc_in);
+	int (*resume)(char user_space_response);
+	int (*shutdown)(void);
+	int (*update)(char user_space_response);
+	int (*reset)(char *ggb, char keep_rsoc);
+
+	int (*shell_update)(void);
+	unsigned char * (*shell_memory)(int *mem_size);
+	int (*shell_backup)(void);
+	unsigned char * (*shell_backup_memory)(int *mem_size);
+	unsigned char * (*shell_table_memory)(int *mem_size);
+	unsigned char * (*shell_table_buf_memory)(int *mem_size);
+
+	int (*get_voltage)(void);
+	int (*get_voltage_now)(void);
+	int (*get_current)(void);
+	int (*get_current_now)(void);
+	int (*get_external_temperature)(void);
+	int (*get_external_temperature_now)(void);
+	int (*get_internal_temperature)(void);
+	int (*get_internal_temperature_now)(void);
+	int (*get_remaining_capacity)(void);
+	int (*get_full_charge_capacity)(void);
+	int (*get_relative_state_of_charge)(void);
+	char * (*get_version)(void);
+	int (*get_polling_time)(void);
+	int (*get_module_ready)(void);
+	int (*get_battery_removed)(void);
+	int (*get_alarm_status)(void);
+	int (*get_charge_termination_current)(void);
+	int (*get_charge_termination_voltage)(void);
+	int (*get_full_charge_status)(void);
+	int (*get_design_capacity)(void);
+	int (*get_rsense)(void);
+	int (*get_predict_rsoc)(void);
+	int (*get_gpio)(ug31xx_gpio_idx_t gpio);
+	int (*get_cycle_count)(void);
+	int (*get_avg_external_temperature)(void);
+	int (*get_ntc_status)(void);
+	unsigned char * (*get_backup_buffer)(int *size);
+	unsigned char (*get_backup_daemon_cntl)(void);
+	unsigned char (*get_backup_daemon_period)(void);
+	int (*get_update_interval)(void);
+	int (*get_update_time)(void);
+	int (*get_board_offset)(void);
+	int (*get_delta_q)(void);
+	int (*get_ggb_board_offset)(void);
+	int (*get_ntc_offset)(void);
+	int (*get_cumulative_capacity)(void);
+	int (*get_standby_current)(void);
+	int (*get_ggb_board_gain)(void);
+	unsigned int (*get_ggb_config)(void);
+	unsigned char (*get_decimate_rst_sts)(void);
+  int (*get_delta_time)(void);
+  void (*get_cc_chg_offset)(unsigned int *offset_25, unsigned int *offset_50, unsigned int *offset_75, unsigned int *offset_100);
+  int (*get_suspend_time)(void);
+  int (*get_table_rsoc)(void);
+
+	int (*set_backup_file)(char enable);
+	int (*set_charger_full)(char is_full);
+	int (*set_charge_termination_current)(int curr);
+	int (*set_charge_termination_voltage)(int volt);
+	int (*set_battery_temp_external)(void);
+	int (*set_battery_temp_internal)(void);
+	int (*set_rsense)(int rsense);
+	int (*set_backup_file_name)(char *filename, int length);
+	int (*set_suspend_file_name)(char *filename, int length);
+	int (*set_options)(unsigned char options);
+	int (*set_gpio)(ug31xx_gpio_idx_t gpio, int status);
+	int (*set_shell_ap)(char *apname, int length);
+	int (*set_backup_daemon_cntl)(unsigned char cntl);
+	int (*set_capacity_suspend_mode)(char in_suspend);
+	int (*set_cable_out)(unsigned char cntl);
+	int (*set_ggb_board_offset)(int offset);
+	int (*set_board_offset)(int offset, char from_upi_bo);
+	int (*set_ntc_offset)(int offset);
+	int (*set_standby_current)(int curr);
+	int (*set_ggb_board_gain)(int gain);
+	int (*set_ggb_config)(unsigned int config);
+  int (*set_cc_chg_offset)(unsigned int offset_25, unsigned int offset_50, unsigned int offset_75, unsigned int offset_100);
+  int (*set_capacity_force)(int rsoc);
+
+	int (*chk_backup_file)(void);
+	int (*enable_save_data)(char enable);
+	int (*change_to_pri_batt)(char *ggb, char pri_batt);
+	int (*ug31xx_i2c_read)(unsigned short addr, unsigned char *data);
+	int (*ug31xx_i2c_write)(unsigned short addr, unsigned char *data);
+	int (*reset_cycle_count)(void);
+	int (*adjust_cell_table)(unsigned short adjust_design_capacity, char force_reset);
+	int (*calibrate_offset)(unsigned char options);
+	int (*backup_pointer)(void);
+	int (*restore_pointer)(void);
+  int (*reset_q_from_cc)(void);
+};
+
+enum {
+	PWR_SUPPLY_BATTERY = 0,
+	PWR_SUPPLY_AC,
+	PWR_SUPPLY_USB
+};
+
+enum {
+	UG31XX_NO_CABLE = 0,
+	UG31XX_USB_PC_CABLE = 1,
+	UG31XX_PAD_POWER = 2,
+	UG31XX_AC_ADAPTER_CABLE = 3
+};
+
+enum {
+  UG31XX_CHARGER_NO_DETECTS_FULL = 0,
+  UG31XX_CHARGER_DETECTS_FULL,
+  UG31XX_CHARGER_DETECTS_FULL_STEP,
+  UG31XX_CHARGER_DETECTS_FULL_CHECK,
+  UG31XX_TAPER_REACHED,
+  UG31XX_BOARD_OFFSET_CALI_STEP,
+  UG31XX_BOARD_OFFSET_CALI_FULL,
+  UG31XX_BOARD_OFFSET_CALI_FULL_NO_UPPER,
+  UG31XX_BOARD_OFFSET_CALI_AVG,
+  UG31XX_BOARD_OFFSET_FROM_UPI_BO,
+  UG31XX_BOARD_OFFSET_FROM_UPI_COS,
+  UG31XX_BOARD_OFFSET_NOT_FROM_UPI_BO,
+  UG31XX_CABLE_OUT,
+  UG31XX_CABLE_IN,
+  UG31XX_USER_SPACE_RESPONSE,
+  UG31XX_USER_SPACE_NO_RESPONSE,
+  UG31XX_DECIMATE_RST_ACTIVE,
+  UG31XX_DECIMATE_RST_NOT_ACTIVE,
+  UG31XX_OP_NORMAL,
+  UG31XX_OP_EARLY_SUSPEND,
+  UG31XX_OP_SUSPEND,
+  UG31XX_OP_RESUME,
+  UG31XX_OP_LATE_RESUME,
+};
+
+extern struct ug31xx_module_interface ug31_module;
+
+#endif /*__UPI_ug31xx_GAUGE_H */
diff --git a/drivers/power/supply/ASUS_BATTERY/ME176C/ug31xx/ug31xx_ggb_data_k013.h b/drivers/power/supply/ASUS_BATTERY/ME176C/ug31xx/ug31xx_ggb_data_k013.h
new file mode 100755
index 000000000000..3da9199f301b
--- /dev/null
+++ b/drivers/power/supply/ASUS_BATTERY/ME176C/ug31xx/ug31xx_ggb_data_k013.h
@@ -0,0 +1,237 @@
+
+/* This file is auto-generated. Don't edit this file. */
+
+/// R-Sense = 10
+/// ILMD = 4070
+/// EDVF = 3400
+/// Taper Current = 256
+/// Taper Voltage = 4250
+/// Taper Time = 60
+
+char FactoryGGBXFile[] = {
+    0x5f,0x47,0x47,0x5f,0xfd,0x45,0x00,0x00,
+    0x0d,0xcb,0xb1,0x96,0x0e,0x00,0x00,0x00,
+    0xee,0x00,0x00,0x00,0xe8,0x05,0x00,0x00,
+    0xd6,0x06,0x00,0x00,0x00,0x00,0x00,0x00,
+    0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+    0x00,0x00,0x00,0x00,0x41,0x53,0x55,0x53,
+    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+    0x00,0x00,0x00,0x00,0x4d,0x45,0x31,0x37,
+    0x36,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+    0x00,0x00,0x00,0x00,0xaf,0x44,0x35,0x6e,
+    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+    0x00,0x00,0x00,0x00,0x00,0x00,0x50,0x30,
+    0x30,0x33,0x00,0x00,0x00,0x00,0x00,0x00,
+    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+    0x01,0x01,0x01,0x00,0x01,0x01,0x00,0x00,
+    0x70,0x00,0x64,0x00,0x00,0x00,0x00,0x0a,
+    0x00,0x00,0xe6,0x0f,0x48,0x0d,0x14,0x00,
+    0x00,0x01,0x9a,0x10,0x3c,0x00,0x0b,0x00,
+    0x06,0x00,0x7c,0x10,0xb8,0x0b,0x80,0x0c,
+    0x00,0x00,0x32,0x00,0xf4,0x01,0xc2,0x01,
+    0x5c,0xff,0x77,0x01,0x0a,0x05,0x00,0x00,
+    0x00,0x00,0x00,0x00,0xf0,0xdf,0xf4,0x67,
+    0xe8,0xcf,0xee,0x1b,0xb3,0x03,0xb0,0x03,
+    0x08,0x00,0xe8,0x03,0x00,0x00,0x10,0x27,
+    0x3c,0xae,0x20,0x8a,0x4a,0x6e,0xab,0x58,
+    0xc2,0x47,0x70,0x3a,0xe1,0x2f,0x74,0x27,
+    0xd0,0x20,0x6e,0x1b,0x0c,0x17,0x75,0x13,
+    0x80,0x10,0x0e,0x0e,0x06,0x0c,0x54,0x0a,
+    0xe8,0x08,0xb5,0x07,0xb2,0x06,0xe8,0x03,
+    0x84,0x03,0xee,0x02,0x58,0x02,0xc2,0x01,
+    0x2c,0x01,0x0e,0x01,0xf0,0x00,0xd2,0x00,
+    0xb4,0x00,0x96,0x00,0x78,0x00,0x5a,0x00,
+    0x3c,0x00,0x1e,0x00,0x00,0x00,0x1e,0x00,
+    0xe8,0x03,0xff,0x77,0x00,0x00,0x00,0x00,
+    0xe6,0x0f,0x21,0x30,0x5c,0x00,0xb8,0x10,
+    0xb8,0x10,0xb8,0x10,0xb8,0x10,0xb8,0x10,
+    0x99,0x10,0x69,0x10,0x3f,0x10,0x1a,0x10,
+    0xf9,0x0f,0xdb,0x0f,0xbe,0x0f,0xa7,0x0f,
+    0x94,0x0f,0x85,0x0f,0x77,0x0f,0x61,0x0f,
+    0x3d,0x0f,0x1e,0x0f,0xfe,0x0e,0x48,0x0d,
+    0x1b,0x11,0xce,0x10,0x82,0x10,0x19,0x10,
+    0xff,0x0f,0xe5,0x0f,0x90,0x0f,0x7b,0x0f,
+    0x66,0x0f,0x19,0x0f,0x06,0x0f,0xf3,0x0e,
+    0xd0,0x0e,0xc7,0x0e,0xbf,0x0e,0xba,0x0e,
+    0xad,0x0e,0x79,0x0e,0x73,0x0e,0x5f,0x0e,
+    0x48,0x0d,0x13,0x11,0xc7,0x10,0x7b,0x10,
+    0x12,0x10,0xf8,0x0f,0xde,0x0f,0x89,0x0f,
+    0x73,0x0f,0x5e,0x0f,0x12,0x0f,0xff,0x0e,
+    0xec,0x0e,0xc9,0x0e,0xc0,0x0e,0xb8,0x0e,
+    0xb3,0x0e,0xa6,0x0e,0x72,0x0e,0x6c,0x0e,
+    0x58,0x0e,0x48,0x0d,0xb8,0x10,0xb8,0x10,
+    0xb8,0x10,0xb8,0x10,0xb8,0x10,0xb7,0x10,
+    0x8a,0x10,0x62,0x10,0x3f,0x10,0x20,0x10,
+    0x05,0x10,0xed,0x0f,0xd6,0x0f,0xc4,0x0f,
+    0xb5,0x0f,0xa7,0x0f,0x90,0x0f,0x6a,0x0f,
+    0x45,0x0f,0x26,0x0f,0x48,0x0d,0xfb,0x10,
+    0xbb,0x10,0x7b,0x10,0x12,0x10,0xf7,0x0f,
+    0xdd,0x0f,0x82,0x0f,0x6b,0x0f,0x54,0x0f,
+    0x0f,0x0f,0xfe,0x0e,0xed,0x0e,0xcc,0x0e,
+    0xc4,0x0e,0xbc,0x0e,0xb9,0x0e,0xaf,0x0e,
+    0x82,0x0e,0x7b,0x0e,0x65,0x0e,0x48,0x0d,
+    0xf5,0x10,0xb4,0x10,0x73,0x10,0x09,0x10,
+    0xef,0x0f,0xd5,0x0f,0x7a,0x0f,0x63,0x0f,
+    0x4c,0x0f,0x07,0x0f,0xf6,0x0e,0xe5,0x0e,
+    0xc4,0x0e,0xbc,0x0e,0xb4,0x0e,0xb1,0x0e,
+    0xa7,0x0e,0x7a,0x0e,0x73,0x0e,0x5d,0x0e,
+    0x48,0x0d,0xb8,0x10,0xb8,0x10,0xb8,0x10,
+    0xb8,0x10,0xb8,0x10,0xb8,0x10,0xb8,0x10,
+    0xb8,0x10,0xb8,0x10,0x96,0x10,0x6e,0x10,
+    0x4f,0x10,0x51,0x10,0x3c,0x10,0x22,0x10,
+    0x0e,0x10,0xfb,0x0f,0xd3,0x0f,0xb0,0x0f,
+    0x96,0x0f,0x48,0x0d,0xfb,0x10,0xb5,0x10,
+    0x70,0x10,0x06,0x10,0xec,0x0f,0xd2,0x0f,
+    0x75,0x0f,0x5e,0x0f,0x47,0x0f,0x06,0x0f,
+    0xf5,0x0e,0xe5,0x0e,0xc4,0x0e,0xbc,0x0e,
+    0xb4,0x0e,0xb2,0x0e,0xa9,0x0e,0x7b,0x0e,
+    0x73,0x0e,0x5c,0x0e,0x48,0x0d,0xf2,0x10,
+    0xab,0x10,0x65,0x10,0xfc,0x0f,0xe1,0x0f,
+    0xc7,0x0f,0x6b,0x0f,0x54,0x0f,0x3d,0x0f,
+    0xfc,0x0e,0xec,0x0e,0xdc,0x0e,0xbb,0x0e,
+    0xb2,0x0e,0xaa,0x0e,0xa8,0x0e,0x9f,0x0e,
+    0x71,0x0e,0x69,0x0e,0x53,0x0e,0x48,0x0d,
+    0xb8,0x10,0xb8,0x10,0xb8,0x10,0xb8,0x10,
+    0xb8,0x10,0xb8,0x10,0xb8,0x10,0xb8,0x10,
+    0xb8,0x10,0xb8,0x10,0xb8,0x10,0xb4,0x10,
+    0xa1,0x10,0x88,0x10,0x76,0x10,0x63,0x10,
+    0x49,0x10,0x25,0x10,0xfc,0x0f,0xe7,0x0f,
+    0x48,0x0d,0xf0,0x10,0x9f,0x10,0x4e,0x10,
+    0xe3,0x0f,0xc8,0x0f,0xad,0x0f,0x4f,0x0f,
+    0x37,0x0f,0x20,0x0f,0xe7,0x0e,0xd9,0x0e,
+    0xcb,0x0e,0xaf,0x0e,0xa8,0x0e,0xa2,0x0e,
+    0x9f,0x0e,0x93,0x0e,0x61,0x0e,0x57,0x0e,
+    0x33,0x0e,0x48,0x0d,0xe5,0x10,0x93,0x10,
+    0x41,0x10,0xd6,0x0f,0xbb,0x0f,0xa1,0x0f,
+    0x44,0x0f,0x2d,0x0f,0x16,0x0f,0xdd,0x0e,
+    0xcf,0x0e,0xc1,0x0e,0xa5,0x0e,0x9e,0x0e,
+    0x97,0x0e,0x94,0x0e,0x88,0x0e,0x56,0x0e,
+    0x4d,0x0e,0x2a,0x0e,0x48,0x0d,0x70,0x10,
+    0xd9,0x0f,0x35,0x0f,0xac,0x0e,0x4b,0x0e,
+    0x0d,0x0e,0x03,0x0e,0xf9,0x0d,0xee,0x0d,
+    0xe1,0x0d,0xd2,0x0d,0xc1,0x0d,0xaf,0x0d,
+    0x9c,0x0d,0x80,0x0d,0x48,0x0d,0x00,0x00,
+    0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
+    0xc5,0x10,0x41,0x10,0xa0,0x0f,0x1a,0x0f,
+    0xb1,0x0e,0x77,0x0e,0x6e,0x0e,0x64,0x0e,
+    0x59,0x0e,0x4b,0x0e,0x39,0x0e,0x20,0x0e,
+    0x14,0x0e,0x0b,0x0e,0xed,0x0d,0x48,0x0d,
+    0x00,0x00,0xff,0xff,0xff,0xff,0xff,0xff,
+    0xff,0xff,0xf8,0x10,0x63,0x10,0xc4,0x0f,
+    0x42,0x0f,0xd3,0x0e,0x9d,0x0e,0x93,0x0e,
+    0x86,0x0e,0x7a,0x0e,0x6d,0x0e,0x5a,0x0e,
+    0x40,0x0e,0x38,0x0e,0x31,0x0e,0x0d,0x0e,
+    0x48,0x0d,0x00,0x00,0xff,0xff,0xff,0xff,
+    0xff,0xff,0xff,0xff,0x5d,0x10,0xab,0x0f,
+    0x0c,0x0f,0x8b,0x0e,0x2f,0x0e,0xf0,0x0d,
+    0xe7,0x0d,0xdc,0x0d,0xd2,0x0d,0xc6,0x0d,
+    0xb9,0x0d,0xaa,0x0d,0x98,0x0d,0x84,0x0d,
+    0x6b,0x0d,0x48,0x0d,0x00,0x00,0xff,0xff,
+    0xff,0xff,0xff,0xff,0xff,0xff,0xbd,0x10,
+    0x27,0x10,0x87,0x0f,0xfc,0x0e,0x9e,0x0e,
+    0x68,0x0e,0x60,0x0e,0x59,0x0e,0x4f,0x0e,
+    0x42,0x0e,0x30,0x0e,0x18,0x0e,0x06,0x0e,
+    0xf6,0x0d,0xd3,0x0d,0x48,0x0d,0x00,0x00,
+    0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
+    0xdd,0x10,0x54,0x10,0xb5,0x0f,0x2d,0x0f,
+    0xc8,0x0e,0x95,0x0e,0x8e,0x0e,0x87,0x0e,
+    0x7d,0x0e,0x70,0x0e,0x5c,0x0e,0x41,0x0e,
+    0x36,0x0e,0x2d,0x0e,0x09,0x0e,0x48,0x0d,
+    0x00,0x00,0xff,0xff,0xff,0xff,0xff,0xff,
+    0xff,0xff,0x0f,0x10,0x5b,0x0f,0xd1,0x0e,
+    0x5a,0x0e,0x00,0x0e,0xbe,0x0d,0xb5,0x0d,
+    0xa9,0x0d,0x9e,0x0d,0x97,0x0d,0x8c,0x0d,
+    0x85,0x0d,0x78,0x0d,0x6b,0x0d,0x59,0x0d,
+    0x48,0x0d,0x00,0x00,0xff,0xff,0xff,0xff,
+    0xff,0xff,0xff,0xff,0xa6,0x10,0x04,0x10,
+    0x65,0x0f,0xdd,0x0e,0x85,0x0e,0x4f,0x0e,
+    0x47,0x0e,0x3f,0x0e,0x35,0x0e,0x28,0x0e,
+    0x17,0x0e,0x01,0x0e,0xed,0x0d,0xda,0x0d,
+    0xb5,0x0d,0x48,0x0d,0x00,0x00,0xff,0xff,
+    0xff,0xff,0xff,0xff,0xff,0xff,0xd0,0x10,
+    0x3c,0x10,0xa0,0x0f,0x18,0x0f,0xb9,0x0e,
+    0x85,0x0e,0x7d,0x0e,0x77,0x0e,0x6e,0x0e,
+    0x62,0x0e,0x4d,0x0e,0x32,0x0e,0x24,0x0e,
+    0x19,0x0e,0xf9,0x0d,0x48,0x0d,0x00,0x00,
+    0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
+    0xe0,0x0f,0x0e,0x0f,0x90,0x0e,0x2e,0x0e,
+    0xe1,0x0d,0xa4,0x0d,0x9a,0x0d,0x92,0x0d,
+    0x86,0x0d,0x7d,0x0d,0x75,0x0d,0x6a,0x0d,
+    0x61,0x0d,0x5b,0x0d,0x51,0x0d,0x48,0x0d,
+    0x00,0x00,0xff,0xff,0xff,0xff,0xff,0xff,
+    0xff,0xff,0x86,0x10,0xc5,0x0f,0x28,0x0f,
+    0xad,0x0e,0x57,0x0e,0x1e,0x0e,0x15,0x0e,
+    0x0b,0x0e,0xff,0x0d,0xf1,0x0d,0xdf,0x0d,
+    0xcc,0x0d,0xb4,0x0d,0x99,0x0d,0x76,0x0d,
+    0x48,0x0d,0x00,0x00,0xff,0xff,0xff,0xff,
+    0xff,0xff,0xff,0xff,0xbd,0x10,0x10,0x10,
+    0x74,0x0f,0xef,0x0e,0x9b,0x0e,0x6c,0x0e,
+    0x65,0x0e,0x5d,0x0e,0x51,0x0e,0x42,0x0e,
+    0x2e,0x0e,0x15,0x0e,0xfe,0x0d,0xe6,0x0d,
+    0xba,0x0d,0x48,0x0d,0x00,0x00,0xff,0xff,
+    0xff,0xff,0xff,0xff,0xff,0xff,0x76,0x0f,
+    0x8c,0x01,0x54,0x02,0x50,0x02,0x55,0x02,
+    0x4c,0x02,0x7b,0x00,0x75,0x00,0x73,0x00,
+    0x77,0x00,0x75,0x00,0x79,0x00,0x78,0x00,
+    0x75,0x00,0x74,0x00,0x75,0x00,0xac,0x00,
+    0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
+    0xc5,0x0f,0x92,0x01,0x60,0x02,0x5e,0x02,
+    0x5c,0x02,0x60,0x02,0x77,0x00,0x7c,0x00,
+    0x71,0x00,0x7c,0x00,0x77,0x00,0x7d,0x00,
+    0x82,0x00,0x6b,0x00,0x7b,0x00,0x78,0x00,
+    0x5f,0x00,0xff,0xff,0xff,0xff,0xff,0xff,
+    0xff,0xff,0xd4,0x0f,0x96,0x01,0x60,0x02,
+    0x5f,0x02,0x63,0x02,0x63,0x02,0x6c,0x00,
+    0x83,0x00,0x7a,0x00,0x79,0x00,0x74,0x00,
+    0x75,0x00,0x75,0x00,0x86,0x00,0x71,0x00,
+    0x78,0x00,0x53,0x00,0xff,0xff,0xff,0xff,
+    0xff,0xff,0xff,0xff,0x76,0x0e,0x74,0x01,
+    0x2c,0x02,0x2c,0x02,0x29,0x02,0x31,0x02,
+    0x67,0x00,0x77,0x00,0x6c,0x00,0x6f,0x00,
+    0x6b,0x00,0x6e,0x00,0x74,0x00,0x6a,0x00,
+    0x6e,0x00,0x6d,0x00,0x5f,0x01,0xff,0xff,
+    0xff,0xff,0xff,0xff,0xff,0xff,0x94,0x0f,
+    0x91,0x01,0x55,0x02,0x53,0x02,0x5c,0x02,
+    0x5b,0x02,0x7a,0x00,0x68,0x00,0x7f,0x00,
+    0x76,0x00,0x74,0x00,0x77,0x00,0x79,0x00,
+    0x78,0x00,0x76,0x00,0x77,0x00,0x6a,0x00,
+    0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
+    0xba,0x0f,0x92,0x01,0x5e,0x02,0x5c,0x02,
+    0x5b,0x02,0x5e,0x02,0x6f,0x00,0x79,0x00,
+    0x7d,0x00,0x79,0x00,0x77,0x00,0x77,0x00,
+    0x86,0x00,0x6b,0x00,0x79,0x00,0x77,0x00,
+    0x51,0x00,0xff,0xff,0xff,0xff,0xff,0xff,
+    0xff,0xff,0x93,0x0c,0x3c,0x01,0xe1,0x01,
+    0xe3,0x01,0xe7,0x01,0xe5,0x01,0x47,0x00,
+    0x76,0x00,0x6b,0x00,0x39,0x00,0x75,0x00,
+    0x5f,0x00,0x61,0x00,0x5c,0x00,0x75,0x00,
+    0x5a,0x00,0x8e,0x02,0xff,0xff,0xff,0xff,
+    0xff,0xff,0xff,0xff,0x07,0x0f,0x80,0x01,
+    0x43,0x02,0x3f,0x02,0x3e,0x02,0x40,0x02,
+    0x79,0x00,0x6c,0x00,0x74,0x00,0x77,0x00,
+    0x6f,0x00,0x73,0x00,0x72,0x00,0x73,0x00,
+    0x75,0x00,0x72,0x00,0x7d,0x00,0xff,0xff,
+    0xff,0xff,0xff,0xff,0xff,0xff,0x3b,0x0f,
+    0x83,0x01,0x4c,0x02,0x49,0x02,0x43,0x02,
+    0x29,0x02,0x81,0x00,0x02,0x00,0xd7,0x00,
+    0x57,0x00,0x9f,0x00,0x78,0x00,0x48,0x00,
+    0x09,0x00,0xde,0x00,0xb9,0x00,0x5c,0x00,
+    0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
+    0x1b,0x08,0xcf,0x00,0x2e,0x01,0x3c,0x01,
+    0x37,0x01,0x3a,0x01,0x3b,0x00,0x31,0x00,
+    0x49,0x00,0x3a,0x00,0x33,0x00,0x49,0x00,
+    0x13,0x00,0x5a,0x00,0x37,0x00,0x5b,0x00,
+    0xc6,0x05,0xff,0xff,0xff,0xff,0xff,0xff,
+    0xff,0xff,0xbd,0x0d,0x5f,0x01,0x12,0x02,
+    0x0b,0x02,0x17,0x02,0x0f,0x02,0x6a,0x00,
+    0x65,0x00,0x66,0x00,0x67,0x00,0x6f,0x00,
+    0x64,0x00,0x6a,0x00,0x6a,0x00,0x6a,0x00,
+    0x67,0x00,0x4a,0x01,0xff,0xff,0xff,0xff,
+    0xff,0xff,0xff,0xff,0xc0,0x0e,0x79,0x01,
+    0x39,0x02,0x35,0x02,0x35,0x02,0x38,0x02,
+    0x6c,0x00,0x6a,0x00,0x7b,0x00,0x73,0x00,
+    0x6f,0x00,0x6f,0x00,0x71,0x00,0x71,0x00,
+    0x6f,0x00,0x71,0x00,0x83,0x00,0xff,0xff,
+    0xff,0xff,0xff,0xff,0xff,0xff,
+};
+
diff --git a/drivers/power/supply/ASUS_BATTERY/ME176C/ug31xx/ug31xx_version.h b/drivers/power/supply/ASUS_BATTERY/ME176C/ug31xx/ug31xx_version.h
new file mode 100644
index 000000000000..1ad2864b9e7f
--- /dev/null
+++ b/drivers/power/supply/ASUS_BATTERY/ME176C/ug31xx/ug31xx_version.h
@@ -0,0 +1,8 @@
+#define UG31XX_DRIVER_VERSION       (110)
+#define UG31XX_DRIVER_VERSION_STR   ("110")
+#define UG31XX_DRIVER_RELEASE_DATE  ("20140710-070130")
+#define UG31XX_DRIVER_RELEASE_NOTE  ("645:5")
+
+/// Release Note
+///
+///   1. The 20% capacity difference criterion is decent if the power-off time is longer than 1 hour.
diff --git a/drivers/power/supply/Kconfig b/drivers/power/supply/Kconfig
index 5ab90c1f3f7c..c969e88bcb4b 100644
--- a/drivers/power/supply/Kconfig
+++ b/drivers/power/supply/Kconfig
@@ -7,6 +7,7 @@ menuconfig POWER_SUPPLY
 	  (if selected below).
 
 if POWER_SUPPLY
+source "drivers/power/supply/ASUS_BATTERY/ME176C/Kconfig"
 
 config POWER_SUPPLY_DEBUG
 	bool "Power supply debug"
diff --git a/drivers/power/supply/Makefile b/drivers/power/supply/Makefile
index aae4e4a8bbb3..bcff1c68b689 100644
--- a/drivers/power/supply/Makefile
+++ b/drivers/power/supply/Makefile
@@ -82,3 +82,5 @@ obj-$(CONFIG_CHARGER_TPS65090)	+= tps65090-charger.o
 obj-$(CONFIG_CHARGER_TPS65217)	+= tps65217_charger.o
 obj-$(CONFIG_AXP288_FUEL_GAUGE) += axp288_fuel_gauge.o
 obj-$(CONFIG_AXP288_CHARGER)	+= axp288_charger.o
+
+obj-y += ASUS_BATTERY/ME176C/
-- 
2.18.0

