From a3299f825d8b167f3d28c92eefa9fdba6a37c934 Mon Sep 17 00:00:00 2001
From: lambdadroid <lambdadroid@gmail.com>
Date: Wed, 24 May 2017 16:15:17 +0200
Subject: [PATCH 20/26] ME176C: power: supply: Fix battery/charger drivers (v2)

 - Major cleanup for bq24192_charger: removed a lot of unused code
 - Load bq24192_charger using ACPI (added to custom DSDT table)
 - Silence some annoying log messages for UPI battery driver

v2:
 - More cleanup; removed more unused code
 - Use extcon to get charger detection results
 - Enable USB OTG support (enable OTG 5V boost if OTG cable is
   detected)
---
 .../power/supply/ASUS_BATTERY/ME176C/Kconfig  |    2 +-
 .../ASUS_BATTERY/ME176C/bq24192_charger.c     | 2050 +++--------------
 .../ME176C/ug31xx/uG31xx_API_Measurement.c    |   10 +-
 .../ME176C/ug31xx/uG31xx_API_Platform.c       |    3 +-
 .../ME176C/ug31xx/uG31xx_API_Platform.h       |    3 +-
 .../ME176C/ug31xx/uG31xx_API_System.c         |    2 +-
 .../ASUS_BATTERY/ME176C/ug31xx/ug31xx_gauge.c |   89 +-
 drivers/power/supply/Makefile                 |    2 +-
 8 files changed, 415 insertions(+), 1746 deletions(-)

diff --git a/drivers/power/supply/ASUS_BATTERY/ME176C/Kconfig b/drivers/power/supply/ASUS_BATTERY/ME176C/Kconfig
index 36c8bdc71d9c..497042183009 100644
--- a/drivers/power/supply/ASUS_BATTERY/ME176C/Kconfig
+++ b/drivers/power/supply/ASUS_BATTERY/ME176C/Kconfig
@@ -14,7 +14,7 @@ config ASUS_BATTERY_ME176C_CHARGER_BQ24192
 	tristate "TI BQ24192/BQ24191/BQ24190 Charger"
         default y
 	select POWER_SUPPLY_CHARGER
-	depends on I2C
+	depends on I2C && INTEL_MID_PMIC_COMPAT
 	help
 	  BQ24192 is the charger chip for lithium-ion (Li+) batteries
 	  in handheld and portable equipment.
diff --git a/drivers/power/supply/ASUS_BATTERY/ME176C/bq24192_charger.c b/drivers/power/supply/ASUS_BATTERY/ME176C/bq24192_charger.c
index 841243513818..0dab75adf5aa 100755
--- a/drivers/power/supply/ASUS_BATTERY/ME176C/bq24192_charger.c
+++ b/drivers/power/supply/ASUS_BATTERY/ME176C/bq24192_charger.c
@@ -34,7 +34,6 @@
 #include <linux/debugfs.h>
 #include <linux/seq_file.h>
 #include <linux/power_supply.h>
-#include <linux/power/bq24192_charger.h>
 #include <linux/sfi.h>
 #include <linux/pm_runtime.h>
 #include <linux/io.h>
@@ -44,25 +43,20 @@
 #include <linux/wakelock.h>
 #include <linux/version.h>
 #include <linux/usb/otg.h>
-#include <linux/platform_data/intel_mid_remoteproc.h>
-#include <linux/rpmsg.h>
+#include <linux/extcon.h>
+#include <linux/acpi.h>
 
-#include <asm/intel_mid_gpadc.h>
+#include <asm/uaccess.h>
 #include <asm/intel_scu_ipc.h>
-#include <asm/intel_scu_pmic.h>
-#include <asm/intel_mid_rpmsg.h>
 
 #define DRV_NAME "bq24192_charger"
 #define DEV_NAME "bq24192"
-#include <linux/acpi_gpio.h>
+#include <linux/mfd/intel_soc_pmic.h>
 #include <linux/mfd/intel_mid_pmic.h>
 #include <linux/regulator/of_regulator.h>
 #include <linux/regulator/consumer.h>
 #include <linux/proc_fs.h>
 
-
-#define REGULATOR_V3P3S		"v3p3s"
-
 #define R_PMIC_CHGRIRQ 0x0A
 #define R_PMIC_MIRQS0  0x17
 #define R_PMIC_MIRQSX  0x18
@@ -229,28 +223,15 @@
 /* Max no. of tries to reset the bq24192i WDT */
 #define MAX_RESET_WDT_RETRY 8
 
-/*
- * usb notify callback
- */
-#define USB_NOTIFY_CALLBACK
-
 static struct power_supply *fg_psy;
 struct bq24192_chip *chip_extern=NULL;
-extern int entry_mode;
+//extern int entry_mode;
 
 //...........................................................................
-static int bq2415x_sysfs_flag=0; //lambert
-static int suspend_flag=1;  //lambert,1:normal charger,0:mode for aging
 static unsigned char WakeLockFlag=0;//lambert,0:already unlock,1:already lock
-static int g_charger_mode = -1; //lambert,0:dc,1:usb,2:ac
 
 //.......................................................................................................
-struct bq24192_otg_event {
-	struct list_head node;
-	bool is_enable;
-};
-
-static enum bq24192_chrgr_stat {
+enum bq24192_chrgr_stat {
 	BQ24192_CHRGR_STAT_UNKNOWN =0,
 	BQ24192_CHRGR_STAT_CHARGING,
 	BQ24192_CHRGR_STAT_FAULT,
@@ -260,29 +241,20 @@ static enum bq24192_chrgr_stat {
 
 struct bq24192_chip {
 	struct i2c_client *client;
-	struct bq24192_platform_data *pdata;
-	struct power_supply usb;
-	struct delayed_work power_state_task_wrkr;
+	struct power_supply *usb;
 	struct delayed_work chrg_task_wrkr;
 	struct delayed_work chrg_full_wrkr;
 	struct delayed_work jeita_wrkr;
-	struct delayed_work chrg_temp_wrkr;
-	struct delayed_work otg_disable_wrkr;
-	struct delayed_work otg_wrkr;
-	struct work_struct otg_evt_work;
-	struct notifier_block	otg_nb;
-	struct list_head	otg_queue;
 	struct mutex event_lock;
-	struct power_supply_cable_props cap;
-	struct power_supply_cable_props cached_cap;
-	struct usb_phy *transceiver;
 	/* Wake lock to prevent platform from going to S3 when charging */
 	struct wake_lock wakelock;
-	spinlock_t otg_queue_lock;
 
+	struct extcon_dev *vbus_edev, *id_edev, *charger_edev;
+	struct notifier_block vbus_nb, charger_nb, otg_nb;
+	struct work_struct charger_type_work;
+	struct delayed_work otg_work;
 
 	enum bq24192_chrgr_stat chgr_stat;
-	enum power_supply_charger_cable_type cable_type;
 	int cc;
 	int cv;
 	int inlmt;
@@ -291,34 +263,20 @@ struct bq24192_chip {
 	int max_temp;
 	int min_temp;
 	int iterm;
-	int batt_status;
-	int bat_health;
 	int cntl_state;
 	int irq;
-	bool is_charger_enabled;
-	bool is_charging_enabled;
-	bool votg;
-	bool is_pwr_good;
 	bool boost_mode;
 	bool online;
 	bool present;
-	bool sfttmr_expired;
 };
 
-void charger_enabled_poweron();
+void charger_enabled_poweron(void);
 int bq24192_chargeric_status(void);
 
 // Webber +++++++++++++++++++++++++++
 bool detect_charging(void);
 // Webber ---------------------------
 
-
-
-#ifdef CONFIG_DEBUG_FS
-static struct dentry *bq24192_dbgfs_root;
-static char bq24192_dbg_regs[BQ24192_MAX_MEM][4];
-#endif
-
 static int bq24192_reg_read_modify(struct i2c_client *client, u8 reg,
 							u8 val, bool bit_set);
 
@@ -329,115 +287,29 @@ static enum power_supply_property bq24192_usb_props[] = {
 	POWER_SUPPLY_PROP_ONLINE,
 	POWER_SUPPLY_PROP_TYPE,
 	POWER_SUPPLY_PROP_HEALTH,
-	POWER_SUPPLY_PROP_MAX_CHARGE_CURRENT,
-	POWER_SUPPLY_PROP_MAX_CHARGE_VOLTAGE,
-	POWER_SUPPLY_PROP_CHARGE_CURRENT,
-	POWER_SUPPLY_PROP_CHARGE_VOLTAGE,
-	POWER_SUPPLY_PROP_INLMT,
-	POWER_SUPPLY_PROP_ENABLE_CHARGING,
-	POWER_SUPPLY_PROP_ENABLE_CHARGER,
-	POWER_SUPPLY_PROP_CHARGE_TERM_CUR,
-	POWER_SUPPLY_PROP_CABLE_TYPE,
+	POWER_SUPPLY_PROP_CONSTANT_CHARGE_CURRENT_MAX,
+	POWER_SUPPLY_PROP_CONSTANT_CHARGE_VOLTAGE_MAX,
+	POWER_SUPPLY_PROP_CONSTANT_CHARGE_CURRENT,
+	POWER_SUPPLY_PROP_CONSTANT_CHARGE_VOLTAGE,
+	POWER_SUPPLY_PROP_INPUT_CURRENT_LIMIT,
 	POWER_SUPPLY_PROP_CHARGE_CONTROL_LIMIT,
 	POWER_SUPPLY_PROP_CHARGE_CONTROL_LIMIT_MAX,
-	POWER_SUPPLY_PROP_MAX_TEMP,
-	POWER_SUPPLY_PROP_MIN_TEMP
-};
-
-static enum power_supply_type get_power_supply_type(
-		enum power_supply_charger_cable_type cable)
-{
-
-	switch (cable) {
-
-	case POWER_SUPPLY_CHARGER_TYPE_USB_DCP:
-		return POWER_SUPPLY_TYPE_USB_DCP;
-	case POWER_SUPPLY_CHARGER_TYPE_USB_CDP:
-		return POWER_SUPPLY_TYPE_USB_CDP;
-	case POWER_SUPPLY_CHARGER_TYPE_USB_ACA:
-		return POWER_SUPPLY_TYPE_USB_ACA;
-	case POWER_SUPPLY_CHARGER_TYPE_AC:
-		return POWER_SUPPLY_TYPE_MAINS;
-	case POWER_SUPPLY_CHARGER_TYPE_NONE:
-	case POWER_SUPPLY_CHARGER_TYPE_USB_SDP:
-	default:
-		return POWER_SUPPLY_TYPE_USB;
-	}
-
-	return POWER_SUPPLY_TYPE_USB;
-}
-
-#ifdef ASUS_ENG_BUILD
-bool eng_charging_limit = true;
-
-int asus_charging_toggle_write(struct file *file, const char *buffer, size_t count, loff_t *data) {
-
-    if (buffer[0] == '1') {
-        /* turn on charging limit in eng mode */
-        eng_charging_limit = true;
-    } else if (buffer[0] == '0') {
-        /* turn off charging limit in eng mode */
-        eng_charging_limit = false;
-        charger_enabled_poweron();
-    }
-    printk(" %s: %s\n", __func__, eng_charging_limit ? "enable charger limit" : "disable charger limit");
-
-    cancel_delayed_work_sync(&chip_extern->jeita_wrkr);
-    schedule_delayed_work(&chip_extern->jeita_wrkr, 0*HZ);
-
-    return count;
-}
-
-static int asus_charging_toggle_read(struct seq_file *m, void *p) {
-        int len = 0;
-        printk(" %s: %s\n", __func__, eng_charging_limit ? "enable charger limit" : "disable charger limit");
-        seq_printf(m,"%s: %s\n", __func__, eng_charging_limit ? "enable charger limit" : "disable charger limit");
-        return len;
-}
-
-static int proc_asus_charging_toggle_open(struct inode *inode, struct file *file) {
-	return single_open(file, asus_charging_toggle_read, NULL);
-}
-
-static const struct file_operations asus_eng_charging_limit_ops = {
-        .open		= proc_asus_charging_toggle_open,
-	.read		= seq_read,
-        .write          = asus_charging_toggle_write,
-	.llseek		= seq_lseek,
-	.release	= seq_release
+	POWER_SUPPLY_PROP_TEMP_MAX,
+	POWER_SUPPLY_PROP_TEMP_MIN
 };
 
-int init_asus_charging_limit_toggle(void) {
-    struct proc_dir_entry *entry = NULL;
-
-    entry = proc_create("driver/charger_limit_enable", 0666, NULL, &asus_eng_charging_limit_ops);
-    if (!entry) {
-        printk("Unable to create asus_charging_toggle\n");
-        return -EINVAL;
-    }
-    return 0;
-}
-#endif
-
-unsigned char volatile VbusDetach = 1;
-unsigned char vbus_Event = 0;
-#ifndef USB_NOTIFY_CALLBACK
-extern volatile unsigned char PowerStateOk;
-#endif
-extern volatile int Power_State;
-
 static void bq24192_ac_lock(void)
 {
 	unsigned long		flags;
 	local_irq_save(flags);
 	if(chip_extern){
-		printk("bq24192_ac_lock\n");
+		dev_dbg(&chip_extern->client->dev, "bq24192_ac_lock\n");
 		wake_lock(&chip_extern->wakelock);
 	}
 	local_irq_restore(flags);
 
 }
-static void bq24192_ac_unlock()
+static void bq24192_ac_unlock(void)
 {
 	unsigned long		flags;
 	local_irq_save(flags);
@@ -447,19 +319,14 @@ static void bq24192_ac_unlock()
 	}
 	local_irq_restore(flags);
 }
-#ifndef USB_NOTIFY_CALLBACK
-extern enum power_supply_charger_cable_type
-	GetPowerState(void);
-#endif
 static int bq24192_write_reg(struct i2c_client *client, u8 reg, u8 value);
 extern unsigned char cur_cable_status;
-unsigned char OtgOk = 0;
 static inline int bq24192_set_inlmt(struct bq24192_chip *chip, int inlmt);
 /*-------------------------------------------------------------------------*/
 //--------------2014-1-1----distinction sdp/dcp----------------
 static int USB_STATE,AC_STATE;
 
-extern enum {
+enum {
 	UG31XX_NO_CABLE = 0,
 	UG31XX_USB_PC_CABLE = 1,
 	UG31XX_PAD_POWER = 2,
@@ -491,11 +358,11 @@ static int bq24192_power_get_property(struct power_supply *psy,
 	switch (psp)
 	{
 	case POWER_SUPPLY_PROP_ONLINE:
-		if((psy->type == POWER_SUPPLY_TYPE_MAINS))
+		if((psy->desc->type == POWER_SUPPLY_TYPE_MAINS))
 		{
 			val->intval = AC_STATE;
 		}
-		else if((psy->type == POWER_SUPPLY_TYPE_USB))
+		else if((psy->desc->type == POWER_SUPPLY_TYPE_USB))
 		{
 			val->intval = USB_STATE;
 		}
@@ -505,14 +372,14 @@ static int bq24192_power_get_property(struct power_supply *psy,
 		}
 		break;
         case POWER_SUPPLY_PROP_PRESENT:
-            if (psy->type == POWER_SUPPLY_TYPE_USB) {
+            if (psy->desc->type == POWER_SUPPLY_TYPE_USB) {
                 /* for ATD test to acquire the status about charger ic */
                 ret = bq24192_chargeric_status();
                 if (ret >= 0) {
                    val->intval = 1;
                 } else
                    val->intval = 0;
-            } else if (psy->type == POWER_SUPPLY_TYPE_MAINS) {
+            } else if (psy->desc->type == POWER_SUPPLY_TYPE_MAINS) {
                 ret = bq24192_chargeric_status();
                 if (ret >= 0) {
                    val->intval = 1;
@@ -527,12 +394,10 @@ static int bq24192_power_get_property(struct power_supply *psy,
 	return ret;
 }
 
-static struct power_supply bq24192_supply[] = {
+static struct power_supply_desc bq24192_supply_desc[] = {
 	{
 		.name			= "ac",
 		.type			= POWER_SUPPLY_TYPE_MAINS,
-		.supplied_to		= supply_list,
-		.num_supplicants	= ARRAY_SIZE(supply_list),
 		.properties 		= bq24192_pwr_props,
 		.num_properties	= ARRAY_SIZE(bq24192_pwr_props),
 		.get_property		= bq24192_power_get_property,
@@ -540,8 +405,6 @@ static struct power_supply bq24192_supply[] = {
 	{
 		.name			= "usb",
 		.type			= POWER_SUPPLY_TYPE_USB,
-		.supplied_to		= supply_list,
-		.num_supplicants	= ARRAY_SIZE(supply_list),
 		.properties 		= bq24192_pwr_props,
 		.num_properties 	= ARRAY_SIZE(bq24192_pwr_props),
 		.get_property 		= bq24192_power_get_property,
@@ -549,33 +412,38 @@ static struct power_supply bq24192_supply[] = {
 	{
 		.name = "bq24155",
 		.type = POWER_SUPPLY_TYPE_USB,
-		.supplied_to		= supply_list,
-		.num_supplicants	= ARRAY_SIZE(supply_list),
 		.properties 		= bq24192_pwr_props,
 		.num_properties 	= ARRAY_SIZE(bq24192_pwr_props),
 		.get_property = bq24192_power_get_property,
 	},
 };
 
-static unsigned char cable_status = POWER_SUPPLY_CHARGER_TYPE_NONE;
+static struct power_supply_config bq24192_supply_config = {
+	.supplied_to		= supply_list,
+	.num_supplicants	= ARRAY_SIZE(supply_list),
+};
+
+static struct power_supply *bq24192_supply[3];
 
-int bq24192_cable_callback(unsigned char usb_cable_state)
+static unsigned char cable_status = EXTCON_NONE;
+
+static int bq24192_cable_callback(unsigned char usb_cable_state)
 {
-	if(OtgOk){
+	if (chip_extern->boost_mode) {
 		cur_cable_status = UG31XX_NO_CABLE;
 		cable_status = UG31XX_NO_CABLE;
 		AC_STATE   = 0;
 		USB_STATE = 0;
-		power_supply_changed(&bq24192_supply[PWR_SUPPLY_USB]);
-		power_supply_changed(&bq24192_supply[PWR_SUPPLY_AC]);
+		power_supply_changed(bq24192_supply[PWR_SUPPLY_USB]);
+		power_supply_changed(bq24192_supply[PWR_SUPPLY_AC]);
 		return 0;
 	}
-	printk("%s  usb_cable_state = %x, power source ok ? = %d \n", __func__, usb_cable_state,detect_charging()) ;
+	dev_dbg(&chip_extern->client->dev, "%s  usb_cable_state = %x, power source ok ? = %d \n", __func__, usb_cable_state,detect_charging()) ;
 
 	if(usb_cable_state != cable_status)
 	{
 		cable_status = usb_cable_state;
-		if((cable_status == POWER_SUPPLY_CHARGER_TYPE_USB_SDP) && (detect_charging() == true))
+		if((cable_status == EXTCON_CHG_USB_SDP) && (detect_charging() == true))
 		{
                         charger_enabled_poweron();
 			if(WakeLockFlag==0){
@@ -592,7 +460,7 @@ int bq24192_cable_callback(unsigned char usb_cable_state)
 
 		}else
 		{
-			if((cable_status == POWER_SUPPLY_CHARGER_TYPE_USB_DCP) && (detect_charging() == true))
+			if((cable_status == EXTCON_CHG_USB_DCP) && (detect_charging() == true))
 			{
                                 charger_enabled_poweron();
 				if(WakeLockFlag==0){
@@ -606,7 +474,7 @@ int bq24192_cable_callback(unsigned char usb_cable_state)
 
 				printk("%s  AC_IN  \n", __func__) ;
 
-			}else if((cable_status == POWER_SUPPLY_CHARGER_TYPE_NONE) && (detect_charging() == false))
+			}else if((cable_status == EXTCON_NONE) && (detect_charging() == false))
 			{
 				if(WakeLockFlag==1){
 					 WakeLockFlag=0;
@@ -623,24 +491,26 @@ int bq24192_cable_callback(unsigned char usb_cable_state)
 				printk("%s  other condition ,  state =  %x , power source ok ? %d \n", __func__, usb_cable_state,detect_charging()) ;
 			}
 		}
-		power_supply_changed(&bq24192_supply[PWR_SUPPLY_USB]);
-		power_supply_changed(&bq24192_supply[PWR_SUPPLY_AC]);
-		power_supply_changed(&bq24192_supply[PWR_SUPPLY_bq21455]);
+		power_supply_changed(bq24192_supply[PWR_SUPPLY_USB]);
+		power_supply_changed(bq24192_supply[PWR_SUPPLY_AC]);
+		power_supply_changed(bq24192_supply[PWR_SUPPLY_bq21455]);
 	}
 	return 0;
 }
-EXPORT_SYMBOL(bq24192_cable_callback);
 
 static int bq24192_powersupply_init(struct i2c_client *client)
 {
 	int i, ret;
 	for (i = 0; i < ARRAY_SIZE(bq24192_supply); i++) {
-		ret = power_supply_register(&client->dev, &bq24192_supply[i]);
-		if (ret) {
+		bq24192_supply[i] = power_supply_register(&client->dev, &bq24192_supply_desc[i],
+					&bq24192_supply_config);
+		if (IS_ERR(bq24192_supply[i])) {
+			ret = PTR_ERR(bq24192_supply[i]);
+			bq24192_supply[i] = NULL;
 			printk("[%s] Failed to register power supply\n", __func__);
-			do {
-				power_supply_unregister(&bq24192_supply[i]);
-			} while ((--i) >= 0);
+			while ((--i) >= 0) {
+				power_supply_unregister(bq24192_supply[i]);
+			}
 			return ret;
 		}
 	}
@@ -685,7 +555,7 @@ static inline int bq24192_set_vindpm(struct bq24192_chip *chip, int vindpm)
 
 static inline int bq24192_set_boostlim(u8 lim)
 {
-	u8 ret,value;
+	u8 value;
 
 	dev_warn(&chip_extern->client->dev, "%s\n", __func__);
 
@@ -699,7 +569,7 @@ static inline int bq24192_set_boostlim(u8 lim)
 
 static inline int bq24192_set_sysmin(int sysmin)
 {
-	int ret,value,regval;
+	int value,regval;
 
 	dev_warn(&chip_extern->client->dev, "%s:%d %d\n", __func__, __LINE__, sysmin);
 
@@ -744,7 +614,7 @@ static void ChargeInit(unsigned int power_type)
 	bq24192_write_reg(chip_extern->client, BQ24192_CHRG_THRM_REGL_REG,0x73);
 
 
-	if(power_type == POWER_SUPPLY_CHARGER_TYPE_USB_DCP){
+	if(power_type == EXTCON_CHG_USB_DCP){
 		bq24192_set_inlmt(chip_extern,1200);		//00	inlim:1200mA
 		}else{ //POWER_SUPPLY_CHARGER_TYPE_USB_SDP
 			bq24192_set_inlmt(chip_extern,500);	//00	inlim:500mA
@@ -775,42 +645,6 @@ static void ChargeInit(unsigned int power_type)
 
 }
 
-
-
-static void otg_worker(struct work_struct *work)
-{
-	int gpio_handle,gpio_data,ret;
-
-	msleep(300);
-	gpio_handle = acpi_get_gpio("\\_SB.GPO2", 22);
-	gpio_data    = __gpio_get_value(gpio_handle);
-	if((gpio_data == 0)&&(OtgOk == 0)){
-		printk("Otg plug in\n");
-		OtgOk = 1;
-		cur_cable_status = UG31XX_NO_CABLE;
-		cable_status = UG31XX_NO_CABLE;
-		bq24192_reg_read_modify(chip_extern->client,BQ24192_POWER_ON_CFG_REG,0x20, true);
-	}
-	else{
-		if((gpio_data == 1)&&(OtgOk == 1))
-		{
-		printk("Otg plug out\n");
-		OtgOk = 0;
-		bq24192_reg_read_modify(chip_extern->client,BQ24192_POWER_ON_CFG_REG,0x20, false);
-		}
-	}
-
-}
-static irqreturn_t otg_irq_thread(int irq, void *devid)
-{
-        // callback from USB notify
-	//schedule_delayed_work(&chip_extern->otg_wrkr, 0*HZ);
-}
-static irqreturn_t otg_irq_isr(int irq, void *devid)
-{
-	return IRQ_WAKE_THREAD;
-}
-
 //Charge Portint Guide 2014-01-20------------------------------end
 
 static int bq24192_reg_read_modify(struct i2c_client *client, u8 reg,
@@ -824,10 +658,10 @@ void bq24192_charge_enable(int enable) {
         }
 
 	if (enable) {
-		printk("Start charging\n");
+		dev_dbg(&chip_extern->client->dev, "Start charging\n");
 		bq24192_reg_read_modify(chip_extern->client,BQ24192_POWER_ON_CFG_REG,0x10, true);
 	} else {
-		printk("Stop charging\n");
+		dev_dbg(&chip_extern->client->dev, "Stop charging\n");
 		bq24192_reg_read_modify(chip_extern->client,BQ24192_POWER_ON_CFG_REG,0x10, false);
 	}
 }
@@ -853,18 +687,12 @@ static void JetiaWork(struct work_struct *work)
             goto End;
         }
 
-        if (entry_mode == 4 && capacity == 100) {
+        /* TODO bq24192_charge_enable(0);
+		if (entry_mode == 4 && capacity == 100) {
             printk("## in charging mode, battery capacity is 100%% and full charger, no need do JEITA !!\n");
             schedule_delayed_work(&chip_extern->jeita_wrkr, 120*HZ);
             return;
-        }
-#ifdef ASUS_ENG_BUILD
-        if (capacity > 59 && eng_charging_limit) {
-                printk(" %s: In eng mode, Disable charger on capacity(%d%%) is more than 60 %% \n", __func__, capacity);
-                bq24192_charge_enable(0);
-                goto Done;
-        }
-#endif
+        }*/
 
 	temp = fg_chip_get_property(POWER_SUPPLY_PROP_TEMP);
 	if((temp-oldtemp) > 0){
@@ -934,11 +762,6 @@ static void JetiaWork(struct work_struct *work)
 			// [Webber] ----------------------------
 			break;
 	}
-#ifdef ASUS_ENG_BUILD
-Done:
-        power_supply_changed(&bq24192_supply[PWR_SUPPLY_USB]);
-        power_supply_changed(&bq24192_supply[PWR_SUPPLY_AC]);
-#endif
 End:
 	schedule_delayed_work(&chip_extern->jeita_wrkr, 30*HZ);
 }
@@ -1087,25 +910,6 @@ static int bq24192_reg_read_modify(struct i2c_client *client, u8 reg,
 	return ret;
 }
 
-static int bq24192_reg_multi_bitset(struct i2c_client *client, u8 reg,
-						u8 val, u8 pos, u8 len)
-{
-	int ret;
-	u8 data;
-
-	ret = bq24192_read_reg(client, reg);
-	if (ret < 0) {
-		dev_warn(&client->dev, "I2C SMbus Read error:%d\n", ret);
-		return ret;
-	}
-
-	data = (1 << len) - 1;
-	ret = (ret & ~(data << pos)) | val;
-	ret = bq24192_write_reg(client, reg, ret);
-
-	return ret;
-}
-
 /*
  * This function verifies if the bq24192i charger chip is in Hi-Z
  * If yes, then clear the Hi-Z to resume the charger operations
@@ -1173,7 +977,7 @@ static int check_batt_psy(struct device *dev, void *data)
 	struct power_supply *psy = dev_get_drvdata(dev);
 
 	/* check for whether power supply type is battery */
-	if (psy->type == POWER_SUPPLY_TYPE_BATTERY) {
+	if (psy->desc->type == POWER_SUPPLY_TYPE_BATTERY) {
 		fg_psy = psy;
 		return 1;
 	}
@@ -1212,7 +1016,7 @@ static int fg_chip_get_property(enum power_supply_property psp)
 	if (!fg_psy)
 		fg_psy = get_fg_chip_psy();
 	if (fg_psy) {
-		ret = fg_psy->get_property(fg_psy, psp, &val);
+		ret = fg_psy->desc->get_property(fg_psy, psp, &val);
 		if (!ret)
 			return val.intval;
 	}
@@ -1232,10 +1036,6 @@ int bq24192_get_charger_health(void)
 
 	dev_dbg(&chip->client->dev, "%s\n", __func__);
 
-	/* If we do not have any cable connected, return health as UNKNOWN */
-	if (chip->cable_type == POWER_SUPPLY_CHARGER_TYPE_NONE)
-		return POWER_SUPPLY_HEALTH_UNKNOWN;
-
 	ret_fault = bq24192_read_reg(chip->client, BQ24192_FAULT_STAT_REG);
 	if (ret_fault < 0) {
 		dev_warn(&chip->client->dev,
@@ -1261,58 +1061,6 @@ int bq24192_get_charger_health(void)
 	return POWER_SUPPLY_HEALTH_GOOD;
 }
 
-/**
- * bq24192_get_battery_health_me176c - to get the battery health status
- *
- * Returns battery health status
- */
-int bq24192_get_battery_health_me176c(void)
-{
-	int  temp,vnow;
-	struct bq24192_chip *chip;
-	if (!bq24192_client)
-		return POWER_SUPPLY_HEALTH_UNKNOWN;
-
-	chip = i2c_get_clientdata(bq24192_client);
-
-	dev_info(&chip->client->dev, "+%s\n", __func__);
-
-	/* If power supply is emulating as battery, return health as good */
-	if (!chip->pdata->sfi_tabl_present)
-		return POWER_SUPPLY_HEALTH_GOOD;
-
-	/* Report the battery health w.r.t battery temperature from FG */
-	temp = fg_chip_get_property(POWER_SUPPLY_PROP_TEMP);
-	if (temp == -ENODEV || temp == -EINVAL) {
-		dev_err(&chip->client->dev,
-				"Failed to read batt profile\n");
-		return POWER_SUPPLY_HEALTH_UNSPEC_FAILURE;
-	}
-
-	temp /= 10;
-
-	if ((temp <= chip->min_temp) ||
-		(temp > chip->max_temp))
-		return POWER_SUPPLY_HEALTH_OVERHEAT;
-	/* read the battery voltage */
-	vnow = fg_chip_get_property(POWER_SUPPLY_PROP_VOLTAGE_NOW);
-	if (vnow == -ENODEV || vnow == -EINVAL) {
-		dev_err(&chip->client->dev, "Can't read voltage from FG\n");
-		return POWER_SUPPLY_HEALTH_UNSPEC_FAILURE;
-	}
-
-	/* convert voltage into millivolts */
-	vnow /= 1000;
-	dev_warn(&chip->client->dev, "vnow = %d\n", vnow);
-
-	if (vnow > chip->max_cv)
-		return POWER_SUPPLY_HEALTH_OVERVOLTAGE;
-
-	dev_dbg(&chip->client->dev, "-%s\n", __func__);
-	return POWER_SUPPLY_HEALTH_GOOD;
-}
-EXPORT_SYMBOL(bq24192_get_battery_health_me176c);
-
 /***********************************************************************/
 
 /* convert the input current limit value
@@ -1321,7 +1069,7 @@ EXPORT_SYMBOL(bq24192_get_battery_health_me176c);
  */
 static u8 chrg_ilim_to_reg(int ilim)
 {
-	u8 reg;
+	u8 reg = 0;
 
 	/* Set the input source current limit
 	 * between 100 to 1500mA */
@@ -1401,53 +1149,6 @@ static u8 chrg_volt_to_reg(int volt)
 	return reg;
 }
 
-static int bq24192_enable_hw_term(struct bq24192_chip *chip, bool hw_term_en)
-{
-	int ret = 0;
-
-	dev_info(&chip->client->dev, "%s\n", __func__);
-
-	/* Disable and enable charging to restart the charging */
-	ret = bq24192_reg_multi_bitset(chip->client,
-					BQ24192_POWER_ON_CFG_REG,
-					POWER_ON_CFG_CHRG_CFG_DIS,
-					CHR_CFG_BIT_POS,
-					CHR_CFG_BIT_LEN);
-	if (ret < 0) {
-		dev_warn(&chip->client->dev,
-			"i2c reg write failed: reg: %d, ret: %d\n",
-			BQ24192_POWER_ON_CFG_REG, ret);
-		return ret;
-	}
-
-	/* Read the timer control register */
-	ret = bq24192_read_reg(chip->client, BQ24192_CHRG_TIMER_EXP_CNTL_REG);
-	if (ret < 0) {
-		dev_warn(&chip->client->dev, "TIMER CTRL reg read failed\n");
-		return ret;
-	}
-
-	/*
-	 * Enable the HW termination. When disabled the HW termination, battery
-	 * was taking too long to go from charging to full state. HW based
-	 * termination could cause the battery capacity to drop but it would
-	 * result in good battery life.
-	 */
-	if (hw_term_en)
-		ret |= CHRG_TIMER_EXP_CNTL_EN_TERM;
-	else
-		ret &= ~CHRG_TIMER_EXP_CNTL_EN_TERM;
-
-	/* Program the TIMER CTRL register */
-	ret = bq24192_write_reg(chip->client,
-				BQ24192_CHRG_TIMER_EXP_CNTL_REG,
-				ret);
-	if (ret < 0)
-		dev_warn(&chip->client->dev, "TIMER CTRL I2C write failed\n");
-
-	return ret;
-}
-
 /*
  * chip->event_lock need to be acquired before calling this function
  * to avoid the race condition
@@ -1554,413 +1255,109 @@ static int bq24192_modify_vindpm(u8 vindpm)
 	return ret;
 }
 
-/* This function should be called with the mutex held */
-static int bq24192_turn_otg_vbus(struct bq24192_chip *chip, bool votg_on)
+static inline int bq24192_set_cc(struct bq24192_chip *chip, int cc)
 {
-	int ret = 0;
-
-	dev_info(&chip->client->dev, "%s %d\n", __func__, votg_on);
-
-	if (votg_on) {
-			/* Program the timers */
-			ret = program_timers(chip,
-						CHRG_TIMER_EXP_CNTL_WDT80SEC,
-						false);
-			if (ret < 0) {
-				dev_warn(&chip->client->dev,
-					"TIMER enable failed %s\n", __func__);
-				goto i2c_write_fail;
-			}
-			/* Configure the charger in OTG mode */
-			ret = bq24192_reg_read_modify(chip->client,
-					BQ24192_POWER_ON_CFG_REG,
-					POWER_ON_CFG_CHRG_CFG_OTG, true);
-			if (ret < 0) {
-				dev_warn(&chip->client->dev,
-						"read reg modify failed\n");
-				goto i2c_write_fail;
-			}
-
-			/* Put the charger IC in reverse boost mode. Since
-			 * SDP charger can supply max 500mA charging current
-			 * Setting the boost current to 500mA
-			 */
-			ret = bq24192_reg_read_modify(chip->client,
-					BQ24192_POWER_ON_CFG_REG,
-					POWER_ON_CFG_BOOST_LIM, false);
-			if (ret < 0) {
-				dev_warn(&chip->client->dev,
-						"read reg modify failed\n");
-				goto i2c_write_fail;
-			}
-			chip->boost_mode = true;
-			/* Schedule the charger task worker now */
-			schedule_delayed_work(&chip->chrg_task_wrkr,
-						0);
-	} else {
-			/* Clear the charger from the OTG mode */
-			ret = bq24192_reg_read_modify(chip->client,
-					BQ24192_POWER_ON_CFG_REG,
-					POWER_ON_CFG_CHRG_CFG_OTG, false);
-			if (ret < 0) {
-				dev_warn(&chip->client->dev,
-						"read reg modify failed\n");
-				goto i2c_write_fail;
-			}
-
-			/* Put the charger IC out of reverse boost mode 500mA */
-			ret = bq24192_reg_read_modify(chip->client,
-					BQ24192_POWER_ON_CFG_REG,
-					POWER_ON_CFG_BOOST_LIM, false);
-			if (ret < 0) {
-				dev_warn(&chip->client->dev,
-						"read reg modify failed\n");
-				goto i2c_write_fail;
-			}
-			chip->boost_mode = false;
-			/* Cancel the charger task worker now */
-			cancel_delayed_work_sync(&chip->chrg_task_wrkr);
-	}
+	u8 regval,value;
 
-	/*
-	 *  Drive the gpio to turn ON/OFF the VBUS
-	 */
-	if (chip->pdata->drive_vbus)
-		chip->pdata->drive_vbus(votg_on);
+	dev_dbg(&chip->client->dev, "%s:%d %d\n", __func__, __LINE__, cc);
+	regval = chrg_cur_to_reg(cc);
+	value = bq24192_read_reg(chip->client, BQ24192_CHRG_CUR_CNTL_REG);
+	value = ((value&0x03)|regval);
 
-	return ret;
-i2c_write_fail:
-	dev_err(&chip->client->dev, "%s: Failed\n", __func__);
-	return ret;
+	return bq24192_write_reg(chip->client, BQ24192_CHRG_CUR_CNTL_REG,
+				value);
 }
 
-#ifdef CONFIG_DEBUG_FS
-#define DBGFS_REG_BUF_LEN	3
-
-static int bq24192_show(struct seq_file *seq, void *unused)
+static inline int bq24192_set_cv(struct bq24192_chip *chip, int cv)
 {
-	u16 val;
-	long addr;
-
-	if (kstrtol((char *)seq->private, 16, &addr))
-		return -EINVAL;
+	u8 regval;
 
-	val = bq24192_read_reg(bq24192_client, addr);
-	seq_printf(seq, "%x\n", val);
+	dev_dbg(&chip->client->dev, "%s:%d %d\n", __func__, __LINE__, cv);
+	regval = chrg_volt_to_reg(cv);
 
-	return 0;
+	return bq24192_write_reg(chip->client, BQ24192_CHRG_VOLT_CNTL_REG,
+					(regval | CHRG_VOLT_CNTL_VRECHRG)|CHRG_VOLT_CNTL_BATTLOWV);
 }
 
-static int bq24192_dbgfs_open(struct inode *inode, struct file *file)
+static inline int bq24192_set_inlmt(struct bq24192_chip *chip, int inlmt)
 {
-	return single_open(file, bq24192_show, inode->i_private);
+	u8 regval,value;
+
+	dev_warn(&chip->client->dev, "%s:%d %d\n", __func__, __LINE__, inlmt);
+	chip->inlmt = inlmt;
+	regval = chrg_ilim_to_reg(inlmt);
+	value = bq24192_read_reg(chip->client, BQ24192_INPUT_SRC_CNTL_REG);
+	regval = ((value&0xF8)|regval);
+	return bq24192_write_reg(chip->client, BQ24192_INPUT_SRC_CNTL_REG,
+				regval);
 }
 
-static ssize_t bq24192_dbgfs_reg_write(struct file *file,
-		const char __user *user_buf, size_t count, loff_t *ppos)
+static inline int bq24192_set_iterm(struct bq24192_chip *chip, int iterm)
 {
-	char buf[DBGFS_REG_BUF_LEN];
-	long addr;
-	unsigned long value;
-	int ret;
-	struct seq_file *seq = file->private_data;
-
-	if (!seq || kstrtol((char *)seq->private, 16, &addr))
-		return -EINVAL;
+	u8 reg_val;
 
-	if (copy_from_user(buf, user_buf, DBGFS_REG_BUF_LEN-1))
-		return -EFAULT;
+	if (iterm > BQ24192_CHRG_ITERM_OFFSET)
+		dev_warn(&chip->client->dev,
+			"%s ITERM set for >128mA", __func__);
 
-	buf[DBGFS_REG_BUF_LEN-1] = '\0';
-	if (kstrtoul(buf, 16, &value))
-		return -EINVAL;
+	reg_val = chrg_iterm_to_reg(iterm);
+	//msleep(500);
 
-	dev_info(&bq24192_client->dev,
-			"[dbgfs write] Addr:0x%x Val:0x%x\n",
-			(u32)addr, (u32)value);
+	return bq24192_write_reg(chip->client,
+			BQ24192_PRECHRG_TERM_CUR_CNTL_REG,
+				(BQ24192_PRE_CHRG_CURR_256 | reg_val));
+}
 
+static inline int bq24192_get_inlmt(struct bq24192_chip *chip) {
+	u8 regval;
+        int value = 100;
 
-	ret = bq24192_write_reg(bq24192_client, addr, value);
-	if (ret < 0)
-		dev_warn(&bq24192_client->dev, "I2C write failed\n");
+        regval = bq24192_read_reg(chip->client, BQ24192_INPUT_SRC_CNTL_REG);
+	regval &= 0x07;
+        switch (regval) {
+            case 0:
+               value = 100;
+               break;
+            case 1:
+               value = 150;
+               break;
+            case 2:
+               value = 500;
+               break;
+            case 3:
+               value = 900;
+               break;
+            case 4:
+               value = 1000;
+               break;
+            case 5:
+               value = 1200;
+               break;
+            case 6:
+               value = 2000;
+               break;
+            case 7:
+               value = 3000;
+               break;
+        }
+        dev_warn(&chip->client->dev, "%s:%d ,input current = %d mA\n", __func__, __LINE__, value);
 
-	return count;
+	return value;
 }
 
-static const struct file_operations bq24192_dbgfs_fops = {
-	.owner		= THIS_MODULE,
-	.open		= bq24192_dbgfs_open,
-	.read		= seq_read,
-	.write		= bq24192_dbgfs_reg_write,
-	.llseek		= seq_lseek,
-	.release	= single_release,
-};
-
-static int bq24192_create_debugfs(struct bq24192_chip *chip)
-{
-	int i;
-	struct dentry *entry;
+int bq24192_chargeric_status (void) {
+	int ret;
+	struct bq24192_chip *chip=NULL;
 
-	bq24192_dbgfs_root = debugfs_create_dir(DEV_NAME, NULL);
-	if (IS_ERR(bq24192_dbgfs_root)) {
-		dev_warn(&chip->client->dev, "DEBUGFS DIR create failed\n");
-		return -ENOMEM;
+	chip = chip_extern;
+	if((chip->client == NULL)||(chip == NULL)) {
+		printk("chip->client == null\n");
+		return -1;
 	}
 
-	for (i = 0; i < BQ24192_MAX_MEM; i++) {
-		sprintf((char *)&bq24192_dbg_regs[i], "%x", i);
-		entry = debugfs_create_file(
-					(const char *)&bq24192_dbg_regs[i],
-					S_IRUGO,
-					bq24192_dbgfs_root,
-					&bq24192_dbg_regs[i],
-					&bq24192_dbgfs_fops);
-		if (IS_ERR(entry)) {
-			debugfs_remove_recursive(bq24192_dbgfs_root);
-			bq24192_dbgfs_root = NULL;
-			dev_warn(&chip->client->dev,
-					"DEBUGFS entry Create failed\n");
-			return -ENOMEM;
-		}
-	}
-
-	return 0;
-}
-static inline void bq24192_remove_debugfs(struct bq24192_chip *chip)
-{
-	if (bq24192_dbgfs_root)
-		debugfs_remove_recursive(bq24192_dbgfs_root);
-}
-#else
-static inline int bq24192_create_debugfs(struct bq24192_chip *chip)
-{
-	return 0;
-}
-static inline void bq24192_remove_debugfs(struct bq24192_chip *chip)
-{
-}
-#endif
-
-static inline int bq24192_enable_charging(
-			struct bq24192_chip *chip, bool val)
-{
-	int ret;
-	u8 regval;
-
-	dev_warn(&chip->client->dev, "%s:%d %d\n", __func__, __LINE__, val);
-
-	ret = program_timers(chip, CHRG_TIMER_EXP_CNTL_WDT160SEC, true);
-	if (ret < 0) {
-		dev_err(&chip->client->dev,
-				"program_timers failed: %d\n", ret);
-		return ret;
-	}
-
-	/*
-	 * Program the inlmt here in case we are asked to resume the charging
-	 * framework would send only set CC/CV commands and not the inlmt. This
-	 * would make sure that we program the last set inlmt into the register
-	 * in case for some reasons WDT expires
-	 */
-	regval = chrg_ilim_to_reg(chip->inlmt);
-
-	ret = bq24192_reg_read_modify(chip->client, BQ24192_INPUT_SRC_CNTL_REG,
-				regval, true);
-	if (ret < 0) {
-		dev_err(&chip->client->dev,
-				"inlmt programming failed: %d\n", ret);
-		return ret;
-	}
-
-	/*
-	 * check if we have the battery emulator connected. We do not start
-	 * charging if the emulator is connected. Disable the charging
-	 * explicitly.
-	 */
-	if (!chip->pdata->sfi_tabl_present) {
-		ret = bq24192_reg_multi_bitset(chip->client,
-						BQ24192_POWER_ON_CFG_REG,
-						POWER_ON_CFG_CHRG_CFG_DIS,
-						CHR_CFG_BIT_POS,
-						CHR_CFG_BIT_LEN);
-		/* Schedule the charger task worker now */
-		schedule_delayed_work(&chip->chrg_task_wrkr,
-						0);
-		return ret;
-	}
-
-	if (val) {
-		/* Schedule the charger task worker now */
-		schedule_delayed_work(&chip->chrg_task_wrkr, 0);
-
-		/*
-		 * Prevent system from entering s3 while charger is connected
-		 */
-		if (!wake_lock_active(&chip->wakelock))
-			wake_lock(&chip->wakelock);
-	} else {
-		/* Release the wake lock */
-		if (wake_lock_active(&chip->wakelock))
-			wake_unlock(&chip->wakelock);
-
-		/*
-		 * Cancel the worker since it need not run when charging is not
-		 * happening
-		 */
-		cancel_delayed_work_sync(&chip->chrg_full_wrkr);
-
-		/* Read the status to know about input supply */
-		ret = bq24192_read_reg(chip->client, BQ24192_SYSTEM_STAT_REG);
-		if (ret < 0) {
-			dev_warn(&chip->client->dev,
-				"read reg failed %s\n", __func__);
-		}
-
-		/* If no charger connected, cancel the workers */
-		if (!(ret & SYSTEM_STAT_VBUS_OTG)) {
-			dev_info(&chip->client->dev, "NO charger connected\n");
-			chip->sfttmr_expired = false;
-			cancel_delayed_work_sync(&chip->chrg_task_wrkr);
-		}
-	}
-
-	ret = val ? POWER_ON_CFG_CHRG_CFG_EN : POWER_ON_CFG_CHRG_CFG_DIS;
-
-	if (!val && chip->sfttmr_expired)
-		return ret;
-
-	ret = bq24192_reg_multi_bitset(chip->client,
-					BQ24192_POWER_ON_CFG_REG,
-					ret, CHR_CFG_BIT_POS,
-					CHR_CFG_BIT_LEN);
-
-	return ret;
-}
-
-static inline int bq24192_enable_charger(
-			struct bq24192_chip *chip, int val)
-{
-	int ret;
-
-	/*stop charger for throttle state 3, by putting it in HiZ mode*/
-	if (chip->cntl_state == 0x3) {
-		ret = bq24192_reg_read_modify(chip->client,
-			BQ24192_INPUT_SRC_CNTL_REG,
-				INPUT_SRC_CNTL_EN_HIZ, true);
-
-		if (ret < 0)
-			dev_warn(&chip->client->dev,
-				"Input src cntl write failed\n");
-	}
-
-	dev_warn(&chip->client->dev, "%s:%d %d\n", __func__, __LINE__, val);
-
-	return bq24192_enable_charging(chip, val);
-}
-
-static inline int bq24192_set_cc(struct bq24192_chip *chip, int cc)
-{
-	u8 regval,value;
-
-	dev_warn(&chip->client->dev, "%s:%d %d\n", __func__, __LINE__, cc);
-	regval = chrg_cur_to_reg(cc);
-	value = bq24192_read_reg(chip->client, BQ24192_CHRG_CUR_CNTL_REG);
-	value = ((value&0x03)|regval);
-
-	return bq24192_write_reg(chip->client, BQ24192_CHRG_CUR_CNTL_REG,
-				value);
-}
-
-static inline int bq24192_set_cv(struct bq24192_chip *chip, int cv)
-{
-	u8 regval;
-
-	dev_warn(&chip->client->dev, "%s:%d %d\n", __func__, __LINE__, cv);
-	regval = chrg_volt_to_reg(cv);
-
-	return bq24192_write_reg(chip->client, BQ24192_CHRG_VOLT_CNTL_REG,
-					(regval | CHRG_VOLT_CNTL_VRECHRG)|CHRG_VOLT_CNTL_BATTLOWV);
-}
-
-static inline int bq24192_set_inlmt(struct bq24192_chip *chip, int inlmt)
-{
-	u8 regval,value;
-
-	dev_warn(&chip->client->dev, "%s:%d %d\n", __func__, __LINE__, inlmt);
-	chip->inlmt = inlmt;
-	regval = chrg_ilim_to_reg(inlmt);
-	value = bq24192_read_reg(chip->client, BQ24192_INPUT_SRC_CNTL_REG);
-	regval = ((value&0xF8)|regval);
-	return bq24192_write_reg(chip->client, BQ24192_INPUT_SRC_CNTL_REG,
-				regval);
-}
-
-static inline int bq24192_set_iterm(struct bq24192_chip *chip, int iterm)
-{
-	u8 reg_val;
-
-	if (iterm > BQ24192_CHRG_ITERM_OFFSET)
-		dev_warn(&chip->client->dev,
-			"%s ITERM set for >128mA", __func__);
-
-	reg_val = chrg_iterm_to_reg(iterm);
-	//msleep(500);
-
-	return bq24192_write_reg(chip->client,
-			BQ24192_PRECHRG_TERM_CUR_CNTL_REG,
-				(BQ24192_PRE_CHRG_CURR_256 | reg_val));
-}
-
-static inline int bq24192_get_inlmt(struct bq24192_chip *chip) {
-	u8 regval;
-        int value = 100;
-
-        regval = bq24192_read_reg(chip->client, BQ24192_INPUT_SRC_CNTL_REG);
-	regval &= 0x07;
-        switch (regval) {
-            case 0:
-               value = 100;
-               break;
-            case 1:
-               value = 150;
-               break;
-            case 2:
-               value = 500;
-               break;
-            case 3:
-               value = 900;
-               break;
-            case 4:
-               value = 1000;
-               break;
-            case 5:
-               value = 1200;
-               break;
-            case 6:
-               value = 2000;
-               break;
-            case 7:
-               value = 3000;
-               break;
-        }
-        dev_warn(&chip->client->dev, "%s:%d ,input current = %d mA\n", __func__, __LINE__, value);
-
-	return value;
-}
-
-int bq24192_chargeric_status (void) {
-	int ret;
-	struct bq24192_chip *chip=NULL;
-
-	chip = chip_extern;
-	if((chip->client == NULL)||(chip == NULL)) {
-		printk("chip->client == null\n");
-		return -1;
-	}
-
-        mutex_lock(&chip_extern->event_lock);
-	ret = bq24192_read_reg(chip->client, BQ24192_SYSTEM_STAT_REG);
-        mutex_unlock(&chip_extern->event_lock);
+        mutex_lock(&chip_extern->event_lock);
+	ret = bq24192_read_reg(chip->client, BQ24192_SYSTEM_STAT_REG);
+        mutex_unlock(&chip_extern->event_lock);
 
 	if (ret < 0)
 		dev_err(&chip->client->dev, "STATUS register read failed\n");
@@ -2003,12 +1400,10 @@ int bq24192_is_charging(void)
 
 	return chip->chgr_stat;
 }
-EXPORT_SYMBOL(bq24192_is_charging);
 
 // Webber [TT-559041] ++++++++++++++++++++++++++++++++++++
 bool detect_charging(void)
 {
-	int charger_status;
 	int ret;
 	struct bq24192_chip *chip=NULL;
 
@@ -2025,14 +1420,14 @@ bool detect_charging(void)
 
 	ret &= SYSTEM_STAT_PWR_GOOD;
 
-	printk("[%s] ret = %d  \n", __func__ , ret);
+	dev_dbg(&chip->client->dev, "[%s] ret = %d  \n", __func__ , ret);
 
 	if ( ret == SYSTEM_STAT_PWR_GOOD )
 	{
-	        printk("[%s] charging\n", __func__);
+	        dev_dbg(&chip->client->dev, "[%s] charging\n", __func__);
 		return (true);
 	}else{
-		printk("[%s] isn't charging\n", __func__);
+		dev_dbg(&chip->client->dev, "[%s] isn't charging\n", __func__);
 		return (false);
 	}
 
@@ -2044,9 +1439,7 @@ static int bq24192_usb_set_property(struct power_supply *psy,
 					enum power_supply_property psp,
 					const union power_supply_propval *val)
 {
-	struct bq24192_chip *chip = container_of(psy,
-						struct bq24192_chip,
-						usb);
+	struct bq24192_chip *chip = power_supply_get_drvdata(psy);
 	int ret = 0;
 
 	dev_dbg(&chip->client->dev, "%s %d\n", __func__, psp);
@@ -2065,64 +1458,31 @@ static int bq24192_usb_set_property(struct power_supply *psy,
 	case POWER_SUPPLY_PROP_ONLINE:
 		chip->online = val->intval;
 		break;
-	case POWER_SUPPLY_PROP_ENABLE_CHARGING:
-		bq24192_enable_hw_term(chip, val->intval);
-		ret = bq24192_enable_charging(chip, val->intval);
-
-		if (ret < 0)
-			dev_err(&chip->client->dev,
-				"Error(%d) in %s charging", ret,
-				(val->intval ? "enable" : "disable"));
-		else
-			chip->is_charging_enabled = val->intval;
-
-		if (!val->intval)
-			cancel_delayed_work_sync(&chip->chrg_full_wrkr);
-		break;
-	case POWER_SUPPLY_PROP_ENABLE_CHARGER:
-		ret = bq24192_enable_charger(chip, val->intval);
-
-		if (ret < 0) {
-			dev_err(&chip->client->dev,
-			"Error(%d) in %s charger", ret,
-			(val->intval ? "enable" : "disable"));
-		} else
-			chip->is_charger_enabled = val->intval;
-		break;
-	case POWER_SUPPLY_PROP_CHARGE_CURRENT:
+	case POWER_SUPPLY_PROP_CONSTANT_CHARGE_CURRENT:
 		ret = bq24192_set_cc(chip, val->intval);
 		if (!ret)
 			chip->cc = val->intval;
 		break;
-	case POWER_SUPPLY_PROP_CHARGE_VOLTAGE:
+	case POWER_SUPPLY_PROP_CONSTANT_CHARGE_VOLTAGE:
 		ret = bq24192_set_cv(chip, val->intval);
 		if (!ret)
 			chip->cv = val->intval;
 		break;
-	case POWER_SUPPLY_PROP_MAX_CHARGE_CURRENT:
+	case POWER_SUPPLY_PROP_CONSTANT_CHARGE_CURRENT_MAX:
 		chip->max_cc = val->intval;
 		break;
-	case POWER_SUPPLY_PROP_MAX_CHARGE_VOLTAGE:
+	case POWER_SUPPLY_PROP_CONSTANT_CHARGE_VOLTAGE_MAX:
 		chip->max_cv = val->intval;
 		break;
-	case POWER_SUPPLY_PROP_CHARGE_TERM_CUR:
-		ret = bq24192_set_iterm(chip, val->intval);
-		if (!ret)
-			chip->iterm = val->intval;
-		break;
-	case POWER_SUPPLY_PROP_CABLE_TYPE:
-		chip->cable_type = val->intval;
-		chip->usb.type = get_power_supply_type(chip->cable_type);
-		break;
-	case POWER_SUPPLY_PROP_INLMT:
+	case POWER_SUPPLY_PROP_INPUT_CURRENT_LIMIT:
 		ret = bq24192_set_inlmt(chip, val->intval);
 		if (!ret)
 			chip->inlmt = val->intval;
 		break;
-	case POWER_SUPPLY_PROP_MAX_TEMP:
+	case POWER_SUPPLY_PROP_TEMP_MAX:
 		chip->max_temp = val->intval;
 		break;
-	case POWER_SUPPLY_PROP_MIN_TEMP:
+	case POWER_SUPPLY_PROP_TEMP_MIN:
 		chip->min_temp = val->intval;
 		break;
 	case POWER_SUPPLY_PROP_CHARGE_CONTROL_LIMIT:
@@ -2140,10 +1500,7 @@ static int bq24192_usb_get_property(struct power_supply *psy,
 			enum power_supply_property psp,
 			union power_supply_propval *val)
 {
-	struct bq24192_chip *chip = container_of(psy,
-					struct bq24192_chip,
-					usb);
-	enum bq24192_chrgr_stat charging;
+	struct bq24192_chip *chip = power_supply_get_drvdata(psy);
 
 	dev_dbg(&chip->client->dev, "%s %d\n", __func__, psp);
 	if (system_state != SYSTEM_RUNNING) {
@@ -2162,48 +1519,31 @@ static int bq24192_usb_get_property(struct power_supply *psy,
 	case POWER_SUPPLY_PROP_HEALTH:
 		val->intval = bq24192_get_charger_health();
 		break;
-	case POWER_SUPPLY_PROP_MAX_CHARGE_CURRENT:
+	case POWER_SUPPLY_PROP_CONSTANT_CHARGE_CURRENT_MAX:
 		val->intval = chip->max_cc;
 		break;
-	case POWER_SUPPLY_PROP_MAX_CHARGE_VOLTAGE:
+	case POWER_SUPPLY_PROP_CONSTANT_CHARGE_VOLTAGE_MAX:
 		val->intval = chip->max_cv;
 		break;
-	case POWER_SUPPLY_PROP_CHARGE_CURRENT:
+	case POWER_SUPPLY_PROP_CONSTANT_CHARGE_CURRENT:
 		val->intval = chip->cc;
 		break;
-	case POWER_SUPPLY_PROP_CHARGE_VOLTAGE:
+	case POWER_SUPPLY_PROP_CONSTANT_CHARGE_VOLTAGE:
 		val->intval = chip->cv;
 		break;
-	case POWER_SUPPLY_PROP_INLMT:
+	case POWER_SUPPLY_PROP_INPUT_CURRENT_LIMIT:
 		val->intval = chip->inlmt;
 		break;
-	case POWER_SUPPLY_PROP_CHARGE_TERM_CUR:
-		val->intval = chip->iterm;
-		break;
-	case POWER_SUPPLY_PROP_CABLE_TYPE:
-		val->intval = chip->cable_type;
-		break;
-	case POWER_SUPPLY_PROP_ENABLE_CHARGING:
-		if (chip->boost_mode)
-			val->intval = false;
-		else {
-			charging = bq24192_is_charging();
-			val->intval = (chip->is_charging_enabled && charging);
-		}
-		break;
-	case POWER_SUPPLY_PROP_ENABLE_CHARGER:
-		val->intval = chip->is_charger_enabled;
-		break;
 	case POWER_SUPPLY_PROP_CHARGE_CONTROL_LIMIT:
 		val->intval = chip->cntl_state;
 		break;
 	case POWER_SUPPLY_PROP_CHARGE_CONTROL_LIMIT_MAX:
-		val->intval = chip->pdata->num_throttle_states;
+		val->intval = 3;
 		break;
-	case POWER_SUPPLY_PROP_MAX_TEMP:
+	case POWER_SUPPLY_PROP_TEMP_MAX:
 		val->intval = chip->max_temp;
 		break;
-	case POWER_SUPPLY_PROP_MIN_TEMP:
+	case POWER_SUPPLY_PROP_TEMP_MIN:
 		val->intval = chip->min_temp;
 		break;
 	default:
@@ -2215,20 +1555,6 @@ static int bq24192_usb_get_property(struct power_supply *psy,
 	return 0;
 }
 
-static void bq24192_resume_charging(struct bq24192_chip *chip)
-{
-	if (chip->inlmt)
-		bq24192_set_inlmt(chip, chip->inlmt);
-	if (chip->cc)
-		bq24192_set_cc(chip, chip->cc);
-	if (chip->cv)
-		bq24192_set_cv(chip, chip->cv);
-	if (chip->is_charging_enabled)
-		bq24192_enable_charging(chip, true);
-	if (chip->is_charger_enabled)
-		bq24192_enable_charger(chip, true);
-}
-
 static void bq24192_full_worker(struct work_struct *work)
 {
 	struct bq24192_chip *chip = container_of(work,
@@ -2240,7 +1566,7 @@ static void bq24192_full_worker(struct work_struct *work)
 	if(count == 4){
 		count = 0;
 		ret = bq24192_read_reg(chip_extern->client, BQ24192_INPUT_SRC_CNTL_REG);
-		printk("Input limit:%x %d\n",ret,cable_status);
+		dev_dbg(&chip->client->dev, "Input limit:%x %d\n",ret,cable_status);
 	}
 	//power_supply_changed(NULL);
 	reset_wdt_timer(chip_extern);
@@ -2248,17 +1574,6 @@ static void bq24192_full_worker(struct work_struct *work)
 	schedule_delayed_work(&chip->chrg_full_wrkr, 30*HZ);
 }
 
-static void otg_disable_worker(struct work_struct *work)
-{
-	printk("otg_resume_enable\n");
-	int ret=0;
-	ret=bq24192_reg_read_modify(chip_extern->client,
-		                 BQ24192_POWER_ON_CFG_REG,0x20, true);
-    if (ret < 0) {
-		 printk("Error in writing the control register BQ24192_POWER_ON_CFG_REG\n");
-	}
-}
-
 /* IRQ handler for charger Interrupts configured to GPIO pin */
 static irqreturn_t bq24192_irq_isr(int irq, void *devid)
 {
@@ -2296,14 +1611,13 @@ static irqreturn_t bq24192_irq_thread(int irq, void *devid)
         if (ret < 0) {
 		 printk("Error in writing the control register\n");
 		}
-	   //schedule_delayed_work(&chip->otg_disable_wrkr, 5);
        printk("bq24192 otg fault\n");
 	}
-	dev_info(&chip->client->dev, "FAULT reg %x\n", reg_fault);
+	dev_dbg(&chip->client->dev, "FAULT reg %x\n", reg_fault);
 	reg_fault = bq24192_read_reg(chip->client, BQ24192_FAULT_STAT_REG);
 	if (reg_fault < 0)
 		dev_err(&chip->client->dev, "FAULT register read failed:\n");
-	dev_info(&chip->client->dev, "FAULT reg %x\n", reg_fault);
+	dev_dbg(&chip->client->dev, "FAULT reg %x\n", reg_fault);
 	/*
 	 * check the bq24192 status/fault registers to see what is the
 	 * source of the interrupt
@@ -2311,10 +1625,10 @@ static irqreturn_t bq24192_irq_thread(int irq, void *devid)
 	reg_status = bq24192_read_reg(chip->client, BQ24192_SYSTEM_STAT_REG);
 	if (reg_status < 0)
 		dev_err(&chip->client->dev, "STATUS register read failed:\n");
-	dev_info(&chip->client->dev, "STATUS reg %x\n", reg_status);
+	dev_dbg(&chip->client->dev, "STATUS reg %x\n", reg_status);
 
 	if( (reg_status&0x30) == 0x20){
-		if(cable_status == POWER_SUPPLY_CHARGER_TYPE_USB_DCP){
+		if(cable_status == EXTCON_CHG_USB_DCP){
 			ret = bq24192_read_reg(chip->client, BQ24192_INPUT_SRC_CNTL_REG);
 			printk("Input source: %x\n",ret);
 			bq24192_set_inlmt(chip_extern,1200);
@@ -2323,55 +1637,11 @@ static irqreturn_t bq24192_irq_thread(int irq, void *devid)
 	return IRQ_HANDLED;
 }
 
-static void bq24192_PowerState_worker(struct work_struct *work)
-{
-	int type;
-	int ret=0;
-
-#ifndef USB_NOTIFY_CALLBACK
-	if(PowerStateOk){
-		   mutex_lock(&chip_extern->event_lock);
-		    ret=bq24192_reg_read_modify(chip_extern->client,
-		              BQ24192_INPUT_SRC_CNTL_REG,0x80,false);
-		    if (ret < 0) {
-			     mutex_unlock(&chip_extern->event_lock);
-			     printk("Error in writing the control register\n");
-			   return;
-
-		     }
-		   mutex_unlock(&chip_extern->event_lock);
-
-	   	    mutex_lock(&chip_extern->event_lock);
-		    ret=bq24192_reg_read_modify(chip_extern->client,
-		              BQ24192_POWER_ON_CFG_REG,0x10, true);
-		    if (ret < 0) {
-			     mutex_unlock(&chip_extern->event_lock);
-			     printk("Error in writing the control register\n");
-			   return;
-
-		     }
-		    chip_extern->is_charging_enabled=true;
-		    mutex_unlock(&chip_extern->event_lock);
-		 PowerStateOk = 0;
-		 type = GetPowerState();
-
-		 if(OtgOk)
-			type = POWER_SUPPLY_CHARGER_TYPE_NONE;
-		 bq24192_cable_callback(type);
-	   }
-	else{
-		schedule_delayed_work(&chip_extern->power_state_task_wrkr, 1*HZ);
-	}
-#endif
-}
-
 static void bq24192_task_worker(struct work_struct *work)
 {
 	struct bq24192_chip *chip =
 	    container_of(work, struct bq24192_chip, chrg_task_wrkr.work);
 	int ret, jiffy = CHARGER_TASK_JIFFIES, vbatt;
-	static int prev_health = POWER_SUPPLY_HEALTH_GOOD;
-	int curr_health;
 	u8 vindpm = INPUT_SRC_VOLT_LMT_DEF;
 
 	dev_info(&chip->client->dev, "%s\n", __func__);
@@ -2444,18 +1714,8 @@ static void bq24192_task_worker(struct work_struct *work)
 		power_supply_changed(NULL);
 
 sched_task_work:
-
-	curr_health = bq24192_get_battery_health();
-	if (prev_health != curr_health) {
-		power_supply_changed(&chip->usb);
-		dev_warn(&chip->client->dev,
-			"%s health status  %d",
-				__func__, prev_health);
-	}
-	prev_health = curr_health;
-
 	if (BQ24192_CHRGR_STAT_BAT_FULL == bq24192_is_charging()) {
-		power_supply_changed(&chip->usb);
+		power_supply_changed(chip->usb);
 		dev_warn(&chip->client->dev,
 			"%s battery full", __func__);
 	}
@@ -2463,651 +1723,139 @@ static void bq24192_task_worker(struct work_struct *work)
 	schedule_delayed_work(&chip->chrg_task_wrkr, jiffy);
 }
 
-static void bq24192_otg_evt_worker(struct work_struct *work)
-{
-	struct bq24192_chip *chip =
-	    container_of(work, struct bq24192_chip, otg_evt_work);
-	struct bq24192_otg_event *evt, *tmp;
-	unsigned long flags;
-	int ret = 0;
-
-	dev_info(&chip->client->dev, "%s\n", __func__);
-
-	spin_lock_irqsave(&chip->otg_queue_lock, flags);
-	list_for_each_entry_safe(evt, tmp, &chip->otg_queue, node) {
-		list_del(&evt->node);
-		spin_unlock_irqrestore(&chip->otg_queue_lock, flags);
-
-		dev_info(&chip->client->dev,
-			"%s:%d state=%d\n", __FILE__, __LINE__,
-				evt->is_enable);
-
-		ret = bq24192_turn_otg_vbus(chip, evt->is_enable);
-		if (ret < 0)
-			dev_err(&chip->client->dev, "VBUS ON FAILED:\n");
-
-		spin_lock_irqsave(&chip->otg_queue_lock, flags);
-		kfree(evt);
-
-	}
-	spin_unlock_irqrestore(&chip->otg_queue_lock, flags);
-}
-
-
-static void bq24192_temp_update_worker(struct work_struct *work)
-{
-	struct bq24192_chip *chip =
-	    container_of(work, struct bq24192_chip, chrg_temp_wrkr.work);
-	int fault_reg = 0, fg_temp = 0;
-	static bool is_otp_notified;
-
-	dev_info(&chip->client->dev, "%s\n", __func__);
-	/* Check if battery fault condition occured. Reading the register
-	   value two times to get reliable reg value, recommended by vendor*/
-	fault_reg = bq24192_read_reg(chip->client, BQ24192_FAULT_STAT_REG);
-	if (fault_reg < 0) {
-		dev_err(&chip->client->dev,
-			"Fault status read failed: %d\n", fault_reg);
-		goto temp_wrkr_error;
-	}
-	fault_reg = bq24192_read_reg(chip->client, BQ24192_FAULT_STAT_REG);
-	if (fault_reg < 0) {
-		dev_err(&chip->client->dev,
-			"Fault status read failed: %d\n", fault_reg);
-		goto temp_wrkr_error;
-	}
+extern int intel_mid_pmic_writeb(int reg, u8 val);
 
-	fg_temp = fg_chip_get_property(POWER_SUPPLY_PROP_TEMP);
-	if (fg_temp == -ENODEV || fg_temp == -EINVAL) {
-		dev_err(&chip->client->dev,
-			"Failed to read FG temperature\n");
-		/* If failed to read fg temperature, use charger fault
-		 * status to identify the recovery */
-		if (fault_reg & FAULT_STAT_BATT_TEMP_BITS) {
-			schedule_delayed_work(&chip->chrg_temp_wrkr,
-				TEMP_THREAD_JIFFIES);
-		} else {
-			power_supply_changed(&chip->usb);
-		}
-		goto temp_wrkr_error;
-	}
-	fg_temp = fg_temp/10;
+void charger_enabled_poweron() {
+       int ret = 0;
 
-	if (fg_temp >= chip->pdata->max_temp
-		|| fg_temp <= chip->pdata->min_temp) {
-		if (!is_otp_notified) {
-			dev_info(&chip->client->dev,
-				"Battery over temp occurred!!!!\n");
-			power_supply_changed(&chip->usb);
-			is_otp_notified = true;
-		}
-	} else if (!(fault_reg & FAULT_STAT_BATT_TEMP_BITS)) {
-		/* over temperature is recovered if battery temp
-		 * is between min_temp to max_temp and charger
-		 * temperature fault bits are cleared */
-		is_otp_notified = false;
-		dev_info(&chip->client->dev,
-			"Battery over temp recovered!!!!\n");
-		power_supply_changed(&chip->usb);
-		/*Return without reschedule as over temp recovered*/
+        mutex_lock(&chip_extern->event_lock);
+	ret=bq24192_reg_read_modify(chip_extern->client, BQ24192_INPUT_SRC_CNTL_REG,0x80,false);
+	if (ret < 0) {
+		mutex_unlock(&chip_extern->event_lock);
+		printk("Error in writing the control register\n");
 		return;
 	}
-	schedule_delayed_work(&chip->chrg_temp_wrkr, TEMP_THREAD_JIFFIES);
-	return;
-
-temp_wrkr_error:
-	is_otp_notified = false;
-	return;
-}
-
+	mutex_unlock(&chip_extern->event_lock);
 
-static int otg_handle_notification(struct notifier_block *nb,
-				   unsigned long event, void *param)
-{
-	struct bq24192_chip *chip =
-	    container_of(nb, struct bq24192_chip, otg_nb);
-	struct bq24192_otg_event *evt;
-
-	dev_info(&chip->client->dev, "OTG notification: %lu\n", event);
-
-    	printk("wigman....%s...vbus_Event=%d\n",__func__,vbus_Event);
-	if((!OtgOk)&&vbus_Event){
-	    vbus_Event = 0;
-	    printk("wigman.....clear vbus_Event%d\n",VbusDetach);
-	    if(VbusDetach){
-#ifndef USB_NOTIFY_CALLBACK
-		   PowerStateOk = 0;
-#endif
-		   Power_State = POWER_SUPPLY_CHARGER_TYPE_NONE;
-		   cancel_delayed_work(&chip_extern->power_state_task_wrkr);
-		   bq24192_cable_callback(POWER_SUPPLY_CHARGER_TYPE_NONE);
-		}else{
-			schedule_delayed_work(&chip->power_state_task_wrkr, 1*HZ);
-		}
-	}
-	if (!param || event != USB_EVENT_DRIVE_VBUS)
-		return NOTIFY_DONE;
-
-	evt = kzalloc(sizeof(*evt), GFP_ATOMIC);
-	if (!evt) {
-		dev_err(&chip->client->dev,
-			"failed to allocate memory for OTG event\n");
-		return NOTIFY_DONE;
+	mutex_lock(&chip_extern->event_lock);
+	ret=bq24192_reg_read_modify(chip_extern->client,
+	BQ24192_POWER_ON_CFG_REG,0x10, true);
+	if (ret < 0) {
+		mutex_unlock(&chip_extern->event_lock);
+		printk("Error in writing the control register\n");
+		 return;
 	}
-
-	evt->is_enable = *(bool *)param;
-	dev_info(&chip->client->dev, "evt->is_enable is %d\n", evt->is_enable);
-	INIT_LIST_HEAD(&evt->node);
-
-	spin_lock(&chip->otg_queue_lock);
-	list_add_tail(&evt->node, &chip->otg_queue);
-	spin_unlock(&chip->otg_queue_lock);
-
-	queue_work(system_nrt_wq, &chip->otg_evt_work);
-	return NOTIFY_OK;
+	mutex_unlock(&chip_extern->event_lock);
 }
 
-static inline int register_otg_notification(struct bq24192_chip *chip)
-{
+static struct power_supply_desc bq24192_usb_desc = {
+	.name = CHARGER_PS_NAME,
+	.type = POWER_SUPPLY_TYPE_USB,
+	.properties = bq24192_usb_props,
+	.num_properties = ARRAY_SIZE(bq24192_usb_props),
+	.get_property = bq24192_usb_get_property,
+	.set_property = bq24192_usb_set_property,
+};
 
-	int retval;
+static char *bq24192_supplied_to[] = {
+	"battery",
+};
 
-	INIT_LIST_HEAD(&chip->otg_queue);
-	INIT_WORK(&chip->otg_evt_work, bq24192_otg_evt_worker);
-	spin_lock_init(&chip->otg_queue_lock);
+static int bq24192_vbus_notifier(struct notifier_block *nb,
+	unsigned long event, void *ptr)
+{
+	struct bq24192_chip *chip = container_of(nb, struct bq24192_chip, vbus_nb);
 
-	chip->otg_nb.notifier_call = otg_handle_notification;
+	if (event && chip->boost_mode) {
+		/*
+		 * VBUS may trigger when in OTG boost mode.
+		 * This is incorrect, so cancel the event since running
+		 * charger detection would be pointless.
+		 */
+		return NOTIFY_BAD;
+	}
 
 	/*
-	 * Get the USB transceiver instance
+	 * When power source is removed from the OTG adapter,
+	 * we need to enable the OTG boost to power it from battery.
+	 *
+	 * TODO: Right now, the USB devices are disconnected for a short moment.
+	 *   This could be only avoided by enabling OTG boost all the time..
 	 */
-	chip->transceiver = usb_get_phy(USB_PHY_TYPE_USB2);
-	if (!chip->transceiver) {
-		dev_err(&chip->client->dev, "Failed to get the USB transceiver\n");
-		return -EINVAL;
-	}
-	retval = usb_register_notifier(chip->transceiver, &chip->otg_nb);
-	if (retval) {
-		dev_err(&chip->client->dev,
-			"failed to register otg notifier\n");
-		return -EINVAL;
-	}
-
-	return 0;
-}
-
-int bq24192_slave_mode_enable_charging(int volt, int cur, int ilim)
-{
-	struct bq24192_chip *chip = i2c_get_clientdata(bq24192_client);
-	int ret;
-
-	mutex_lock(&chip->event_lock);
-	chip->inlmt = chrg_ilim_to_reg(ilim);
-	if (chip->inlmt >= 0)
-		bq24192_set_inlmt(chip, chip->inlmt);
-	mutex_unlock(&chip->event_lock);
-
-	chip->cc = chrg_cur_to_reg(cur);
-	if (chip->cc)
-		bq24192_set_cc(chip, chip->cc);
-
-	chip->cv = chrg_volt_to_reg(volt);
-	if (chip->cv)
-		bq24192_set_cv(chip, chip->cv);
-
-	mutex_lock(&chip->event_lock);
-	ret = bq24192_enable_charging(chip, true);
-	if (ret < 0)
-		dev_err(&chip->client->dev, "charge enable failed\n");
+	 if (!event && !chip->boost_mode)
+		 schedule_delayed_work(&chip->otg_work, msecs_to_jiffies(100));
 
-	mutex_unlock(&chip->event_lock);
-	return ret;
+	return NOTIFY_DONE;
 }
-EXPORT_SYMBOL(bq24192_slave_mode_enable_charging);
 
-int bq24192_slave_mode_disable_charging(void)
+static void bq24192_update_charger_state(struct work_struct *work)
 {
-	struct bq24192_chip *chip = i2c_get_clientdata(bq24192_client);
-	int ret;
-
-	mutex_lock(&chip->event_lock);
-	ret = bq24192_enable_charging(chip, false);
-	if (ret < 0)
-		dev_err(&chip->client->dev, "charge enable failed\n");
+	struct bq24192_chip *chip = container_of(work,
+									struct bq24192_chip, charger_type_work);
 
-	mutex_unlock(&chip->event_lock);
-	return ret;
+	if (extcon_get_state(chip->charger_edev, EXTCON_CHG_USB_DCP) == 1) {
+		bq24192_cable_callback(EXTCON_CHG_USB_DCP);
+	} else if (extcon_get_state(chip->charger_edev, EXTCON_CHG_USB_SDP) == 1) {
+		bq24192_cable_callback(EXTCON_CHG_USB_SDP);
+	} else {
+		bq24192_cable_callback(EXTCON_NONE);
+	}
 }
-//--------------------------------------------------------------------
-/* show mode entry (auto, none, host, dedicated or boost) */
-static ssize_t bq2415x_sysfs_show_mode(struct device *dev,
-				       struct device_attribute *attr,
-				       char *buf)
-{
-	ssize_t ret = 0;
 
-	switch(g_charger_mode){
-	case 0:
-		ret += sprintf(buf+ret, "off");
-		break;
-	case 1:
-	case 2:
-		ret += sprintf(buf+ret, "dedicated");
-		break;
-	default: break;
-		}
-
-	ret += sprintf(buf+ret, "\n");
-	return ret;
-}
-static ssize_t bq2415x_sysfs_set_mode(struct device *dev,
-				      struct device_attribute *attr,
-				      const char *buf,
-				      size_t count)
+static int bq24192_charger_notifier(struct notifier_block *nb,
+	unsigned long event, void *ptr)
 {
-	int ret = 0;
-	if (strncmp(buf, "off", 3) == 0){
-
-		suspend_flag=0;
-		g_charger_mode=0;
-
-		//--register
-		printk("Find: Stop charge 6\n");
-		mutex_lock(&chip_extern->event_lock);
-		    ret=bq24192_reg_read_modify(chip_extern->client,
-		              BQ24192_INPUT_SRC_CNTL_REG,0x80,true);
-		    if (ret < 0) {
-			     mutex_unlock(&chip_extern->event_lock);
-			     printk("Error in writing the control register\n");
-			   return ret;
-
-		     }
-		mutex_unlock(&chip_extern->event_lock);
-
-		mutex_lock(&chip_extern->event_lock);
-		ret=bq24192_reg_read_modify(chip_extern->client,
-		                 BQ24192_POWER_ON_CFG_REG,0x10, false);
-		if (ret < 0) {
-			mutex_unlock(&chip_extern->event_lock);
-			printk("xia:Error in writing the control register\n");
-			return ret;
-		}
-		chip_extern->is_charging_enabled=false;
-		mutex_unlock(&chip_extern->event_lock);
-		if(WakeLockFlag==1){
-			printk("y1\n");
-			 WakeLockFlag=0;
-			 bq24192_ac_unlock();
-		}
-		cur_cable_status = UG31XX_NO_CABLE;
-		AC_STATE   = 0;
-		USB_STATE = 0;
-		//bq24192_write_reg(bq24192_client, BQ24192_INPUT_SRC_CNTL_REG, 0x32);
-
-	    printk("xia0:g_charger_mode=%d,suspend_flag=%d\n",g_charger_mode,suspend_flag);
-
- 	}
-	 else if(strncmp(buf,"dedicated",9) == 0){
-
-		suspend_flag=0;
-
-		//--register
-		printk("Find: Open charge 5\n");
-		mutex_lock(&chip_extern->event_lock);
-		    ret=bq24192_reg_read_modify(chip_extern->client,
-		              BQ24192_INPUT_SRC_CNTL_REG,0x80,false);
-		    if (ret < 0) {
-			     mutex_unlock(&chip_extern->event_lock);
-			     printk("Error in writing the control register\n");
-			   return ret;
-
-		     }
-		mutex_unlock(&chip_extern->event_lock);
-
-		mutex_lock(&chip_extern->event_lock);
-		ret=bq24192_reg_read_modify(chip_extern->client,
-		              BQ24192_POWER_ON_CFG_REG,0x10, true);
-		if (ret < 0) {
-			mutex_unlock(&chip_extern->event_lock);
-			printk("xia:Error in writing the control register\n");
-			return ret;
-		}
-		chip_extern->is_charging_enabled=true;
-		mutex_unlock(&chip_extern->event_lock);
-
-		int type;
-		if((!VbusDetach)&&(!OtgOk)){
-#ifndef USB_NOTIFY_CALLBACK
-			type = GetPowerState();
-#endif
-			if(type== POWER_SUPPLY_CHARGER_TYPE_USB_SDP){
-		        if(WakeLockFlag==0){
-					printk("y2\n");
-			    bq24192_ac_lock();
-			    WakeLockFlag=1;
-		        }
-			    cur_cable_status = UG31XX_USB_PC_CABLE;
-			    AC_STATE   = 0;
-			    USB_STATE = 1;
-			   g_charger_mode=1;
-			   bq24192_write_reg(bq24192_client, BQ24192_INPUT_SRC_CNTL_REG, 0x32);
-		    }
-			else if(type== POWER_SUPPLY_CHARGER_TYPE_USB_DCP){
-
-			    if(WakeLockFlag==0){
-					printk("y3\n");
-			      bq24192_ac_lock();
-			      WakeLockFlag=1;
-		         }
-				cur_cable_status = UG31XX_AC_ADAPTER_CABLE;
-				AC_STATE   = 1;
-				USB_STATE = 0;
-				g_charger_mode=2;
-				bq24192_write_reg(bq24192_client, BQ24192_INPUT_SRC_CNTL_REG, 0x35);
-		   }
-		   else {
-		   	    if(WakeLockFlag==1){
-					printk("y4\n");
-			      WakeLockFlag=0;
-			      bq24192_ac_unlock();
-		        }
-		   	    cur_cable_status = UG31XX_NO_CABLE;
-		        AC_STATE   = 0;
-		        USB_STATE = 0;
-		        bq24192_write_reg(bq24192_client, BQ24192_INPUT_SRC_CNTL_REG, 0x32);
-			   g_charger_mode=-1;
-		   }
-
-		}
-        else{
-			if(WakeLockFlag==1){
-				printk("y5\n");
-			      WakeLockFlag=0;
-			      bq24192_ac_unlock();
-		        }
-		   	    cur_cable_status = UG31XX_NO_CABLE;
-		        AC_STATE   = 0;
-		        USB_STATE = 0;
-		        bq24192_write_reg(bq24192_client, BQ24192_INPUT_SRC_CNTL_REG, 0x32);
-            g_charger_mode=-1;
-        }
-		printk("xia1:g_charger_mode=%d,suspend_flag=%d\n",g_charger_mode,suspend_flag);
-
-	}
-
-	power_supply_changed(&bq24192_supply[PWR_SUPPLY_USB]);
-	power_supply_changed(&bq24192_supply[PWR_SUPPLY_AC]);
-	power_supply_changed(&bq24192_supply[PWR_SUPPLY_bq21455]);
-
-	return count;
+	struct bq24192_chip *chip = container_of(nb,
+									struct bq24192_chip, charger_nb);
+	schedule_work(&chip->charger_type_work);
+	return NOTIFY_OK;
 }
 
-/* close ac suspend mode */
-static ssize_t bq2415x_sysfs_set_ac_suspend_mode(struct device *dev,
-				       struct device_attribute *attr,
-				       const char *buf,
-				       size_t count)//lambert
+static void bq24192_otg_boost(struct bq24192_chip *chip, bool enable)
 {
-	int ret=0;
-#ifndef USB_NOTIFY_CALLBACK
-	if (strncmp(buf, "close", 5) == 0)
-	{
-		suspend_flag=1;
-		printk("xiahuang2:suspend-flag=%d\n",suspend_flag);
-		printk("Find: Open charge 6\n");
-
-		mutex_lock(&chip_extern->event_lock);
-		    ret=bq24192_reg_read_modify(chip_extern->client,
-		              BQ24192_INPUT_SRC_CNTL_REG,0x80,false);
-		    if (ret < 0) {
-			     mutex_unlock(&chip_extern->event_lock);
-			     printk("Error in writing the control register\n");
-			   return ret;
-
-		     }
-		mutex_unlock(&chip_extern->event_lock);
-
-		mutex_lock(&chip_extern->event_lock);
-		ret=bq24192_reg_read_modify(chip_extern->client,
-		              BQ24192_POWER_ON_CFG_REG,0x10, true);
-		if (ret < 0) {
-			mutex_unlock(&chip_extern->event_lock);
-			printk("xia:Error in writing the control register\n");
-			return ret;
-		}
-		chip_extern->is_charging_enabled=true;
-		mutex_unlock(&chip_extern->event_lock);
+	if (chip->boost_mode == enable)
+		return;
 
-		int type;
-		if((!VbusDetach)&&(!OtgOk)){
-			type = GetPowerState();
-			if(type== POWER_SUPPLY_CHARGER_TYPE_USB_SDP){
-		        if(WakeLockFlag==0){
-					printk("y2\n");
-			    bq24192_ac_lock();
-			    WakeLockFlag=1;
-		        }
-			    cur_cable_status = UG31XX_USB_PC_CABLE;
-			    AC_STATE   = 0;
-			    USB_STATE = 1;
-			   g_charger_mode=-1;
-			   bq24192_write_reg(bq24192_client, BQ24192_INPUT_SRC_CNTL_REG, 0x32);
-		    }
-			else if(type== POWER_SUPPLY_CHARGER_TYPE_USB_DCP){
-
-			    if(WakeLockFlag==0){
-					printk("y3\n");
-			      bq24192_ac_lock();
-			      WakeLockFlag=1;
-		         }
-				cur_cable_status = UG31XX_AC_ADAPTER_CABLE;
-				AC_STATE   = 1;
-				USB_STATE = 0;
-				g_charger_mode=-1;
-				bq24192_write_reg(bq24192_client, BQ24192_INPUT_SRC_CNTL_REG, 0x35);
-		   }
-		   else {
-		   	    if(WakeLockFlag==1){
-					printk("y4\n");
-			      WakeLockFlag=0;
-			      bq24192_ac_unlock();
-		        }
-		   	    cur_cable_status = UG31XX_NO_CABLE;
-		        AC_STATE   = 0;
-		        USB_STATE = 0;
-		        bq24192_write_reg(bq24192_client, BQ24192_INPUT_SRC_CNTL_REG, 0x32);
-			   g_charger_mode=-1;
-		   }
+	dev_info(&chip->client->dev, "Update OTG boost: %d\n", enable);
 
-		}
-        else{
-			if(WakeLockFlag==1){
-				printk("y5\n");
-			      WakeLockFlag=0;
-			      bq24192_ac_unlock();
-		        }
-		   	    cur_cable_status = UG31XX_NO_CABLE;
-		        AC_STATE   = 0;
-		        USB_STATE = 0;
-		        bq24192_write_reg(bq24192_client, BQ24192_INPUT_SRC_CNTL_REG, 0x32);
-            g_charger_mode=-1;
-        }
-		printk("xia1:g_charger_mode=%d,suspend_flag=%d\n",g_charger_mode,suspend_flag);
-	power_supply_changed(&bq24192_supply[PWR_SUPPLY_USB]);
-	power_supply_changed(&bq24192_supply[PWR_SUPPLY_AC]);
-	power_supply_changed(&bq24192_supply[PWR_SUPPLY_bq21455]);
-	}
-#endif
-	return count;
+	bq24192_reg_read_modify(chip->client,
+			BQ24192_POWER_ON_CFG_REG, 0x20, enable);
+	chip->boost_mode = enable;
 }
 
-
-static ssize_t bq2415x_sysfs_show_ac_suspend_mode(struct device *dev,
-					struct device_attribute *attr,
-					char *buf)
+static void bq24192_update_otg_state(struct work_struct *work)
 {
-	ssize_t ret = 0;
-    printk("xia2:g_charger_mode=%d,suspend_flag=%d\n",g_charger_mode,suspend_flag);
-	if(suspend_flag==1) ret += sprintf(buf+ret, "close");
-	else ret += sprintf(buf+ret, "open");
-
-	ret += sprintf(buf+ret, "\n");
-	return ret;
-}
-
-static DEVICE_ATTR(ac_suspend_mode, S_IRWXU | S_IRWXG ,
-		bq2415x_sysfs_show_ac_suspend_mode, bq2415x_sysfs_set_ac_suspend_mode);
-static DEVICE_ATTR(mode, S_IRWXU |S_IRWXG ,
-		bq2415x_sysfs_show_mode, bq2415x_sysfs_set_mode);
+	struct bq24192_chip *chip = container_of(work,
+									struct bq24192_chip, otg_work.work);
 
-static struct attribute *bq2415x_sysfs_attributes[] = {
 	/*
-	 * TODO: some (appropriate) of these attrs should be switched to
-	 * use power supply class props.
+	 * Enable 5V boost for OTG if host mode is activated
+	 * and there is no charger/power source inserted.
 	 */
-	&dev_attr_ac_suspend_mode.attr,
-	&dev_attr_mode.attr,
-	NULL,
-};
-
-static const struct attribute_group bq2415x_sysfs_attr_group = {
-	.attrs = bq2415x_sysfs_attributes,
-};
-
-static int bq2415x_sysfs_init(void)
-{
-	return sysfs_create_group(&bq24192_supply[2].dev->kobj,
-			&bq2415x_sysfs_attr_group);
+	bq24192_otg_boost(chip,
+		extcon_get_state(chip->id_edev, EXTCON_USB_HOST) == 1
+			&& !extcon_get_state(chip->vbus_edev, EXTCON_USB));
 }
 
-static void bq2415x_sysfs_exit(void)
+static int bq24192_otg_notifier(struct notifier_block *nb,
+	unsigned long event, void *ptr)
 {
-	sysfs_remove_group(&bq24192_supply[2].dev->kobj, &bq2415x_sysfs_attr_group);
+	struct bq24192_chip *chip = container_of(nb, struct bq24192_chip, otg_nb);
+	schedule_delayed_work(&chip->otg_work, msecs_to_jiffies(300));
+	return NOTIFY_DONE;
 }
-//--------------------------------------------------------------------
-extern int intel_mid_pmic_writeb(int reg, u8 val);
-static int g_usb_state;
-struct workqueue_struct *charger_work_queue = NULL;
-struct delayed_work charger_work;
 
-void charger_enabled_poweron() {
-       int ret = 0;
-
-        mutex_lock(&chip_extern->event_lock);
-	ret=bq24192_reg_read_modify(chip_extern->client, BQ24192_INPUT_SRC_CNTL_REG,0x80,false);
-	if (ret < 0) {
-		mutex_unlock(&chip_extern->event_lock);
-		printk("Error in writing the control register\n");
-		return;
-	}
-	mutex_unlock(&chip_extern->event_lock);
-
-	mutex_lock(&chip_extern->event_lock);
-	ret=bq24192_reg_read_modify(chip_extern->client,
-	BQ24192_POWER_ON_CFG_REG,0x10, true);
-	if (ret < 0) {
-		mutex_unlock(&chip_extern->event_lock);
-		printk("Error in writing the control register\n");
-		 return;
-	}
-	chip_extern->is_charging_enabled = true;
-	mutex_unlock(&chip_extern->event_lock);
-}
-
-static void do_charger(struct work_struct *work) {
-        bq24192_cable_callback(g_usb_state);
-}
-
-int setCharger(int usb_state) {
-        g_usb_state = usb_state;
-        queue_delayed_work(charger_work_queue, &charger_work, 0);
-
-	return 0;
-}
-#ifdef USB_NOTIFY_CALLBACK
-extern unsigned int query_cable_status(void);
-
-
-static int cable_status_notify(struct notifier_block *self, unsigned long action, void *dev) {
-
-/*
-   if (ischargerSuspend) {
-       printk(KERN_INFO "%s chager is suspend but USB still notify !!!\n", __func__);
-       wake_lock(&wakelock_smb347);
-       isUSBSuspendNotify = true;
-       return NOTIFY_OK;
-   }
-*/
-
-   switch (action) {
-      case POWER_SUPPLY_CHARGER_TYPE_USB_SDP:
-          printk(KERN_INFO "%s POWER_SUPPLY_CHARGER_TYPE_USB_SDP !!!\n", __func__);
-          setCharger(action);
-          break;
-
-      case POWER_SUPPLY_CHARGER_TYPE_USB_CDP:
-          printk(KERN_INFO "%s POWER_SUPPLY_CHARGER_TYPE_USB_CDP !!!\n", __func__);
-          setCharger(action);
-          break;
-
-      case POWER_SUPPLY_CHARGER_TYPE_USB_DCP:
-          printk(KERN_INFO "%s POWER_SUPPLY_CHARGER_TYPE_USB_DCP !!!\n", __func__);
-          setCharger(action);
-          break;
-
-      case POWER_SUPPLY_CHARGER_TYPE_ACA_DOCK:
-          printk(KERN_INFO "%s POWER_SUPPLY_CHARGER_TYPE_ACA_DOCK !!!\n", __func__);
-          setCharger(action);
-          break;
-
-      case POWER_SUPPLY_CHARGER_TYPE_SE1:
-          printk(KERN_INFO "%s POWER_SUPPLY_CHARGER_TYPE_SE1 !!!\n", __func__);
-          setCharger(action);
-          break;
-
-      case POWER_SUPPLY_CHARGER_TYPE_USB_OTG_CONNECTED:
-          printk(KERN_INFO "%s POWER_SUPPLY_CHARGER_TYPE_USB_OTG_CONNECTED !!!\n", __func__);
-          schedule_delayed_work(&chip_extern->otg_wrkr, 0*HZ);
-          break;
-
-      case POWER_SUPPLY_CHARGER_TYPE_USB_OTG_DISCONNECTED:
-          printk(KERN_INFO "%s POWER_SUPPLY_CHARGER_TYPE_USB_OTG_DISCONNECTED !!!\n", __func__);
-          schedule_delayed_work(&chip_extern->otg_wrkr, 0*HZ);
-          break;
-
-      case POWER_SUPPLY_CHARGER_TYPE_NONE:
-          printk(KERN_INFO "%s POWER_SUPPLY_CHARGER_TYPE_NONE !!!\n", __func__);
-          setCharger(action);
-	  break;
-
-      default:
-          printk(KERN_INFO "%s no status = %d !!!\n", __func__, (int)action);
-	  break;
-   }
-   return NOTIFY_OK;
-}
-
-static struct notifier_block cable_status_notifier = {
-	.notifier_call = cable_status_notify,
-};
-
-extern int cable_status_register_client(struct notifier_block *nb);
-extern int cable_status_unregister_client(struct notifier_block *nb);
-#endif
+#define CRYSTAL_COVE_IRQ_CHGR		4
+extern struct intel_soc_pmic *intel_pmic;
 
 static int bq24192_probe(struct i2c_client *client,
 			const struct i2c_device_id *id)
 {
-	struct i2c_adapter *adapter = to_i2c_adapter(client->dev.parent);
 	struct bq24192_chip *chip;
-	int ret,gpio_handle,gpio_data,irq,rgrt;
-
-	if (!client->dev.platform_data) {
-		dev_err(&client->dev, "platform Data is NULL");
-		return -EFAULT;
-	}
+	struct power_supply_config usb_config;
+	int ret;
 
-	if (!i2c_check_functionality(adapter, I2C_FUNC_SMBUS_BYTE_DATA)) {
+	if (!i2c_check_functionality(client->adapter, I2C_FUNC_SMBUS_BYTE_DATA)) {
 		dev_err(&client->dev,
 				"SMBus doesn't support BYTE transactions\n");
 		return -EIO;
@@ -3119,7 +1867,6 @@ static int bq24192_probe(struct i2c_client *client,
 		return -ENOMEM;
 	}
 
-	chip->pdata = client->dev.platform_data;
 	/*assigning default value for min and max temp*/
 	chip->min_temp = BATT_TEMP_MIN_DEF;
 	chip->max_temp = BATT_TEMP_MAX_DEF;
@@ -3146,26 +1893,14 @@ static int bq24192_probe(struct i2c_client *client,
 	chip_extern = chip;
 	chip->client = client;
 
-	/*
-	 * Initialize the platform data
-	 */
-	if (chip->pdata->init_platform_data) {
-		ret = chip->pdata->init_platform_data();
-		if (ret < 0) {
-			dev_err(&chip->client->dev,
-					"FAILED: init_platform_data\n");
-		}
-	}
-
-
 	/*
 	 * Request for charger chip gpio.This will be used to
 	 * register for an interrupt handler for servicing charger
 	 * interrupts
 	 */
-
-	if (chip->pdata->get_irq_number) {
-		chip->irq = chip->pdata->get_irq_number();
+	if (intel_pmic) {
+		chip->irq = regmap_irq_get_virq(intel_pmic->irq_chip_data,
+						CRYSTAL_COVE_IRQ_CHGR);
 		if (chip->irq < 0) {
 			dev_err(&chip->client->dev,
 				"chgr_int_n GPIO is not available\n");
@@ -3189,47 +1924,41 @@ static int bq24192_probe(struct i2c_client *client,
 	intel_mid_pmic_writeb(R_PMIC_MIRQS0,0x00);
 	intel_mid_pmic_writeb(R_PMIC_MIRQSX,0x00);
 
-	INIT_DELAYED_WORK(&chip->otg_wrkr, otg_worker);
-
-#ifndef USB_NOTIFY_CALLBACK
-	gpio_request(152, "CHRGE_OTG");
-	gpio_handle = acpi_get_gpio("\\_SB.GPO2", 22);
-	gpio_direction_input(gpio_handle);
-	irq = gpio_to_irq(152);
-	ret = request_threaded_irq(irq,
-	otg_irq_isr, otg_irq_thread,
-	IRQF_TRIGGER_FALLING|IRQF_TRIGGER_RISING|IRQF_DISABLED|IRQF_ONESHOT, "OtgTrip", NULL);
-	if(ret)
-		printk("failed to register irq for pin %d\n",irq);
-#endif
+	/*
+	 * Get extcon devices (might as well hard-code since this driver is
+	 * too bad to be used anywhere else...)
+	 */
+	chip->vbus_edev = extcon_get_extcon_dev("crystal_cove_pwrsrc");
+	if (!chip->vbus_edev) {
+		dev_err(&client->dev, "VBUS extcon device does not exist\n");
+		return -ENODEV;
+	}
+	if (IS_ERR(chip->vbus_edev))
+		return PTR_ERR(chip->vbus_edev);
 
-	ChargeInit(POWER_SUPPLY_CHARGER_TYPE_USB_SDP);
+	chip->id_edev = extcon_get_extcon_dev("INT3496:00");
+	if (!chip->id_edev) {
+		dev_err(&client->dev, "ID extcon device does not exist\n");
+		return -ENODEV;
+	}
+	if (IS_ERR(chip->id_edev))
+		return PTR_ERR(chip->id_edev);
 
-	gpio_handle = acpi_get_gpio("\\_SB.GPO2", 22);//OTG function
-	gpio_data = __gpio_get_value(gpio_handle);
-	printk("OTG_ID:%d\n",gpio_data);
-	if(gpio_data == 0){
-		printk("[%s] Otg plug in !! \n",__func__);
-		 OtgOk = 1;
-		 bq24192_reg_read_modify(chip->client,BQ24192_POWER_ON_CFG_REG,0x20, true);
-	}else{
-		printk("[%s] OTG plug out !! \n",__func__);
-		OtgOk = 0;
-		bq24192_reg_read_modify(chip->client,BQ24192_POWER_ON_CFG_REG,0x20, false);
+	chip->charger_edev = extcon_get_extcon_dev("phy-dwc3.1.auto.ulpi.0");
+	if (!chip->charger_edev) {
+		dev_err(&client->dev, "Charger extcon device does not exist\n");
+		return -ENODEV;
 	}
+	if (IS_ERR(chip->charger_edev))
+		return PTR_ERR(chip->charger_edev);
+
+	ChargeInit(EXTCON_CHG_USB_SDP);
 
 	INIT_DELAYED_WORK(&chip->chrg_full_wrkr, bq24192_full_worker);
 	INIT_DELAYED_WORK(&chip->chrg_task_wrkr, bq24192_task_worker);
-	INIT_DELAYED_WORK(&chip->power_state_task_wrkr, bq24192_PowerState_worker);
 	INIT_DELAYED_WORK(&chip->jeita_wrkr, JetiaWork);
-	INIT_DELAYED_WORK(&chip->otg_disable_wrkr, otg_disable_worker);
 	schedule_delayed_work(&chip->chrg_full_wrkr, 3*HZ);
-#ifdef ASUS_ENG_BUILD
-        schedule_delayed_work(&chip->jeita_wrkr, 20*HZ);
-#else
 	schedule_delayed_work(&chip->jeita_wrkr, 60*HZ);
-#endif
-	//INIT_DELAYED_WORK(&chip->chrg_temp_wrkr, bq24192_temp_update_worker);
 	mutex_init(&chip->event_lock);
 
 	/* Initialize the wakelock */
@@ -3237,25 +1966,17 @@ static int bq24192_probe(struct i2c_client *client,
 						"ctp_charger_wakelock");
 
 	/* register bq24192 usb with power supply subsystem */
-	if (!chip->pdata->slave_mode) {
-		chip->usb.name = CHARGER_PS_NAME;
-		chip->usb.type = POWER_SUPPLY_TYPE_USB;
-		chip->usb.supplied_to = chip->pdata->supplied_to;
-		chip->usb.num_supplicants = chip->pdata->num_supplicants;
-		chip->usb.throttle_states = chip->pdata->throttle_states;
-		chip->usb.num_throttle_states =
-					chip->pdata->num_throttle_states;
-		chip->usb.supported_cables = chip->pdata->supported_cables;
+	if (true) { // !chip->pdata->slave_mode
+		usb_config.drv_data = chip;
+		usb_config.supplied_to = bq24192_supplied_to;
+		usb_config.num_supplicants = ARRAY_SIZE(bq24192_supplied_to);
 		chip->max_cc = 1216;
 		chip->max_cv = 4200;
-		chip->bat_health = POWER_SUPPLY_HEALTH_GOOD;
 		chip->chgr_stat = BQ24192_CHRGR_STAT_UNKNOWN;
-		chip->usb.properties = bq24192_usb_props;
-		chip->usb.num_properties = ARRAY_SIZE(bq24192_usb_props);
-		chip->usb.get_property = bq24192_usb_get_property;
-		chip->usb.set_property = bq24192_usb_set_property;
-		ret = power_supply_register(&client->dev, &chip->usb);
-		if (ret) {
+		chip->usb = power_supply_register(&client->dev, &bq24192_usb_desc,
+						&usb_config);
+		if (IS_ERR(chip->usb)) {
+			ret = PTR_ERR(chip->usb);
 			dev_err(&client->dev, "failed:power supply register\n");
 			i2c_set_clientdata(client, NULL);
 			kfree(chip);
@@ -3266,51 +1987,48 @@ static int bq24192_probe(struct i2c_client *client,
 	//pm_runtime_put_noidle(&chip->client->dev);
 	//pm_schedule_suspend(&chip->client->dev, MSEC_PER_SEC);
 
-	/* create debugfs for maxim registers */
-	ret = bq24192_create_debugfs(chip);
-	if (ret < 0) {
-		dev_err(&client->dev, "debugfs create failed\n");
-		power_supply_unregister(&chip->usb);
-		i2c_set_clientdata(client, NULL);
-		kfree(chip);
+	ret = bq24192_powersupply_init(client);
+	if (ret)
 		return ret;
-	}
-        charger_work_queue = create_singlethread_workqueue("charger_workqueue");
-        INIT_DELAYED_WORK(&charger_work, do_charger);
-#ifdef USB_NOTIFY_CALLBACK
-	cable_status_register_client(&cable_status_notifier);
-        cable_status_notify( NULL, query_cable_status(), &client->dev);
-#else
-	/*
-	 * Register to get USB transceiver events
-	 */
-	ret = register_otg_notification(chip);
+
+	INIT_WORK(&chip->charger_type_work, bq24192_update_charger_state);
+	INIT_DELAYED_WORK(&chip->otg_work, bq24192_update_otg_state);
+
+	/* Setup extcon notifiers */
+	chip->vbus_nb.priority = 1; /* Higher priority to cancel event to PHY */
+	chip->vbus_nb.notifier_call = bq24192_vbus_notifier;
+	ret = devm_extcon_register_notifier(&client->dev, chip->vbus_edev,
+					EXTCON_USB, &chip->vbus_nb);
 	if (ret) {
-		dev_err(&chip->client->dev,
-					"REGISTER OTG NOTIFICATION FAILED\n");
+		dev_err(&client->dev,
+			"Failed to register VBUS extcon notifier: %d\n", ret);
 	}
-#endif
-	/* Program the safety charge temperature threshold with default value*/
-	ret =  intel_scu_ipc_iowrite8(MSIC_CHRTMPCTRL,
-				(CHRTMPCTRL_TMPH_45 | CHRTMPCTRL_TMPL_00));
+
+	chip->charger_nb.notifier_call = bq24192_charger_notifier;
+	ret = devm_extcon_register_notifier_all(
+			&client->dev, chip->charger_edev, &chip->charger_nb);
 	if (ret) {
-		dev_err(&chip->client->dev,
-				"IPC Failed with %d error\n", ret);
+		dev_err(&client->dev,
+			"Failed to register charger extcon notifier: %d\n", ret);
 	}
 
-	bq2415x_sysfs_flag=bq24192_powersupply_init(client);
-	if(!bq2415x_sysfs_flag){
-		bq2415x_sysfs_init();
+	chip->otg_nb.notifier_call = bq24192_otg_notifier;
+	ret = devm_extcon_register_notifier(&client->dev, chip->id_edev,
+					EXTCON_USB_HOST, &chip->otg_nb);
+	if (ret) {
+		dev_err(&client->dev,
+			"Failed to register OTG ID extcon notifier: %d\n", ret);
 	}
 
+	/* Check initial charger state */
+	schedule_work(&chip->charger_type_work);
+	flush_work(&chip->charger_type_work);
+
+	/* Check initial OTG state */
+	schedule_delayed_work(&chip->otg_work, 0);
+	flush_delayed_work(&chip->otg_work);
+
 	intel_mid_pmic_writeb(0x24, 0xaa);//vaild battery detection threshold 3.5v
-#ifdef  ASUS_ENG_BUILD
-        ret = init_asus_charging_limit_toggle();
-        if (ret) {
-            printk("Unable to create proc file\n");
-            return ret;
-        }
-#endif
 	return 0;
 }
 
@@ -3318,20 +2036,12 @@ static int bq24192_remove(struct i2c_client *client)
 {
 	struct bq24192_chip *chip = i2c_get_clientdata(client);
 
-	bq24192_remove_debugfs(chip);
-#ifdef USB_NOTIFY_CALLBACK
-	cable_status_unregister_client(&cable_status_notifier);
-#endif
-	if (!chip->pdata->slave_mode)
-		power_supply_unregister(&chip->usb);
+	if (true) // !chip->pdata->slave_mode
+		power_supply_unregister(chip->usb);
 
 	if (chip->irq > 0)
 		free_irq(chip->irq, chip);
 
-    if(!bq2415x_sysfs_flag){
-
-		bq2415x_sysfs_exit();
-	}
 	i2c_set_clientdata(client, NULL);
 	wake_lock_destroy(&chip->wakelock);
 	kfree(chip);
@@ -3342,31 +2052,25 @@ static int bq24192_remove(struct i2c_client *client)
 
 static void bq24192_shutdown(struct i2c_client *client)
 {
-	//disable otg
-	if(OtgOk){
-		bq24192_reg_read_modify(chip_extern->client,
-		   BQ24192_POWER_ON_CFG_REG,
-		   0x20, false);
-		OtgOk = 0;
-		}
+	struct bq24192_chip *chip = i2c_get_clientdata(client);
+
+	// Disable OTG
+	bq24192_otg_boost(chip, false);
 
 	cancel_delayed_work(&chip_extern->chrg_full_wrkr);
 	cancel_delayed_work(&chip_extern->chrg_task_wrkr);
-	cancel_delayed_work(&chip_extern->power_state_task_wrkr);
 	flush_delayed_work(&chip_extern->chrg_full_wrkr);
 	flush_delayed_work(&chip_extern->chrg_task_wrkr);
-	flush_delayed_work(&chip_extern->power_state_task_wrkr);
 }
 
 static int bq24192_suspend(struct device *dev)
 {
 	struct bq24192_chip *chip = dev_get_drvdata(dev);
-	int ret,reg;
+	int ret;
 
 	printk("bq24192_suspend\n");
 	flush_delayed_work(&chip->chrg_full_wrkr);
 	flush_delayed_work(&chip->chrg_task_wrkr);
-	flush_delayed_work(&chip->power_state_task_wrkr);
 	if (chip->irq > 0) {
 		/*
 		 * Once the WDT is expired all bq24192 registers gets
@@ -3393,7 +2097,7 @@ static int bq24192_suspend(struct device *dev)
 static int bq24192_resume(struct device *dev)
 {
 	struct bq24192_chip *chip = dev_get_drvdata(dev);
-	int ret,gpio_handle,gpio_data;
+	int ret;
 
 	printk("bq24192_resume\n");
 	schedule_delayed_work(&chip->chrg_full_wrkr, 0);
@@ -3421,7 +2125,7 @@ static int bq24192_resume(struct device *dev)
 #define bq24192_resume NULL
 #endif
 
-#ifdef CONFIG_PM_RUNTIME
+#ifdef CONFIG_PM
 static int bq24192_runtime_suspend(struct device *dev)
 {
 
@@ -3453,6 +2157,14 @@ static const struct i2c_device_id bq24192_id[] = {
 };
 MODULE_DEVICE_TABLE(i2c, bq24192_id);
 
+#ifdef CONFIG_ACPI
+static const struct acpi_device_id bq24192_acpi_match[] = {
+	{ "TIBQ2419", 0 },
+	{ },
+};
+MODULE_DEVICE_TABLE(acpi, bq24192_acpi_match);
+#endif
+
 static const struct dev_pm_ops bq24192_pm_ops = {
 	.suspend		= bq24192_suspend,
 	.resume			= bq24192_resume,
@@ -3465,6 +2177,7 @@ static struct i2c_driver bq24192_i2c_driver = {
 	.driver	= {
 		.name	= DEV_NAME,
 		.owner	= THIS_MODULE,
+		.acpi_match_table = ACPI_PTR(bq24192_acpi_match),
 		.pm	= &bq24192_pm_ops,
 	},
 	.probe		= bq24192_probe,
@@ -3472,7 +2185,7 @@ static struct i2c_driver bq24192_i2c_driver = {
 	.id_table	= bq24192_id,
 	.shutdown   = bq24192_shutdown,
 };
-//--------legacy
+
 static int __init bq24192_init(void)
 {
 	return i2c_add_driver(&bq24192_i2c_driver);
@@ -3483,76 +2196,7 @@ static void __exit bq24192_exit(void)
 	i2c_del_driver(&bq24192_i2c_driver);
 }
 module_exit(bq24192_exit);
-/*
-static int bq24192_init(void)
-{
-	return i2c_add_driver(&bq24192_i2c_driver);
-}
 
-static void bq24192_exit(void)
-{
-	i2c_del_driver(&bq24192_i2c_driver);
-}
-
-static int bq24192_rpmsg_probe(struct rpmsg_channel *rpdev)
-{
-	int ret = 0;
-
-	if (rpdev == NULL) {
-		pr_err("rpmsg channel not created\n");
-		ret = -ENODEV;
-		goto out;
-	}
-
-	dev_info(&rpdev->dev, "Probed bq24192 rpmsg device\n");
-
-	ret = bq24192_init();
-
-out:
-	return ret;
-}
-
-static void bq24192_rpmsg_remove(struct rpmsg_channel *rpdev)
-{
-	bq24192_exit();
-	dev_info(&rpdev->dev, "Removed bq24192 rpmsg device\n");
-}
-
-static void bq24192_rpmsg_cb(struct rpmsg_channel *rpdev, void *data,
-					int len, void *priv, u32 src)
-{
-	dev_warn(&rpdev->dev, "unexpected, message\n");
-
-	print_hex_dump(KERN_DEBUG, __func__, DUMP_PREFIX_NONE, 16, 1,
-		       data, len,  true);
-}
-
-static struct rpmsg_device_id bq24192_rpmsg_id_table[] = {
-	{ .name	= "rpmsg_bq24192" },
-	{ },
-};
-MODULE_DEVICE_TABLE(rpmsg, bq24192_rpmsg_id_table);
-
-static struct rpmsg_driver bq24192_rpmsg = {
-	.drv.name	= KBUILD_MODNAME,
-	.drv.owner	= THIS_MODULE,
-	.id_table	= bq24192_rpmsg_id_table,
-	.probe		= bq24192_rpmsg_probe,
-	.callback	= bq24192_rpmsg_cb,
-	.remove		= bq24192_rpmsg_remove,
-};
-
-static int __init bq24192_rpmsg_init(void)
-{
-	return register_rpmsg_driver(&bq24192_rpmsg);
-}
-module_init(bq24192_rpmsg_init);
-
-static void __exit bq24192_rpmsg_exit(void)
-{
-	return unregister_rpmsg_driver(&bq24192_rpmsg);
-}
-*/
 MODULE_AUTHOR("Ramakrishna Pallala <ramakrishna.pallala@intel.com>");
 MODULE_AUTHOR("Raj Pandey <raj.pandey@intel.com>");
 MODULE_DESCRIPTION("BQ24192 Charger Driver");
diff --git a/drivers/power/supply/ASUS_BATTERY/ME176C/ug31xx/uG31xx_API_Measurement.c b/drivers/power/supply/ASUS_BATTERY/ME176C/ug31xx/uG31xx_API_Measurement.c
index a9bf5fcae8ec..cca4ac579303 100644
--- a/drivers/power/supply/ASUS_BATTERY/ME176C/ug31xx/uG31xx_API_Measurement.c
+++ b/drivers/power/supply/ASUS_BATTERY/ME176C/ug31xx/uG31xx_API_Measurement.c
@@ -1126,13 +1126,13 @@ void TimeTick(MeasDataInternalType *obj)
     }
     /// [AT-PM] : Use conversion count to estimate delta time ; 06/11/2013
     obj->info->deltaTime = obj->info->deltaTime*obj->info->adc1ConvertTime/TIME_CONVERT_TIME_TO_MSEC;
-    UG31_LOGE("[%s]: In internal suspend mode, deltaTime = %d\n", __func__,
+    UG31_LOGDD("[%s]: In internal suspend mode, deltaTime = %d\n", __func__,
               (int)obj->info->deltaTime);
     if(MEAS_LEAVE_SUSPEND_MODE(obj->info->status) == _UPI_TRUE_)
     {
       obj->info->status = obj->info->status & (~MEAS_STATUS_LAST_IN_SUSPEND_MODE);
       obj->info->lastTimeTick = GetTickCount();
-      UG31_LOGE("[%s]: Leave internal suspend mode, lastTimeTick = %d\n", __func__,
+      UG31_LOGDD("[%s]: Leave internal suspend mode, lastTimeTick = %d\n", __func__,
                 (int)obj->info->lastTimeTick);
     }
     return;
@@ -1236,7 +1236,7 @@ void _ReadRegister(_meas_u8_ addr, _meas_u8_ size, _meas_u8_ *rdata)
     {
       break;
     }
-    UG31_LOGE("[%s]: re-read i2c %x%x -> %x != %x%x (%d)\n", __func__,
+    UG31_LOGDD("[%s]: re-read i2c %x%x -> %x != %x%x (%d)\n", __func__,
               addr,
               *(rdata+1),
               *rdata,
@@ -1854,7 +1854,7 @@ _meas_u16_ CalibrateETCode(MeasDataInternalType *obj)
     }
     if(tmp16 < MIN_ET_CODE_DIFF)
     {
-      UG31_LOGE("[%s]: Exceed minimum ET code difference (%d < %d)\n", __func__, tmp16, MIN_ET_CODE_DIFF);
+      UG31_LOGDD("[%s]: Exceed minimum ET code difference (%d < %d)\n", __func__, tmp16, MIN_ET_CODE_DIFF);
       tmp16 = MIN_ET_CODE_DIFF;
     }
     tmp16 = tmp16 + obj->info->codeExtTemperature;
@@ -2231,7 +2231,7 @@ MEAS_RTN_CODE UpiMeasurement(MeasDataType *data, MEAS_SEL_CODE select)
   rtn = FetchAdcCode(obj);
   if((select == MEAS_SEL_ALL) || (select == MEAS_SEL_INITIAL))
   {
-  UG31_LOGE("[%s]: (%d-%d) V=%d, I=%d, IT=%d, ET=%d, CH=%d, CT=%d, %02x%02x %02x%02x%02x%02x %02x%02x%02x %02x%02x %02x%02x %02x%02x\n", __func__,
+  UG31_LOGDD("[%s]: (%d-%d) V=%d, I=%d, IT=%d, ET=%d, CH=%d, CT=%d, %02x%02x %02x%02x%02x%02x %02x%02x%02x %02x%02x %02x%02x %02x%02x\n", __func__,
               select, obj->info->fetchRetryCnt, obj->codeBat1, obj->codeCurrent,
               obj->codeIntTemperature, obj->codeExtTemperature, obj->codeCharge, obj->codeCounter,
               obj->reg14, obj->reg9C,
diff --git a/drivers/power/supply/ASUS_BATTERY/ME176C/ug31xx/uG31xx_API_Platform.c b/drivers/power/supply/ASUS_BATTERY/ME176C/ug31xx/uG31xx_API_Platform.c
index 8f983510af3a..e70d3915f256 100644
--- a/drivers/power/supply/ASUS_BATTERY/ME176C/ug31xx/uG31xx_API_Platform.c
+++ b/drivers/power/supply/ASUS_BATTERY/ME176C/ug31xx/uG31xx_API_Platform.c
@@ -21,6 +21,7 @@
                                     2nd byte: had backup before */
 #define I2C_RETRY_CNT           (20)
 
+#ifdef CONFIG_ASUS_ENGINEER_MODE
 /**
  * ug31xx_restore_config_data - restore config data
  * @name : Power Supply name
@@ -118,6 +119,7 @@ int ug31xx_write_backup_tag(const char *name, u8 *data)
 
     return ret;
 }
+#endif
 
 #ifdef  uG31xx_OS_WINDOWS
 
@@ -1506,4 +1508,3 @@ void SleepMiniSecond(_upi_u32_ msec)
 
   #endif  ///< end of uG31xx_OS_WINDOWS
 }
-
diff --git a/drivers/power/supply/ASUS_BATTERY/ME176C/ug31xx/uG31xx_API_Platform.h b/drivers/power/supply/ASUS_BATTERY/ME176C/ug31xx/uG31xx_API_Platform.h
index 8e2643bb834c..c4f937f6b960 100644
--- a/drivers/power/supply/ASUS_BATTERY/ME176C/ug31xx/uG31xx_API_Platform.h
+++ b/drivers/power/supply/ASUS_BATTERY/ME176C/ug31xx/uG31xx_API_Platform.h
@@ -210,6 +210,8 @@ extern _upi_u8_ Ug31DebugEnable;
     #define UG31_LOGD(...)  if(Ug31DebugEnable >= LOG_LEVEL_DEBUG)\
                               printk("<UG31/D>" __VA_ARGS__);
 
+    #define UG31_LOGDD(fmt, ...)  pr_debug(fmt, ##__VA_ARGS__);
+
     extern int ug31_printk(int level, const char *fmt, ...);
     extern int ug31_printk_special(int level, const char *fmt, ...);
 
@@ -242,4 +244,3 @@ extern _upi_u8_ Ug31DebugEnable;
 #endif  ///< end of uG31xx_BOOT_LOADER
 
 #endif  ///< end of uG31xx_OS_WINDOWS
-
diff --git a/drivers/power/supply/ASUS_BATTERY/ME176C/ug31xx/uG31xx_API_System.c b/drivers/power/supply/ASUS_BATTERY/ME176C/ug31xx/uG31xx_API_System.c
index 0d4f97468040..07187d86675b 100644
--- a/drivers/power/supply/ASUS_BATTERY/ME176C/ug31xx/uG31xx_API_System.c
+++ b/drivers/power/supply/ASUS_BATTERY/ME176C/ug31xx/uG31xx_API_System.c
@@ -1613,7 +1613,7 @@ void UpiSaveBatInfoTOIC(SystemDataType *data)
               data->rmFromIC);
     data->rmFromIC = 0;
   }
-  UG31_LOGE("[%s]:timeTag =%d/%x ms,NAC = %d maH,LMD = %d maH\n",
+  UG31_LOGDD("[%s]:timeTag =%d/%x ms,NAC = %d maH,LMD = %d maH\n",
   						__func__,
   						(int)data->timeTagFromIC,
   						(int)data->timeTagFromIC,
diff --git a/drivers/power/supply/ASUS_BATTERY/ME176C/ug31xx/ug31xx_gauge.c b/drivers/power/supply/ASUS_BATTERY/ME176C/ug31xx/ug31xx_gauge.c
index 8e0f1c465528..ade7c0a0f978 100644
--- a/drivers/power/supply/ASUS_BATTERY/ME176C/ug31xx/ug31xx_gauge.c
+++ b/drivers/power/supply/ASUS_BATTERY/ME176C/ug31xx/ug31xx_gauge.c
@@ -32,13 +32,12 @@
 #include "ug31xx_gauge.h"
 #include "uG31xx_API_Platform.h"
 #include <linux/ioctl.h>
-#include <asm/uaccess.h>
+#include <linux/uaccess.h>
 #include <linux/miscdevice.h>
 #include <linux/proc_fs.h>
 #include <linux/version.h>
 
 #include <linux/timer.h>
-#include <linux/android_alarm.h>
 #include <linux/hrtimer.h>
 //Carlisle add for ACPI match ++
 #include <linux/acpi.h>
@@ -53,7 +52,7 @@
 #define UG31XX_SHOW_EXT_TEMP    ///< [FC] : Set temperature reference by external ; 09/30/2013
 #define UG31XX_MISC_DEV
 #define UG31XX_PROBE_CHARGER_OFF      ///< [AT-PM] : Used for charger off at probe ; 12/06/2013
-#define UG31XX_EARLY_SUSPEND			///< [AT-PM] : Used for early suspend instead of suspend ; 12/07/2013
+//#define UG31XX_EARLY_SUSPEND			///< [AT-PM] : Used for early suspend instead of suspend ; 12/07/2013
 #define UG31XX_KOBJECT      ///< [AT-PM] : Used for register kobject ; 12/23/2013
 #define UG31XX_USER_SPACE_ALGORITHM     ///< [AT-PM] : Used for user space algorithm operation ; 12/24/2013
 #define UG31XX_USER_SPACE_BACKUP        ///< [AT-PM] : Used for user space backup operation ; 12/30/2013
@@ -61,15 +60,17 @@
 //#define UG31XX_CALI_BO_EARLY_SUSPEND    ///< [AT-PM] : Used for calibrate board offset in early suspend ; 02/27/2014
 #define UG31XX_PROC_DEV
 
+#define UG31XX_EARLY_POWER_SUPPLY
 
-#include <linux/switch.h>
-#include <linux/earlysuspend.h>
 #define ENABLE_BATTERY_SHIFTx
 bool ug31xx_probe_done = false;//TOM
 EXPORT_SYMBOL(ug31xx_probe_done);//TOM
 int Status;
 //extern int entry_mode;
+
+#ifdef CONFIG_SWITCH
 struct switch_dev batt_dev;
+#endif
 
 #define UG31XX_USER_DAEMON_VER_LENGTH    (16)
 #define UG31XX_CALI_BO_FACTORY_DELAY	 (300)
@@ -153,9 +154,10 @@ static void batt_info_update_work_func(struct work_struct *work);
 
 #define CABLE_STATUS_CHANGE_RELEASE_COUNT (1)
 
-#define GAUGE_err(...)        printk(KERN_ERR "<BATT> " __VA_ARGS__);
-#define GAUGE_notice(...)     printk(KERN_NOTICE "<BATT> " __VA_ARGS__);
-#define GAUGE_info(...)       printk(KERN_INFO "<BATT> " __VA_ARGS__);
+#define GAUGE_err(fmt, ...)     pr_err("<BATT> " fmt, ##__VA_ARGS__);
+#define GAUGE_notice(fmt, ...)  pr_notice("<BATT> " fmt, ##__VA_ARGS__);
+#define GAUGE_info(fmt, ...)    pr_info("<BATT> " fmt, ##__VA_ARGS__);
+#define GAUGE_debug(fmt, ...)   pr_debug("<BATT> " fmt, ##__VA_ARGS__);
 
 #ifdef UG31XX_MISC_DEV
 
@@ -283,6 +285,7 @@ static int ug31xx_backup_file_status = 0;
 static unsigned short design_capacity = 0;
 static bool probe_with_cable = false;
 static bool in_early_suspend = false;
+static int rsoc_before_suspend = 0;
 static int delta_q_in_suspend = 0;
 static bool user_space_algorithm_response = true;
 static int user_space_algorithm_prev_fc_sts = 0;
@@ -1148,7 +1151,7 @@ static void change_ug31xx_kobj(void)
     return;
   }
 
-  GAUGE_notice("[%s]: Send change uevent (%d).\n", __func__, kobj_event_env);
+  GAUGE_debug("[%s]: Send change uevent (%d).\n", __func__, kobj_event_env);
 
   switch(kobj_event_env)
   {
@@ -1317,7 +1320,7 @@ static char *supply_list[] = {
 
 #ifdef	UG31XX_REGISTER_POWERSUPPLY
 
-static struct power_supply ug31xx_supply[] = {
+static struct power_supply_desc ug31xx_supply_desc[] = {
 	{
 		.name			= "battery",
 		.type			= POWER_SUPPLY_TYPE_BATTERY,
@@ -1352,6 +1355,8 @@ static struct power_supply ug31xx_supply[] = {
 #endif	///< end of UPI_CALLBACK_FUNC
 };
 
+static struct power_supply *ug31xx_supply[ARRAY_SIZE(ug31xx_supply_desc)];
+
 static int ug31xx_battery_get_property(struct power_supply *psy,
 				       enum power_supply_property psp,
 				       union power_supply_propval *val)
@@ -1614,13 +1619,16 @@ static int ug31xx_powersupply_init(struct i2c_client *client)
 {
   #ifdef  UG31XX_REGISTER_POWERSUPPLY
 	int i, ret;
-	for (i = 0; i < ARRAY_SIZE(ug31xx_supply); i++) {
-		ret = power_supply_register(&client->dev, &ug31xx_supply[i]);
-		if (ret) {
+	for (i = 0; i < ARRAY_SIZE(ug31xx_supply_desc); i++) {
+		ug31xx_supply[i] = power_supply_register(&client->dev,
+								&ug31xx_supply_desc[i], NULL);
+		if (IS_ERR(ug31xx_supply[i])) {
+			ret = PTR_ERR(ug31xx_supply[i]);
+			ug31xx_supply[i] = NULL;
 			GAUGE_err("[%s] Failed to register power supply\n", __func__);
-			do {
-				power_supply_unregister(&ug31xx_supply[i]);
-			} while ((--i) >= 0);
+			while ((--i) >= 0) {
+				power_supply_unregister(ug31xx_supply[i]);
+			}
 			return ret;
 		}
 	}
@@ -1658,20 +1666,20 @@ int ug31xx_cable_callback(unsigned char usb_cable_state)
 	{
 		if(old_cable_status == UG31XX_AC_ADAPTER_CABLE)
 		{
-			power_supply_changed(&ug31xx_supply[PWR_SUPPLY_AC]);
+			power_supply_changed(ug31xx_supply[PWR_SUPPLY_AC]);
 		}
 		else if(old_cable_status == UG31XX_USB_PC_CABLE)
 		{
-			power_supply_changed(&ug31xx_supply[PWR_SUPPLY_USB]);
+			power_supply_changed(ug31xx_supply[PWR_SUPPLY_USB]);
 		}
 	}
 	else if(cur_cable_status == UG31XX_USB_PC_CABLE)
 	{
-		power_supply_changed(&ug31xx_supply[PWR_SUPPLY_USB]);
+		power_supply_changed(ug31xx_supply[PWR_SUPPLY_USB]);
 	}
 	else if(cur_cable_status == UG31XX_AC_ADAPTER_CABLE)
 	{
-		power_supply_changed(&ug31xx_supply[PWR_SUPPLY_AC]);
+		power_supply_changed(ug31xx_supply[PWR_SUPPLY_AC]);
 	}
 #endif  ///< end of UG31XX_REGISTER_POWERSUPPLY
 	return (0);
@@ -2057,12 +2065,12 @@ static void batt_power_update_work_func(struct work_struct *work)
 		wake_unlock(&ug31_dev->batt_wake_lock);
 	}
 	wake_lock_timeout(&ug31->batt_wake_lock, UG31XX_WAKE_LOCK_TIMEOUT*HZ);
-	power_supply_changed(&ug31xx_supply[PWR_SUPPLY_BATTERY]);
+	power_supply_changed(ug31xx_supply[PWR_SUPPLY_BATTERY]);
 
 	#endif  ///< end of UG31XX_REGISTER_POWERSUPPLY
 
 	schedule_delayed_work(&ug31_dev->batt_power_update_work, ug31_dev->polling_time*HZ);
-	GAUGE_info("[%s] issue power_supply_changed.\n", __func__);
+	GAUGE_debug("[%s] issue power_supply_changed.\n", __func__);
 }
 
 /// =================================================================
@@ -2100,6 +2108,7 @@ static void stop_charging(void)
     }
 }
 
+#ifdef CONFIG_SWITCH
 static ssize_t batt_switch_name(struct switch_dev *sdev, char *buf)
 {
 	const char* FAIL = "0xFFFF";
@@ -2111,6 +2120,7 @@ static ssize_t batt_switch_name(struct switch_dev *sdev, char *buf)
 
 	return sprintf(buf, "%s-%s\n", ug31_module.get_version(), ug31->daemon_ver);
 }
+#endif
 
 /// =================================================================
 /// Charger control for initial capacity prediction (Stop)
@@ -3007,8 +3017,6 @@ static void ug31xx_early_suspend(struct early_suspend *e)
 		return;
 	}
 
-	dev_info(&ug31_dev->client->dev, "enter %s\n", __func__);
-
 	op_actions = UG31XX_OP_EARLY_SUSPEND;
 	kobj_event_env = UG31XX_KOBJ_ENV_UPDATE_CAPACITY;
 	change_ug31xx_kobj();
@@ -3055,8 +3063,6 @@ static void ug31xx_late_resume(struct early_suspend *e)
 		return;
 	}
 
-	dev_info(&ug31_dev->client->dev, "enter %s\n", __func__);
-
 	op_actions = UG31XX_OP_LATE_RESUME;
 	kobj_event_env = UG31XX_KOBJ_ENV_UPDATE_CAPACITY;
 	change_ug31xx_kobj();
@@ -3637,10 +3643,12 @@ static void batt_probe_work_func(struct work_struct *work)
         }
 // 20141024 Tom -------
 
+#ifndef UG31XX_EARLY_POWER_SUPPLY
 	if(ug31xx_powersupply_init(ug31->client))
 	{
 		goto pwr_supply_fail;
 	}
+#endif
 	ug31xx_drv_status = UG31XX_DRV_INIT_OK;
 
 #ifdef	UPI_CALLBACK_FUNC
@@ -3800,8 +3808,9 @@ static void batt_probe_work_func(struct work_struct *work)
 
 	/* request charger driver to update "power supply changed" */
 	//tan request_power_supply_changed();
-	//power_supply_changed(&ug31xx_supply[PWR_SUPPLY_BATTERY]);//tan#
+	//power_supply_changed(ug31xx_supply[PWR_SUPPLY_BATTERY]);//tan#
 
+#ifdef CONFIG_SWITCH
 	/* register switch device for battery information versions report */
 	batt_dev.name = "battery";
 	batt_dev.print_name = batt_switch_name;
@@ -3809,6 +3818,7 @@ static void batt_probe_work_func(struct work_struct *work)
 		GAUGE_err("%s: fail to register battery switch\n", __func__);
 		goto pwr_supply_fail;
 	}
+#endif
 	ug31xx_config_earlysuspend(ug31);
 
 	schedule_delayed_work(&ug31->batt_info_update_work, 0*HZ);
@@ -3830,7 +3840,9 @@ static void batt_probe_work_func(struct work_struct *work)
 initial_fail:
 	start_charging();
 	show_abnormal_batt_status_for_retry();
+#ifndef UG31XX_EARLY_POWER_SUPPLY
 	ug31xx_powersupply_init(ug31->client);
+#endif
 	schedule_delayed_work(&ug31->batt_retry_work, UG31XX_RESET_DELAY_TIME*HZ);
 	return;
 }
@@ -3900,6 +3912,10 @@ static int ug31xx_i2c_probe(struct i2c_client *client,
   INIT_DELAYED_WORK(&ug31->stop_charging_work, stop_charging_work_func);
   INIT_DELAYED_WORK(&ug31->curr_check_work, curr_check_work_func);
 
+#ifdef UG31XX_EARLY_POWER_SUPPLY
+	ug31xx_powersupply_init(ug31->client);
+#endif
+
 #ifdef  UG31XX_PROBE_CHARGER_OFF
 
 	probe_with_cable = is_charging();
@@ -3949,7 +3965,7 @@ static int ug31xx_i2c_remove(struct i2c_client *client)
 
 	for (i = 0; i < ARRAY_SIZE(ug31xx_supply); i++)
 	{
-		power_supply_unregister(&ug31xx_supply[i]);
+		power_supply_unregister(ug31xx_supply[i]);
 	}
 
 	#endif  ///< end of UG31XX_REGISTER_POWERSUPPLY
@@ -4000,7 +4016,7 @@ static int ug31xx_i2c_remove(struct i2c_client *client)
 	return 0;
 }
 
-static int ug31xx_i2c_suspend(struct i2c_client *client, pm_message_t mesg)
+static int ug31xx_i2c_suspend(struct device *dev)
 {
 	int gg_status;
 
@@ -4055,7 +4071,7 @@ static int ug31xx_i2c_suspend(struct i2c_client *client, pm_message_t mesg)
 	return 0;
 }
 
-static int ug31xx_i2c_resume(struct i2c_client *client)
+static int ug31xx_i2c_resume(struct device *dev)
 {
 	#if !(defined(CONFIG_HAS_EARLYSUSPEND) && defined(UG31XX_EARLY_SUSPEND))
 
@@ -4323,6 +4339,13 @@ MODULE_DEVICE_TABLE(acpi, ug31xx_acpi_match);
 #endif
 //Carlisle add for match via ACPI ---
 
+#ifdef CONFIG_PM
+static const struct dev_pm_ops ug31xx_dev_pm_ops = {
+	.suspend = ug31xx_i2c_suspend,
+	.resume = ug31xx_i2c_resume,
+};
+#endif
+
 static struct i2c_driver ug31xx_i2c_driver = {
 	.driver    = {
 		.name  = UG31XX_DEV_NAME,
@@ -4332,11 +4355,12 @@ static struct i2c_driver ug31xx_i2c_driver = {
 		.acpi_match_table = ACPI_PTR(ug31xx_acpi_match),
 #endif
 //Carlisle add for match via ACPI ---
+#ifdef CONFIG_PM
+		.pm = &ug31xx_dev_pm_ops,
+#endif
 	},
 	.probe     = ug31xx_i2c_probe,
 	.remove    = ug31xx_i2c_remove,
-	.suspend   = ug31xx_i2c_suspend,
-	.resume    = ug31xx_i2c_resume,
 	.shutdown  = ug31xx_i2c_shutdown,
 	.id_table  = ug31xx_i2c_id,
 };
@@ -4463,4 +4487,3 @@ module_param(cc_chg_offset_100, uint, 0644);
 MODULE_PARM_DESC(cc_chg_offset_100, "Set CC mode charging offset below 100%");
 module_param(cali_rsoc_time, int, 0644);
 MODULE_PARM_DESC(cali_rsoc_time, "Set time threshold for calibrating rsoc");
-
diff --git a/drivers/power/supply/Makefile b/drivers/power/supply/Makefile
index bcff1c68b689..1bcd50f94917 100644
--- a/drivers/power/supply/Makefile
+++ b/drivers/power/supply/Makefile
@@ -83,4 +83,4 @@ obj-$(CONFIG_CHARGER_TPS65217)	+= tps65217_charger.o
 obj-$(CONFIG_AXP288_FUEL_GAUGE) += axp288_fuel_gauge.o
 obj-$(CONFIG_AXP288_CHARGER)	+= axp288_charger.o
 
-obj-y += ASUS_BATTERY/ME176C/
+obj-$(CONFIG_ASUS_ME176C_BATTERY) += ASUS_BATTERY/ME176C/
-- 
2.17.1

